# Repository: hume-typescript-sdk
URL: https://github.com/HumeAI/hume-typescript-sdk
Transcription Date: 2026-02-03 12:38:08 UTC


## /.fern/metadata.json
```json
{
    "cliVersion": "3.4.3",
    "generatorName": "fernapi/fern-typescript-node-sdk",
    "generatorVersion": "3.43.3",
    "generatorConfig": {
        "extraDependencies": {
            "uuid": "9.0.1",
            "zod": "^3.23.8"
        },
        "extraDevDependencies": {
            "@types/uuid": "9.0.7",
            "@types/ws": "^8.5.9"
        },
        "formDataSupport": "Node18",
        "noSerdeLayer": false,
        "enableInlineTypes": false,
        "allowCustomFetcher": true,
        "shouldGenerateWebsocketClients": true,
        "namespaceExport": "Hume"
    },
    "sdkVersion": "0.15.11"
}

```


## /.fernignore
```fernignore
# Specify files that shouldn't be modified by Fern

README.md
CITATIONS.md
LICENSE
CONTRIBUTING.md

# Tooling
eslint.config.mjs
#jest.config.mjs
justfile
tsconfig.dev.json
.nvmrc
.github
.prettierignore


# EVI WebSocket
# Supplier.ts - sync version required to keep EVI chat client .connect() method synchronous
src/core/fetcher/Supplier.ts
# src/Client.ts
# src/api/resources/empathicVoice/client/Client.ts
# src/api/resources/empathicVoice/resources/chat/index.ts
# src/api/resources/empathicVoice/resources/chat/client
# src/core/websocket
# src/core/index.ts
# EVI Chat Client - manually maintained to preserve backward compatibility
# Client.ts changes from generated version:
# - ConnectArgs.sessionSettings is optional (was required)
# - ConnectArgs.configVersion accepts string | number (was only number)
# - ConnectArgs.voiceId added back as deprecated parameter
# - ConnectArgs.queryParams added for arbitrary query parameters
# - connect() args parameter is optional with default {}
# - Handles voiceId parameter (maps to voice_id query param)
# - Handles flexible configVersion types (both string and number)
# - Conditional sessionSettings serialization (only if provided)
# - Merges custom queryParams into query parameters
src/api/resources/empathicVoice/resources/chat/client/Client.ts

# The below websocket clients also need a custom _getCustomAuthorizationHeaders
src/api/resources/tts/resources/streamInput/client/Client.ts
src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts

# Socket.ts changes from generated version:
# - Response type includes receivedAt: Date timestamp
# - handleMessage adds receivedAt timestamp to messages
# - Restored 8 convenience methods that wrap sendPublish():
#   - sendAudioInput(), sendSessionSettings(), sendAssistantInput()
#   - pauseAssistant(), resumeAssistant()
#   - sendToolResponseMessage(), sendToolErrorMessage(), sendUserInput()
# - Added tillSocketOpen() as deprecated alias for waitForOpen()
src/api/resources/empathicVoice/resources/chat/client/Socket.ts

# index.ts - manually maintained to export Chat and ChatSocket
# Generated version exports nothing (export {}), but we need to export
# our manually maintained Client and Socket classes
src/api/resources/empathicVoice/resources/chat/client/index.ts

# Manually added tests
tests/unit/url-resolution.test.ts
tests/expressionMeasurement/batch.test.ts
tests/expressionMeasurement/streaming.test.ts

# Required manual edits for Node 18 compatibility
tests/unit/fetcher/Fetcher.test.ts
tests/unit/file/file.test.ts
tests/unit/file/test-file.txt

# Needed because node 18 doesn't actually have a global.File
tests/BrowserTestEnvironment.ts

# Needed to send apiKey on websocket queryParams
# See https://github.com/fern-demo/hume-typescript-sdk/pull/1
src/core/websocket/ws.ts

# Needed to export the utilities under src/wrapper
src/wrapper
src/index.ts

# Deprecated type aliases for backward compatibility
src/api/resources/empathicVoice/resources/chat/types/SubscribeEvent.ts
src/serialization/resources/empathicVoice/resources/chat/types/SubscribeEvent.ts
# Modified index files to support deprecated aliases
src/api/resources/empathicVoice/resources/chat/index.ts
src/serialization/resources/empathicVoice/resources/chat/index.ts

scripts/test-examples-local.sh
justfile

# Custom HeaderAuthProvider to support both apiKey and accessToken authentication
src/auth/HeaderAuthProvider.ts

# Auth tests
tests/unit/auth/auth.test.ts
```


## /.github/ISSUE_TEMPLATE/bug_report.md
```markdown
---
name: Bug report
about: Create a report to help us improve
title: ""
labels: ""
assignees: ""
---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:

1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**

- OS: [e.g. iOS]
- Browser [e.g. chrome, safari]
- Version [e.g. 22]

**Smartphone (please complete the following information):**

- Device: [e.g. iPhone6]
- OS: [e.g. iOS8.1]
- Browser [e.g. stock browser, safari]
- Version [e.g. 22]

**Additional context**
Add any other context about the problem here.

```


## /.github/ISSUE_TEMPLATE/feature_request.md
```markdown
---
name: Feature request
about: Suggest an idea for this project
title: ""
labels: ""
assignees: ""
---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.

```


## /.github/dependabot.yml
```yaml
version: 2

updates:
    # check for updated versions of github actions on a weekly basis
    - package-ecosystem: "github-actions"
      directory: "/"
      schedule:
          interval: "weekly"
          day: "monday"
          time: "06:00"
          timezone: "America/New_York"
      commit-message:
          prefix: "[github actions] "
      open-pull-requests-limit: 5

    # commented out for now because dep versions are defined in fern-config,
    # so each Fern generation will overwrite any updates made by Dependabot in this SDK

    # check for updated versions of npm dependencies on a daily basis
    # - package-ecosystem: "npm"
    #   directory: "/"
    #   schedule:
    #       interval: "daily"
    #       time: "06:00"
    #       timezone: "America/New_York"
    #   commit-message:
    #       prefix: "[npm] "
    #   open-pull-requests-limit: 5

```


## /.github/workflows/ci.yml
```yaml
name: ci

on:
  push:
  pull_request:
    types: [synchronize, reopened, ready_for_review]

jobs:
  format:
    runs-on: ubuntu-latest
    # Only run on push events to branches (not tags), and not on main/master
    if: github.event_name == 'push' && !contains(github.ref, 'refs/tags/') && github.ref != 'refs/heads/main' && github.ref != 'refs/heads/master'
    permissions:
      contents: write
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '18.18.0'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Run formatter
        run: pnpm format

      - name: Check for formatting changes
        id: verify_diff
        run: |
          git diff --exit-code || echo "has_changes=true" >> $GITHUB_OUTPUT

      - name: Commit formatting changes
        if: steps.verify_diff.outputs.has_changes == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: 'style: auto-format code'
          commit_options: '--no-verify'

      - name: Fail if formatting was needed
        if: steps.verify_diff.outputs.has_changes == 'true'
        run: |
          echo "::error::Code was not properly formatted. Auto-format commit has been pushed. Please pull the latest changes."
          exit 1

  compile:
    runs-on: ubuntu-latest
    needs: [format]
    # Run if format succeeded or was skipped (on main/tags)
    if: always() && github.event_name == 'push' && (needs.format.result == 'success' || needs.format.result == 'skipped')
    permissions:
      contents: read
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '18.18.0'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Compile
        run: pnpm build

  test:
    runs-on: ubuntu-latest
    needs: [format]
    # Run if format succeeded or was skipped (on main/tags)
    if: always() && github.event_name == 'push' && (needs.format.result == 'success' || needs.format.result == 'skipped')
    permissions:
      contents: read
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '18.18.0'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Check for formatting issues
        run: pnpm format:check

      - name: Run tests
        # --configLoader runner is used to make vitest able to load its config as a ESM module in node 18. We wouldn't need to specify this if we didn't support node 18.
        run: pnpm test --configLoader runner

  test-examples:
    runs-on: ubuntu-latest
    # Run on pull_request events and push events (to test feature branches)
    if: (github.event_name == 'pull_request' || github.event_name == 'push') && github.actor != 'dependabot[bot]'
    permissions:
      contents: read
    steps:
      - name: Checkout SDK repo (PR branch)
        uses: actions/checkout@v4
        with:
          path: sdk
          # checkout the PR branch, not main
          ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}
          fetch-depth: 0

      - name: Checkout examples repo
        uses: actions/checkout@v4
        with:
          repository: humeai/hume-api-examples
          path: examples

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.20.0

      - name: Build SDK
        working-directory: ./sdk
        run: |
          echo "=== SDK Build Info ==="
          echo "Branch: ${{ github.head_ref || github.ref_name || 'unknown' }}"
          echo "Ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}"
          echo "Commit SHA: $(git rev-parse HEAD)"
          echo "Branch name: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'detached')"
          echo "======================"
          pnpm install
          pnpm build
          echo "SDK version from package.json: $(node -p "require('./package.json').version")"

      - name: Link SDK to examples
        run: |
          cd ./sdk
          SDK_VERSION=$(node -p "require('./package.json').version")
          SDK_PATH=$(pwd)
          echo "=== Linking SDK ==="
          echo "SDK version: $SDK_VERSION"
          echo "SDK path: $SDK_PATH"
          pnpm link --global
          cd ../examples/evi/evi-typescript-quickstart
          pnpm install --no-frozen-lockfile
          pnpm remove hume || true
          pnpm link hume
          echo ""
          echo "=== Verifying Linked SDK ==="
          if [ -L node_modules/hume ]; then
            LINK_TARGET=$(readlink -f node_modules/hume)
            echo "✓ node_modules/hume is a symlink"
            echo "  Link target: $LINK_TARGET"
            if [[ "$LINK_TARGET" == *"$SDK_PATH"* ]] || [[ "$LINK_TARGET" == *"global"* ]]; then
              echo "✓ Link points to local SDK (not npm package)"
            else
              echo "✗ WARNING: Link may not point to local SDK"
            fi
          else
            echo "✗ ERROR: node_modules/hume is NOT a symlink - using npm package!"
            exit 1
          fi
          INSTALLED_VERSION=$(node -p "require('hume/package.json').version")
          echo "Installed hume version: $INSTALLED_VERSION"
          if [ "$INSTALLED_VERSION" != "$SDK_VERSION" ]; then
            echo "✗ WARNING: Version mismatch! Expected $SDK_VERSION, got $INSTALLED_VERSION"
          else
            echo "✓ Version matches: $INSTALLED_VERSION"
          fi
          echo "===================="
          cd ../../tts/tts-typescript-quickstart
          pnpm install --no-frozen-lockfile
          pnpm remove hume || true
          pnpm link hume
          echo ""
          echo "=== Verifying Linked SDK ==="
          if [ -L node_modules/hume ]; then
            LINK_TARGET=$(readlink -f node_modules/hume)
            echo "✓ node_modules/hume is a symlink"
            echo "  Link target: $LINK_TARGET"
            if [[ "$LINK_TARGET" == *"$SDK_PATH"* ]] || [[ "$LINK_TARGET" == *"global"* ]]; then
              echo "✓ Link points to local SDK (not npm package)"
            else
              echo "✗ WARNING: Link may not point to local SDK"
            fi
          else
            echo "✗ ERROR: node_modules/hume is NOT a symlink - using npm package!"
            exit 1
          fi
          INSTALLED_VERSION=$(node -p "require('hume/package.json').version")
          echo "Installed hume version: $INSTALLED_VERSION"
          if [ "$INSTALLED_VERSION" != "$SDK_VERSION" ]; then
            echo "✗ WARNING: Version mismatch! Expected $SDK_VERSION, got $INSTALLED_VERSION"
          else
            echo "✓ Version matches: $INSTALLED_VERSION"
          fi
          echo "===================="

      - name: Run example evi-typescript-quickstart
        working-directory: ./examples/evi/evi-typescript-quickstart
        run: pnpm run test
        env:
          TEST_HUME_API_KEY: ${{ secrets.TEST_HUME_API_KEY }}
          TEST_HUME_SECRET_KEY: ${{ secrets.TEST_HUME_SECRET_KEY }}

      - name: Run example tts-typescript-quickstart
        working-directory: ./examples/tts/tts-typescript-quickstart
        run: pnpm run test
        env:
          TEST_HUME_API_KEY: ${{ secrets.TEST_HUME_API_KEY }}
          TEST_HUME_SECRET_KEY: ${{ secrets.TEST_HUME_SECRET_KEY }}

  publish:
    needs: [compile, test]
    if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Required for OIDC publishing to NPM
      contents: read
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '18.18.0'
          registry-url: 'https://registry.npmjs.org'

      - name: Setup pnpm
        run: npm install -g pnpm

      - name: Install dependencies
        run: pnpm install

      - name: Build
        run: pnpm build

      - name: Publish to npm
        run: |

          publish() {
            npx -y npm@latest publish --provenance "$@"
          }
          if [[ ${GITHUB_REF} == *alpha* ]]; then
            publish --access public --tag alpha
          elif [[ ${GITHUB_REF} == *beta* ]]; then
            publish --access public --tag beta
          else
            publish --access public
          fi
      - name: Trigger React SDK bump
        uses: peter-evans/repository-dispatch@v4
        with:
          token: ${{ secrets.REPO_DISPATCH_TOKEN }}
          repository: HumeAI/hume-react-sdk
          event-type: typescript-sdk-published
          client-payload: |
            {
              "version": "${{ github.ref_name }}",
              "tag": "${{ github.ref_name }}",
              "is_prerelease": ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') }}
            }

```


## /.github/workflows/publish.yml
```yaml
name: Manual Publish to npm

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Git tag to publish (e.g., 0.15.12)'
        required: true
        type: string
      npm_tag:
        description: 'npm dist-tag (latest, alpha, beta)'
        required: false
        default: 'latest'
        type: choice
        options:
          - latest
          - alpha
          - beta

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout repo at tag
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.tag }}

      - name: Verify tag exists
        run: |
          if ! git describe --tags --exact-match HEAD 2>/dev/null; then
            echo "Warning: HEAD is not at an exact tag. Proceeding anyway with ref: ${{ inputs.tag }}"
          fi

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '18.18.0'
          registry-url: 'https://registry.npmjs.org'

      - name: Setup pnpm
        run: npm install -g pnpm

      - name: Install dependencies
        run: pnpm install

      - name: Build
        run: pnpm build

      - name: Verify version matches tag
        run: |
          PACKAGE_VERSION=$(node -p "require('./package.json').version")
          echo "Package version: $PACKAGE_VERSION"
          echo "Input tag: ${{ inputs.tag }}"
          if [ "$PACKAGE_VERSION" != "${{ inputs.tag }}" ]; then
            echo "Warning: package.json version ($PACKAGE_VERSION) does not match input tag (${{ inputs.tag }})"
          fi

      - name: Publish to npm
        run: npx -y npm@latest publish --provenance --access public --tag ${{ inputs.npm_tag }}

      - name: Trigger React SDK bump
        if: inputs.npm_tag == 'latest'
        uses: peter-evans/repository-dispatch@v4
        with:
          token: ${{ secrets.REPO_DISPATCH_TOKEN }}
          repository: HumeAI/hume-react-sdk
          event-type: typescript-sdk-published
          client-payload: |
            {
              "version": "${{ inputs.tag }}",
              "tag": "${{ inputs.tag }}",
              "is_prerelease": ${{ inputs.npm_tag != 'latest' }}
            }

```


## /.github/workflows/test-examples-dependabot.yml
```yaml
name: test-examples-dependabot

on:
  pull_request_target:
    types: [opened, synchronize, reopened]

jobs:
  test-examples-dependabot:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request_target' && github.actor == 'dependabot[bot]'
    permissions:
      contents: read
      pull-requests: read

    steps:
      - name: Checkout base SHA (trusted)
        uses: actions/checkout@v4
        with:
          path: sdk
          ref: ${{ github.event.pull_request.base.sha }}
          fetch-depth: 0
          persist-credentials: false

      - name: Verify PR changes are dependency-only
        working-directory: sdk
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          PR: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail

          files="$(curl -fsSL \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO/pulls/$PR/files?per_page=100" \
            | jq -r '.[].filename')"

          echo "Changed files:"
          echo "$files"

          allowed='^(
            package\.json|
            pnpm-lock\.yaml|
            pnpm-workspace\.yaml|
            \.npmrc|
            examples/.*/package\.json|
            examples/.*/pnpm-lock\.yaml
          )$'

          bad="$(echo "$files" | tr -d '\r' | grep -Ev "$allowed" || true)"
          if [ -n "$bad" ]; then
            echo "::error::Disallowed file changes in Dependabot PR:"
            echo "$bad"
            exit 1
          fi

      - name: Apply Dependabot PR patch
        working-directory: sdk
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          PR: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail
          curl -fsSL \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3.patch" \
            "https://api.github.com/repos/$REPO/pulls/$PR" \
            > pr.patch
          git apply --whitespace=nowarn pr.patch

      - name: Checkout examples repo
        uses: actions/checkout@v4
        with:
          repository: humeai/hume-api-examples
          path: examples
          fetch-depth: 0

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '18.18.0'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: '10.20.0'

      - name: Build SDK
        working-directory: ./sdk
        run: |
          echo "=== SDK Build Info ==="
          echo "Branch: ${{ github.head_ref || github.ref_name || 'unknown' }}"
          echo "Ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}"
          echo "Commit SHA: $(git rev-parse HEAD)"
          echo "Branch name: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'detached')"
          echo "======================"
          pnpm install
          pnpm build
          echo "SDK version from package.json: $(node -p "require('./package.json').version")"

      - name: Link SDK to examples
        run: |
          cd ./sdk
          SDK_VERSION=$(node -p "require('./package.json').version")
          SDK_PATH=$(pwd)
          echo "=== Linking SDK ==="
          echo "SDK version: $SDK_VERSION"
          echo "SDK path: $SDK_PATH"
          pnpm link --global

          cd ../examples/evi/evi-typescript-quickstart
          pnpm install --no-frozen-lockfile
          pnpm remove hume || true
          pnpm link hume

          echo ""
          echo "=== Verifying Linked SDK ==="
          if [ -L node_modules/hume ]; then
            LINK_TARGET=$(readlink -f node_modules/hume)
            echo "✓ node_modules/hume is a symlink"
            echo "  Link target: $LINK_TARGET"
            if [[ "$LINK_TARGET" == *"$SDK_PATH"* ]] || [[ "$LINK_TARGET" == *"global"* ]]; then
              echo "✓ Link points to local SDK (not npm package)"
            else
              echo "✗ WARNING: Link may not point to local SDK"
            fi
          else
            echo "✗ ERROR: node_modules/hume is NOT a symlink - using npm package!"
            exit 1
          fi

          INSTALLED_VERSION=$(node -p "require('hume/package.json').version")
          echo "Installed hume version: $INSTALLED_VERSION"
          if [ "$INSTALLED_VERSION" != "$SDK_VERSION" ]; then
            echo "✗ WARNING: Version mismatch! Expected $SDK_VERSION, got $INSTALLED_VERSION"
          else
            echo "✓ Version matches: $INSTALLED_VERSION"
          fi
          echo "===================="

          cd ../../tts/tts-typescript-quickstart
          pnpm install --no-frozen-lockfile
          pnpm remove hume || true
          pnpm link hume

          echo ""
          echo "=== Verifying Linked SDK ==="
          if [ -L node_modules/hume ]; then
            LINK_TARGET=$(readlink -f node_modules/hume)
            echo "✓ node_modules/hume is a symlink"
            echo "  Link target: $LINK_TARGET"
            if [[ "$LINK_TARGET" == *"$SDK_PATH"* ]] || [[ "$LINK_TARGET" == *"global"* ]]; then
              echo "✓ Link points to local SDK (not npm package)"
            else
              echo "✗ WARNING: Link may not point to local SDK"
            fi
          else
            echo "✗ ERROR: node_modules/hume is NOT a symlink - using npm package!"
            exit 1
          fi

          INSTALLED_VERSION=$(node -p "require('hume/package.json').version")
          echo "Installed hume version: $INSTALLED_VERSION"
          if [ "$INSTALLED_VERSION" != "$SDK_VERSION" ]; then
            echo "✗ WARNING: Version mismatch! Expected $SDK_VERSION, got $INSTALLED_VERSION"
          else
            echo "✓ Version matches: $INSTALLED_VERSION"
          fi
          echo "===================="

      - name: Run example evi-typescript-quickstart
        working-directory: ./examples/evi/evi-typescript-quickstart
        env:
          TEST_HUME_API_KEY: ${{ secrets.TEST_HUME_API_KEY }}
          TEST_HUME_SECRET_KEY: ${{ secrets.TEST_HUME_SECRET_KEY }}
        run: pnpm run test

      - name: Run example tts-typescript-quickstart
        working-directory: ./examples/tts/tts-typescript-quickstart
        env:
          TEST_HUME_API_KEY: ${{ secrets.TEST_HUME_API_KEY }}
          TEST_HUME_SECRET_KEY: ${{ secrets.TEST_HUME_SECRET_KEY }}
        run: pnpm run test

```


## /.gitignore
```gitignore
node_modules
.DS_Store
/dist
```


## /.nvmrc
```nvmrc
18.18.0

```


## /.prettierignore
```prettierignore
.mock

```


## /CITATIONS.md
```markdown
# Citations

To cite Hume's expressive communication platform, please reference one or more of the papers relevant to your application.

| Publication                                                                                                                                                                          | Year | Modality |   BibTeX    |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--: | :------: | :---------: |
| [Self-report captures 27 distinct categories of emotion bridged by continuous gradients](https://doi.org/10.1073/pnas.1702247114)                                                    | 2017 |  multi   | [Cite](#1)  |
| [Mapping the Passions: Toward a High-Dimensional Taxonomy of Emotional Experience and Expression](https://doi.org/10.1177/1529100619850176)                                          | 2019 |  multi   | [Cite](#2)  |
| [The primacy of categories in the recognition of 12 emotions in speech prosody across two cultures](https://doi.org/10.1038/s41562-019-0533-6)                                       | 2019 |  voice   | [Cite](#3)  |
| [Mapping 24 emotions conveyed by brief human vocalization](https://doi.org/10.1037/amp0000399)                                                                                       | 2019 |  voice   | [Cite](#4)  |
| [Emotional expression: Advances in basic emotion theory](https://doi.org/10.1007%2Fs10919-019-00293-3)                                                                               | 2019 |  multi   | [Cite](#5)  |
| [What the face displays: Mapping 28 emotions conveyed by naturalistic expression](https://doi.org/10.1037/amp0000488)                                                                | 2020 |   face   | [Cite](#6)  |
| [The neural representation of visually evoked emotion is high-dimensional, categorical, and distributed across transmodal brain regions](https://doi.org/10.1016/j.isci.2020.101060) | 2020 |  multi   | [Cite](#7)  |
| [What music makes us feel: At least 13 dimensions organize subjective experiences associated with music across different cultures](https://doi.org/10.1073/pnas.1910704117)          | 2020 |  music   | [Cite](#8)  |
| [GoEmotions: A Dataset of Fine-Grained Emotions](https://doi.org/10.18653/v1/2020.acl-main.372)                                                                                      | 2020 |   text   | [Cite](#9)  |
| [Universal facial expressions uncovered in art of the ancient Americas: A computational approach](https://doi.org/10.1126/sciadv.abb1005)                                            | 2020 |   face   | [Cite](#10) |
| [Sixteen facial expressions occur in similar contexts worldwide](https://doi.org/10.1038/s41586-020-3037-7)                                                                          | 2021 |   face   | [Cite](#11) |
| [The MuSe 2022 Multimodal Sentiment Analysis Challenge: Humor, Emotional Reactions, and Stress](https://doi.org/10.48550/arXiv.2207.05691)                                           | 2022 |  multi   | [Cite](#12) |
| [The ACII 2022 Affective Vocal Bursts Workshop & Competition: Understanding a critically understudied modality of emotional expression](https://doi.org/10.48550/arXiv.2207.03572)   | 2022 |  voice   | [Cite](#13) |
| [The ICML 2022 Expressive Vocalizations Workshop and Competition: Recognizing, Generating, and Personalizing Vocal Bursts](https://doi.org/10.48550/arXiv.2205.01780)                | 2022 |  voice   | [Cite](#14) |
| [Intersectionality in emotion signaling and recognition: The influence of gender, ethnicity, and social class](https://doi.org/10.1037/emo0001082)                                   | 2022 |   body   | [Cite](#15) |
| [How emotions, relationships, and culture constitute each other: advances in social functionalist theory](https://doi.org/10.1080/02699931.2022.2047009)                             | 2022 |  multi   | [Cite](#16) |
| [State & Trait Measurement from Nonverbal Vocalizations: A Multi-Task Joint Learning Approach](https://doi.org/10.21437/Interspeech.2022-10927)                                      | 2022 |  voice   | [Cite](#17) |

## BibTeX

### <a id="1"></a>

```bibtex
@article{cowen2017self,
  title={Self-report captures 27 distinct categories of emotion bridged by continuous gradients},
  author={Cowen, Alan S and Keltner, Dacher},
  journal={Proceedings of the national academy of sciences},
  volume={114},
  number={38},
  pages={E7900--E7909},
  year={2017},
  publisher={National Acad Sciences}
}
```

### <a id="2"></a>

```bibtex
@article{cowen2019mapping,
  title={Mapping the passions: Toward a high-dimensional taxonomy of emotional experience and expression},
  author={Cowen, Alan and Sauter, Disa and Tracy, Jessica L and Keltner, Dacher},
  journal={Psychological Science in the Public Interest},
  volume={20},
  number={1},
  pages={69--90},
  year={2019},
  publisher={Sage Publications Sage CA: Los Angeles, CA}
}
```

### <a id="3"></a>

```bibtex
@article{cowen2019primacy,
  title={The primacy of categories in the recognition of 12 emotions in speech prosody across two cultures},
  author={Cowen, Alan S and Laukka, Petri and Elfenbein, Hillary Anger and Liu, Runjing and Keltner, Dacher},
  journal={Nature human behaviour},
  volume={3},
  number={4},
  pages={369--382},
  year={2019},
  publisher={Nature Publishing Group}
}
```

### <a id="4"></a>

```bibtex
@article{cowen2019mapping,
  title={Mapping 24 emotions conveyed by brief human vocalization.},
  author={Cowen, Alan S and Elfenbein, Hillary Anger and Laukka, Petri and Keltner, Dacher},
  journal={American Psychologist},
  volume={74},
  number={6},
  pages={698},
  year={2019},
  publisher={American Psychological Association}
}
```

### <a id="5"></a>

```bibtex
@article{keltner2019emotional,
  title={Emotional expression: Advances in basic emotion theory},
  author={Keltner, Dacher and Sauter, Disa and Tracy, Jessica and Cowen, Alan},
  journal={Journal of nonverbal behavior},
  volume={43},
  number={2},
  pages={133--160},
  year={2019},
  publisher={Springer}
}
```

### <a id="6"></a>

```bibtex
@article{cowen2020face,
  title={What the face displays: Mapping 28 emotions conveyed by naturalistic expression.},
  author={Cowen, Alan S and Keltner, Dacher},
  journal={American Psychologist},
  volume={75},
  number={3},
  pages={349},
  year={2020},
  publisher={American Psychological Association}
}
```

### <a id="7"></a>

```bibtex
@article{horikawa2020neural,
  title={The neural representation of visually evoked emotion is high-dimensional, categorical, and distributed across transmodal brain regions},
  author={Horikawa, Tomoyasu and Cowen, Alan S and Keltner, Dacher and Kamitani, Yukiyasu},
  journal={Iscience},
  volume={23},
  number={5},
  pages={101060},
  year={2020},
  publisher={Elsevier}
}
```

### <a id="8"></a>

```bibtex
@article{cowen2020music,
  title={What music makes us feel: At least 13 dimensions organize subjective experiences associated with music across different cultures},
  author={Cowen, Alan S and Fang, Xia and Sauter, Disa and Keltner, Dacher},
  journal={Proceedings of the National Academy of Sciences},
  volume={117},
  number={4},
  pages={1924--1934},
  year={2020},
  publisher={National Acad Sciences}
}
```

### <a id="9"></a>

```bibtex
@article{demszky2020goemotions,
  title={GoEmotions: A dataset of fine-grained emotions},
  author={Demszky, Dorottya and Movshovitz-Attias, Dana and Ko, Jeongwoo and Cowen, Alan and Nemade, Gaurav and Ravi, Sujith},
  journal={arXiv preprint arXiv:2005.00547},
  year={2020}
}
```

### <a id="10"></a>

```bibtex
@article{cowen2020universal,
  title={Universal facial expressions uncovered in art of the ancient Americas: A computational approach},
  author={Cowen, Alan S and Keltner, Dacher},
  journal={Science advances},
  volume={6},
  number={34},
  pages={eabb1005},
  year={2020},
  publisher={American Association for the Advancement of Science}
}
```

### <a id="11"></a>

```bibtex
@article{cowen2021sixteen,
  title={Sixteen facial expressions occur in similar contexts worldwide},
  author={Cowen, Alan S and Keltner, Dacher and Schroff, Florian and Jou, Brendan and Adam, Hartwig and Prasad, Gautam},
  journal={Nature},
  volume={589},
  number={7841},
  pages={251--257},
  year={2021},
  publisher={Nature Publishing Group}
}
```

### <a id="12"></a>

```bibtex
@article{christ2022muse,
  title={The MuSe 2022 Multimodal Sentiment Analysis Challenge: Humor, Emotional Reactions, and Stress},
  author={Christ, Lukas and Amiriparian, Shahin and Baird, Alice and Tzirakis, Panagiotis and Kathan, Alexander and M{\"u}ller, Niklas and Stappen, Lukas and Me{\ss}ner, Eva-Maria and K{\"o}nig, Andreas and Cowen, Alan and others},
  year={2022}
}
```

### <a id="13"></a>

```bibtex
@article{baird2022acii,
  title={The ACII 2022 Affective Vocal Bursts Workshop \& Competition: Understanding a critically understudied modality of emotional expression},
  author={Baird, Alice and Tzirakis, Panagiotis and Brooks, Jeffrey A and Gregory, Christopher B and Schuller, Bj{\"o}rn and Batliner, Anton and Keltner, Dacher and Cowen, Alan},
  journal={arXiv preprint arXiv:2207.03572},
  year={2022}
}
```

### <a id="14"></a>

```bibtex
@article{baird2022icml,
  title={The ICML 2022 Expressive Vocalizations Workshop and Competition: Recognizing, Generating, and Personalizing Vocal Bursts},
  author={Baird, Alice and Tzirakis, Panagiotis and Gidel, Gauthier and Jiralerspong, Marco and Muller, Eilif B and Mathewson, Kory and Schuller, Bj{\"o}rn and Cambria, Erik and Keltner, Dacher and Cowen, Alan},
  journal={arXiv preprint arXiv:2205.01780},
  year={2022}
}
```

### <a id="15"></a>

```bibtex
@article{monroy2022intersectionality,
  title={Intersectionality in emotion signaling and recognition: The influence of gender, ethnicity, and social class.},
  author={Monroy, Maria and Cowen, Alan S and Keltner, Dacher},
  journal={Emotion},
  year={2022},
  publisher={American Psychological Association}
}
```

### <a id="16"></a>

```bibtex
@article{keltner2022emotions,
  title={How emotions, relationships, and culture constitute each other: advances in social functionalist theory},
  author={Keltner, Dacher and Sauter, Disa and Tracy, Jessica L and Wetchler, Everett and Cowen, Alan S},
  journal={Cognition and Emotion},
  volume={36},
  number={3},
  pages={388--401},
  year={2022},
  publisher={Taylor \& Francis}
}
```

### <a id="17"></a>

```bibtex
@inproceedings{baird22_interspeech,
  author={Alice Baird and Panagiotis Tzirakis and Jeff Brooks and Lauren Kim and Michael Opara and Chris Gregory and Jacob Metrick and Garrett Boseck and Dacher Keltner and Alan Cowen},
  title={{State & Trait Measurement from Nonverbal Vocalizations: A Multi-Task Joint Learning Approach}},
  year=2022,
  booktitle={Proc. Interspeech 2022},
  pages={2028--2032},
  doi={10.21437/Interspeech.2022-10927}
}
```

```


## /CONTRIBUTING.md
```markdown
# Contributing

While we value open-source contributions to this SDK, this library is generated programmatically. Additions made directly to this library would have to be moved over to our generation code, otherwise they would be overwritten upon the next generated release. Feel free to open a PR as a proof of concept, but know that we will not be able to merge it as-is. We suggest opening an issue first to discuss with us!

On the other hand, contributions to the README are always very welcome!

```


## /LICENSE
```
MIT License

Copyright (c) 2022 Hume AI, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```


## /README.md
```markdown
<div align="center">
  <img src="https://storage.googleapis.com/hume-public-logos/hume/hume-banner.png">
  <h1>Hume AI TypeScript SDK</h1>

  <p>
    <strong>Integrate Hume APIs directly into your Node application or frontend</strong>
  </p>

  <br>
  <div>
    <a href="https://www.npmjs.com/package/hume"><img src="https://img.shields.io/npm/v/hume">
    <a href="https://buildwithfern.com/"><img src="https://img.shields.io/badge/%F0%9F%8C%BF-SDK%20generated%20by%20Fern-brightgreen">
  </div>
  <br>
</div>

## Documentation

API reference documentation is available [here](https://dev.hume.ai/reference/).

## Installation

```
npm i hume
```

## Usage

```typescript
import { HumeClient } from "hume";

const hume = new HumeClient({
    apiKey: "YOUR_API_KEY",
});

const job = await hume.expressionMeasurement.batch.startInferenceJob({
    models: {
        face: {},
    },
    urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
});

console.log("Running...");

await job.awaitCompletion();

const predictions = await hume.expressionMeasurement.batch.getJobPredictions(job.jobId);

console.log(predictions);
```

## Namespaces

This SDK contains the APIs for expression measurement, empathic voice and custom models. Even
if you do not plan on using more than one API to start, the SDK provides easy access in
case you find additional APIs in the future.

Each API is namespaced accordingly:

```typescript
import { HumeClient } from "hume";

const hume = new HumeClient({
    apiKey: "YOUR_API_KEY"
});

hume.expressionMeasurement. // APIs specific to Expression Measurement

hume.emapthicVoice. // APIs specific to Empathic Voice
```

## Websockets

The SDK supports interacting with both WebSocket and REST APIs.

### Request-Reply

The SDK supports a request-reply pattern for the streaming expression measurement API.
You'll be able to pass an inference request and `await` till the response is received.

```typescript
import { HumeClient } from "hume";

const hume = new HumeClient({
    apiKey: "YOUR_API_KEY",
});

const socket = hume.expressionMeasurement.stream.connect({
    config: {
        language: {},
    },
});

for (const sample of samples) {
    const result = await socket.sendText({ text: sample });
    console.log(result);
}
```

### Empathic Voice

The SDK supports sending and receiving audio from Empathic Voice.

```typescript
import { HumeClient } from "hume";

const hume = new HumeClient({
    apiKey: "<>",
    secretKey: "<>",
});

const socket = hume.empathicVoice.chat.connect();

socket.on("message", (message) => {
    if (message.type === "audio_output") {
        const decoded = Buffer.from(message.data, "base64");
        // play decoded message
    }
});

// optional utility to wait for socket to be open
await socket.tillSocketOpen();

socket.sendUserInput("Hello, how are you?");
```

## Errors

When the API returns a non-success status code (4xx or 5xx response),
a subclass of [HumeError](./src/errors/HumeError.ts) will be thrown:

```typescript
import { HumeError, HumeTimeoutError } from "hume";

try {
    await hume.expressionMeasurement.batch.startInferenceJob(/* ... */);
} catch (err) {
    if (err instanceof HumeTimeoutError) {
        console.log("Request timed out", err);
    } else if (err instanceof HumeError) {
        // catch all errros
        console.log(err.statusCode);
        console.log(err.message);
        console.log(err.body);
    }
}
```

## Retries

409 Conflict, 429 Rate Limit, and >=500 Internal errors will all be retried twice with exponential bakcoff.
You can use the maxRetries option to configure this behavior:

```typescript
await hume.expressionMeasurement.batch.startInferenceJob(..., {
    maxRetries: 0, // disable retries
});
```

## Timeouts

By default, the SDK has a timeout of 60s. You can use the `timeoutInSeconds` option to configure
this behavior

```typescript
await hume.expressionMeasurement.batch.startInferenceJob(..., {
    timeoutInSeconds: 10, // timeout after 10 seconds
});
```

## Beta Status

This SDK is in beta, and there may be breaking changes between versions without a major
version update. Therefore, we recommend pinning the package version to a specific version.
This way, you can install the same version each time without breaking changes.

## Contributing

While we value open-source contributions to this SDK, this library is generated programmatically.
Additions made directly to this library would have to be moved over to our generation code,
otherwise they would be overwritten upon the next generated release. Feel free to open a PR as a
proof of concept, but know that we will not be able to merge it as-is. We suggest opening an
issue first to discuss with us!

On the other hand, contributions to the README are always very welcome!

```


## /biome.json
```json
{
    "$schema": "https://biomejs.dev/schemas/2.3.1/schema.json",
    "root": true,
    "vcs": {
        "enabled": false
    },
    "files": {
        "ignoreUnknown": true,
        "includes": [
            "**",
            "!!dist",
            "!!**/dist",
            "!!lib",
            "!!**/lib",
            "!!_tmp_*",
            "!!**/_tmp_*",
            "!!*.tmp",
            "!!**/*.tmp",
            "!!.tmp/",
            "!!**/.tmp/",
            "!!*.log",
            "!!**/*.log",
            "!!**/.DS_Store",
            "!!**/Thumbs.db"
        ]
    },
    "formatter": {
        "enabled": true,
        "indentStyle": "space",
        "indentWidth": 4,
        "lineWidth": 120
    },
    "javascript": {
        "formatter": {
            "quoteStyle": "double"
        }
    },
    "assist": {
        "enabled": true,
        "actions": {
            "source": {
                "organizeImports": "on"
            }
        }
    },
    "linter": {
        "rules": {
            "style": {
                "useNodejsImportProtocol": "off"
            },
            "suspicious": {
                "noAssignInExpressions": "warn",
                "noUselessEscapeInString": {
                    "level": "warn",
                    "fix": "none",
                    "options": {}
                },
                "noThenProperty": "warn",
                "useIterableCallbackReturn": "warn",
                "noShadowRestrictedNames": "warn",
                "noTsIgnore": {
                    "level": "warn",
                    "fix": "none",
                    "options": {}
                },
                "noConfusingVoidType": {
                    "level": "warn",
                    "fix": "none",
                    "options": {}
                }
            }
        }
    }
}

```


## /eslint.config.mjs
```mjs
import js from "@eslint/js";
import tseslint from "typescript-eslint";

const fernRules = {
    files: ["src/**/*.ts"],
    rules: {
        "@typescript-eslint/no-unused-vars": "off",
        "@typescript-eslint/no-unnecessary-type-assertion": "warn",
        "@typescript-eslint/no-explicit-any": "warn",
        "@typescript-eslint/ban-ts-comment": "warn",
        "prefer-const": "warn",
    },
};

const humeRules = {
    files: ["src/wrapper/**/*.ts"],
    rules: {
        "@typescript-eslint/no-unused-vars": "error",
        "@typescript-eslint/no-unnecessary-type-assertion": "error",
        "@typescript-eslint/no-explicit-any": "error",
        "@typescript-eslint/ban-ts-comment": "error",
        "prefer-const": "error",
    },
};

export default [
    js.configs.recommended,
    ...tseslint.configs.recommended,
    {
        ignores: ["dist", "src/core/**/*.ts", "jest.config.js"],
    },
    {
        languageOptions: {
            parserOptions: {
                project: "./tsconfig.dev.json",
            },
        },
    },
    {
        rules: {
            "@typescript-eslint/no-namespace": "off",
        },
    },
    fernRules,
    humeRules,
];

```


## /justfile
```
# run the CI workflow locally
local-ci:
    act -W '.github/workflows/ci.yml' --container-architecture linux/amd64 -s GITHUB_TOKEN="$(gh auth token)"
```


## /package.json
```json
{
    "name": "hume",
    "version": "0.15.12",
    "private": false,
    "repository": {
        "type": "git",
        "url": "git+https://github.com/HumeAI/hume-typescript-sdk.git"
    },
    "type": "commonjs",
    "main": "./dist/cjs/index.js",
    "module": "./dist/esm/index.mjs",
    "types": "./dist/cjs/index.d.ts",
    "exports": {
        ".": {
            "types": "./dist/cjs/index.d.ts",
            "import": {
                "types": "./dist/esm/index.d.mts",
                "default": "./dist/esm/index.mjs"
            },
            "require": {
                "types": "./dist/cjs/index.d.ts",
                "default": "./dist/cjs/index.js"
            },
            "default": "./dist/cjs/index.js"
        },
        "./serialization": {
            "types": "./dist/cjs/serialization/index.d.ts",
            "import": {
                "types": "./dist/esm/serialization/index.d.mts",
                "default": "./dist/esm/serialization/index.mjs"
            },
            "require": {
                "types": "./dist/cjs/serialization/index.d.ts",
                "default": "./dist/cjs/serialization/index.js"
            },
            "default": "./dist/cjs/serialization/index.js"
        },
        "./package.json": "./package.json"
    },
    "files": [
        "dist",
        "reference.md",
        "README.md",
        "LICENSE"
    ],
    "scripts": {
        "format": "biome format --write --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
        "format:check": "biome format --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
        "lint": "biome lint --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
        "lint:fix": "biome lint --fix --unsafe --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
        "check": "biome check --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
        "check:fix": "biome check --fix --unsafe --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
        "build": "pnpm build:cjs && pnpm build:esm",
        "build:cjs": "tsc --project ./tsconfig.cjs.json",
        "build:esm": "tsc --project ./tsconfig.esm.json && node scripts/rename-to-esm-files.js dist/esm",
        "test": "vitest",
        "test:unit": "vitest --project unit",
        "test:wire": "vitest --project wire"
    },
    "dependencies": {
        "ws": "^8.16.0",
        "uuid": "9.0.1",
        "zod": "^3.23.8"
    },
    "devDependencies": {
        "webpack": "^5.97.1",
        "ts-loader": "^9.5.1",
        "@types/ws": "^8.5.9",
        "vitest": "^3.2.4",
        "msw": "2.11.2",
        "@types/node": "^18.19.70",
        "typescript": "~5.7.2",
        "@biomejs/biome": "2.3.1",
        "@types/uuid": "9.0.7"
    },
    "browser": {
        "fs": false,
        "os": false,
        "path": false,
        "stream": false
    },
    "packageManager": "pnpm@10.20.0",
    "engines": {
        "node": ">=18.0.0"
    },
    "sideEffects": false
}

```


## /pnpm-lock.yaml
```yaml
lockfileVersion: '9.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

importers:

  .:
    dependencies:
      uuid:
        specifier: 9.0.1
        version: 9.0.1
      ws:
        specifier: ^8.16.0
        version: 8.19.0
      zod:
        specifier: ^3.23.8
        version: 3.25.76
    devDependencies:
      '@biomejs/biome':
        specifier: 2.3.1
        version: 2.3.1
      '@types/node':
        specifier: ^18.19.70
        version: 18.19.130
      '@types/uuid':
        specifier: 9.0.7
        version: 9.0.7
      '@types/ws':
        specifier: ^8.5.9
        version: 8.18.1
      msw:
        specifier: 2.11.2
        version: 2.11.2(@types/node@18.19.130)(typescript@5.7.3)
      ts-loader:
        specifier: ^9.5.1
        version: 9.5.4(typescript@5.7.3)(webpack@5.104.1)
      typescript:
        specifier: ~5.7.2
        version: 5.7.3
      vitest:
        specifier: ^3.2.4
        version: 3.2.4(@types/node@18.19.130)(msw@2.11.2(@types/node@18.19.130)(typescript@5.7.3))(terser@5.44.1)
      webpack:
        specifier: ^5.97.1
        version: 5.104.1

packages:

  '@biomejs/biome@2.3.1':
    resolution: {integrity: sha512-A29evf1R72V5bo4o2EPxYMm5mtyGvzp2g+biZvRFx29nWebGyyeOSsDWGx3tuNNMFRepGwxmA9ZQ15mzfabK2w==}
    engines: {node: '>=14.21.3'}
    hasBin: true

  '@biomejs/cli-darwin-arm64@2.3.1':
    resolution: {integrity: sha512-ombSf3MnTUueiYGN1SeI9tBCsDUhpWzOwS63Dove42osNh0PfE1cUtHFx6eZ1+MYCCLwXzlFlYFdrJ+U7h6LcA==}
    engines: {node: '>=14.21.3'}
    cpu: [arm64]
    os: [darwin]

  '@biomejs/cli-darwin-x64@2.3.1':
    resolution: {integrity: sha512-pcOfwyoQkrkbGvXxRvZNe5qgD797IowpJPovPX5biPk2FwMEV+INZqfCaz4G5bVq9hYnjwhRMamg11U4QsRXrQ==}
    engines: {node: '>=14.21.3'}
    cpu: [x64]
    os: [darwin]

  '@biomejs/cli-linux-arm64-musl@2.3.1':
    resolution: {integrity: sha512-+DZYv8l7FlUtTrWs1Tdt1KcNCAmRO87PyOnxKGunbWm5HKg1oZBSbIIPkjrCtDZaeqSG1DiGx7qF+CPsquQRcg==}
    engines: {node: '>=14.21.3'}
    cpu: [arm64]
    os: [linux]

  '@biomejs/cli-linux-arm64@2.3.1':
    resolution: {integrity: sha512-td5O8pFIgLs8H1sAZsD6v+5quODihyEw4nv2R8z7swUfIK1FKk+15e4eiYVLcAE4jUqngvh4j3JCNgg0Y4o4IQ==}
    engines: {node: '>=14.21.3'}
    cpu: [arm64]
    os: [linux]

  '@biomejs/cli-linux-x64-musl@2.3.1':
    resolution: {integrity: sha512-Y3Ob4nqgv38Mh+6EGHltuN+Cq8aj/gyMTJYzkFZV2AEj+9XzoXB9VNljz9pjfFNHUxvLEV4b55VWyxozQTBaUQ==}
    engines: {node: '>=14.21.3'}
    cpu: [x64]
    os: [linux]

  '@biomejs/cli-linux-x64@2.3.1':
    resolution: {integrity: sha512-PYWgEO7up7XYwSAArOpzsVCiqxBCXy53gsReAb1kKYIyXaoAlhBaBMvxR/k2Rm9aTuZ662locXUmPk/Aj+Xu+Q==}
    engines: {node: '>=14.21.3'}
    cpu: [x64]
    os: [linux]

  '@biomejs/cli-win32-arm64@2.3.1':
    resolution: {integrity: sha512-RHIG/zgo+69idUqVvV3n8+j58dKYABRpMyDmfWu2TITC+jwGPiEaT0Q3RKD+kQHiS80mpBrST0iUGeEXT0bU9A==}
    engines: {node: '>=14.21.3'}
    cpu: [arm64]
    os: [win32]

  '@biomejs/cli-win32-x64@2.3.1':
    resolution: {integrity: sha512-izl30JJ5Dp10mi90Eko47zhxE6pYyWPcnX1NQxKpL/yMhXxf95oLTzfpu4q+MDBh/gemNqyJEwjBpe0MT5iWPA==}
    engines: {node: '>=14.21.3'}
    cpu: [x64]
    os: [win32]

  '@bundled-es-modules/cookie@2.0.1':
    resolution: {integrity: sha512-8o+5fRPLNbjbdGRRmJj3h6Hh1AQJf2dk3qQ/5ZFb+PXkRNiSoMGGUKlsgLfrxneb72axVJyIYji64E2+nNfYyw==}

  '@bundled-es-modules/statuses@1.0.1':
    resolution: {integrity: sha512-yn7BklA5acgcBr+7w064fGV+SGIFySjCKpqjcWgBAIfrAkY+4GQTJJHQMeT3V/sgz23VTEVV8TtOmkvJAhFVfg==}

  '@esbuild/aix-ppc64@0.27.2':
    resolution: {integrity: sha512-GZMB+a0mOMZs4MpDbj8RJp4cw+w1WV5NYD6xzgvzUJ5Ek2jerwfO2eADyI6ExDSUED+1X8aMbegahsJi+8mgpw==}
    engines: {node: '>=18'}
    cpu: [ppc64]
    os: [aix]

  '@esbuild/android-arm64@0.27.2':
    resolution: {integrity: sha512-pvz8ZZ7ot/RBphf8fv60ljmaoydPU12VuXHImtAs0XhLLw+EXBi2BLe3OYSBslR4rryHvweW5gmkKFwTiFy6KA==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [android]

  '@esbuild/android-arm@0.27.2':
    resolution: {integrity: sha512-DVNI8jlPa7Ujbr1yjU2PfUSRtAUZPG9I1RwW4F4xFB1Imiu2on0ADiI/c3td+KmDtVKNbi+nffGDQMfcIMkwIA==}
    engines: {node: '>=18'}
    cpu: [arm]
    os: [android]

  '@esbuild/android-x64@0.27.2':
    resolution: {integrity: sha512-z8Ank4Byh4TJJOh4wpz8g2vDy75zFL0TlZlkUkEwYXuPSgX8yzep596n6mT7905kA9uHZsf/o2OJZubl2l3M7A==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [android]

  '@esbuild/darwin-arm64@0.27.2':
    resolution: {integrity: sha512-davCD2Zc80nzDVRwXTcQP/28fiJbcOwvdolL0sOiOsbwBa72kegmVU0Wrh1MYrbuCL98Omp5dVhQFWRKR2ZAlg==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [darwin]

  '@esbuild/darwin-x64@0.27.2':
    resolution: {integrity: sha512-ZxtijOmlQCBWGwbVmwOF/UCzuGIbUkqB1faQRf5akQmxRJ1ujusWsb3CVfk/9iZKr2L5SMU5wPBi1UWbvL+VQA==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [darwin]

  '@esbuild/freebsd-arm64@0.27.2':
    resolution: {integrity: sha512-lS/9CN+rgqQ9czogxlMcBMGd+l8Q3Nj1MFQwBZJyoEKI50XGxwuzznYdwcav6lpOGv5BqaZXqvBSiB/kJ5op+g==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [freebsd]

  '@esbuild/freebsd-x64@0.27.2':
    resolution: {integrity: sha512-tAfqtNYb4YgPnJlEFu4c212HYjQWSO/w/h/lQaBK7RbwGIkBOuNKQI9tqWzx7Wtp7bTPaGC6MJvWI608P3wXYA==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [freebsd]

  '@esbuild/linux-arm64@0.27.2':
    resolution: {integrity: sha512-hYxN8pr66NsCCiRFkHUAsxylNOcAQaxSSkHMMjcpx0si13t1LHFphxJZUiGwojB1a/Hd5OiPIqDdXONia6bhTw==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [linux]

  '@esbuild/linux-arm@0.27.2':
    resolution: {integrity: sha512-vWfq4GaIMP9AIe4yj1ZUW18RDhx6EPQKjwe7n8BbIecFtCQG4CfHGaHuh7fdfq+y3LIA2vGS/o9ZBGVxIDi9hw==}
    engines: {node: '>=18'}
    cpu: [arm]
    os: [linux]

  '@esbuild/linux-ia32@0.27.2':
    resolution: {integrity: sha512-MJt5BRRSScPDwG2hLelYhAAKh9imjHK5+NE/tvnRLbIqUWa+0E9N4WNMjmp/kXXPHZGqPLxggwVhz7QP8CTR8w==}
    engines: {node: '>=18'}
    cpu: [ia32]
    os: [linux]

  '@esbuild/linux-loong64@0.27.2':
    resolution: {integrity: sha512-lugyF1atnAT463aO6KPshVCJK5NgRnU4yb3FUumyVz+cGvZbontBgzeGFO1nF+dPueHD367a2ZXe1NtUkAjOtg==}
    engines: {node: '>=18'}
    cpu: [loong64]
    os: [linux]

  '@esbuild/linux-mips64el@0.27.2':
    resolution: {integrity: sha512-nlP2I6ArEBewvJ2gjrrkESEZkB5mIoaTswuqNFRv/WYd+ATtUpe9Y09RnJvgvdag7he0OWgEZWhviS1OTOKixw==}
    engines: {node: '>=18'}
    cpu: [mips64el]
    os: [linux]

  '@esbuild/linux-ppc64@0.27.2':
    resolution: {integrity: sha512-C92gnpey7tUQONqg1n6dKVbx3vphKtTHJaNG2Ok9lGwbZil6DrfyecMsp9CrmXGQJmZ7iiVXvvZH6Ml5hL6XdQ==}
    engines: {node: '>=18'}
    cpu: [ppc64]
    os: [linux]

  '@esbuild/linux-riscv64@0.27.2':
    resolution: {integrity: sha512-B5BOmojNtUyN8AXlK0QJyvjEZkWwy/FKvakkTDCziX95AowLZKR6aCDhG7LeF7uMCXEJqwa8Bejz5LTPYm8AvA==}
    engines: {node: '>=18'}
    cpu: [riscv64]
    os: [linux]

  '@esbuild/linux-s390x@0.27.2':
    resolution: {integrity: sha512-p4bm9+wsPwup5Z8f4EpfN63qNagQ47Ua2znaqGH6bqLlmJ4bx97Y9JdqxgGZ6Y8xVTixUnEkoKSHcpRlDnNr5w==}
    engines: {node: '>=18'}
    cpu: [s390x]
    os: [linux]

  '@esbuild/linux-x64@0.27.2':
    resolution: {integrity: sha512-uwp2Tip5aPmH+NRUwTcfLb+W32WXjpFejTIOWZFw/v7/KnpCDKG66u4DLcurQpiYTiYwQ9B7KOeMJvLCu/OvbA==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [linux]

  '@esbuild/netbsd-arm64@0.27.2':
    resolution: {integrity: sha512-Kj6DiBlwXrPsCRDeRvGAUb/LNrBASrfqAIok+xB0LxK8CHqxZ037viF13ugfsIpePH93mX7xfJp97cyDuTZ3cw==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [netbsd]

  '@esbuild/netbsd-x64@0.27.2':
    resolution: {integrity: sha512-HwGDZ0VLVBY3Y+Nw0JexZy9o/nUAWq9MlV7cahpaXKW6TOzfVno3y3/M8Ga8u8Yr7GldLOov27xiCnqRZf0tCA==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [netbsd]

  '@esbuild/openbsd-arm64@0.27.2':
    resolution: {integrity: sha512-DNIHH2BPQ5551A7oSHD0CKbwIA/Ox7+78/AWkbS5QoRzaqlev2uFayfSxq68EkonB+IKjiuxBFoV8ESJy8bOHA==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [openbsd]

  '@esbuild/openbsd-x64@0.27.2':
    resolution: {integrity: sha512-/it7w9Nb7+0KFIzjalNJVR5bOzA9Vay+yIPLVHfIQYG/j+j9VTH84aNB8ExGKPU4AzfaEvN9/V4HV+F+vo8OEg==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [openbsd]

  '@esbuild/openharmony-arm64@0.27.2':
    resolution: {integrity: sha512-LRBbCmiU51IXfeXk59csuX/aSaToeG7w48nMwA6049Y4J4+VbWALAuXcs+qcD04rHDuSCSRKdmY63sruDS5qag==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [openharmony]

  '@esbuild/sunos-x64@0.27.2':
    resolution: {integrity: sha512-kMtx1yqJHTmqaqHPAzKCAkDaKsffmXkPHThSfRwZGyuqyIeBvf08KSsYXl+abf5HDAPMJIPnbBfXvP2ZC2TfHg==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [sunos]

  '@esbuild/win32-arm64@0.27.2':
    resolution: {integrity: sha512-Yaf78O/B3Kkh+nKABUF++bvJv5Ijoy9AN1ww904rOXZFLWVc5OLOfL56W+C8F9xn5JQZa3UX6m+IktJnIb1Jjg==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [win32]

  '@esbuild/win32-ia32@0.27.2':
    resolution: {integrity: sha512-Iuws0kxo4yusk7sw70Xa2E2imZU5HoixzxfGCdxwBdhiDgt9vX9VUCBhqcwY7/uh//78A1hMkkROMJq9l27oLQ==}
    engines: {node: '>=18'}
    cpu: [ia32]
    os: [win32]

  '@esbuild/win32-x64@0.27.2':
    resolution: {integrity: sha512-sRdU18mcKf7F+YgheI/zGf5alZatMUTKj/jNS6l744f9u3WFu4v7twcUI9vu4mknF4Y9aDlblIie0IM+5xxaqQ==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [win32]

  '@inquirer/ansi@1.0.2':
    resolution: {integrity: sha512-S8qNSZiYzFd0wAcyG5AXCvUHC5Sr7xpZ9wZ2py9XR88jUz8wooStVx5M6dRzczbBWjic9NP7+rY0Xi7qqK/aMQ==}
    engines: {node: '>=18'}

  '@inquirer/confirm@5.1.21':
    resolution: {integrity: sha512-KR8edRkIsUayMXV+o3Gv+q4jlhENF9nMYUZs9PA2HzrXeHI8M5uDag70U7RJn9yyiMZSbtF5/UexBtAVtZGSbQ==}
    engines: {node: '>=18'}
    peerDependencies:
      '@types/node': '>=18'
    peerDependenciesMeta:
      '@types/node':
        optional: true

  '@inquirer/core@10.3.2':
    resolution: {integrity: sha512-43RTuEbfP8MbKzedNqBrlhhNKVwoK//vUFNW3Q3vZ88BLcrs4kYpGg+B2mm5p2K/HfygoCxuKwJJiv8PbGmE0A==}
    engines: {node: '>=18'}
    peerDependencies:
      '@types/node': '>=18'
    peerDependenciesMeta:
      '@types/node':
        optional: true

  '@inquirer/figures@1.0.15':
    resolution: {integrity: sha512-t2IEY+unGHOzAaVM5Xx6DEWKeXlDDcNPeDyUpsRc6CUhBfU3VQOEl+Vssh7VNp1dR8MdUJBWhuObjXCsVpjN5g==}
    engines: {node: '>=18'}

  '@inquirer/type@3.0.10':
    resolution: {integrity: sha512-BvziSRxfz5Ov8ch0z/n3oijRSEcEsHnhggm4xFZe93DHcUCTlutlq9Ox4SVENAfcRD22UQq7T/atg9Wr3k09eA==}
    engines: {node: '>=18'}
    peerDependencies:
      '@types/node': '>=18'
    peerDependenciesMeta:
      '@types/node':
        optional: true

  '@jridgewell/gen-mapping@0.3.13':
    resolution: {integrity: sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==}

  '@jridgewell/resolve-uri@3.1.2':
    resolution: {integrity: sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/source-map@0.3.11':
    resolution: {integrity: sha512-ZMp1V8ZFcPG5dIWnQLr3NSI1MiCU7UETdS/A0G8V/XWHvJv3ZsFqutJn1Y5RPmAPX6F3BiE397OqveU/9NCuIA==}

  '@jridgewell/sourcemap-codec@1.5.5':
    resolution: {integrity: sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==}

  '@jridgewell/trace-mapping@0.3.31':
    resolution: {integrity: sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==}

  '@mswjs/interceptors@0.39.8':
    resolution: {integrity: sha512-2+BzZbjRO7Ct61k8fMNHEtoKjeWI9pIlHFTqBwZ5icHpqszIgEZbjb1MW5Z0+bITTCTl3gk4PDBxs9tA/csXvA==}
    engines: {node: '>=18'}

  '@open-draft/deferred-promise@2.2.0':
    resolution: {integrity: sha512-CecwLWx3rhxVQF6V4bAgPS5t+So2sTbPgAzafKkVizyi7tlwpcFpdFqq+wqF2OwNBmqFuu6tOyouTuxgpMfzmA==}

  '@open-draft/logger@0.3.0':
    resolution: {integrity: sha512-X2g45fzhxH238HKO4xbSr7+wBS8Fvw6ixhTDuvLd5mqh6bJJCFAPwU9mPDxbcrRtfxv4u5IHCEH77BmxvXmmxQ==}

  '@open-draft/until@2.1.0':
    resolution: {integrity: sha512-U69T3ItWHvLwGg5eJ0n3I62nWuE6ilHlmz7zM0npLBRvPRd7e6NYmg54vvRtP5mZG7kZqZCFVdsTWo7BPtBujg==}

  '@rollup/rollup-android-arm-eabi@4.55.1':
    resolution: {integrity: sha512-9R0DM/ykwfGIlNu6+2U09ga0WXeZ9MRC2Ter8jnz8415VbuIykVuc6bhdrbORFZANDmTDvq26mJrEVTl8TdnDg==}
    cpu: [arm]
    os: [android]

  '@rollup/rollup-android-arm64@4.55.1':
    resolution: {integrity: sha512-eFZCb1YUqhTysgW3sj/55du5cG57S7UTNtdMjCW7LwVcj3dTTcowCsC8p7uBdzKsZYa8J7IDE8lhMI+HX1vQvg==}
    cpu: [arm64]
    os: [android]

  '@rollup/rollup-darwin-arm64@4.55.1':
    resolution: {integrity: sha512-p3grE2PHcQm2e8PSGZdzIhCKbMCw/xi9XvMPErPhwO17vxtvCN5FEA2mSLgmKlCjHGMQTP6phuQTYWUnKewwGg==}
    cpu: [arm64]
    os: [darwin]

  '@rollup/rollup-darwin-x64@4.55.1':
    resolution: {integrity: sha512-rDUjG25C9qoTm+e02Esi+aqTKSBYwVTaoS1wxcN47/Luqef57Vgp96xNANwt5npq9GDxsH7kXxNkJVEsWEOEaQ==}
    cpu: [x64]
    os: [darwin]

  '@rollup/rollup-freebsd-arm64@4.55.1':
    resolution: {integrity: sha512-+JiU7Jbp5cdxekIgdte0jfcu5oqw4GCKr6i3PJTlXTCU5H5Fvtkpbs4XJHRmWNXF+hKmn4v7ogI5OQPaupJgOg==}
    cpu: [arm64]
    os: [freebsd]

  '@rollup/rollup-freebsd-x64@4.55.1':
    resolution: {integrity: sha512-V5xC1tOVWtLLmr3YUk2f6EJK4qksksOYiz/TCsFHu/R+woubcLWdC9nZQmwjOAbmExBIVKsm1/wKmEy4z4u4Bw==}
    cpu: [x64]
    os: [freebsd]

  '@rollup/rollup-linux-arm-gnueabihf@4.55.1':
    resolution: {integrity: sha512-Rn3n+FUk2J5VWx+ywrG/HGPTD9jXNbicRtTM11e/uorplArnXZYsVifnPPqNNP5BsO3roI4n8332ukpY/zN7rQ==}
    cpu: [arm]
    os: [linux]

  '@rollup/rollup-linux-arm-musleabihf@4.55.1':
    resolution: {integrity: sha512-grPNWydeKtc1aEdrJDWk4opD7nFtQbMmV7769hiAaYyUKCT1faPRm2av8CX1YJsZ4TLAZcg9gTR1KvEzoLjXkg==}
    cpu: [arm]
    os: [linux]

  '@rollup/rollup-linux-arm64-gnu@4.55.1':
    resolution: {integrity: sha512-a59mwd1k6x8tXKcUxSyISiquLwB5pX+fJW9TkWU46lCqD/GRDe9uDN31jrMmVP3feI3mhAdvcCClhV8V5MhJFQ==}
    cpu: [arm64]
    os: [linux]

  '@rollup/rollup-linux-arm64-musl@4.55.1':
    resolution: {integrity: sha512-puS1MEgWX5GsHSoiAsF0TYrpomdvkaXm0CofIMG5uVkP6IBV+ZO9xhC5YEN49nsgYo1DuuMquF9+7EDBVYu4uA==}
    cpu: [arm64]
    os: [linux]

  '@rollup/rollup-linux-loong64-gnu@4.55.1':
    resolution: {integrity: sha512-r3Wv40in+lTsULSb6nnoudVbARdOwb2u5fpeoOAZjFLznp6tDU8kd+GTHmJoqZ9lt6/Sys33KdIHUaQihFcu7g==}
    cpu: [loong64]
    os: [linux]

  '@rollup/rollup-linux-loong64-musl@4.55.1':
    resolution: {integrity: sha512-MR8c0+UxAlB22Fq4R+aQSPBayvYa3+9DrwG/i1TKQXFYEaoW3B5b/rkSRIypcZDdWjWnpcvxbNaAJDcSbJU3Lw==}
    cpu: [loong64]
    os: [linux]

  '@rollup/rollup-linux-ppc64-gnu@4.55.1':
    resolution: {integrity: sha512-3KhoECe1BRlSYpMTeVrD4sh2Pw2xgt4jzNSZIIPLFEsnQn9gAnZagW9+VqDqAHgm1Xc77LzJOo2LdigS5qZ+gw==}
    cpu: [ppc64]
    os: [linux]

  '@rollup/rollup-linux-ppc64-musl@4.55.1':
    resolution: {integrity: sha512-ziR1OuZx0vdYZZ30vueNZTg73alF59DicYrPViG0NEgDVN8/Jl87zkAPu4u6VjZST2llgEUjaiNl9JM6HH1Vdw==}
    cpu: [ppc64]
    os: [linux]

  '@rollup/rollup-linux-riscv64-gnu@4.55.1':
    resolution: {integrity: sha512-uW0Y12ih2XJRERZ4jAfKamTyIHVMPQnTZcQjme2HMVDAHY4amf5u414OqNYC+x+LzRdRcnIG1YodLrrtA8xsxw==}
    cpu: [riscv64]
    os: [linux]

  '@rollup/rollup-linux-riscv64-musl@4.55.1':
    resolution: {integrity: sha512-u9yZ0jUkOED1BFrqu3BwMQoixvGHGZ+JhJNkNKY/hyoEgOwlqKb62qu+7UjbPSHYjiVy8kKJHvXKv5coH4wDeg==}
    cpu: [riscv64]
    os: [linux]

  '@rollup/rollup-linux-s390x-gnu@4.55.1':
    resolution: {integrity: sha512-/0PenBCmqM4ZUd0190j7J0UsQ/1nsi735iPRakO8iPciE7BQ495Y6msPzaOmvx0/pn+eJVVlZrNrSh4WSYLxNg==}
    cpu: [s390x]
    os: [linux]

  '@rollup/rollup-linux-x64-gnu@4.55.1':
    resolution: {integrity: sha512-a8G4wiQxQG2BAvo+gU6XrReRRqj+pLS2NGXKm8io19goR+K8lw269eTrPkSdDTALwMmJp4th2Uh0D8J9bEV1vg==}
    cpu: [x64]
    os: [linux]

  '@rollup/rollup-linux-x64-musl@4.55.1':
    resolution: {integrity: sha512-bD+zjpFrMpP/hqkfEcnjXWHMw5BIghGisOKPj+2NaNDuVT+8Ds4mPf3XcPHuat1tz89WRL+1wbcxKY3WSbiT7w==}
    cpu: [x64]
    os: [linux]

  '@rollup/rollup-openbsd-x64@4.55.1':
    resolution: {integrity: sha512-eLXw0dOiqE4QmvikfQ6yjgkg/xDM+MdU9YJuP4ySTibXU0oAvnEWXt7UDJmD4UkYialMfOGFPJnIHSe/kdzPxg==}
    cpu: [x64]
    os: [openbsd]

  '@rollup/rollup-openharmony-arm64@4.55.1':
    resolution: {integrity: sha512-xzm44KgEP11te3S2HCSyYf5zIzWmx3n8HDCc7EE59+lTcswEWNpvMLfd9uJvVX8LCg9QWG67Xt75AuHn4vgsXw==}
    cpu: [arm64]
    os: [openharmony]

  '@rollup/rollup-win32-arm64-msvc@4.55.1':
    resolution: {integrity: sha512-yR6Bl3tMC/gBok5cz/Qi0xYnVbIxGx5Fcf/ca0eB6/6JwOY+SRUcJfI0OpeTpPls7f194as62thCt/2BjxYN8g==}
    cpu: [arm64]
    os: [win32]

  '@rollup/rollup-win32-ia32-msvc@4.55.1':
    resolution: {integrity: sha512-3fZBidchE0eY0oFZBnekYCfg+5wAB0mbpCBuofh5mZuzIU/4jIVkbESmd2dOsFNS78b53CYv3OAtwqkZZmU5nA==}
    cpu: [ia32]
    os: [win32]

  '@rollup/rollup-win32-x64-gnu@4.55.1':
    resolution: {integrity: sha512-xGGY5pXj69IxKb4yv/POoocPy/qmEGhimy/FoTpTSVju3FYXUQQMFCaZZXJVidsmGxRioZAwpThl/4zX41gRKg==}
    cpu: [x64]
    os: [win32]

  '@rollup/rollup-win32-x64-msvc@4.55.1':
    resolution: {integrity: sha512-SPEpaL6DX4rmcXtnhdrQYgzQ5W2uW3SCJch88lB2zImhJRhIIK44fkUrgIV/Q8yUNfw5oyZ5vkeQsZLhCb06lw==}
    cpu: [x64]
    os: [win32]

  '@types/chai@5.2.3':
    resolution: {integrity: sha512-Mw558oeA9fFbv65/y4mHtXDs9bPnFMZAL/jxdPFUpOHHIXX91mcgEHbS5Lahr+pwZFR8A7GQleRWeI6cGFC2UA==}

  '@types/cookie@0.6.0':
    resolution: {integrity: sha512-4Kh9a6B2bQciAhf7FSuMRRkUWecJgJu9nPnx3yzpsfXX/c50REIqpHY4C82bXP90qrLtXtkDxTZosYO3UpOwlA==}

  '@types/deep-eql@4.0.2':
    resolution: {integrity: sha512-c9h9dVVMigMPc4bwTvC5dxqtqJZwQPePsWjPlpSOnojbor6pGqdk541lfA7AqFQr5pB1BRdq0juY9db81BwyFw==}

  '@types/eslint-scope@3.7.7':
    resolution: {integrity: sha512-MzMFlSLBqNF2gcHWO0G1vP/YQyfvrxZ0bF+u7mzUdZ1/xK4A4sru+nraZz5i3iEIk1l1uyicaDVTB4QbbEkAYg==}

  '@types/eslint@9.6.1':
    resolution: {integrity: sha512-FXx2pKgId/WyYo2jXw63kk7/+TY7u7AziEJxJAnSFzHlqTAS3Ync6SvgYAN/k4/PQpnnVuzoMuVnByKK2qp0ag==}

  '@types/estree@1.0.8':
    resolution: {integrity: sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==}

  '@types/json-schema@7.0.15':
    resolution: {integrity: sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==}

  '@types/node@18.19.130':
    resolution: {integrity: sha512-GRaXQx6jGfL8sKfaIDD6OupbIHBr9jv7Jnaml9tB7l4v068PAOXqfcujMMo5PhbIs6ggR1XODELqahT2R8v0fg==}

  '@types/statuses@2.0.6':
    resolution: {integrity: sha512-xMAgYwceFhRA2zY+XbEA7mxYbA093wdiW8Vu6gZPGWy9cmOyU9XesH1tNcEWsKFd5Vzrqx5T3D38PWx1FIIXkA==}

  '@types/uuid@9.0.7':
    resolution: {integrity: sha512-WUtIVRUZ9i5dYXefDEAI7sh9/O7jGvHg7Df/5O/gtH3Yabe5odI3UWopVR1qbPXQtvOxWu3mM4XxlYeZtMWF4g==}

  '@types/ws@8.18.1':
    resolution: {integrity: sha512-ThVF6DCVhA8kUGy+aazFQ4kXQ7E1Ty7A3ypFOe0IcJV8O/M511G99AW24irKrW56Wt44yG9+ij8FaqoBGkuBXg==}

  '@vitest/expect@3.2.4':
    resolution: {integrity: sha512-Io0yyORnB6sikFlt8QW5K7slY4OjqNX9jmJQ02QDda8lyM6B5oNgVWoSoKPac8/kgnCUzuHQKrSLtu/uOqqrig==}

  '@vitest/mocker@3.2.4':
    resolution: {integrity: sha512-46ryTE9RZO/rfDd7pEqFl7etuyzekzEhUbTW3BvmeO/BcCMEgq59BKhek3dXDWgAj4oMK6OZi+vRr1wPW6qjEQ==}
    peerDependencies:
      msw: ^2.4.9
      vite: ^5.0.0 || ^6.0.0 || ^7.0.0-0
    peerDependenciesMeta:
      msw:
        optional: true
      vite:
        optional: true

  '@vitest/pretty-format@3.2.4':
    resolution: {integrity: sha512-IVNZik8IVRJRTr9fxlitMKeJeXFFFN0JaB9PHPGQ8NKQbGpfjlTx9zO4RefN8gp7eqjNy8nyK3NZmBzOPeIxtA==}

  '@vitest/runner@3.2.4':
    resolution: {integrity: sha512-oukfKT9Mk41LreEW09vt45f8wx7DordoWUZMYdY/cyAk7w5TWkTRCNZYF7sX7n2wB7jyGAl74OxgwhPgKaqDMQ==}

  '@vitest/snapshot@3.2.4':
    resolution: {integrity: sha512-dEYtS7qQP2CjU27QBC5oUOxLE/v5eLkGqPE0ZKEIDGMs4vKWe7IjgLOeauHsR0D5YuuycGRO5oSRXnwnmA78fQ==}

  '@vitest/spy@3.2.4':
    resolution: {integrity: sha512-vAfasCOe6AIK70iP5UD11Ac4siNUNJ9i/9PZ3NKx07sG6sUxeag1LWdNrMWeKKYBLlzuK+Gn65Yd5nyL6ds+nw==}

  '@vitest/utils@3.2.4':
    resolution: {integrity: sha512-fB2V0JFrQSMsCo9HiSq3Ezpdv4iYaXRG1Sx8edX3MwxfyNn83mKiGzOcH+Fkxt4MHxr3y42fQi1oeAInqgX2QA==}

  '@webassemblyjs/ast@1.14.1':
    resolution: {integrity: sha512-nuBEDgQfm1ccRp/8bCQrx1frohyufl4JlbMMZ4P1wpeOfDhF6FQkxZJ1b/e+PLwr6X1Nhw6OLme5usuBWYBvuQ==}

  '@webassemblyjs/floating-point-hex-parser@1.13.2':
    resolution: {integrity: sha512-6oXyTOzbKxGH4steLbLNOu71Oj+C8Lg34n6CqRvqfS2O71BxY6ByfMDRhBytzknj9yGUPVJ1qIKhRlAwO1AovA==}

  '@webassemblyjs/helper-api-error@1.13.2':
    resolution: {integrity: sha512-U56GMYxy4ZQCbDZd6JuvvNV/WFildOjsaWD3Tzzvmw/mas3cXzRJPMjP83JqEsgSbyrmaGjBfDtV7KDXV9UzFQ==}

  '@webassemblyjs/helper-buffer@1.14.1':
    resolution: {integrity: sha512-jyH7wtcHiKssDtFPRB+iQdxlDf96m0E39yb0k5uJVhFGleZFoNw1c4aeIcVUPPbXUVJ94wwnMOAqUHyzoEPVMA==}

  '@webassemblyjs/helper-numbers@1.13.2':
    resolution: {integrity: sha512-FE8aCmS5Q6eQYcV3gI35O4J789wlQA+7JrqTTpJqn5emA4U2hvwJmvFRC0HODS+3Ye6WioDklgd6scJ3+PLnEA==}

  '@webassemblyjs/helper-wasm-bytecode@1.13.2':
    resolution: {integrity: sha512-3QbLKy93F0EAIXLh0ogEVR6rOubA9AoZ+WRYhNbFyuB70j3dRdwH9g+qXhLAO0kiYGlg3TxDV+I4rQTr/YNXkA==}

  '@webassemblyjs/helper-wasm-section@1.14.1':
    resolution: {integrity: sha512-ds5mXEqTJ6oxRoqjhWDU83OgzAYjwsCV8Lo/N+oRsNDmx/ZDpqalmrtgOMkHwxsG0iI//3BwWAErYRHtgn0dZw==}

  '@webassemblyjs/ieee754@1.13.2':
    resolution: {integrity: sha512-4LtOzh58S/5lX4ITKxnAK2USuNEvpdVV9AlgGQb8rJDHaLeHciwG4zlGr0j/SNWlr7x3vO1lDEsuePvtcDNCkw==}

  '@webassemblyjs/leb128@1.13.2':
    resolution: {integrity: sha512-Lde1oNoIdzVzdkNEAWZ1dZ5orIbff80YPdHx20mrHwHrVNNTjNr8E3xz9BdpcGqRQbAEa+fkrCb+fRFTl/6sQw==}

  '@webassemblyjs/utf8@1.13.2':
    resolution: {integrity: sha512-3NQWGjKTASY1xV5m7Hr0iPeXD9+RDobLll3T9d2AO+g3my8xy5peVyjSag4I50mR1bBSN/Ct12lo+R9tJk0NZQ==}

  '@webassemblyjs/wasm-edit@1.14.1':
    resolution: {integrity: sha512-RNJUIQH/J8iA/1NzlE4N7KtyZNHi3w7at7hDjvRNm5rcUXa00z1vRz3glZoULfJ5mpvYhLybmVcwcjGrC1pRrQ==}

  '@webassemblyjs/wasm-gen@1.14.1':
    resolution: {integrity: sha512-AmomSIjP8ZbfGQhumkNvgC33AY7qtMCXnN6bL2u2Js4gVCg8fp735aEiMSBbDR7UQIj90n4wKAFUSEd0QN2Ukg==}

  '@webassemblyjs/wasm-opt@1.14.1':
    resolution: {integrity: sha512-PTcKLUNvBqnY2U6E5bdOQcSM+oVP/PmrDY9NzowJjislEjwP/C4an2303MCVS2Mg9d3AJpIGdUFIQQWbPds0Sw==}

  '@webassemblyjs/wasm-parser@1.14.1':
    resolution: {integrity: sha512-JLBl+KZ0R5qB7mCnud/yyX08jWFw5MsoalJ1pQ4EdFlgj9VdXKGuENGsiCIjegI1W7p91rUlcB/LB5yRJKNTcQ==}

  '@webassemblyjs/wast-printer@1.14.1':
    resolution: {integrity: sha512-kPSSXE6De1XOR820C90RIo2ogvZG+c3KiHzqUoO/F34Y2shGzesfqv7o57xrxovZJH/MetF5UjroJ/R/3isoiw==}

  '@xtuc/ieee754@1.2.0':
    resolution: {integrity: sha512-DX8nKgqcGwsc0eJSqYt5lwP4DH5FlHnmuWWBRy7X0NcaGR0ZtuyeESgMwTYVEtxmsNGY+qit4QYT/MIYTOTPeA==}

  '@xtuc/long@4.2.2':
    resolution: {integrity: sha512-NuHqBY1PB/D8xU6s/thBgOAiAP7HOYDQ32+BFZILJ8ivkUkAHQnWfn6WhL79Owj1qmUnoN/YPhktdIoucipkAQ==}

  acorn-import-phases@1.0.4:
    resolution: {integrity: sha512-wKmbr/DDiIXzEOiWrTTUcDm24kQ2vGfZQvM2fwg2vXqR5uW6aapr7ObPtj1th32b9u90/Pf4AItvdTh42fBmVQ==}
    engines: {node: '>=10.13.0'}
    peerDependencies:
      acorn: ^8.14.0

  acorn@8.15.0:
    resolution: {integrity: sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==}
    engines: {node: '>=0.4.0'}
    hasBin: true

  ajv-formats@2.1.1:
    resolution: {integrity: sha512-Wx0Kx52hxE7C18hkMEggYlEifqWZtYaRgouJor+WMdPnQyEK13vgEWyVNup7SoeeoLMsr4kf5h6dOW11I15MUA==}
    peerDependencies:
      ajv: ^8.0.0
    peerDependenciesMeta:
      ajv:
        optional: true

  ajv-keywords@5.1.0:
    resolution: {integrity: sha512-YCS/JNFAUyr5vAuhk1DWm1CBxRHW9LbJ2ozWeemrIqpbsqKjHVxYPyi5GC0rjZIT5JxJ3virVTS8wk4i/Z+krw==}
    peerDependencies:
      ajv: ^8.8.2

  ajv@8.17.1:
    resolution: {integrity: sha512-B/gBuNg5SiMTrPkC+A2+cW0RszwxYmn6VYxB/inlBStS5nx6xHIt/ehKRhIMhqusl7a8LjQoZnjCs5vhwxOQ1g==}

  ansi-regex@5.0.1:
    resolution: {integrity: sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==}
    engines: {node: '>=8'}

  ansi-styles@4.3.0:
    resolution: {integrity: sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==}
    engines: {node: '>=8'}

  assertion-error@2.0.1:
    resolution: {integrity: sha512-Izi8RQcffqCeNVgFigKli1ssklIbpHnCYc6AknXGYoB6grJqyeby7jv12JUQgmTAnIDnbck1uxksT4dzN3PWBA==}
    engines: {node: '>=12'}

  baseline-browser-mapping@2.9.11:
    resolution: {integrity: sha512-Sg0xJUNDU1sJNGdfGWhVHX0kkZ+HWcvmVymJbj6NSgZZmW/8S9Y2HQ5euytnIgakgxN6papOAWiwDo1ctFDcoQ==}
    hasBin: true

  braces@3.0.3:
    resolution: {integrity: sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==}
    engines: {node: '>=8'}

  browserslist@4.28.1:
    resolution: {integrity: sha512-ZC5Bd0LgJXgwGqUknZY/vkUQ04r8NXnJZ3yYi4vDmSiZmC/pdSN0NbNRPxZpbtO4uAfDUAFffO8IZoM3Gj8IkA==}
    engines: {node: ^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7}
    hasBin: true

  buffer-from@1.1.2:
    resolution: {integrity: sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==}

  cac@6.7.14:
    resolution: {integrity: sha512-b6Ilus+c3RrdDk+JhLKUAQfzzgLEPy6wcXqS7f/xe1EETvsDP6GORG7SFuOs6cID5YkqchW/LXZbX5bc8j7ZcQ==}
    engines: {node: '>=8'}

  caniuse-lite@1.0.30001762:
    resolution: {integrity: sha512-PxZwGNvH7Ak8WX5iXzoK1KPZttBXNPuaOvI2ZYU7NrlM+d9Ov+TUvlLOBNGzVXAntMSMMlJPd+jY6ovrVjSmUw==}

  chai@5.3.3:
    resolution: {integrity: sha512-4zNhdJD/iOjSH0A05ea+Ke6MU5mmpQcbQsSOkgdaUMJ9zTlDTD/GYlwohmIE2u0gaxHYiVHEn1Fw9mZ/ktJWgw==}
    engines: {node: '>=18'}

  chalk@4.1.2:
    resolution: {integrity: sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==}
    engines: {node: '>=10'}

  check-error@2.1.3:
    resolution: {integrity: sha512-PAJdDJusoxnwm1VwW07VWwUN1sl7smmC3OKggvndJFadxxDRyFJBX/ggnu/KE4kQAB7a3Dp8f/YXC1FlUprWmA==}
    engines: {node: '>= 16'}

  chrome-trace-event@1.0.4:
    resolution: {integrity: sha512-rNjApaLzuwaOTjCiT8lSDdGN1APCiqkChLMJxJPWLunPAt5fy8xgU9/jNOchV84wfIxrA0lRQB7oCT8jrn/wrQ==}
    engines: {node: '>=6.0'}

  cli-width@4.1.0:
    resolution: {integrity: sha512-ouuZd4/dm2Sw5Gmqy6bGyNNNe1qt9RpmxveLSO7KcgsTnU7RXfsw+/bukWGo1abgBiMAic068rclZsO4IWmmxQ==}
    engines: {node: '>= 12'}

  cliui@8.0.1:
    resolution: {integrity: sha512-BSeNnyus75C4//NQ9gQt1/csTXyo/8Sb+afLAkzAptFuMsod9HFokGNudZpi/oQV73hnVK+sR+5PVRMd+Dr7YQ==}
    engines: {node: '>=12'}

  color-convert@2.0.1:
    resolution: {integrity: sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==}
    engines: {node: '>=7.0.0'}

  color-name@1.1.4:
    resolution: {integrity: sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==}

  commander@2.20.3:
    resolution: {integrity: sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==}

  cookie@0.7.2:
    resolution: {integrity: sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==}
    engines: {node: '>= 0.6'}

  debug@4.4.3:
    resolution: {integrity: sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==}
    engines: {node: '>=6.0'}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  deep-eql@5.0.2:
    resolution: {integrity: sha512-h5k/5U50IJJFpzfL6nO9jaaumfjO/f2NjK/oYB2Djzm4p9L+3T9qWpZqZ2hAbLPuuYq9wrU08WQyBTL5GbPk5Q==}
    engines: {node: '>=6'}

  electron-to-chromium@1.5.267:
    resolution: {integrity: sha512-0Drusm6MVRXSOJpGbaSVgcQsuB4hEkMpHXaVstcPmhu5LIedxs1xNK/nIxmQIU/RPC0+1/o0AVZfBTkTNJOdUw==}

  emoji-regex@8.0.0:
    resolution: {integrity: sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==}

  enhanced-resolve@5.18.4:
    resolution: {integrity: sha512-LgQMM4WXU3QI+SYgEc2liRgznaD5ojbmY3sb8LxyguVkIg5FxdpTkvk72te2R38/TGKxH634oLxXRGY6d7AP+Q==}
    engines: {node: '>=10.13.0'}

  es-module-lexer@1.7.0:
    resolution: {integrity: sha512-jEQoCwk8hyb2AZziIOLhDqpm5+2ww5uIE6lkO/6jcOCusfk6LhMHpXXfBLXTZ7Ydyt0j4VoUQv6uGNYbdW+kBA==}

  es-module-lexer@2.0.0:
    resolution: {integrity: sha512-5POEcUuZybH7IdmGsD8wlf0AI55wMecM9rVBTI/qEAy2c1kTOm3DjFYjrBdI2K3BaJjJYfYFeRtM0t9ssnRuxw==}

  esbuild@0.27.2:
    resolution: {integrity: sha512-HyNQImnsOC7X9PMNaCIeAm4ISCQXs5a5YasTXVliKv4uuBo1dKrG0A+uQS8M5eXjVMnLg3WgXaKvprHlFJQffw==}
    engines: {node: '>=18'}
    hasBin: true

  escalade@3.2.0:
    resolution: {integrity: sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==}
    engines: {node: '>=6'}

  eslint-scope@5.1.1:
    resolution: {integrity: sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==}
    engines: {node: '>=8.0.0'}

  esrecurse@4.3.0:
    resolution: {integrity: sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==}
    engines: {node: '>=4.0'}

  estraverse@4.3.0:
    resolution: {integrity: sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==}
    engines: {node: '>=4.0'}

  estraverse@5.3.0:
    resolution: {integrity: sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==}
    engines: {node: '>=4.0'}

  estree-walker@3.0.3:
    resolution: {integrity: sha512-7RUKfXgSMMkzt6ZuXmqapOurLGPPfgj6l9uRZ7lRGolvk0y2yocc35LdcxKC5PQZdn2DMqioAQ2NoWcrTKmm6g==}

  events@3.3.0:
    resolution: {integrity: sha512-mQw+2fkQbALzQ7V0MY0IqdnXNOeTtP4r0lN9z7AAawCXgqea7bDii20AYrIBrFd/Hx0M2Ocz6S111CaFkUcb0Q==}
    engines: {node: '>=0.8.x'}

  expect-type@1.3.0:
    resolution: {integrity: sha512-knvyeauYhqjOYvQ66MznSMs83wmHrCycNEN6Ao+2AeYEfxUIkuiVxdEa1qlGEPK+We3n0THiDciYSsCcgW/DoA==}
    engines: {node: '>=12.0.0'}

  fast-deep-equal@3.1.3:
    resolution: {integrity: sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==}

  fast-uri@3.1.0:
    resolution: {integrity: sha512-iPeeDKJSWf4IEOasVVrknXpaBV0IApz/gp7S2bb7Z4Lljbl2MGJRqInZiUrQwV16cpzw/D3S5j5Julj/gT52AA==}

  fdir@6.5.0:
    resolution: {integrity: sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==}
    engines: {node: '>=12.0.0'}
    peerDependencies:
      picomatch: ^3 || ^4
    peerDependenciesMeta:
      picomatch:
        optional: true

  fill-range@7.1.1:
    resolution: {integrity: sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==}
    engines: {node: '>=8'}

  fsevents@2.3.3:
    resolution: {integrity: sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==}
    engines: {node: ^8.16.0 || ^10.6.0 || >=11.0.0}
    os: [darwin]

  get-caller-file@2.0.5:
    resolution: {integrity: sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==}
    engines: {node: 6.* || 8.* || >= 10.*}

  glob-to-regexp@0.4.1:
    resolution: {integrity: sha512-lkX1HJXwyMcprw/5YUZc2s7DrpAiHB21/V+E1rHUrVNokkvB6bqMzT0VfV6/86ZNabt1k14YOIaT7nDvOX3Iiw==}

  graceful-fs@4.2.11:
    resolution: {integrity: sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==}

  graphql@16.12.0:
    resolution: {integrity: sha512-DKKrynuQRne0PNpEbzuEdHlYOMksHSUI8Zc9Unei5gTsMNA2/vMpoMz/yKba50pejK56qj98qM0SjYxAKi13gQ==}
    engines: {node: ^12.22.0 || ^14.16.0 || ^16.0.0 || >=17.0.0}

  has-flag@4.0.0:
    resolution: {integrity: sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==}
    engines: {node: '>=8'}

  headers-polyfill@4.0.3:
    resolution: {integrity: sha512-IScLbePpkvO846sIwOtOTDjutRMWdXdJmXdMvk6gCBHxFO8d+QKOQedyZSxFTTFYRSmlgSTDtXqqq4pcenBXLQ==}

  is-fullwidth-code-point@3.0.0:
    resolution: {integrity: sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==}
    engines: {node: '>=8'}

  is-node-process@1.2.0:
    resolution: {integrity: sha512-Vg4o6/fqPxIjtxgUH5QLJhwZ7gW5diGCVlXpuUfELC62CuxM1iHcRe51f2W1FDy04Ai4KJkagKjx3XaqyfRKXw==}

  is-number@7.0.0:
    resolution: {integrity: sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==}
    engines: {node: '>=0.12.0'}

  jest-worker@27.5.1:
    resolution: {integrity: sha512-7vuh85V5cdDofPyxn58nrPjBktZo0u9x1g8WtjQol+jZDaE+fhN+cIvTj11GndBnMnyfrUOG1sZQxCdjKh+DKg==}
    engines: {node: '>= 10.13.0'}

  js-tokens@9.0.1:
    resolution: {integrity: sha512-mxa9E9ITFOt0ban3j6L5MpjwegGz6lBQmM1IJkWeBZGcMxto50+eWdjC/52xDbS2vy0k7vIMK0Fe2wfL9OQSpQ==}

  json-parse-even-better-errors@2.3.1:
    resolution: {integrity: sha512-xyFwyhro/JEof6Ghe2iz2NcXoj2sloNsWr/XsERDK/oiPCfaNhl5ONfp+jQdAZRQQ0IJWNzH9zIZF7li91kh2w==}

  json-schema-traverse@1.0.0:
    resolution: {integrity: sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==}

  loader-runner@4.3.1:
    resolution: {integrity: sha512-IWqP2SCPhyVFTBtRcgMHdzlf9ul25NwaFx4wCEH/KjAXuuHY4yNjvPXsBokp8jCB936PyWRaPKUNh8NvylLp2Q==}
    engines: {node: '>=6.11.5'}

  loupe@3.2.1:
    resolution: {integrity: sha512-CdzqowRJCeLU72bHvWqwRBBlLcMEtIvGrlvef74kMnV2AolS9Y8xUv1I0U/MNAWMhBlKIoyuEgoJ0t/bbwHbLQ==}

  magic-string@0.30.21:
    resolution: {integrity: sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==}

  merge-stream@2.0.0:
    resolution: {integrity: sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==}

  micromatch@4.0.8:
    resolution: {integrity: sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==}
    engines: {node: '>=8.6'}

  mime-db@1.52.0:
    resolution: {integrity: sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==}
    engines: {node: '>= 0.6'}

  mime-types@2.1.35:
    resolution: {integrity: sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==}
    engines: {node: '>= 0.6'}

  ms@2.1.3:
    resolution: {integrity: sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==}

  msw@2.11.2:
    resolution: {integrity: sha512-MI54hLCsrMwiflkcqlgYYNJJddY5/+S0SnONvhv1owOplvqohKSQyGejpNdUGyCwgs4IH7PqaNbPw/sKOEze9Q==}
    engines: {node: '>=18'}
    hasBin: true
    peerDependencies:
      typescript: '>= 4.8.x'
    peerDependenciesMeta:
      typescript:
        optional: true

  mute-stream@2.0.0:
    resolution: {integrity: sha512-WWdIxpyjEn+FhQJQQv9aQAYlHoNVdzIzUySNV1gHUPDSdZJ3yZn7pAAbQcV7B56Mvu881q9FZV+0Vx2xC44VWA==}
    engines: {node: ^18.17.0 || >=20.5.0}

  nanoid@3.3.11:
    resolution: {integrity: sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==}
    engines: {node: ^10 || ^12 || ^13.7 || ^14 || >=15.0.1}
    hasBin: true

  neo-async@2.6.2:
    resolution: {integrity: sha512-Yd3UES5mWCSqR+qNT93S3UoYUkqAZ9lLg8a7g9rimsWmYGK8cVToA4/sF3RrshdyV3sAGMXVUmpMYOw+dLpOuw==}

  node-releases@2.0.27:
    resolution: {integrity: sha512-nmh3lCkYZ3grZvqcCH+fjmQ7X+H0OeZgP40OierEaAptX4XofMh5kwNbWh7lBduUzCcV/8kZ+NDLCwm2iorIlA==}

  outvariant@1.4.3:
    resolution: {integrity: sha512-+Sl2UErvtsoajRDKCE5/dBz4DIvHXQQnAxtQTF04OJxY0+DyZXSo5P5Bb7XYWOh81syohlYL24hbDwxedPUJCA==}

  path-to-regexp@6.3.0:
    resolution: {integrity: sha512-Yhpw4T9C6hPpgPeA28us07OJeqZ5EzQTkbfwuhsUg0c237RomFoETJgmp2sa3F/41gfLE6G5cqcYwznmeEeOlQ==}

  pathe@2.0.3:
    resolution: {integrity: sha512-WUjGcAqP1gQacoQe+OBJsFA7Ld4DyXuUIjZ5cc75cLHvJ7dtNsTugphxIADwspS+AraAUePCKrSVtPLFj/F88w==}

  pathval@2.0.1:
    resolution: {integrity: sha512-//nshmD55c46FuFw26xV/xFAaB5HF9Xdap7HJBBnrKdAd6/GxDBaNA1870O79+9ueg61cZLSVc+OaFlfmObYVQ==}
    engines: {node: '>= 14.16'}

  picocolors@1.1.1:
    resolution: {integrity: sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==}

  picomatch@2.3.1:
    resolution: {integrity: sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==}
    engines: {node: '>=8.6'}

  picomatch@4.0.3:
    resolution: {integrity: sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==}
    engines: {node: '>=12'}

  postcss@8.5.6:
    resolution: {integrity: sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==}
    engines: {node: ^10 || ^12 || >=14}

  randombytes@2.1.0:
    resolution: {integrity: sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==}

  require-directory@2.1.1:
    resolution: {integrity: sha512-fGxEI7+wsG9xrvdjsrlmL22OMTTiHRwAMroiEeMgq8gzoLC/PQr7RsRDSTLUg/bZAZtF+TVIkHc6/4RIKrui+Q==}
    engines: {node: '>=0.10.0'}

  require-from-string@2.0.2:
    resolution: {integrity: sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==}
    engines: {node: '>=0.10.0'}

  rettime@0.7.0:
    resolution: {integrity: sha512-LPRKoHnLKd/r3dVxcwO7vhCW+orkOGj9ViueosEBK6ie89CijnfRlhaDhHq/3Hxu4CkWQtxwlBG0mzTQY6uQjw==}

  rollup@4.55.1:
    resolution: {integrity: sha512-wDv/Ht1BNHB4upNbK74s9usvl7hObDnvVzknxqY/E/O3X6rW1U1rV1aENEfJ54eFZDTNo7zv1f5N4edCluH7+A==}
    engines: {node: '>=18.0.0', npm: '>=8.0.0'}
    hasBin: true

  safe-buffer@5.2.1:
    resolution: {integrity: sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==}

  schema-utils@4.3.3:
    resolution: {integrity: sha512-eflK8wEtyOE6+hsaRVPxvUKYCpRgzLqDTb8krvAsRIwOGlHoSgYLgBXoubGgLd2fT41/OUYdb48v4k4WWHQurA==}
    engines: {node: '>= 10.13.0'}

  semver@7.7.3:
    resolution: {integrity: sha512-SdsKMrI9TdgjdweUSR9MweHA4EJ8YxHn8DFaDisvhVlUOe4BF1tLD7GAj0lIqWVl+dPb/rExr0Btby5loQm20Q==}
    engines: {node: '>=10'}
    hasBin: true

  serialize-javascript@6.0.2:
    resolution: {integrity: sha512-Saa1xPByTTq2gdeFZYLLo+RFE35NHZkAbqZeWNd3BpzppeVisAqpDjcp8dyf6uIvEqJRd46jemmyA4iFIeVk8g==}

  siginfo@2.0.0:
    resolution: {integrity: sha512-ybx0WO1/8bSBLEWXZvEd7gMW3Sn3JFlW3TvX1nREbDLRNQNaeNN8WK0meBwPdAaOI7TtRRRJn/Es1zhrrCHu7g==}

  signal-exit@4.1.0:
    resolution: {integrity: sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==}
    engines: {node: '>=14'}

  source-map-js@1.2.1:
    resolution: {integrity: sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==}
    engines: {node: '>=0.10.0'}

  source-map-support@0.5.21:
    resolution: {integrity: sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==}

  source-map@0.6.1:
    resolution: {integrity: sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==}
    engines: {node: '>=0.10.0'}

  source-map@0.7.6:
    resolution: {integrity: sha512-i5uvt8C3ikiWeNZSVZNWcfZPItFQOsYTUAOkcUPGd8DqDy1uOUikjt5dG+uRlwyvR108Fb9DOd4GvXfT0N2/uQ==}
    engines: {node: '>= 12'}

  stackback@0.0.2:
    resolution: {integrity: sha512-1XMJE5fQo1jGH6Y/7ebnwPOBEkIEnT4QF32d5R1+VXdXveM0IBMJt8zfaxX1P3QhVwrYe+576+jkANtSS2mBbw==}

  statuses@2.0.2:
    resolution: {integrity: sha512-DvEy55V3DB7uknRo+4iOGT5fP1slR8wQohVdknigZPMpMstaKJQWhwiYBACJE3Ul2pTnATihhBYnRhZQHGBiRw==}
    engines: {node: '>= 0.8'}

  std-env@3.10.0:
    resolution: {integrity: sha512-5GS12FdOZNliM5mAOxFRg7Ir0pWz8MdpYm6AY6VPkGpbA7ZzmbzNcBJQ0GPvvyWgcY7QAhCgf9Uy89I03faLkg==}

  strict-event-emitter@0.5.1:
    resolution: {integrity: sha512-vMgjE/GGEPEFnhFub6pa4FmJBRBVOLpIII2hvCZ8Kzb7K0hlHo7mQv6xYrBvCL2LtAIBwFUK8wvuJgTVSQ5MFQ==}

  string-width@4.2.3:
    resolution: {integrity: sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==}
    engines: {node: '>=8'}

  strip-ansi@6.0.1:
    resolution: {integrity: sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==}
    engines: {node: '>=8'}

  strip-literal@3.1.0:
    resolution: {integrity: sha512-8r3mkIM/2+PpjHoOtiAW8Rg3jJLHaV7xPwG+YRGrv6FP0wwk/toTpATxWYOW0BKdWwl82VT2tFYi5DlROa0Mxg==}

  supports-color@7.2.0:
    resolution: {integrity: sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==}
    engines: {node: '>=8'}

  supports-color@8.1.1:
    resolution: {integrity: sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==}
    engines: {node: '>=10'}

  tapable@2.3.0:
    resolution: {integrity: sha512-g9ljZiwki/LfxmQADO3dEY1CbpmXT5Hm2fJ+QaGKwSXUylMybePR7/67YW7jOrrvjEgL1Fmz5kzyAjWVWLlucg==}
    engines: {node: '>=6'}

  terser-webpack-plugin@5.3.16:
    resolution: {integrity: sha512-h9oBFCWrq78NyWWVcSwZarJkZ01c2AyGrzs1crmHZO3QUg9D61Wu4NPjBy69n7JqylFF5y+CsUZYmYEIZ3mR+Q==}
    engines: {node: '>= 10.13.0'}
    peerDependencies:
      '@swc/core': '*'
      esbuild: '*'
      uglify-js: '*'
      webpack: ^5.1.0
    peerDependenciesMeta:
      '@swc/core':
        optional: true
      esbuild:
        optional: true
      uglify-js:
        optional: true

  terser@5.44.1:
    resolution: {integrity: sha512-t/R3R/n0MSwnnazuPpPNVO60LX0SKL45pyl9YlvxIdkH0Of7D5qM2EVe+yASRIlY5pZ73nclYJfNANGWPwFDZw==}
    engines: {node: '>=10'}
    hasBin: true

  tinybench@2.9.0:
    resolution: {integrity: sha512-0+DUvqWMValLmha6lr4kD8iAMK1HzV0/aKnCtWb9v9641TnP/MFb7Pc2bxoxQjTXAErryXVgUOfv2YqNllqGeg==}

  tinyexec@0.3.2:
    resolution: {integrity: sha512-KQQR9yN7R5+OSwaK0XQoj22pwHoTlgYqmUscPYoknOoWCWfj/5/ABTMRi69FrKU5ffPVh5QcFikpWJI/P1ocHA==}

  tinyglobby@0.2.15:
    resolution: {integrity: sha512-j2Zq4NyQYG5XMST4cbs02Ak8iJUdxRM0XI5QyxXuZOzKOINmWurp3smXu3y5wDcJrptwpSjgXHzIQxR0omXljQ==}
    engines: {node: '>=12.0.0'}

  tinypool@1.1.1:
    resolution: {integrity: sha512-Zba82s87IFq9A9XmjiX5uZA/ARWDrB03OHlq+Vw1fSdt0I+4/Kutwy8BP4Y/y/aORMo61FQ0vIb5j44vSo5Pkg==}
    engines: {node: ^18.0.0 || >=20.0.0}

  tinyrainbow@2.0.0:
    resolution: {integrity: sha512-op4nsTR47R6p0vMUUoYl/a+ljLFVtlfaXkLQmqfLR1qHma1h/ysYk4hEXZ880bf2CYgTskvTa/e196Vd5dDQXw==}
    engines: {node: '>=14.0.0'}

  tinyspy@4.0.4:
    resolution: {integrity: sha512-azl+t0z7pw/z958Gy9svOTuzqIk6xq+NSheJzn5MMWtWTFywIacg2wUlzKFGtt3cthx0r2SxMK0yzJOR0IES7Q==}
    engines: {node: '>=14.0.0'}

  tldts-core@7.0.19:
    resolution: {integrity: sha512-lJX2dEWx0SGH4O6p+7FPwYmJ/bu1JbcGJ8RLaG9b7liIgZ85itUVEPbMtWRVrde/0fnDPEPHW10ZsKW3kVsE9A==}

  tldts@7.0.19:
    resolution: {integrity: sha512-8PWx8tvC4jDB39BQw1m4x8y5MH1BcQ5xHeL2n7UVFulMPH/3Q0uiamahFJ3lXA0zO2SUyRXuVVbWSDmstlt9YA==}
    hasBin: true

  to-regex-range@5.0.1:
    resolution: {integrity: sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==}
    engines: {node: '>=8.0'}

  tough-cookie@6.0.0:
    resolution: {integrity: sha512-kXuRi1mtaKMrsLUxz3sQYvVl37B0Ns6MzfrtV5DvJceE9bPyspOqk9xxv7XbZWcfLWbFmm997vl83qUWVJA64w==}
    engines: {node: '>=16'}

  ts-loader@9.5.4:
    resolution: {integrity: sha512-nCz0rEwunlTZiy6rXFByQU1kVVpCIgUpc/psFiKVrUwrizdnIbRFu8w7bxhUF0X613DYwT4XzrZHpVyMe758hQ==}
    engines: {node: '>=12.0.0'}
    peerDependencies:
      typescript: '*'
      webpack: ^5.0.0

  type-fest@4.41.0:
    resolution: {integrity: sha512-TeTSQ6H5YHvpqVwBRcnLDCBnDOHWYu7IvGbHT6N8AOymcr9PJGjc1GTtiWZTYg0NCgYwvnYWEkVChQAr9bjfwA==}
    engines: {node: '>=16'}

  typescript@5.7.3:
    resolution: {integrity: sha512-84MVSjMEHP+FQRPy3pX9sTVV/INIex71s9TL2Gm5FG/WG1SqXeKyZ0k7/blY/4FdOzI12CBy1vGc4og/eus0fw==}
    engines: {node: '>=14.17'}
    hasBin: true

  undici-types@5.26.5:
    resolution: {integrity: sha512-JlCMO+ehdEIKqlFxk6IfVoAUVmgz7cU7zD/h9XZ0qzeosSHmUJVOzSQvvYSYWXkFXC+IfLKSIffhv0sVZup6pA==}

  update-browserslist-db@1.2.3:
    resolution: {integrity: sha512-Js0m9cx+qOgDxo0eMiFGEueWztz+d4+M3rGlmKPT+T4IS/jP4ylw3Nwpu6cpTTP8R1MAC1kF4VbdLt3ARf209w==}
    hasBin: true
    peerDependencies:
      browserslist: '>= 4.21.0'

  uuid@9.0.1:
    resolution: {integrity: sha512-b+1eJOlsR9K8HJpow9Ok3fiWOWSIcIzXodvv0rQjVoOVNpWMpxf1wZNpt4y9h10odCNrqnYp1OBzRktckBe3sA==}
    hasBin: true

  vite-node@3.2.4:
    resolution: {integrity: sha512-EbKSKh+bh1E1IFxeO0pg1n4dvoOTt0UDiXMd/qn++r98+jPO1xtJilvXldeuQ8giIB5IkpjCgMleHMNEsGH6pg==}
    engines: {node: ^18.0.0 || ^20.0.0 || >=22.0.0}
    hasBin: true

  vite@7.3.0:
    resolution: {integrity: sha512-dZwN5L1VlUBewiP6H9s2+B3e3Jg96D0vzN+Ry73sOefebhYr9f94wwkMNN/9ouoU8pV1BqA1d1zGk8928cx0rg==}
    engines: {node: ^20.19.0 || >=22.12.0}
    hasBin: true
    peerDependencies:
      '@types/node': ^20.19.0 || >=22.12.0
      jiti: '>=1.21.0'
      less: ^4.0.0
      lightningcss: ^1.21.0
      sass: ^1.70.0
      sass-embedded: ^1.70.0
      stylus: '>=0.54.8'
      sugarss: ^5.0.0
      terser: ^5.16.0
      tsx: ^4.8.1
      yaml: ^2.4.2
    peerDependenciesMeta:
      '@types/node':
        optional: true
      jiti:
        optional: true
      less:
        optional: true
      lightningcss:
        optional: true
      sass:
        optional: true
      sass-embedded:
        optional: true
      stylus:
        optional: true
      sugarss:
        optional: true
      terser:
        optional: true
      tsx:
        optional: true
      yaml:
        optional: true

  vitest@3.2.4:
    resolution: {integrity: sha512-LUCP5ev3GURDysTWiP47wRRUpLKMOfPh+yKTx3kVIEiu5KOMeqzpnYNsKyOoVrULivR8tLcks4+lga33Whn90A==}
    engines: {node: ^18.0.0 || ^20.0.0 || >=22.0.0}
    hasBin: true
    peerDependencies:
      '@edge-runtime/vm': '*'
      '@types/debug': ^4.1.12
      '@types/node': ^18.0.0 || ^20.0.0 || >=22.0.0
      '@vitest/browser': 3.2.4
      '@vitest/ui': 3.2.4
      happy-dom: '*'
      jsdom: '*'
    peerDependenciesMeta:
      '@edge-runtime/vm':
        optional: true
      '@types/debug':
        optional: true
      '@types/node':
        optional: true
      '@vitest/browser':
        optional: true
      '@vitest/ui':
        optional: true
      happy-dom:
        optional: true
      jsdom:
        optional: true

  watchpack@2.5.0:
    resolution: {integrity: sha512-e6vZvY6xboSwLz2GD36c16+O/2Z6fKvIf4pOXptw2rY9MVwE/TXc6RGqxD3I3x0a28lwBY7DE+76uTPSsBrrCA==}
    engines: {node: '>=10.13.0'}

  webpack-sources@3.3.3:
    resolution: {integrity: sha512-yd1RBzSGanHkitROoPFd6qsrxt+oFhg/129YzheDGqeustzX0vTZJZsSsQjVQC4yzBQ56K55XU8gaNCtIzOnTg==}
    engines: {node: '>=10.13.0'}

  webpack@5.104.1:
    resolution: {integrity: sha512-Qphch25abbMNtekmEGJmeRUhLDbe+QfiWTiqpKYkpCOWY64v9eyl+KRRLmqOFA2AvKPpc9DC6+u2n76tQLBoaA==}
    engines: {node: '>=10.13.0'}
    hasBin: true
    peerDependencies:
      webpack-cli: '*'
    peerDependenciesMeta:
      webpack-cli:
        optional: true

  why-is-node-running@2.3.0:
    resolution: {integrity: sha512-hUrmaWBdVDcxvYqnyh09zunKzROWjbZTiNy8dBEjkS7ehEDQibXJ7XvlmtbwuTclUiIyN+CyXQD4Vmko8fNm8w==}
    engines: {node: '>=8'}
    hasBin: true

  wrap-ansi@6.2.0:
    resolution: {integrity: sha512-r6lPcBGxZXlIcymEu7InxDMhdW0KDxpLgoFLcguasxCaJ/SOIZwINatK9KY/tf+ZrlywOKU0UDj3ATXUBfxJXA==}
    engines: {node: '>=8'}

  wrap-ansi@7.0.0:
    resolution: {integrity: sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==}
    engines: {node: '>=10'}

  ws@8.19.0:
    resolution: {integrity: sha512-blAT2mjOEIi0ZzruJfIhb3nps74PRWTCz1IjglWEEpQl5XS/UNama6u2/rjFkDDouqr4L67ry+1aGIALViWjDg==}
    engines: {node: '>=10.0.0'}
    peerDependencies:
      bufferutil: ^4.0.1
      utf-8-validate: '>=5.0.2'
    peerDependenciesMeta:
      bufferutil:
        optional: true
      utf-8-validate:
        optional: true

  y18n@5.0.8:
    resolution: {integrity: sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==}
    engines: {node: '>=10'}

  yargs-parser@21.1.1:
    resolution: {integrity: sha512-tVpsJW7DdjecAiFpbIB1e3qxIQsE6NoPc5/eTdrbbIC4h0LVsWhnoa3g+m2HclBIujHzsxZ4VJVA+GUuc2/LBw==}
    engines: {node: '>=12'}

  yargs@17.7.2:
    resolution: {integrity: sha512-7dSzzRQ++CKnNI/krKnYRV7JKKPUXMEh61soaHKg9mrWEhzFWhFnxPxGl+69cD1Ou63C13NUPCnmIcrvqCuM6w==}
    engines: {node: '>=12'}

  yoctocolors-cjs@2.1.3:
    resolution: {integrity: sha512-U/PBtDf35ff0D8X8D0jfdzHYEPFxAI7jJlxZXwCSez5M3190m+QobIfh+sWDWSHMCWWJN2AWamkegn6vr6YBTw==}
    engines: {node: '>=18'}

  zod@3.25.76:
    resolution: {integrity: sha512-gzUt/qt81nXsFGKIFcC3YnfEAx5NkunCfnDlvuBSSFS02bcXu4Lmea0AFIUwbLWxWPx3d9p8S5QoaujKcNQxcQ==}

snapshots:

  '@biomejs/biome@2.3.1':
    optionalDependencies:
      '@biomejs/cli-darwin-arm64': 2.3.1
      '@biomejs/cli-darwin-x64': 2.3.1
      '@biomejs/cli-linux-arm64': 2.3.1
      '@biomejs/cli-linux-arm64-musl': 2.3.1
      '@biomejs/cli-linux-x64': 2.3.1
      '@biomejs/cli-linux-x64-musl': 2.3.1
      '@biomejs/cli-win32-arm64': 2.3.1
      '@biomejs/cli-win32-x64': 2.3.1

  '@biomejs/cli-darwin-arm64@2.3.1':
    optional: true

  '@biomejs/cli-darwin-x64@2.3.1':
    optional: true

  '@biomejs/cli-linux-arm64-musl@2.3.1':
    optional: true

  '@biomejs/cli-linux-arm64@2.3.1':
    optional: true

  '@biomejs/cli-linux-x64-musl@2.3.1':
    optional: true

  '@biomejs/cli-linux-x64@2.3.1':
    optional: true

  '@biomejs/cli-win32-arm64@2.3.1':
    optional: true

  '@biomejs/cli-win32-x64@2.3.1':
    optional: true

  '@bundled-es-modules/cookie@2.0.1':
    dependencies:
      cookie: 0.7.2

  '@bundled-es-modules/statuses@1.0.1':
    dependencies:
      statuses: 2.0.2

  '@esbuild/aix-ppc64@0.27.2':
    optional: true

  '@esbuild/android-arm64@0.27.2':
    optional: true

  '@esbuild/android-arm@0.27.2':
    optional: true

  '@esbuild/android-x64@0.27.2':
    optional: true

  '@esbuild/darwin-arm64@0.27.2':
    optional: true

  '@esbuild/darwin-x64@0.27.2':
    optional: true

  '@esbuild/freebsd-arm64@0.27.2':
    optional: true

  '@esbuild/freebsd-x64@0.27.2':
    optional: true

  '@esbuild/linux-arm64@0.27.2':
    optional: true

  '@esbuild/linux-arm@0.27.2':
    optional: true

  '@esbuild/linux-ia32@0.27.2':
    optional: true

  '@esbuild/linux-loong64@0.27.2':
    optional: true

  '@esbuild/linux-mips64el@0.27.2':
    optional: true

  '@esbuild/linux-ppc64@0.27.2':
    optional: true

  '@esbuild/linux-riscv64@0.27.2':
    optional: true

  '@esbuild/linux-s390x@0.27.2':
    optional: true

  '@esbuild/linux-x64@0.27.2':
    optional: true

  '@esbuild/netbsd-arm64@0.27.2':
    optional: true

  '@esbuild/netbsd-x64@0.27.2':
    optional: true

  '@esbuild/openbsd-arm64@0.27.2':
    optional: true

  '@esbuild/openbsd-x64@0.27.2':
    optional: true

  '@esbuild/openharmony-arm64@0.27.2':
    optional: true

  '@esbuild/sunos-x64@0.27.2':
    optional: true

  '@esbuild/win32-arm64@0.27.2':
    optional: true

  '@esbuild/win32-ia32@0.27.2':
    optional: true

  '@esbuild/win32-x64@0.27.2':
    optional: true

  '@inquirer/ansi@1.0.2': {}

  '@inquirer/confirm@5.1.21(@types/node@18.19.130)':
    dependencies:
      '@inquirer/core': 10.3.2(@types/node@18.19.130)
      '@inquirer/type': 3.0.10(@types/node@18.19.130)
    optionalDependencies:
      '@types/node': 18.19.130

  '@inquirer/core@10.3.2(@types/node@18.19.130)':
    dependencies:
      '@inquirer/ansi': 1.0.2
      '@inquirer/figures': 1.0.15
      '@inquirer/type': 3.0.10(@types/node@18.19.130)
      cli-width: 4.1.0
      mute-stream: 2.0.0
      signal-exit: 4.1.0
      wrap-ansi: 6.2.0
      yoctocolors-cjs: 2.1.3
    optionalDependencies:
      '@types/node': 18.19.130

  '@inquirer/figures@1.0.15': {}

  '@inquirer/type@3.0.10(@types/node@18.19.130)':
    optionalDependencies:
      '@types/node': 18.19.130

  '@jridgewell/gen-mapping@0.3.13':
    dependencies:
      '@jridgewell/sourcemap-codec': 1.5.5
      '@jridgewell/trace-mapping': 0.3.31

  '@jridgewell/resolve-uri@3.1.2': {}

  '@jridgewell/source-map@0.3.11':
    dependencies:
      '@jridgewell/gen-mapping': 0.3.13
      '@jridgewell/trace-mapping': 0.3.31

  '@jridgewell/sourcemap-codec@1.5.5': {}

  '@jridgewell/trace-mapping@0.3.31':
    dependencies:
      '@jridgewell/resolve-uri': 3.1.2
      '@jridgewell/sourcemap-codec': 1.5.5

  '@mswjs/interceptors@0.39.8':
    dependencies:
      '@open-draft/deferred-promise': 2.2.0
      '@open-draft/logger': 0.3.0
      '@open-draft/until': 2.1.0
      is-node-process: 1.2.0
      outvariant: 1.4.3
      strict-event-emitter: 0.5.1

  '@open-draft/deferred-promise@2.2.0': {}

  '@open-draft/logger@0.3.0':
    dependencies:
      is-node-process: 1.2.0
      outvariant: 1.4.3

  '@open-draft/until@2.1.0': {}

  '@rollup/rollup-android-arm-eabi@4.55.1':
    optional: true

  '@rollup/rollup-android-arm64@4.55.1':
    optional: true

  '@rollup/rollup-darwin-arm64@4.55.1':
    optional: true

  '@rollup/rollup-darwin-x64@4.55.1':
    optional: true

  '@rollup/rollup-freebsd-arm64@4.55.1':
    optional: true

  '@rollup/rollup-freebsd-x64@4.55.1':
    optional: true

  '@rollup/rollup-linux-arm-gnueabihf@4.55.1':
    optional: true

  '@rollup/rollup-linux-arm-musleabihf@4.55.1':
    optional: true

  '@rollup/rollup-linux-arm64-gnu@4.55.1':
    optional: true

  '@rollup/rollup-linux-arm64-musl@4.55.1':
    optional: true

  '@rollup/rollup-linux-loong64-gnu@4.55.1':
    optional: true

  '@rollup/rollup-linux-loong64-musl@4.55.1':
    optional: true

  '@rollup/rollup-linux-ppc64-gnu@4.55.1':
    optional: true

  '@rollup/rollup-linux-ppc64-musl@4.55.1':
    optional: true

  '@rollup/rollup-linux-riscv64-gnu@4.55.1':
    optional: true

  '@rollup/rollup-linux-riscv64-musl@4.55.1':
    optional: true

  '@rollup/rollup-linux-s390x-gnu@4.55.1':
    optional: true

  '@rollup/rollup-linux-x64-gnu@4.55.1':
    optional: true

  '@rollup/rollup-linux-x64-musl@4.55.1':
    optional: true

  '@rollup/rollup-openbsd-x64@4.55.1':
    optional: true

  '@rollup/rollup-openharmony-arm64@4.55.1':
    optional: true

  '@rollup/rollup-win32-arm64-msvc@4.55.1':
    optional: true

  '@rollup/rollup-win32-ia32-msvc@4.55.1':
    optional: true

  '@rollup/rollup-win32-x64-gnu@4.55.1':
    optional: true

  '@rollup/rollup-win32-x64-msvc@4.55.1':
    optional: true

  '@types/chai@5.2.3':
    dependencies:
      '@types/deep-eql': 4.0.2
      assertion-error: 2.0.1

  '@types/cookie@0.6.0': {}

  '@types/deep-eql@4.0.2': {}

  '@types/eslint-scope@3.7.7':
    dependencies:
      '@types/eslint': 9.6.1
      '@types/estree': 1.0.8

  '@types/eslint@9.6.1':
    dependencies:
      '@types/estree': 1.0.8
      '@types/json-schema': 7.0.15

  '@types/estree@1.0.8': {}

  '@types/json-schema@7.0.15': {}

  '@types/node@18.19.130':
    dependencies:
      undici-types: 5.26.5

  '@types/statuses@2.0.6': {}

  '@types/uuid@9.0.7': {}

  '@types/ws@8.18.1':
    dependencies:
      '@types/node': 18.19.130

  '@vitest/expect@3.2.4':
    dependencies:
      '@types/chai': 5.2.3
      '@vitest/spy': 3.2.4
      '@vitest/utils': 3.2.4
      chai: 5.3.3
      tinyrainbow: 2.0.0

  '@vitest/mocker@3.2.4(msw@2.11.2(@types/node@18.19.130)(typescript@5.7.3))(vite@7.3.0(@types/node@18.19.130)(terser@5.44.1))':
    dependencies:
      '@vitest/spy': 3.2.4
      estree-walker: 3.0.3
      magic-string: 0.30.21
    optionalDependencies:
      msw: 2.11.2(@types/node@18.19.130)(typescript@5.7.3)
      vite: 7.3.0(@types/node@18.19.130)(terser@5.44.1)

  '@vitest/pretty-format@3.2.4':
    dependencies:
      tinyrainbow: 2.0.0

  '@vitest/runner@3.2.4':
    dependencies:
      '@vitest/utils': 3.2.4
      pathe: 2.0.3
      strip-literal: 3.1.0

  '@vitest/snapshot@3.2.4':
    dependencies:
      '@vitest/pretty-format': 3.2.4
      magic-string: 0.30.21
      pathe: 2.0.3

  '@vitest/spy@3.2.4':
    dependencies:
      tinyspy: 4.0.4

  '@vitest/utils@3.2.4':
    dependencies:
      '@vitest/pretty-format': 3.2.4
      loupe: 3.2.1
      tinyrainbow: 2.0.0

  '@webassemblyjs/ast@1.14.1':
    dependencies:
      '@webassemblyjs/helper-numbers': 1.13.2
      '@webassemblyjs/helper-wasm-bytecode': 1.13.2

  '@webassemblyjs/floating-point-hex-parser@1.13.2': {}

  '@webassemblyjs/helper-api-error@1.13.2': {}

  '@webassemblyjs/helper-buffer@1.14.1': {}

  '@webassemblyjs/helper-numbers@1.13.2':
    dependencies:
      '@webassemblyjs/floating-point-hex-parser': 1.13.2
      '@webassemblyjs/helper-api-error': 1.13.2
      '@xtuc/long': 4.2.2

  '@webassemblyjs/helper-wasm-bytecode@1.13.2': {}

  '@webassemblyjs/helper-wasm-section@1.14.1':
    dependencies:
      '@webassemblyjs/ast': 1.14.1
      '@webassemblyjs/helper-buffer': 1.14.1
      '@webassemblyjs/helper-wasm-bytecode': 1.13.2
      '@webassemblyjs/wasm-gen': 1.14.1

  '@webassemblyjs/ieee754@1.13.2':
    dependencies:
      '@xtuc/ieee754': 1.2.0

  '@webassemblyjs/leb128@1.13.2':
    dependencies:
      '@xtuc/long': 4.2.2

  '@webassemblyjs/utf8@1.13.2': {}

  '@webassemblyjs/wasm-edit@1.14.1':
    dependencies:
      '@webassemblyjs/ast': 1.14.1
      '@webassemblyjs/helper-buffer': 1.14.1
      '@webassemblyjs/helper-wasm-bytecode': 1.13.2
      '@webassemblyjs/helper-wasm-section': 1.14.1
      '@webassemblyjs/wasm-gen': 1.14.1
      '@webassemblyjs/wasm-opt': 1.14.1
      '@webassemblyjs/wasm-parser': 1.14.1
      '@webassemblyjs/wast-printer': 1.14.1

  '@webassemblyjs/wasm-gen@1.14.1':
    dependencies:
      '@webassemblyjs/ast': 1.14.1
      '@webassemblyjs/helper-wasm-bytecode': 1.13.2
      '@webassemblyjs/ieee754': 1.13.2
      '@webassemblyjs/leb128': 1.13.2
      '@webassemblyjs/utf8': 1.13.2

  '@webassemblyjs/wasm-opt@1.14.1':
    dependencies:
      '@webassemblyjs/ast': 1.14.1
      '@webassemblyjs/helper-buffer': 1.14.1
      '@webassemblyjs/wasm-gen': 1.14.1
      '@webassemblyjs/wasm-parser': 1.14.1

  '@webassemblyjs/wasm-parser@1.14.1':
    dependencies:
      '@webassemblyjs/ast': 1.14.1
      '@webassemblyjs/helper-api-error': 1.13.2
      '@webassemblyjs/helper-wasm-bytecode': 1.13.2
      '@webassemblyjs/ieee754': 1.13.2
      '@webassemblyjs/leb128': 1.13.2
      '@webassemblyjs/utf8': 1.13.2

  '@webassemblyjs/wast-printer@1.14.1':
    dependencies:
      '@webassemblyjs/ast': 1.14.1
      '@xtuc/long': 4.2.2

  '@xtuc/ieee754@1.2.0': {}

  '@xtuc/long@4.2.2': {}

  acorn-import-phases@1.0.4(acorn@8.15.0):
    dependencies:
      acorn: 8.15.0

  acorn@8.15.0: {}

  ajv-formats@2.1.1(ajv@8.17.1):
    optionalDependencies:
      ajv: 8.17.1

  ajv-keywords@5.1.0(ajv@8.17.1):
    dependencies:
      ajv: 8.17.1
      fast-deep-equal: 3.1.3

  ajv@8.17.1:
    dependencies:
      fast-deep-equal: 3.1.3
      fast-uri: 3.1.0
      json-schema-traverse: 1.0.0
      require-from-string: 2.0.2

  ansi-regex@5.0.1: {}

  ansi-styles@4.3.0:
    dependencies:
      color-convert: 2.0.1

  assertion-error@2.0.1: {}

  baseline-browser-mapping@2.9.11: {}

  braces@3.0.3:
    dependencies:
      fill-range: 7.1.1

  browserslist@4.28.1:
    dependencies:
      baseline-browser-mapping: 2.9.11
      caniuse-lite: 1.0.30001762
      electron-to-chromium: 1.5.267
      node-releases: 2.0.27
      update-browserslist-db: 1.2.3(browserslist@4.28.1)

  buffer-from@1.1.2: {}

  cac@6.7.14: {}

  caniuse-lite@1.0.30001762: {}

  chai@5.3.3:
    dependencies:
      assertion-error: 2.0.1
      check-error: 2.1.3
      deep-eql: 5.0.2
      loupe: 3.2.1
      pathval: 2.0.1

  chalk@4.1.2:
    dependencies:
      ansi-styles: 4.3.0
      supports-color: 7.2.0

  check-error@2.1.3: {}

  chrome-trace-event@1.0.4: {}

  cli-width@4.1.0: {}

  cliui@8.0.1:
    dependencies:
      string-width: 4.2.3
      strip-ansi: 6.0.1
      wrap-ansi: 7.0.0

  color-convert@2.0.1:
    dependencies:
      color-name: 1.1.4

  color-name@1.1.4: {}

  commander@2.20.3: {}

  cookie@0.7.2: {}

  debug@4.4.3:
    dependencies:
      ms: 2.1.3

  deep-eql@5.0.2: {}

  electron-to-chromium@1.5.267: {}

  emoji-regex@8.0.0: {}

  enhanced-resolve@5.18.4:
    dependencies:
      graceful-fs: 4.2.11
      tapable: 2.3.0

  es-module-lexer@1.7.0: {}

  es-module-lexer@2.0.0: {}

  esbuild@0.27.2:
    optionalDependencies:
      '@esbuild/aix-ppc64': 0.27.2
      '@esbuild/android-arm': 0.27.2
      '@esbuild/android-arm64': 0.27.2
      '@esbuild/android-x64': 0.27.2
      '@esbuild/darwin-arm64': 0.27.2
      '@esbuild/darwin-x64': 0.27.2
      '@esbuild/freebsd-arm64': 0.27.2
      '@esbuild/freebsd-x64': 0.27.2
      '@esbuild/linux-arm': 0.27.2
      '@esbuild/linux-arm64': 0.27.2
      '@esbuild/linux-ia32': 0.27.2
      '@esbuild/linux-loong64': 0.27.2
      '@esbuild/linux-mips64el': 0.27.2
      '@esbuild/linux-ppc64': 0.27.2
      '@esbuild/linux-riscv64': 0.27.2
      '@esbuild/linux-s390x': 0.27.2
      '@esbuild/linux-x64': 0.27.2
      '@esbuild/netbsd-arm64': 0.27.2
      '@esbuild/netbsd-x64': 0.27.2
      '@esbuild/openbsd-arm64': 0.27.2
      '@esbuild/openbsd-x64': 0.27.2
      '@esbuild/openharmony-arm64': 0.27.2
      '@esbuild/sunos-x64': 0.27.2
      '@esbuild/win32-arm64': 0.27.2
      '@esbuild/win32-ia32': 0.27.2
      '@esbuild/win32-x64': 0.27.2

  escalade@3.2.0: {}

  eslint-scope@5.1.1:
    dependencies:
      esrecurse: 4.3.0
      estraverse: 4.3.0

  esrecurse@4.3.0:
    dependencies:
      estraverse: 5.3.0

  estraverse@4.3.0: {}

  estraverse@5.3.0: {}

  estree-walker@3.0.3:
    dependencies:
      '@types/estree': 1.0.8

  events@3.3.0: {}

  expect-type@1.3.0: {}

  fast-deep-equal@3.1.3: {}

  fast-uri@3.1.0: {}

  fdir@6.5.0(picomatch@4.0.3):
    optionalDependencies:
      picomatch: 4.0.3

  fill-range@7.1.1:
    dependencies:
      to-regex-range: 5.0.1

  fsevents@2.3.3:
    optional: true

  get-caller-file@2.0.5: {}

  glob-to-regexp@0.4.1: {}

  graceful-fs@4.2.11: {}

  graphql@16.12.0: {}

  has-flag@4.0.0: {}

  headers-polyfill@4.0.3: {}

  is-fullwidth-code-point@3.0.0: {}

  is-node-process@1.2.0: {}

  is-number@7.0.0: {}

  jest-worker@27.5.1:
    dependencies:
      '@types/node': 18.19.130
      merge-stream: 2.0.0
      supports-color: 8.1.1

  js-tokens@9.0.1: {}

  json-parse-even-better-errors@2.3.1: {}

  json-schema-traverse@1.0.0: {}

  loader-runner@4.3.1: {}

  loupe@3.2.1: {}

  magic-string@0.30.21:
    dependencies:
      '@jridgewell/sourcemap-codec': 1.5.5

  merge-stream@2.0.0: {}

  micromatch@4.0.8:
    dependencies:
      braces: 3.0.3
      picomatch: 2.3.1

  mime-db@1.52.0: {}

  mime-types@2.1.35:
    dependencies:
      mime-db: 1.52.0

  ms@2.1.3: {}

  msw@2.11.2(@types/node@18.19.130)(typescript@5.7.3):
    dependencies:
      '@bundled-es-modules/cookie': 2.0.1
      '@bundled-es-modules/statuses': 1.0.1
      '@inquirer/confirm': 5.1.21(@types/node@18.19.130)
      '@mswjs/interceptors': 0.39.8
      '@open-draft/deferred-promise': 2.2.0
      '@open-draft/until': 2.1.0
      '@types/cookie': 0.6.0
      '@types/statuses': 2.0.6
      graphql: 16.12.0
      headers-polyfill: 4.0.3
      is-node-process: 1.2.0
      outvariant: 1.4.3
      path-to-regexp: 6.3.0
      picocolors: 1.1.1
      rettime: 0.7.0
      strict-event-emitter: 0.5.1
      tough-cookie: 6.0.0
      type-fest: 4.41.0
      yargs: 17.7.2
    optionalDependencies:
      typescript: 5.7.3
    transitivePeerDependencies:
      - '@types/node'

  mute-stream@2.0.0: {}

  nanoid@3.3.11: {}

  neo-async@2.6.2: {}

  node-releases@2.0.27: {}

  outvariant@1.4.3: {}

  path-to-regexp@6.3.0: {}

  pathe@2.0.3: {}

  pathval@2.0.1: {}

  picocolors@1.1.1: {}

  picomatch@2.3.1: {}

  picomatch@4.0.3: {}

  postcss@8.5.6:
    dependencies:
      nanoid: 3.3.11
      picocolors: 1.1.1
      source-map-js: 1.2.1

  randombytes@2.1.0:
    dependencies:
      safe-buffer: 5.2.1

  require-directory@2.1.1: {}

  require-from-string@2.0.2: {}

  rettime@0.7.0: {}

  rollup@4.55.1:
    dependencies:
      '@types/estree': 1.0.8
    optionalDependencies:
      '@rollup/rollup-android-arm-eabi': 4.55.1
      '@rollup/rollup-android-arm64': 4.55.1
      '@rollup/rollup-darwin-arm64': 4.55.1
      '@rollup/rollup-darwin-x64': 4.55.1
      '@rollup/rollup-freebsd-arm64': 4.55.1
      '@rollup/rollup-freebsd-x64': 4.55.1
      '@rollup/rollup-linux-arm-gnueabihf': 4.55.1
      '@rollup/rollup-linux-arm-musleabihf': 4.55.1
      '@rollup/rollup-linux-arm64-gnu': 4.55.1
      '@rollup/rollup-linux-arm64-musl': 4.55.1
      '@rollup/rollup-linux-loong64-gnu': 4.55.1
      '@rollup/rollup-linux-loong64-musl': 4.55.1
      '@rollup/rollup-linux-ppc64-gnu': 4.55.1
      '@rollup/rollup-linux-ppc64-musl': 4.55.1
      '@rollup/rollup-linux-riscv64-gnu': 4.55.1
      '@rollup/rollup-linux-riscv64-musl': 4.55.1
      '@rollup/rollup-linux-s390x-gnu': 4.55.1
      '@rollup/rollup-linux-x64-gnu': 4.55.1
      '@rollup/rollup-linux-x64-musl': 4.55.1
      '@rollup/rollup-openbsd-x64': 4.55.1
      '@rollup/rollup-openharmony-arm64': 4.55.1
      '@rollup/rollup-win32-arm64-msvc': 4.55.1
      '@rollup/rollup-win32-ia32-msvc': 4.55.1
      '@rollup/rollup-win32-x64-gnu': 4.55.1
      '@rollup/rollup-win32-x64-msvc': 4.55.1
      fsevents: 2.3.3

  safe-buffer@5.2.1: {}

  schema-utils@4.3.3:
    dependencies:
      '@types/json-schema': 7.0.15
      ajv: 8.17.1
      ajv-formats: 2.1.1(ajv@8.17.1)
      ajv-keywords: 5.1.0(ajv@8.17.1)

  semver@7.7.3: {}

  serialize-javascript@6.0.2:
    dependencies:
      randombytes: 2.1.0

  siginfo@2.0.0: {}

  signal-exit@4.1.0: {}

  source-map-js@1.2.1: {}

  source-map-support@0.5.21:
    dependencies:
      buffer-from: 1.1.2
      source-map: 0.6.1

  source-map@0.6.1: {}

  source-map@0.7.6: {}

  stackback@0.0.2: {}

  statuses@2.0.2: {}

  std-env@3.10.0: {}

  strict-event-emitter@0.5.1: {}

  string-width@4.2.3:
    dependencies:
      emoji-regex: 8.0.0
      is-fullwidth-code-point: 3.0.0
      strip-ansi: 6.0.1

  strip-ansi@6.0.1:
    dependencies:
      ansi-regex: 5.0.1

  strip-literal@3.1.0:
    dependencies:
      js-tokens: 9.0.1

  supports-color@7.2.0:
    dependencies:
      has-flag: 4.0.0

  supports-color@8.1.1:
    dependencies:
      has-flag: 4.0.0

  tapable@2.3.0: {}

  terser-webpack-plugin@5.3.16(webpack@5.104.1):
    dependencies:
      '@jridgewell/trace-mapping': 0.3.31
      jest-worker: 27.5.1
      schema-utils: 4.3.3
      serialize-javascript: 6.0.2
      terser: 5.44.1
      webpack: 5.104.1

  terser@5.44.1:
    dependencies:
      '@jridgewell/source-map': 0.3.11
      acorn: 8.15.0
      commander: 2.20.3
      source-map-support: 0.5.21

  tinybench@2.9.0: {}

  tinyexec@0.3.2: {}

  tinyglobby@0.2.15:
    dependencies:
      fdir: 6.5.0(picomatch@4.0.3)
      picomatch: 4.0.3

  tinypool@1.1.1: {}

  tinyrainbow@2.0.0: {}

  tinyspy@4.0.4: {}

  tldts-core@7.0.19: {}

  tldts@7.0.19:
    dependencies:
      tldts-core: 7.0.19

  to-regex-range@5.0.1:
    dependencies:
      is-number: 7.0.0

  tough-cookie@6.0.0:
    dependencies:
      tldts: 7.0.19

  ts-loader@9.5.4(typescript@5.7.3)(webpack@5.104.1):
    dependencies:
      chalk: 4.1.2
      enhanced-resolve: 5.18.4
      micromatch: 4.0.8
      semver: 7.7.3
      source-map: 0.7.6
      typescript: 5.7.3
      webpack: 5.104.1

  type-fest@4.41.0: {}

  typescript@5.7.3: {}

  undici-types@5.26.5: {}

  update-browserslist-db@1.2.3(browserslist@4.28.1):
    dependencies:
      browserslist: 4.28.1
      escalade: 3.2.0
      picocolors: 1.1.1

  uuid@9.0.1: {}

  vite-node@3.2.4(@types/node@18.19.130)(terser@5.44.1):
    dependencies:
      cac: 6.7.14
      debug: 4.4.3
      es-module-lexer: 1.7.0
      pathe: 2.0.3
      vite: 7.3.0(@types/node@18.19.130)(terser@5.44.1)
    transitivePeerDependencies:
      - '@types/node'
      - jiti
      - less
      - lightningcss
      - sass
      - sass-embedded
      - stylus
      - sugarss
      - supports-color
      - terser
      - tsx
      - yaml

  vite@7.3.0(@types/node@18.19.130)(terser@5.44.1):
    dependencies:
      esbuild: 0.27.2
      fdir: 6.5.0(picomatch@4.0.3)
      picomatch: 4.0.3
      postcss: 8.5.6
      rollup: 4.55.1
      tinyglobby: 0.2.15
    optionalDependencies:
      '@types/node': 18.19.130
      fsevents: 2.3.3
      terser: 5.44.1

  vitest@3.2.4(@types/node@18.19.130)(msw@2.11.2(@types/node@18.19.130)(typescript@5.7.3))(terser@5.44.1):
    dependencies:
      '@types/chai': 5.2.3
      '@vitest/expect': 3.2.4
      '@vitest/mocker': 3.2.4(msw@2.11.2(@types/node@18.19.130)(typescript@5.7.3))(vite@7.3.0(@types/node@18.19.130)(terser@5.44.1))
      '@vitest/pretty-format': 3.2.4
      '@vitest/runner': 3.2.4
      '@vitest/snapshot': 3.2.4
      '@vitest/spy': 3.2.4
      '@vitest/utils': 3.2.4
      chai: 5.3.3
      debug: 4.4.3
      expect-type: 1.3.0
      magic-string: 0.30.21
      pathe: 2.0.3
      picomatch: 4.0.3
      std-env: 3.10.0
      tinybench: 2.9.0
      tinyexec: 0.3.2
      tinyglobby: 0.2.15
      tinypool: 1.1.1
      tinyrainbow: 2.0.0
      vite: 7.3.0(@types/node@18.19.130)(terser@5.44.1)
      vite-node: 3.2.4(@types/node@18.19.130)(terser@5.44.1)
      why-is-node-running: 2.3.0
    optionalDependencies:
      '@types/node': 18.19.130
    transitivePeerDependencies:
      - jiti
      - less
      - lightningcss
      - msw
      - sass
      - sass-embedded
      - stylus
      - sugarss
      - supports-color
      - terser
      - tsx
      - yaml

  watchpack@2.5.0:
    dependencies:
      glob-to-regexp: 0.4.1
      graceful-fs: 4.2.11

  webpack-sources@3.3.3: {}

  webpack@5.104.1:
    dependencies:
      '@types/eslint-scope': 3.7.7
      '@types/estree': 1.0.8
      '@types/json-schema': 7.0.15
      '@webassemblyjs/ast': 1.14.1
      '@webassemblyjs/wasm-edit': 1.14.1
      '@webassemblyjs/wasm-parser': 1.14.1
      acorn: 8.15.0
      acorn-import-phases: 1.0.4(acorn@8.15.0)
      browserslist: 4.28.1
      chrome-trace-event: 1.0.4
      enhanced-resolve: 5.18.4
      es-module-lexer: 2.0.0
      eslint-scope: 5.1.1
      events: 3.3.0
      glob-to-regexp: 0.4.1
      graceful-fs: 4.2.11
      json-parse-even-better-errors: 2.3.1
      loader-runner: 4.3.1
      mime-types: 2.1.35
      neo-async: 2.6.2
      schema-utils: 4.3.3
      tapable: 2.3.0
      terser-webpack-plugin: 5.3.16(webpack@5.104.1)
      watchpack: 2.5.0
      webpack-sources: 3.3.3
    transitivePeerDependencies:
      - '@swc/core'
      - esbuild
      - uglify-js

  why-is-node-running@2.3.0:
    dependencies:
      siginfo: 2.0.0
      stackback: 0.0.2

  wrap-ansi@6.2.0:
    dependencies:
      ansi-styles: 4.3.0
      string-width: 4.2.3
      strip-ansi: 6.0.1

  wrap-ansi@7.0.0:
    dependencies:
      ansi-styles: 4.3.0
      string-width: 4.2.3
      strip-ansi: 6.0.1

  ws@8.19.0: {}

  y18n@5.0.8: {}

  yargs-parser@21.1.1: {}

  yargs@17.7.2:
    dependencies:
      cliui: 8.0.1
      escalade: 3.2.0
      get-caller-file: 2.0.5
      require-directory: 2.1.1
      string-width: 4.2.3
      y18n: 5.0.8
      yargs-parser: 21.1.1

  yoctocolors-cjs@2.1.3: {}

  zod@3.25.76: {}

```


## /pnpm-workspace.yaml
```yaml
packages: ['.']
```


## /reference.md
```markdown
# Reference
## Tts
<details><summary><code>client.tts.<a href="/src/api/resources/tts/client/Client.ts">synthesizeJson</a>({ ...params }) -> Hume.ReturnTts</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Synthesizes one or more input texts into speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.

The response includes the base64-encoded audio and metadata in JSON format.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.tts.synthesizeJson({
    context: {
        utterances: [{
                text: "How can people see beauty so differently?",
                description: "A curious student with a clear and respectful tone, seeking clarification on Hume's ideas with a straightforward question."
            }]
    },
    format: {
        type: "mp3"
    },
    numGenerations: 1,
    utterances: [{
            text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
            description: "Middle-aged masculine voice with a clear, rhythmic Scots lilt, rounded vowels, and a warm, steady tone with an articulate, academic quality."
        }]
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.PostedTts` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `TtsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.tts.<a href="/src/api/resources/tts/client/Client.ts">synthesizeFile</a>({ ...params }) -> core.BinaryResponse</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Synthesizes one or more input texts into speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody. 

The response contains the generated audio file in the requested format.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.tts.synthesizeFile({
    context: {
        generationId: "09ad914d-8e7f-40f8-a279-e34f07f7dab2"
    },
    format: {
        type: "mp3"
    },
    numGenerations: 1,
    utterances: [{
            text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
            description: "Middle-aged masculine voice with a clear, rhythmic Scots lilt, rounded vowels, and a warm, steady tone with an articulate, academic quality."
        }]
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.PostedTts` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `TtsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.tts.<a href="/src/api/resources/tts/client/Client.ts">synthesizeFileStreaming</a>({ ...params }) -> core.BinaryResponse</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Streams synthesized speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.tts.synthesizeFileStreaming({
    utterances: [{
            text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
            voice: {
                name: "Male English Actor",
                provider: "HUME_AI"
            }
        }]
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.PostedTts` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `TtsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.tts.<a href="/src/api/resources/tts/client/Client.ts">synthesizeJsonStreaming</a>({ ...params }) -> core.Stream<Hume.TtsOutput></code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Streams synthesized speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody. 

The response is a stream of JSON objects including audio encoded in base64.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
const response = await client.tts.synthesizeJsonStreaming({
    utterances: [{
            text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
            voice: {
                name: "Male English Actor",
                provider: "HUME_AI"
            }
        }]
});
for await (const item of response) {
    console.log(item);
}

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.PostedTts` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `TtsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.tts.<a href="/src/api/resources/tts/client/Client.ts">convertVoiceJson</a>({ ...params }) -> core.Stream<Hume.TtsOutput></code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
const response = await client.tts.convertVoiceJson({});
for await (const item of response) {
    console.log(item);
}

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.tts.ConvertVoiceJsonRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `TtsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## Tts Voices
<details><summary><code>client.tts.voices.<a href="/src/api/resources/tts/resources/voices/client/Client.ts">list</a>({ ...params }) -> core.Page<Hume.ReturnVoice, Hume.ReturnPagedVoices></code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Lists voices you have saved in your account, or voices from the [Voice Library](https://app.hume.ai/voices).
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
const pageableResponse = await client.tts.voices.list({
    provider: "CUSTOM_VOICE"
});
for await (const item of pageableResponse) {
    console.log(item);
}

// Or you can manually iterate page-by-page
let page = await client.tts.voices.list({
    provider: "CUSTOM_VOICE"
});
while (page.hasNextPage()) {
    page = page.getNextPage();
}

// You can also access the underlying response
const response = page.response;

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.tts.VoicesListRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `VoicesClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.tts.voices.<a href="/src/api/resources/tts/resources/voices/client/Client.ts">create</a>({ ...params }) -> Hume.ReturnVoice</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Saves a new custom voice to your account using the specified TTS generation ID.

Once saved, this voice can be reused in subsequent TTS requests, ensuring consistent speech style and prosody. For more details on voice creation, see the [Voices Guide](/docs/text-to-speech-tts/voices).
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.tts.voices.create({
    generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
    name: "David Hume"
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.tts.PostedVoice` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `VoicesClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.tts.voices.<a href="/src/api/resources/tts/resources/voices/client/Client.ts">delete</a>({ ...params }) -> void</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Deletes a previously generated custom voice.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.tts.voices.delete({
    name: "David Hume"
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.tts.VoicesDeleteRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `VoicesClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## EmpathicVoice ControlPlane
<details><summary><code>client.empathicVoice.controlPlane.<a href="/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts">send</a>(chat_id, { ...params }) -> void</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Send a message to a specific chat.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.controlPlane.send("chat_id", {
    type: "session_settings"
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**chat_id:** `string` 
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.ControlPlanePublishEvent` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ControlPlaneClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## EmpathicVoice ChatGroups
<details><summary><code>client.empathicVoice.chatGroups.<a href="/src/api/resources/empathicVoice/resources/chatGroups/client/Client.ts">listChatGroups</a>({ ...params }) -> core.Page<Hume.ReturnChatGroup, Hume.ReturnPagedChatGroups></code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
const pageableResponse = await client.empathicVoice.chatGroups.listChatGroups({
    pageNumber: 0,
    pageSize: 1,
    ascendingOrder: true,
    configId: "1b60e1a0-cc59-424a-8d2c-189d354db3f3"
});
for await (const item of pageableResponse) {
    console.log(item);
}

// Or you can manually iterate page-by-page
let page = await client.empathicVoice.chatGroups.listChatGroups({
    pageNumber: 0,
    pageSize: 1,
    ascendingOrder: true,
    configId: "1b60e1a0-cc59-424a-8d2c-189d354db3f3"
});
while (page.hasNextPage()) {
    page = page.getNextPage();
}

// You can also access the underlying response
const response = page.response;

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.empathicVoice.ChatGroupsListChatGroupsRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ChatGroupsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.chatGroups.<a href="/src/api/resources/empathicVoice/resources/chatGroups/client/Client.ts">getChatGroup</a>(id, { ...params }) -> Hume.ReturnChatGroupPagedChats</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.chatGroups.getChatGroup("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
    pageNumber: 0,
    pageSize: 1,
    ascendingOrder: true
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a chat. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.ChatGroupsGetChatGroupRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ChatGroupsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.chatGroups.<a href="/src/api/resources/empathicVoice/resources/chatGroups/client/Client.ts">getAudio</a>(id, { ...params }) -> Hume.ReturnChatGroupPagedAudioReconstructions</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.chatGroups.getAudio("369846cf-6ad5-404d-905e-a8acb5cdfc78", {
    pageNumber: 0,
    pageSize: 10,
    ascendingOrder: true
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a chat. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.ChatGroupsGetAudioRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ChatGroupsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.chatGroups.<a href="/src/api/resources/empathicVoice/resources/chatGroups/client/Client.ts">listChatGroupEvents</a>(id, { ...params }) -> core.Page<Hume.ReturnChatEvent, Hume.ReturnChatGroupPagedEvents></code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
const pageableResponse = await client.empathicVoice.chatGroups.listChatGroupEvents("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
    pageNumber: 0,
    pageSize: 3,
    ascendingOrder: true
});
for await (const item of pageableResponse) {
    console.log(item);
}

// Or you can manually iterate page-by-page
let page = await client.empathicVoice.chatGroups.listChatGroupEvents("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
    pageNumber: 0,
    pageSize: 3,
    ascendingOrder: true
});
while (page.hasNextPage()) {
    page = page.getNextPage();
}

// You can also access the underlying response
const response = page.response;

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a chat. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.ChatGroupsListChatGroupEventsRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ChatGroupsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## EmpathicVoice Chats
<details><summary><code>client.empathicVoice.chats.<a href="/src/api/resources/empathicVoice/resources/chats/client/Client.ts">listChats</a>({ ...params }) -> core.Page<Hume.ReturnChat, Hume.ReturnPagedChats></code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
const pageableResponse = await client.empathicVoice.chats.listChats({
    pageNumber: 0,
    pageSize: 1,
    ascendingOrder: true
});
for await (const item of pageableResponse) {
    console.log(item);
}

// Or you can manually iterate page-by-page
let page = await client.empathicVoice.chats.listChats({
    pageNumber: 0,
    pageSize: 1,
    ascendingOrder: true
});
while (page.hasNextPage()) {
    page = page.getNextPage();
}

// You can also access the underlying response
const response = page.response;

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.empathicVoice.ChatsListChatsRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ChatsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.chats.<a href="/src/api/resources/empathicVoice/resources/chats/client/Client.ts">listChatEvents</a>(id, { ...params }) -> core.Page<Hume.ReturnChatEvent, Hume.ReturnChatPagedEvents></code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
const pageableResponse = await client.empathicVoice.chats.listChatEvents("470a49f6-1dec-4afe-8b61-035d3b2d63b0", {
    pageNumber: 0,
    pageSize: 3,
    ascendingOrder: true
});
for await (const item of pageableResponse) {
    console.log(item);
}

// Or you can manually iterate page-by-page
let page = await client.empathicVoice.chats.listChatEvents("470a49f6-1dec-4afe-8b61-035d3b2d63b0", {
    pageNumber: 0,
    pageSize: 3,
    ascendingOrder: true
});
while (page.hasNextPage()) {
    page = page.getNextPage();
}

// You can also access the underlying response
const response = page.response;

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a chat. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.ChatsListChatEventsRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ChatsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.chats.<a href="/src/api/resources/empathicVoice/resources/chats/client/Client.ts">getAudio</a>(id) -> Hume.ReturnChatAudioReconstruction</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.chats.getAudio("470a49f6-1dec-4afe-8b61-035d3b2d63b0");

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a chat. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ChatsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## EmpathicVoice Configs
<details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">listConfigs</a>({ ...params }) -> core.Page<Hume.ReturnConfig, Hume.ReturnPagedConfigs></code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
const pageableResponse = await client.empathicVoice.configs.listConfigs({
    pageNumber: 0,
    pageSize: 1
});
for await (const item of pageableResponse) {
    console.log(item);
}

// Or you can manually iterate page-by-page
let page = await client.empathicVoice.configs.listConfigs({
    pageNumber: 0,
    pageSize: 1
});
while (page.hasNextPage()) {
    page = page.getNextPage();
}

// You can also access the underlying response
const response = page.response;

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.empathicVoice.ConfigsListConfigsRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ConfigsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">createConfig</a>({ ...params }) -> Hume.ReturnConfig</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.configs.createConfig({
    name: "Weather Assistant Config",
    prompt: {
        id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
        version: 0
    },
    eviVersion: "3",
    voice: {
        provider: "HUME_AI",
        name: "Ava Song"
    },
    languageModel: {
        modelProvider: "ANTHROPIC",
        modelResource: "claude-3-7-sonnet-latest",
        temperature: 1
    },
    eventMessages: {
        onNewChat: {
            enabled: false,
            text: ""
        },
        onInactivityTimeout: {
            enabled: false,
            text: ""
        },
        onMaxDurationTimeout: {
            enabled: false,
            text: ""
        }
    }
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.empathicVoice.PostedConfig` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ConfigsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">listConfigVersions</a>(id, { ...params }) -> core.Page<Hume.ReturnConfig, Hume.ReturnPagedConfigs></code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
const pageableResponse = await client.empathicVoice.configs.listConfigVersions("1b60e1a0-cc59-424a-8d2c-189d354db3f3");
for await (const item of pageableResponse) {
    console.log(item);
}

// Or you can manually iterate page-by-page
let page = await client.empathicVoice.configs.listConfigVersions("1b60e1a0-cc59-424a-8d2c-189d354db3f3");
while (page.hasNextPage()) {
    page = page.getNextPage();
}

// You can also access the underlying response
const response = page.response;

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a config. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.ConfigsListConfigVersionsRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ConfigsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">createConfigVersion</a>(id, { ...params }) -> Hume.ReturnConfig</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.configs.createConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", {
    versionDescription: "This is an updated version of the Weather Assistant Config.",
    eviVersion: "3",
    prompt: {
        id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
        version: 0
    },
    voice: {
        provider: "HUME_AI",
        name: "Ava Song"
    },
    languageModel: {
        modelProvider: "ANTHROPIC",
        modelResource: "claude-3-7-sonnet-latest",
        temperature: 1
    },
    ellmModel: {
        allowShortResponses: true
    },
    eventMessages: {
        onNewChat: {
            enabled: false,
            text: ""
        },
        onInactivityTimeout: {
            enabled: false,
            text: ""
        },
        onMaxDurationTimeout: {
            enabled: false,
            text: ""
        }
    }
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a config. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.PostedConfigVersion` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ConfigsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">deleteConfig</a>(id) -> void</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.configs.deleteConfig("1b60e1a0-cc59-424a-8d2c-189d354db3f3");

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a config. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ConfigsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">updateConfigName</a>(id, { ...params }) -> string</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.configs.updateConfigName("1b60e1a0-cc59-424a-8d2c-189d354db3f3", {
    name: "Updated Weather Assistant Config Name"
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a config. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.PostedConfigName` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ConfigsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">getConfigVersion</a>(id, version) -> Hume.ReturnConfig</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.configs.getConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1);

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a config. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**version:** `number` — Version number for a config. Version numbers should be integers.
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ConfigsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">deleteConfigVersion</a>(id, version) -> void</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.configs.deleteConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1);

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a config. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**version:** `number` — Version number for a config. Version numbers should be integers.
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ConfigsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">updateConfigDescription</a>(id, version, { ...params }) -> Hume.ReturnConfig</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.configs.updateConfigDescription("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1, {
    versionDescription: "This is an updated version_description."
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a config. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**version:** `number` — Version number for a config. Version numbers should be integers.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.PostedConfigVersionDescription` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ConfigsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## EmpathicVoice Prompts
<details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">listPrompts</a>({ ...params }) -> core.Page<(Hume.ReturnPrompt | undefined), Hume.ReturnPagedPrompts></code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
const pageableResponse = await client.empathicVoice.prompts.listPrompts({
    pageNumber: 0,
    pageSize: 2
});
for await (const item of pageableResponse) {
    console.log(item);
}

// Or you can manually iterate page-by-page
let page = await client.empathicVoice.prompts.listPrompts({
    pageNumber: 0,
    pageSize: 2
});
while (page.hasNextPage()) {
    page = page.getNextPage();
}

// You can also access the underlying response
const response = page.response;

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.empathicVoice.PromptsListPromptsRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `PromptsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">createPrompt</a>({ ...params }) -> Hume.ReturnPrompt | undefined</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.prompts.createPrompt({
    name: "Weather Assistant Prompt",
    text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>"
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.empathicVoice.PostedPrompt` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `PromptsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">listPromptVersions</a>(id, { ...params }) -> Hume.ReturnPagedPrompts</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.prompts.listPromptVersions("af699d45-2985-42cc-91b9-af9e5da3bac5");

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` 
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.PromptsListPromptVersionsRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `PromptsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">createPromptVersion</a>(id, { ...params }) -> Hume.ReturnPrompt | undefined</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.prompts.createPromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", {
    text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
    versionDescription: "This is an updated version of the Weather Assistant Prompt."
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a prompt. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.PostedPromptVersion` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `PromptsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">deletePrompt</a>(id) -> void</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.prompts.deletePrompt("af699d45-2985-42cc-91b9-af9e5da3bac5");

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a prompt. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `PromptsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">updatePromptName</a>(id, { ...params }) -> string</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.prompts.updatePromptName("af699d45-2985-42cc-91b9-af9e5da3bac5", {
    name: "Updated Weather Assistant Prompt Name"
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a prompt. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.PostedPromptName` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `PromptsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">getPromptVersion</a>(id, version) -> Hume.ReturnPrompt | undefined</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.prompts.getPromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", 0);

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a prompt. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**version:** `number` — Version number for a prompt. Version numbers should be integers.
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `PromptsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">deletePromptVersion</a>(id, version) -> void</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.prompts.deletePromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", 1);

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a prompt. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**version:** `number` — Version number for a prompt. Version numbers should be integers.
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `PromptsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">updatePromptDescription</a>(id, version, { ...params }) -> Hume.ReturnPrompt | undefined</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.prompts.updatePromptDescription("af699d45-2985-42cc-91b9-af9e5da3bac5", 1, {
    versionDescription: "This is an updated version_description."
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a prompt. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**version:** `number` — Version number for a prompt. Version numbers should be integers.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.PostedPromptVersionDescription` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `PromptsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## EmpathicVoice Tools
<details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">listTools</a>({ ...params }) -> core.Page<(Hume.ReturnUserDefinedTool | undefined), Hume.ReturnPagedUserDefinedTools></code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
const pageableResponse = await client.empathicVoice.tools.listTools({
    pageNumber: 0,
    pageSize: 2
});
for await (const item of pageableResponse) {
    console.log(item);
}

// Or you can manually iterate page-by-page
let page = await client.empathicVoice.tools.listTools({
    pageNumber: 0,
    pageSize: 2
});
while (page.hasNextPage()) {
    page = page.getNextPage();
}

// You can also access the underlying response
const response = page.response;

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.empathicVoice.ToolsListToolsRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ToolsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">createTool</a>({ ...params }) -> Hume.ReturnUserDefinedTool | undefined</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.tools.createTool({
    name: "get_current_weather",
    parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
    versionDescription: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
    description: "This tool is for getting the current weather.",
    fallbackContent: "Unable to fetch current weather."
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.empathicVoice.PostedUserDefinedTool` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ToolsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">listToolVersions</a>(id, { ...params }) -> core.Page<(Hume.ReturnUserDefinedTool | undefined), Hume.ReturnPagedUserDefinedTools></code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
const pageableResponse = await client.empathicVoice.tools.listToolVersions("00183a3f-79ba-413d-9f3b-609864268bea");
for await (const item of pageableResponse) {
    console.log(item);
}

// Or you can manually iterate page-by-page
let page = await client.empathicVoice.tools.listToolVersions("00183a3f-79ba-413d-9f3b-609864268bea");
while (page.hasNextPage()) {
    page = page.getNextPage();
}

// You can also access the underlying response
const response = page.response;

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` 
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.ToolsListToolVersionsRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ToolsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">createToolVersion</a>(id, { ...params }) -> Hume.ReturnUserDefinedTool | undefined</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.tools.createToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", {
    parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\", \"kelvin\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
    versionDescription: "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
    fallbackContent: "Unable to fetch current weather.",
    description: "This tool is for getting the current weather."
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a tool. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.PostedUserDefinedToolVersion` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ToolsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">deleteTool</a>(id) -> void</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.tools.deleteTool("00183a3f-79ba-413d-9f3b-609864268bea");

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a tool. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ToolsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">updateToolName</a>(id, { ...params }) -> string</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.tools.updateToolName("00183a3f-79ba-413d-9f3b-609864268bea", {
    name: "get_current_temperature"
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a tool. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.PostedUserDefinedToolName` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ToolsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">getToolVersion</a>(id, version) -> Hume.ReturnUserDefinedTool | undefined</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.tools.getToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1);

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a tool. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**version:** `number` — Version number for a tool. Version numbers should be integers.
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ToolsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">deleteToolVersion</a>(id, version) -> void</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.tools.deleteToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1);

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a tool. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**version:** `number` — Version number for a tool. Version numbers should be integers.
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ToolsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">updateToolDescription</a>(id, version, { ...params }) -> Hume.ReturnUserDefinedTool | undefined</code></summary>
<dl>
<dd>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.empathicVoice.tools.updateToolDescription("00183a3f-79ba-413d-9f3b-609864268bea", 1, {
    versionDescription: "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region."
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — Identifier for a tool. Formatted as a UUID.
    
</dd>
</dl>

<dl>
<dd>

**version:** `number` — Version number for a tool. Version numbers should be integers.
    
</dd>
</dl>

<dl>
<dd>

**request:** `Hume.empathicVoice.PostedUserDefinedToolVersionDescription` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `ToolsClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

## ExpressionMeasurement Batch
<details><summary><code>client.expressionMeasurement.batch.<a href="/src/api/resources/expressionMeasurement/resources/batch/client/Client.ts">listJobs</a>({ ...params }) -> Hume.UnionJob[]</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Sort and filter jobs.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.expressionMeasurement.batch.listJobs();

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.expressionMeasurement.batch.BatchListJobsRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `BatchClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.expressionMeasurement.batch.<a href="/src/api/resources/expressionMeasurement/resources/batch/client/Client.ts">startInferenceJob</a>({ ...params }) -> Hume.JobId</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Start a new measurement inference job.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.expressionMeasurement.batch.startInferenceJob({
    urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
    notify: true
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.InferenceBaseRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `BatchClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.expressionMeasurement.batch.<a href="/src/api/resources/expressionMeasurement/resources/batch/client/Client.ts">getJobDetails</a>(id) -> Hume.UnionJob</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Get the request details and state of a given job.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.expressionMeasurement.batch.getJobDetails("job_id");

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — The unique identifier for the job.
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `BatchClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.expressionMeasurement.batch.<a href="/src/api/resources/expressionMeasurement/resources/batch/client/Client.ts">getJobPredictions</a>(id) -> Hume.UnionPredictResult[]</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Get the JSON predictions of a completed inference job.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.expressionMeasurement.batch.getJobPredictions("job_id");

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**id:** `string` — The unique identifier for the job.
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `BatchClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

<details><summary><code>client.expressionMeasurement.batch.<a href="/src/api/resources/expressionMeasurement/resources/batch/client/Client.ts">startInferenceJobFromLocalFile</a>({ ...params }) -> Hume.JobId</code></summary>
<dl>
<dd>

#### 📝 Description

<dl>
<dd>

<dl>
<dd>

Start a new batch inference job.
</dd>
</dl>
</dd>
</dl>

#### 🔌 Usage

<dl>
<dd>

<dl>
<dd>

```typescript
await client.expressionMeasurement.batch.startInferenceJobFromLocalFile({
    file: [fs.createReadStream("/path/to/your/file")]
});

```
</dd>
</dl>
</dd>
</dl>

#### ⚙️ Parameters

<dl>
<dd>

<dl>
<dd>

**request:** `Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest` 
    
</dd>
</dl>

<dl>
<dd>

**requestOptions:** `BatchClient.RequestOptions` 
    
</dd>
</dl>
</dd>
</dl>


</dd>
</dl>
</details>

```


## /scripts/rename-to-esm-files.js
```javascript
#!/usr/bin/env node

const fs = require("fs").promises;
const path = require("path");

const extensionMap = {
    ".js": ".mjs",
    ".d.ts": ".d.mts",
};
const oldExtensions = Object.keys(extensionMap);

async function findFiles(rootPath) {
    const files = [];

    async function scan(directory) {
        const entries = await fs.readdir(directory, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(directory, entry.name);

            if (entry.isDirectory()) {
                if (entry.name !== "node_modules" && !entry.name.startsWith(".")) {
                    await scan(fullPath);
                }
            } else if (entry.isFile()) {
                if (oldExtensions.some((ext) => entry.name.endsWith(ext))) {
                    files.push(fullPath);
                }
            }
        }
    }

    await scan(rootPath);
    return files;
}

async function updateFiles(files) {
    const updatedFiles = [];
    for (const file of files) {
        const updated = await updateFileContents(file);
        updatedFiles.push(updated);
    }

    console.log(`Updated imports in ${updatedFiles.length} files.`);
}

async function updateFileContents(file) {
    const content = await fs.readFile(file, "utf8");

    let newContent = content;
    // Update each extension type defined in the map
    for (const [oldExt, newExt] of Object.entries(extensionMap)) {
        // Handle static imports/exports
        const staticRegex = new RegExp(`(import|export)(.+from\\s+['"])(\\.\\.?\\/[^'"]+)(\\${oldExt})(['"])`, "g");
        newContent = newContent.replace(staticRegex, `$1$2$3${newExt}$5`);

        // Handle dynamic imports (yield import, await import, regular import())
        const dynamicRegex = new RegExp(
            `(yield\\s+import|await\\s+import|import)\\s*\\(\\s*['"](\\.\\.\?\\/[^'"]+)(\\${oldExt})['"]\\s*\\)`,
            "g",
        );
        newContent = newContent.replace(dynamicRegex, `$1("$2${newExt}")`);
    }

    if (content !== newContent) {
        await fs.writeFile(file, newContent, "utf8");
        return true;
    }
    return false;
}

async function renameFiles(files) {
    let counter = 0;
    for (const file of files) {
        const ext = oldExtensions.find((ext) => file.endsWith(ext));
        const newExt = extensionMap[ext];

        if (newExt) {
            const newPath = file.slice(0, -ext.length) + newExt;
            await fs.rename(file, newPath);
            counter++;
        }
    }

    console.log(`Renamed ${counter} files.`);
}

async function main() {
    try {
        const targetDir = process.argv[2];
        if (!targetDir) {
            console.error("Please provide a target directory");
            process.exit(1);
        }

        const targetPath = path.resolve(targetDir);
        const targetStats = await fs.stat(targetPath);

        if (!targetStats.isDirectory()) {
            console.error("The provided path is not a directory");
            process.exit(1);
        }

        console.log(`Scanning directory: ${targetDir}`);

        const files = await findFiles(targetDir);

        if (files.length === 0) {
            console.log("No matching files found.");
            process.exit(0);
        }

        console.log(`Found ${files.length} files.`);
        await updateFiles(files);
        await renameFiles(files);
        console.log("\nDone!");
    } catch (error) {
        console.error("An error occurred:", error.message);
        process.exit(1);
    }
}

main();

```


## /src/BaseClient.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import { HeaderAuthProvider } from "./auth/HeaderAuthProvider.js";
import { mergeHeaders } from "./core/headers.js";
import * as core from "./core/index.js";
import type * as environments from "./environments.js";

export type BaseClientOptions = {
    environment?: core.Supplier<environments.HumeEnvironment | environments.HumeEnvironmentUrls>;
    /** Specify a custom URL to connect the client to. */
    baseUrl?: core.Supplier<string>;
    /** Additional headers to include in requests. */
    headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    /** The default maximum time to wait for a response in seconds. */
    timeoutInSeconds?: number;
    /** The default number of times to retry the request. Defaults to 2. */
    maxRetries?: number;
    /** Provide a custom fetch implementation. Useful for platforms that don't have a built-in fetch or need a custom implementation. */
    fetch?: typeof fetch;
    fetcher?: core.FetchFunction;
    /** Configure logging for the client. */
    logging?: core.logging.LogConfig | core.logging.Logger;
} & HeaderAuthProvider.AuthOptions;

export interface BaseRequestOptions {
    /** The maximum time to wait for a response in seconds. */
    timeoutInSeconds?: number;
    /** The number of times to retry the request. Defaults to 2. */
    maxRetries?: number;
    /** A hook to abort the request. */
    abortSignal?: AbortSignal;
    /** Additional query string parameters to include in the request. */
    queryParams?: Record<string, unknown>;
    /** Additional headers to include in the request. */
    headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
}

export type NormalizedClientOptions<T extends BaseClientOptions = BaseClientOptions> = T & {
    logging: core.logging.Logger;
    authProvider?: core.AuthProvider;
};

export type NormalizedClientOptionsWithAuth<T extends BaseClientOptions = BaseClientOptions> =
    NormalizedClientOptions<T> & {
        authProvider: core.AuthProvider;
    };

export function normalizeClientOptions<T extends BaseClientOptions = BaseClientOptions>(
    options: T,
): NormalizedClientOptions<T> {
    const headers = mergeHeaders(
        {
            "X-Fern-Language": "JavaScript",
            "X-Fern-SDK-Name": "hume",
            "X-Fern-SDK-Version": "0.15.11",
            "User-Agent": "hume/0.15.11",
            "X-Fern-Runtime": core.RUNTIME.type,
            "X-Fern-Runtime-Version": core.RUNTIME.version,
        },
        options?.headers,
    );

    return {
        ...options,
        logging: core.logging.createLogger(options?.logging),
        headers,
    } as NormalizedClientOptions<T>;
}

export function normalizeClientOptionsWithAuth<T extends BaseClientOptions = BaseClientOptions>(
    options: T,
): NormalizedClientOptionsWithAuth<T> {
    const normalized = normalizeClientOptions(options) as NormalizedClientOptionsWithAuth<T>;
    const normalizedWithNoOpAuthProvider = withNoOpAuthProvider(normalized);
    normalized.authProvider ??= new HeaderAuthProvider(normalizedWithNoOpAuthProvider);
    return normalized;
}

function withNoOpAuthProvider<T extends BaseClientOptions = BaseClientOptions>(
    options: NormalizedClientOptions<T>,
): NormalizedClientOptionsWithAuth<T> {
    return {
        ...options,
        authProvider: new core.NoOpAuthProvider(),
    };
}

```


## /src/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import { EmpathicVoiceClient } from "./api/resources/empathicVoice/client/Client.js";
import { ExpressionMeasurementClient } from "./api/resources/expressionMeasurement/client/Client.js";
import { TtsClient } from "./api/resources/tts/client/Client.js";
import type { BaseClientOptions, BaseRequestOptions } from "./BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "./BaseClient.js";

export declare namespace HumeClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class HumeClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<HumeClient.Options>;
    protected _tts: TtsClient | undefined;
    protected _empathicVoice: EmpathicVoiceClient | undefined;
    protected _expressionMeasurement: ExpressionMeasurementClient | undefined;

    constructor(options: HumeClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    public get tts(): TtsClient {
        return (this._tts ??= new TtsClient(this._options));
    }

    public get empathicVoice(): EmpathicVoiceClient {
        return (this._empathicVoice ??= new EmpathicVoiceClient(this._options));
    }

    public get expressionMeasurement(): ExpressionMeasurementClient {
        return (this._expressionMeasurement ??= new ExpressionMeasurementClient(this._options));
    }
}

```


## /src/api/index.ts
```typescript
export * from "./resources/index.js";

```


## /src/api/resources/empathicVoice/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { ChatClient } from "../resources/chat/client/Client.js";
import { ChatGroupsClient } from "../resources/chatGroups/client/Client.js";
import { ChatsClient } from "../resources/chats/client/Client.js";
import { ConfigsClient } from "../resources/configs/client/Client.js";
import { ControlPlaneClient } from "../resources/controlPlane/client/Client.js";
import { PromptsClient } from "../resources/prompts/client/Client.js";
import { ToolsClient } from "../resources/tools/client/Client.js";

export declare namespace EmpathicVoiceClient {
    export type Options = BaseClientOptions;
}

export class EmpathicVoiceClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<EmpathicVoiceClient.Options>;
    protected _controlPlane: ControlPlaneClient | undefined;
    protected _chatGroups: ChatGroupsClient | undefined;
    protected _chats: ChatsClient | undefined;
    protected _configs: ConfigsClient | undefined;
    protected _prompts: PromptsClient | undefined;
    protected _tools: ToolsClient | undefined;
    protected _chat: ChatClient | undefined;

    constructor(options: EmpathicVoiceClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    public get controlPlane(): ControlPlaneClient {
        return (this._controlPlane ??= new ControlPlaneClient(this._options));
    }

    public get chatGroups(): ChatGroupsClient {
        return (this._chatGroups ??= new ChatGroupsClient(this._options));
    }

    public get chats(): ChatsClient {
        return (this._chats ??= new ChatsClient(this._options));
    }

    public get configs(): ConfigsClient {
        return (this._configs ??= new ConfigsClient(this._options));
    }

    public get prompts(): PromptsClient {
        return (this._prompts ??= new PromptsClient(this._options));
    }

    public get tools(): ToolsClient {
        return (this._tools ??= new ToolsClient(this._options));
    }

    public get chat(): ChatClient {
        return (this._chat ??= new ChatClient(this._options));
    }
}

```


## /src/api/resources/empathicVoice/client/index.ts
```typescript
export {};

```


## /src/api/resources/empathicVoice/errors/BadRequestError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../core/index.js";
import * as errors from "../../../../errors/index.js";
import type * as Hume from "../../../index.js";

export class BadRequestError extends errors.HumeError {
    constructor(body: Hume.empathicVoice.ErrorResponse, rawResponse?: core.RawResponse) {
        super({
            message: "BadRequestError",
            statusCode: 400,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }

        this.name = this.constructor.name;
    }
}

```


## /src/api/resources/empathicVoice/errors/UnprocessableEntityError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../core/index.js";
import * as errors from "../../../../errors/index.js";
import type * as Hume from "../../../index.js";

export class UnprocessableEntityError extends errors.HumeError {
    constructor(body: Hume.empathicVoice.HttpValidationError, rawResponse?: core.RawResponse) {
        super({
            message: "UnprocessableEntityError",
            statusCode: 422,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }

        this.name = this.constructor.name;
    }
}

```


## /src/api/resources/empathicVoice/errors/index.ts
```typescript
export * from "./BadRequestError.js";
export * from "./UnprocessableEntityError.js";

```


## /src/api/resources/empathicVoice/index.ts
```typescript
export * from "./client/index.js";
export * from "./errors/index.js";
export * from "./resources/index.js";
export * from "./types/index.js";

```


## /src/api/resources/empathicVoice/resources/chat/client/Client.ts
```typescript
/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
import type { BaseClientOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import * as serializers from "../../../../../../serialization/index.js";
import type * as Hume from "../../../../../index.js";
import { mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import { ChatSocket } from "./Socket.js";

export declare namespace ChatClient {
    export type Options = BaseClientOptions;

    export interface ConnectArgs {
        accessToken?: string;
        allowConnection?: boolean;
        configId?: string;
        /** Accepts both string and number for backward compatibility */
        configVersion?: string | number;
        eventLimit?: number;
        resumedChatGroupId?: string;
        verboseTranscription?: boolean;
        /** @deprecated Use sessionSettings.voiceId instead */
        voiceId?: string;
        apiKey?: string;
        sessionSettings?: Hume.empathicVoice.ConnectSessionSettings;
        /** Extra query parameters sent at WebSocket connection  for backward compatibility */
        queryParams?: Record<string, string | string[] | object | object[]>;
        /** Arbitrary headers to send with the websocket connect request. */
        headers?: Record<string, string>;
        debug?: boolean;
        reconnectAttempts?: number;
    }
}

export class ChatClient {
    protected readonly _options: NormalizedClientOptions<ChatClient.Options>;

    constructor(options: ChatClient.Options = {}) {
        this._options = normalizeClientOptions(options);
    }

    public connect(args: ChatClient.ConnectArgs = {}): ChatSocket {
        const {
            accessToken,
            allowConnection,
            configId,
            configVersion,
            eventLimit,
            resumedChatGroupId,
            verboseTranscription,
            voiceId,
            apiKey,
            sessionSettings,
            queryParams,
            headers,
            debug,
            reconnectAttempts,
        } = args;

        const _queryParams: Record<string, string | string[] | object | object[] | null | undefined> = {
            access_token: accessToken,
            allow_connection: allowConnection != null ? (allowConnection ? "true" : "false") : undefined,
            config_id: configId,
            config_version:
                configVersion != null
                    ? typeof configVersion === "number"
                        ? configVersion.toString()
                        : configVersion
                    : undefined,
            event_limit: eventLimit != null ? eventLimit.toString() : undefined,
            resumed_chat_group_id: resumedChatGroupId,
            verbose_transcription: verboseTranscription != null ? verboseTranscription.toString() : undefined,
            voice_id: voiceId,
            api_key: apiKey,
            session_settings:
                sessionSettings != null
                    ? serializers.empathicVoice.ConnectSessionSettings.jsonOrThrow(sessionSettings, {
                          unrecognizedObjectKeys: "passthrough",
                          allowUnrecognizedUnionMembers: true,
                          allowUnrecognizedEnumValues: true,
                          omitUndefined: true,
                          breadcrumbsPrefix: ["request", "sessionSettings"],
                      })
                    : undefined,
        };

        // Merge in any additional query parameters
        if (queryParams != null) {
            for (const [name, value] of Object.entries(queryParams)) {
                _queryParams[name] = value;
            }
        }

        const _headers: Record<string, unknown> = mergeOnlyDefinedHeaders({
            ...this._getCustomAuthorizationHeaders(),
            ...headers,
        });
        const socket = new core.ReconnectingWebSocket({
            url: core.url.join(
                core.Supplier.get(this._options.baseUrl) ??
                    (core.Supplier.get(this._options.environment) ?? environments.HumeEnvironment.Prod).evi,
                "/chat",
            ),
            protocols: [],
            queryParameters: _queryParams,
            headers: _headers,
            options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
        });

        return new ChatSocket({ socket });
    }

    protected _getCustomAuthorizationHeaders(): Record<string, string | null | undefined> {
        const apiKeyValue = core.Supplier.get(this._options.apiKey);
        // This `authHeaderValue` is manually added as if you don't provide it it will
        // be omitted from the headers which means it won't reach the logic in ws.ts that
        // extracts values from the headers and adds them to query parameters.
        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
    }
}

```


## /src/api/resources/empathicVoice/resources/chat/client/Client.ts.diff
```diff
diff --git a/src/api/resources/empathicVoice/resources/chat/client/Client.ts b/src/api/resources/empathicVoice/resources/chat/client/Client.ts
index b67a3a3..6a5e46a 100644
--- a/src/api/resources/empathicVoice/resources/chat/client/Client.ts
+++ b/src/api/resources/empathicVoice/resources/chat/client/Client.ts
@@ -1,36 +1,26 @@
-/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
+// This file was auto-generated by Fern from our API Definition.
 
-import * as environments from "../../../../../../environments.js";
+import type { BaseClientOptions } from "../../../../../../BaseClient.js";
+import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
 import * as core from "../../../../../../core/index.js";
-import * as Hume from "../../../../../index.js";
-import { mergeOnlyDefinedHeaders, mergeHeaders } from "../../../../../../core/headers.js";
+import * as environments from "../../../../../../environments.js";
 import * as serializers from "../../../../../../serialization/index.js";
+import type * as Hume from "../../../../../index.js";
 import { ChatSocket } from "./Socket.js";
 
 export declare namespace ChatClient {
-    export interface Options {
-        environment?: core.Supplier<environments.HumeEnvironment | environments.HumeEnvironmentUrls>;
-        /** Specify a custom URL to connect the client to. */
-        baseUrl?: core.Supplier<string>;
-        apiKey?: core.Supplier<string | undefined>;
-        /** Additional headers to include in requests. */
-        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
-    }
+    export type Options = BaseClientOptions;
 
     export interface ConnectArgs {
-        accessToken?: string | undefined;
-        configId?: string | undefined;
-        configVersion?: string | number | undefined;
-        eventLimit?: number | undefined;
-        resumedChatGroupId?: string | undefined;
-        verboseTranscription?: boolean | undefined;
-        allowConnection?: boolean | undefined;
-        /** @deprecated Use sessionSettings.voiceId instead */
-        voiceId?: string | undefined;
-        apiKey?: string | undefined;
-        sessionSettings?: Hume.empathicVoice.ConnectSessionSettings;
-        /** Extra query parameters sent at WebSocket connection */
-        queryParams?: Record<string, string | string[] | object | object[]>;
+        accessToken?: string;
+        allowConnection?: boolean;
+        configId?: string;
+        configVersion?: number;
+        eventLimit?: number;
+        resumedChatGroupId?: string;
+        verboseTranscription?: boolean;
+        apiKey?: string;
+        sessionSettings: Hume.empathicVoice.ConnectSessionSettings;
         /** Arbitrary headers to send with the websocket connect request. */
         headers?: Record<string, string>;
         /** Enable debug mode on the websocket. Defaults to false. */
@@ -41,97 +31,49 @@ export declare namespace ChatClient {
 }
 
 export class ChatClient {
-    protected readonly _options: ChatClient.Options;
+    protected readonly _options: NormalizedClientOptions<ChatClient.Options>;
 
-    constructor(_options: ChatClient.Options = {}) {
-        this._options = _options;
+    constructor(options: ChatClient.Options = {}) {
+        this._options = normalizeClientOptions(options);
     }
 
-    public connect(args: ChatClient.ConnectArgs = {}): ChatSocket {
+    public async connect(args: ChatClient.ConnectArgs): Promise<ChatSocket> {
         const {
             accessToken,
+            allowConnection,
             configId,
             configVersion,
             eventLimit,
             resumedChatGroupId,
             verboseTranscription,
-            voiceId,
             apiKey,
             sessionSettings,
-            queryParams,
             headers,
             debug,
             reconnectAttempts,
-            allowConnection,
         } = args;
-        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
-
-        if (accessToken != null) {
-            _queryParams["access_token"] = accessToken;
-        }
-
-        if (configId != null) {
-            _queryParams["config_id"] = configId;
-        }
-
-        if (configVersion != null) {
-            _queryParams["config_version"] =
-                typeof configVersion === "number" ? configVersion.toString() : configVersion;
-        }
-
-        if (eventLimit != null) {
-            _queryParams["event_limit"] = eventLimit.toString();
-        }
-
-        if (resumedChatGroupId != null) {
-            _queryParams["resumed_chat_group_id"] = resumedChatGroupId;
-        }
-
-        if (verboseTranscription != null) {
-            _queryParams["verbose_transcription"] = verboseTranscription.toString();
-        }
-
-        if (voiceId != null) {
-            _queryParams["voice_id"] = voiceId;
-        }
-
-        if (apiKey != null) {
-            _queryParams["api_key"] = apiKey;
-        }
-
-        if (allowConnection != null) {
-            _queryParams["allow_connection"] = allowConnection === true ? "true" : "false";
-        }
-
-        if (sessionSettings != null) {
-            _queryParams["session_settings"] = serializers.empathicVoice.ConnectSessionSettings.jsonOrThrow(
-                sessionSettings,
-                {
-                    unrecognizedObjectKeys: "passthrough",
-                    allowUnrecognizedUnionMembers: true,
-                    allowUnrecognizedEnumValues: true,
-                    omitUndefined: true,
-                    breadcrumbsPrefix: ["request", "sessionSettings"],
-                },
-            );
-        }
-
-        // Merge in any additional query parameters
-        if (queryParams != null) {
-            for (const [name, value] of Object.entries(queryParams)) {
-                _queryParams[name] = value;
-            }
-        }
-
-        let _headers: Record<string, unknown> = mergeHeaders(
-            mergeOnlyDefinedHeaders({ ...this._getCustomAuthorizationHeaders() }),
-            headers,
-        );
-
+        const _queryParams: Record<string, unknown> = {
+            access_token: accessToken,
+            allow_connection: allowConnection,
+            config_id: configId,
+            config_version: configVersion,
+            event_limit: eventLimit,
+            resumed_chat_group_id: resumedChatGroupId,
+            verbose_transcription: verboseTranscription,
+            api_key: apiKey,
+            session_settings: serializers.empathicVoice.ConnectSessionSettings.jsonOrThrow(sessionSettings, {
+                unrecognizedObjectKeys: "passthrough",
+                allowUnrecognizedUnionMembers: true,
+                allowUnrecognizedEnumValues: true,
+                omitUndefined: true,
+                breadcrumbsPrefix: ["request", "sessionSettings"],
+            }),
+        };
+        const _headers: Record<string, unknown> = { ...headers };
         const socket = new core.ReconnectingWebSocket({
             url: core.url.join(
-                core.Supplier.get(this._options["baseUrl"]) ??
-                    (core.Supplier.get(this._options["environment"]) ?? environments.HumeEnvironment.Prod).evi,
+                (await core.Supplier.get(this._options.baseUrl)) ??
+                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).evi,
                 "/chat",
             ),
             protocols: [],
@@ -141,13 +83,4 @@ export class ChatClient {
         });
         return new ChatSocket({ socket });
     }
-
-    protected _getCustomAuthorizationHeaders(): Record<string, string | null | undefined> {
-        const apiKeyValue = core.Supplier.get(this._options.apiKey);
-        // This `authHeaderValue` is manually added as if you don't provide it it will
-        // be omitted from the headers which means it won't reach the logic in ws.ts that
-        // extracts values from the headers and adds them to query parameters.
-        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
-        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
-    }
 }

```


## /src/api/resources/empathicVoice/resources/chat/client/Socket.ts
```typescript
/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */

import * as core from "../../../../../../core/index.js";
import * as Hume from "../../../../../index.js";
import { PublishEvent } from "../../../../../../serialization/resources/empathicVoice/resources/chat/types/PublishEvent.js";
import { fromJson } from "../../../../../../core/json.js";
import * as serializers from "../../../../../../serialization/index.js";

export declare namespace ChatSocket {
    export interface Args {
        socket: core.ReconnectingWebSocket;
    }

    export type Response = Hume.empathicVoice.SubscribeEvent & { receivedAt: Date };
    type EventHandlers = {
        open?: () => void;
        message?: (message: Response) => void;
        close?: (event: core.CloseEvent) => void;
        error?: (error: Error) => void;
    };
}

export class ChatSocket {
    public readonly socket: core.ReconnectingWebSocket;
    protected readonly eventHandlers: ChatSocket.EventHandlers = {};
    private handleOpen: () => void = () => {
        this.eventHandlers.open?.();
    };
    private handleMessage: (event: { data: string }) => void = (event) => {
        const data = fromJson(event.data);

        const parsedResponse = serializers.empathicVoice.ChatSocketResponse.parse(data, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        if (parsedResponse.ok) {
            this.eventHandlers.message?.({
                ...parsedResponse.value,
                receivedAt: new Date(),
            });
        } else {
            this.eventHandlers.error?.(new Error("Received unknown message type"));
        }
    };
    private handleClose: (event: core.CloseEvent) => void = (event) => {
        this.eventHandlers.close?.(event);
    };
    private handleError: (event: core.ErrorEvent) => void = (event) => {
        const message = event.message;
        this.eventHandlers.error?.(new Error(message));
    };

    constructor(args: ChatSocket.Args) {
        this.socket = args.socket;
        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);
    }

    /** The current state of the connection; this is one of the readyState constants. */
    get readyState(): number {
        return this.socket.readyState;
    }

    /**
     * @param event - The event to attach to.
     * @param callback - The callback to run when the event is triggered.
     * Usage:
     * ```typescript
     * this.on('open', () => {
     *     console.log('The websocket is open');
     * });
     * ```
     */
    public on<T extends keyof ChatSocket.EventHandlers>(event: T, callback: ChatSocket.EventHandlers[T]): void {
        this.eventHandlers[event] = callback;
    }

    public sendPublish(message: Hume.empathicVoice.PublishEvent): void {
        this.assertSocketIsOpen();
        const jsonPayload = PublishEvent.jsonOrThrow(message, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        this.socket.send(JSON.stringify(jsonPayload));
    }

    /**
     * Send audio input
     */
    public sendAudioInput(message: Omit<Hume.empathicVoice.AudioInput, "type">): void {
        this.sendPublish({
            type: "audio_input",
            ...message,
        });
    }

    /**
     * Send session settings
     */
    public sendSessionSettings(message: Omit<Hume.empathicVoice.SessionSettings, "type"> = {}): void {
        this.sendPublish({
            type: "session_settings",
            ...message,
        });
    }

    /**
     * Send assistant input
     */
    public sendAssistantInput(message: Omit<Hume.empathicVoice.AssistantInput, "type">): void {
        this.sendPublish({
            type: "assistant_input",
            ...message,
        });
    }

    /**
     * Send pause assistant message
     */
    public pauseAssistant(message: Omit<Hume.empathicVoice.PauseAssistantMessage, "type"> = {}): void {
        this.sendPublish({
            type: "pause_assistant_message",
            ...message,
        });
    }

    /**
     * Send resume assistant message
     */
    public resumeAssistant(message: Omit<Hume.empathicVoice.ResumeAssistantMessage, "type"> = {}): void {
        this.sendPublish({
            type: "resume_assistant_message",
            ...message,
        });
    }

    /**
     * Send tool response message
     */
    public sendToolResponseMessage(message: Omit<Hume.empathicVoice.ToolResponseMessage, "type">): void {
        this.sendPublish({
            type: "tool_response",
            ...message,
        });
    }

    /**
     * Send tool error message
     */
    public sendToolErrorMessage(message: Omit<Hume.empathicVoice.ToolErrorMessage, "type">): void {
        this.sendPublish({
            type: "tool_error",
            ...message,
        });
    }

    /**
     * Send text input
     */
    public sendUserInput(text: string): void {
        this.sendPublish({
            type: "user_input",
            text,
        });
    }

    /** Connect to the websocket and register event handlers. */
    public connect(): ChatSocket {
        this.socket.reconnect();

        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);

        return this;
    }

    /** Close the websocket and unregister event handlers. */
    public close(): void {
        this.socket.close();

        this.handleClose({ code: 1000 } as CloseEvent);

        this.socket.removeEventListener("open", this.handleOpen);
        this.socket.removeEventListener("message", this.handleMessage);
        this.socket.removeEventListener("close", this.handleClose);
        this.socket.removeEventListener("error", this.handleError);
    }

    /** Returns a promise that resolves when the websocket is open. */
    public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
        if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
            return this.socket;
        }

        return new Promise((resolve, reject) => {
            this.socket.addEventListener("open", () => {
                resolve(this.socket);
            });

            this.socket.addEventListener("error", (event: unknown) => {
                reject(event);
            });
        });
    }

    /**
     * @deprecated Use waitForOpen() instead
     */
    public async tillSocketOpen(): Promise<core.ReconnectingWebSocket> {
        return this.waitForOpen();
    }

    /** Asserts that the websocket is open. */
    private assertSocketIsOpen(): void {
        if (!this.socket) {
            throw new Error("Socket is not connected.");
        }

        if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
            throw new Error("Socket is not open.");
        }
    }

    /** Send a binary payload to the websocket. */
    protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
        this.socket.send(payload);
    }
}

```


## /src/api/resources/empathicVoice/resources/chat/client/Socket.ts.diff
```diff
diff --git a/src/api/resources/empathicVoice/resources/chat/client/Socket.ts b/src/api/resources/empathicVoice/resources/chat/client/Socket.ts
index a55c7b5..0f2f2a5 100644
--- a/src/api/resources/empathicVoice/resources/chat/client/Socket.ts
+++ b/src/api/resources/empathicVoice/resources/chat/client/Socket.ts
@@ -1,17 +1,17 @@
-/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
+// This file was auto-generated by Fern from our API Definition.
 
 import * as core from "../../../../../../core/index.js";
-import * as Hume from "../../../../../index.js";
-import { PublishEvent } from "../../../../../../serialization/resources/empathicVoice/resources/chat/types/PublishEvent.js";
 import { fromJson } from "../../../../../../core/json.js";
 import * as serializers from "../../../../../../serialization/index.js";
+import { PublishEvent } from "../../../../../../serialization/resources/empathicVoice/resources/chat/types/PublishEvent.js";
+import type * as Hume from "../../../../../index.js";
 
 export declare namespace ChatSocket {
     export interface Args {
         socket: core.ReconnectingWebSocket;
     }
 
-    export type Response = Hume.empathicVoice.SubscribeEvent & { receivedAt: Date };
+    export type Response = Hume.empathicVoice.SubscribeEvent;
     type EventHandlers = {
         open?: () => void;
         message?: (message: Response) => void;
@@ -37,10 +37,7 @@ export class ChatSocket {
             omitUndefined: true,
         });
         if (parsedResponse.ok) {
-            this.eventHandlers.message?.({
-                ...parsedResponse.value,
-                receivedAt: new Date(),
-            });
+            this.eventHandlers.message?.(parsedResponse.value);
         } else {
             this.eventHandlers.error?.(new Error("Received unknown message type"));
         }
@@ -92,86 +89,6 @@ export class ChatSocket {
         this.socket.send(JSON.stringify(jsonPayload));
     }
 
-    /**
-     * Send audio input
-     */
-    public sendAudioInput(message: Omit<Hume.empathicVoice.AudioInput, "type">): void {
-        this.sendPublish({
-            type: "audio_input",
-            ...message,
-        });
-    }
-
-    /**
-     * Send session settings
-     */
-    public sendSessionSettings(message: Omit<Hume.empathicVoice.SessionSettings, "type"> = {}): void {
-        this.sendPublish({
-            type: "session_settings",
-            ...message,
-        });
-    }
-
-    /**
-     * Send assistant input
-     */
-    public sendAssistantInput(message: Omit<Hume.empathicVoice.AssistantInput, "type">): void {
-        this.sendPublish({
-            type: "assistant_input",
-            ...message,
-        });
-    }
-
-    /**
-     * Send pause assistant message
-     */
-    public pauseAssistant(message: Omit<Hume.empathicVoice.PauseAssistantMessage, "type"> = {}): void {
-        this.sendPublish({
-            type: "pause_assistant_message",
-            ...message,
-        });
-    }
-
-    /**
-     * Send resume assistant message
-     */
-    public resumeAssistant(message: Omit<Hume.empathicVoice.ResumeAssistantMessage, "type"> = {}): void {
-        this.sendPublish({
-            type: "resume_assistant_message",
-            ...message,
-        });
-    }
-
-    /**
-     * Send tool response message
-     */
-    public sendToolResponseMessage(message: Omit<Hume.empathicVoice.ToolResponseMessage, "type">): void {
-        this.sendPublish({
-            type: "tool_response",
-            ...message,
-        });
-    }
-
-    /**
-     * Send tool error message
-     */
-    public sendToolErrorMessage(message: Omit<Hume.empathicVoice.ToolErrorMessage, "type">): void {
-        this.sendPublish({
-            type: "tool_error",
-            ...message,
-        });
-    }
-
-    /**
-     * Send text input
-     */
-    public sendUserInput(text: string): void {
-        this.sendPublish({
-            type: "user_input",
-            text,
-        });
-    }
-
     /** Connect to the websocket and register event handlers. */
     public connect(): ChatSocket {
         this.socket.reconnect();
@@ -213,13 +130,6 @@ export class ChatSocket {
         });
     }
 
-    /**
-     * @deprecated Use waitForOpen() instead
-     */
-    public async tillSocketOpen(): Promise<core.ReconnectingWebSocket> {
-        return this.waitForOpen();
-    }
-
     /** Asserts that the websocket is open. */
     private assertSocketIsOpen(): void {
         if (!this.socket) {

```


## /src/api/resources/empathicVoice/resources/chat/client/index.ts
```typescript
/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
export { ChatSocket } from "./Socket.js";
export { ChatClient as Chat } from "./Client.js";

```


## /src/api/resources/empathicVoice/resources/chat/client/index.ts.diff
```diff
diff --git a/src/api/resources/empathicVoice/resources/chat/client/index.ts b/src/api/resources/empathicVoice/resources/chat/client/index.ts
index ff59f82..cb0ff5c 100644
--- a/src/api/resources/empathicVoice/resources/chat/client/index.ts
+++ b/src/api/resources/empathicVoice/resources/chat/client/index.ts
@@ -1,3 +1 @@
-/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
-export { ChatSocket } from "./Socket.js";
-export { ChatClient as Chat } from "./Client.js";
+export {};

```


## /src/api/resources/empathicVoice/resources/chat/index.ts
```typescript
export * from "./types/index.js";
export * from "./client/index.js";
/**
 * @deprecated Use `Hume.empathicVoice.SubscribeEvent` instead.
 * This type alias will be removed in a future version.
 */
export type { SubscribeEvent } from "./types/SubscribeEvent.js";

```


## /src/api/resources/empathicVoice/resources/chat/index.ts.diff
```diff
diff --git a/src/api/resources/empathicVoice/resources/chat/index.ts b/src/api/resources/empathicVoice/resources/chat/index.ts
index a2f33dc..d9adb1a 100644
--- a/src/api/resources/empathicVoice/resources/chat/index.ts
+++ b/src/api/resources/empathicVoice/resources/chat/index.ts
@@ -1,7 +1,2 @@
-export * from "./types/index.js";
 export * from "./client/index.js";
-/**
- * @deprecated Use `Hume.empathicVoice.SubscribeEvent` instead.
- * This type alias will be removed in a future version.
- */
-export type { SubscribeEvent } from "./types/SubscribeEvent.js";
+export * from "./types/index.js";

```


## /src/api/resources/empathicVoice/resources/chat/types/PublishEvent.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type PublishEvent =
    | Hume.empathicVoice.AudioInput
    | Hume.empathicVoice.SessionSettings
    | Hume.empathicVoice.UserInput
    | Hume.empathicVoice.AssistantInput
    | Hume.empathicVoice.ToolResponseMessage
    | Hume.empathicVoice.ToolErrorMessage
    | Hume.empathicVoice.PauseAssistantMessage
    | Hume.empathicVoice.ResumeAssistantMessage;

```


## /src/api/resources/empathicVoice/resources/chat/types/SubscribeEvent.ts
```typescript
/**
 * This file was manually added to provide backward compatibility.
 *
 * @deprecated Use `Hume.empathicVoice.SubscribeEvent` instead.
 * This type alias will be removed in a future version.
 */

import type { SubscribeEvent as NewSubscribeEvent } from "../../../types/SubscribeEvent.js";

/**
 * @deprecated Use `Hume.empathicVoice.SubscribeEvent` instead.
 * This type alias will be removed in a future version.
 */
export type SubscribeEvent = NewSubscribeEvent;

```


## /src/api/resources/empathicVoice/resources/chat/types/index.ts
```typescript
export * from "./PublishEvent.js";

```


## /src/api/resources/empathicVoice/resources/chatGroups/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace ChatGroupsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class ChatGroupsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ChatGroupsClient.Options>;

    constructor(options: ChatGroupsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * @param {Hume.empathicVoice.ChatGroupsListChatGroupsRequest} request
     * @param {ChatGroupsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chatGroups.listChatGroups({
     *         pageNumber: 0,
     *         pageSize: 1,
     *         ascendingOrder: true,
     *         configId: "1b60e1a0-cc59-424a-8d2c-189d354db3f3"
     *     })
     */
    public async listChatGroups(
        request: Hume.empathicVoice.ChatGroupsListChatGroupsRequest = {},
        requestOptions?: ChatGroupsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnChatGroup, Hume.empathicVoice.ReturnPagedChatGroups>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ChatGroupsListChatGroupsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedChatGroups>> => {
                const { pageNumber, pageSize, ascendingOrder, configId } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    ascending_order: ascendingOrder,
                    config_id: configId,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/evi/chat_groups",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedChatGroups.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chat_groups");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnChatGroup, Hume.empathicVoice.ReturnPagedChatGroups>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.chatGroupsPage ?? []).length > 0,
            getItems: (response) => response?.chatGroupsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {string} id - Identifier for a chat. Formatted as a UUID.
     * @param {Hume.empathicVoice.ChatGroupsGetChatGroupRequest} request
     * @param {ChatGroupsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chatGroups.getChatGroup("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
     *         pageNumber: 0,
     *         pageSize: 1,
     *         ascendingOrder: true
     *     })
     */
    public getChatGroup(
        id: string,
        request: Hume.empathicVoice.ChatGroupsGetChatGroupRequest = {},
        requestOptions?: ChatGroupsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnChatGroupPagedChats> {
        return core.HttpResponsePromise.fromPromise(this.__getChatGroup(id, request, requestOptions));
    }

    private async __getChatGroup(
        id: string,
        request: Hume.empathicVoice.ChatGroupsGetChatGroupRequest = {},
        requestOptions?: ChatGroupsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatGroupPagedChats>> {
        const { status, pageSize, pageNumber, ascendingOrder } = request;
        const _queryParams: Record<string, unknown> = {
            status,
            page_size: pageSize,
            page_number: pageNumber,
            ascending_order: ascendingOrder,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/chat_groups/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnChatGroupPagedChats.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chat_groups/{id}");
    }

    /**
     * @param {string} id - Identifier for a chat. Formatted as a UUID.
     * @param {Hume.empathicVoice.ChatGroupsGetAudioRequest} request
     * @param {ChatGroupsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chatGroups.getAudio("369846cf-6ad5-404d-905e-a8acb5cdfc78", {
     *         pageNumber: 0,
     *         pageSize: 10,
     *         ascendingOrder: true
     *     })
     */
    public getAudio(
        id: string,
        request: Hume.empathicVoice.ChatGroupsGetAudioRequest = {},
        requestOptions?: ChatGroupsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructions> {
        return core.HttpResponsePromise.fromPromise(this.__getAudio(id, request, requestOptions));
    }

    private async __getAudio(
        id: string,
        request: Hume.empathicVoice.ChatGroupsGetAudioRequest = {},
        requestOptions?: ChatGroupsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructions>> {
        const { pageNumber, pageSize, ascendingOrder } = request;
        const _queryParams: Record<string, unknown> = {
            page_number: pageNumber,
            page_size: pageSize,
            ascending_order: ascendingOrder,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/chat_groups/${core.url.encodePathParam(id)}/audio`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnChatGroupPagedAudioReconstructions.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v0/evi/chat_groups/{id}/audio",
        );
    }

    /**
     * @param {string} id - Identifier for a chat. Formatted as a UUID.
     * @param {Hume.empathicVoice.ChatGroupsListChatGroupEventsRequest} request
     * @param {ChatGroupsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chatGroups.listChatGroupEvents("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
     *         pageNumber: 0,
     *         pageSize: 3,
     *         ascendingOrder: true
     *     })
     */
    public async listChatGroupEvents(
        id: string,
        request: Hume.empathicVoice.ChatGroupsListChatGroupEventsRequest = {},
        requestOptions?: ChatGroupsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnChatEvent, Hume.empathicVoice.ReturnChatGroupPagedEvents>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ChatGroupsListChatGroupEventsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatGroupPagedEvents>> => {
                const { pageSize, pageNumber, ascendingOrder } = request;
                const _queryParams: Record<string, unknown> = {
                    page_size: pageSize,
                    page_number: pageNumber,
                    ascending_order: ascendingOrder,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        `v0/evi/chat_groups/${core.url.encodePathParam(id)}/events`,
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnChatGroupPagedEvents.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(
                    _response.error,
                    _response.rawResponse,
                    "GET",
                    "/v0/evi/chat_groups/{id}/events",
                );
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnChatEvent, Hume.empathicVoice.ReturnChatGroupPagedEvents>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.eventsPage ?? []).length > 0,
            getItems: (response) => response?.eventsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }
}

```


## /src/api/resources/empathicVoice/resources/chatGroups/client/index.ts
```typescript
export * from "./requests/index.js";

```


## /src/api/resources/empathicVoice/resources/chatGroups/client/requests/ChatGroupsGetAudioRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 10,
 *         ascendingOrder: true
 *     }
 */
export interface ChatGroupsGetAudioRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
    ascendingOrder?: boolean;
}

```


## /src/api/resources/empathicVoice/resources/chatGroups/client/requests/ChatGroupsGetChatGroupRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 1,
 *         ascendingOrder: true
 *     }
 */
export interface ChatGroupsGetChatGroupRequest {
    /** Chat status to apply to the chat. String from the ChatStatus enum. */
    status?: string;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
    ascendingOrder?: boolean;
}

```


## /src/api/resources/empathicVoice/resources/chatGroups/client/requests/ChatGroupsListChatGroupEventsRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 3,
 *         ascendingOrder: true
 *     }
 */
export interface ChatGroupsListChatGroupEventsRequest {
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
    ascendingOrder?: boolean;
}

```


## /src/api/resources/empathicVoice/resources/chatGroups/client/requests/ChatGroupsListChatGroupsRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 1,
 *         ascendingOrder: true,
 *         configId: "1b60e1a0-cc59-424a-8d2c-189d354db3f3"
 *     }
 */
export interface ChatGroupsListChatGroupsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
    ascendingOrder?: boolean;
    /** Filter chatgroups to only include chats that used this config in their most recent chat. */
    configId?: string;
}

```


## /src/api/resources/empathicVoice/resources/chatGroups/client/requests/index.ts
```typescript
export type { ChatGroupsGetAudioRequest } from "./ChatGroupsGetAudioRequest.js";
export type { ChatGroupsGetChatGroupRequest } from "./ChatGroupsGetChatGroupRequest.js";
export type { ChatGroupsListChatGroupEventsRequest } from "./ChatGroupsListChatGroupEventsRequest.js";
export type { ChatGroupsListChatGroupsRequest } from "./ChatGroupsListChatGroupsRequest.js";

```


## /src/api/resources/empathicVoice/resources/chatGroups/index.ts
```typescript
export * from "./client/index.js";

```


## /src/api/resources/empathicVoice/resources/chats/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace ChatsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class ChatsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ChatsClient.Options>;

    constructor(options: ChatsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * @param {Hume.empathicVoice.ChatsListChatsRequest} request
     * @param {ChatsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chats.listChats({
     *         pageNumber: 0,
     *         pageSize: 1,
     *         ascendingOrder: true
     *     })
     */
    public async listChats(
        request: Hume.empathicVoice.ChatsListChatsRequest = {},
        requestOptions?: ChatsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnChat, Hume.empathicVoice.ReturnPagedChats>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ChatsListChatsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedChats>> => {
                const { pageNumber, pageSize, ascendingOrder, configId, status } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    ascending_order: ascendingOrder,
                    config_id: configId,
                    status,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/evi/chats",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedChats.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chats");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnChat, Hume.empathicVoice.ReturnPagedChats>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.chatsPage ?? []).length > 0,
            getItems: (response) => response?.chatsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {string} id - Identifier for a chat. Formatted as a UUID.
     * @param {Hume.empathicVoice.ChatsListChatEventsRequest} request
     * @param {ChatsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chats.listChatEvents("470a49f6-1dec-4afe-8b61-035d3b2d63b0", {
     *         pageNumber: 0,
     *         pageSize: 3,
     *         ascendingOrder: true
     *     })
     */
    public async listChatEvents(
        id: string,
        request: Hume.empathicVoice.ChatsListChatEventsRequest = {},
        requestOptions?: ChatsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnChatEvent, Hume.empathicVoice.ReturnChatPagedEvents>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ChatsListChatEventsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatPagedEvents>> => {
                const { pageSize, pageNumber, ascendingOrder } = request;
                const _queryParams: Record<string, unknown> = {
                    page_size: pageSize,
                    page_number: pageNumber,
                    ascending_order: ascendingOrder,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        `v0/evi/chats/${core.url.encodePathParam(id)}`,
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnChatPagedEvents.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chats/{id}");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnChatEvent, Hume.empathicVoice.ReturnChatPagedEvents>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.eventsPage ?? []).length > 0,
            getItems: (response) => response?.eventsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {string} id - Identifier for a chat. Formatted as a UUID.
     * @param {ChatsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chats.getAudio("470a49f6-1dec-4afe-8b61-035d3b2d63b0")
     */
    public getAudio(
        id: string,
        requestOptions?: ChatsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnChatAudioReconstruction> {
        return core.HttpResponsePromise.fromPromise(this.__getAudio(id, requestOptions));
    }

    private async __getAudio(
        id: string,
        requestOptions?: ChatsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatAudioReconstruction>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/chats/${core.url.encodePathParam(id)}/audio`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnChatAudioReconstruction.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chats/{id}/audio");
    }
}

```


## /src/api/resources/empathicVoice/resources/chats/client/index.ts
```typescript
export * from "./requests/index.js";

```


## /src/api/resources/empathicVoice/resources/chats/client/requests/ChatsListChatEventsRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 3,
 *         ascendingOrder: true
 *     }
 */
export interface ChatsListChatEventsRequest {
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
    ascendingOrder?: boolean;
}

```


## /src/api/resources/empathicVoice/resources/chats/client/requests/ChatsListChatsRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 1,
 *         ascendingOrder: true
 *     }
 */
export interface ChatsListChatsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
    ascendingOrder?: boolean;
    /** Filter to only include chats that used this config. */
    configId?: string;
    /** Chat status to apply to the chat. String from the ChatStatus enum. */
    status?: string;
}

```


## /src/api/resources/empathicVoice/resources/chats/client/requests/index.ts
```typescript
export type { ChatsListChatEventsRequest } from "./ChatsListChatEventsRequest.js";
export type { ChatsListChatsRequest } from "./ChatsListChatsRequest.js";

```


## /src/api/resources/empathicVoice/resources/chats/index.ts
```typescript
export * from "./client/index.js";

```


## /src/api/resources/empathicVoice/resources/configs/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace ConfigsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class ConfigsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ConfigsClient.Options>;

    constructor(options: ConfigsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * @param {Hume.empathicVoice.ConfigsListConfigsRequest} request
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.listConfigs({
     *         pageNumber: 0,
     *         pageSize: 1
     *     })
     */
    public async listConfigs(
        request: Hume.empathicVoice.ConfigsListConfigsRequest = {},
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnConfig, Hume.empathicVoice.ReturnPagedConfigs>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ConfigsListConfigsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedConfigs>> => {
                const { pageNumber, pageSize, restrictToMostRecent, name } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    restrict_to_most_recent: restrictToMostRecent,
                    name,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/evi/configs",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedConfigs.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/configs");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnConfig, Hume.empathicVoice.ReturnPagedConfigs>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.configsPage ?? []).length > 0,
            getItems: (response) => response?.configsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {Hume.empathicVoice.PostedConfig} request
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.createConfig({
     *         name: "Weather Assistant Config",
     *         prompt: {
     *             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
     *             version: 0
     *         },
     *         eviVersion: "3",
     *         voice: {
     *             provider: "HUME_AI",
     *             name: "Ava Song"
     *         },
     *         languageModel: {
     *             modelProvider: "ANTHROPIC",
     *             modelResource: "claude-3-7-sonnet-latest",
     *             temperature: 1
     *         },
     *         eventMessages: {
     *             onNewChat: {
     *                 enabled: false,
     *                 text: ""
     *             },
     *             onInactivityTimeout: {
     *                 enabled: false,
     *                 text: ""
     *             },
     *             onMaxDurationTimeout: {
     *                 enabled: false,
     *                 text: ""
     *             }
     *         }
     *     })
     */
    public createConfig(
        request: Hume.empathicVoice.PostedConfig,
        requestOptions?: ConfigsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnConfig> {
        return core.HttpResponsePromise.fromPromise(this.__createConfig(request, requestOptions));
    }

    private async __createConfig(
        request: Hume.empathicVoice.PostedConfig,
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnConfig>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/evi/configs",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedConfig.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnConfig.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/configs");
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {Hume.empathicVoice.ConfigsListConfigVersionsRequest} request
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.listConfigVersions("1b60e1a0-cc59-424a-8d2c-189d354db3f3")
     */
    public async listConfigVersions(
        id: string,
        request: Hume.empathicVoice.ConfigsListConfigVersionsRequest = {},
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnConfig, Hume.empathicVoice.ReturnPagedConfigs>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ConfigsListConfigVersionsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedConfigs>> => {
                const { pageNumber, pageSize, restrictToMostRecent } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    restrict_to_most_recent: restrictToMostRecent,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        `v0/evi/configs/${core.url.encodePathParam(id)}`,
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedConfigs.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/configs/{id}");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnConfig, Hume.empathicVoice.ReturnPagedConfigs>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.configsPage ?? []).length > 0,
            getItems: (response) => response?.configsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {Hume.empathicVoice.PostedConfigVersion} request
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.createConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", {
     *         versionDescription: "This is an updated version of the Weather Assistant Config.",
     *         eviVersion: "3",
     *         prompt: {
     *             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
     *             version: 0
     *         },
     *         voice: {
     *             provider: "HUME_AI",
     *             name: "Ava Song"
     *         },
     *         languageModel: {
     *             modelProvider: "ANTHROPIC",
     *             modelResource: "claude-3-7-sonnet-latest",
     *             temperature: 1
     *         },
     *         ellmModel: {
     *             allowShortResponses: true
     *         },
     *         eventMessages: {
     *             onNewChat: {
     *                 enabled: false,
     *                 text: ""
     *             },
     *             onInactivityTimeout: {
     *                 enabled: false,
     *                 text: ""
     *             },
     *             onMaxDurationTimeout: {
     *                 enabled: false,
     *                 text: ""
     *             }
     *         }
     *     })
     */
    public createConfigVersion(
        id: string,
        request: Hume.empathicVoice.PostedConfigVersion,
        requestOptions?: ConfigsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnConfig> {
        return core.HttpResponsePromise.fromPromise(this.__createConfigVersion(id, request, requestOptions));
    }

    private async __createConfigVersion(
        id: string,
        request: Hume.empathicVoice.PostedConfigVersion,
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnConfig>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/configs/${core.url.encodePathParam(id)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedConfigVersion.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnConfig.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/configs/{id}");
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.deleteConfig("1b60e1a0-cc59-424a-8d2c-189d354db3f3")
     */
    public deleteConfig(id: string, requestOptions?: ConfigsClient.RequestOptions): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteConfig(id, requestOptions));
    }

    private async __deleteConfig(
        id: string,
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/configs/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v0/evi/configs/{id}");
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {Hume.empathicVoice.PostedConfigName} request
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.updateConfigName("1b60e1a0-cc59-424a-8d2c-189d354db3f3", {
     *         name: "Updated Weather Assistant Config Name"
     *     })
     */
    public updateConfigName(
        id: string,
        request: Hume.empathicVoice.PostedConfigName,
        requestOptions?: ConfigsClient.RequestOptions,
    ): core.HttpResponsePromise<string> {
        return core.HttpResponsePromise.fromPromise(this.__updateConfigName(id, request, requestOptions));
    }

    private async __updateConfigName(
        id: string,
        request: Hume.empathicVoice.PostedConfigName,
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<string>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/configs/${core.url.encodePathParam(id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedConfigName.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "text",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as string, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/v0/evi/configs/{id}");
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {number} version - Version number for a config. Version numbers should be integers.
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.getConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1)
     */
    public getConfigVersion(
        id: string,
        version: number,
        requestOptions?: ConfigsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnConfig> {
        return core.HttpResponsePromise.fromPromise(this.__getConfigVersion(id, version, requestOptions));
    }

    private async __getConfigVersion(
        id: string,
        version: number,
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnConfig>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/configs/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnConfig.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v0/evi/configs/{id}/version/{version}",
        );
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {number} version - Version number for a config. Version numbers should be integers.
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.deleteConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1)
     */
    public deleteConfigVersion(
        id: string,
        version: number,
        requestOptions?: ConfigsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteConfigVersion(id, version, requestOptions));
    }

    private async __deleteConfigVersion(
        id: string,
        version: number,
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/configs/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/v0/evi/configs/{id}/version/{version}",
        );
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {number} version - Version number for a config. Version numbers should be integers.
     * @param {Hume.empathicVoice.PostedConfigVersionDescription} request
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.updateConfigDescription("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1, {
     *         versionDescription: "This is an updated version_description."
     *     })
     */
    public updateConfigDescription(
        id: string,
        version: number,
        request: Hume.empathicVoice.PostedConfigVersionDescription = {},
        requestOptions?: ConfigsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnConfig> {
        return core.HttpResponsePromise.fromPromise(
            this.__updateConfigDescription(id, version, request, requestOptions),
        );
    }

    private async __updateConfigDescription(
        id: string,
        version: number,
        request: Hume.empathicVoice.PostedConfigVersionDescription = {},
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnConfig>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/configs/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedConfigVersionDescription.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnConfig.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v0/evi/configs/{id}/version/{version}",
        );
    }
}

```


## /src/api/resources/empathicVoice/resources/configs/client/index.ts
```typescript
export * from "./requests/index.js";

```


## /src/api/resources/empathicVoice/resources/configs/client/requests/ConfigsListConfigVersionsRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {}
 */
export interface ConfigsListConfigVersionsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** By default, `restrict_to_most_recent` is set to true, returning only the latest version of each tool. To include all versions of each tool in the list, set `restrict_to_most_recent` to false. */
    restrictToMostRecent?: boolean;
}

```


## /src/api/resources/empathicVoice/resources/configs/client/requests/ConfigsListConfigsRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 1
 *     }
 */
export interface ConfigsListConfigsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** By default, `restrict_to_most_recent` is set to true, returning only the latest version of each tool. To include all versions of each tool in the list, set `restrict_to_most_recent` to false. */
    restrictToMostRecent?: boolean;
    /** Filter to only include configs with this name. */
    name?: string;
}

```


## /src/api/resources/empathicVoice/resources/configs/client/requests/PostedConfig.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../index.js";

/**
 * @example
 *     {
 *         name: "Weather Assistant Config",
 *         prompt: {
 *             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 *             version: 0
 *         },
 *         eviVersion: "3",
 *         voice: {
 *             provider: "HUME_AI",
 *             name: "Ava Song"
 *         },
 *         languageModel: {
 *             modelProvider: "ANTHROPIC",
 *             modelResource: "claude-3-7-sonnet-latest",
 *             temperature: 1
 *         },
 *         eventMessages: {
 *             onNewChat: {
 *                 enabled: false,
 *                 text: ""
 *             },
 *             onInactivityTimeout: {
 *                 enabled: false,
 *                 text: ""
 *             },
 *             onMaxDurationTimeout: {
 *                 enabled: false,
 *                 text: ""
 *             }
 *         }
 *     }
 */
export interface PostedConfig {
    /** Built-in tool specification for a Config. */
    builtinTools?: (Hume.empathicVoice.PostedBuiltinTool | undefined)[];
    ellmModel?: Hume.empathicVoice.PostedEllmModel;
    eventMessages?: Hume.empathicVoice.PostedEventMessageSpecs;
    /** The version of the EVI used with this config. */
    eviVersion: string;
    languageModel?: Hume.empathicVoice.PostedLanguageModel;
    /** Name applied to all versions of a particular Config. */
    name: string;
    nudges?: Hume.empathicVoice.PostedNudgeSpec;
    prompt?: Hume.empathicVoice.PostedConfigPromptSpec;
    timeouts?: Hume.empathicVoice.PostedTimeoutSpecs;
    /** Tool specification for a Config. */
    tools?: (Hume.empathicVoice.PostedUserDefinedToolSpec | undefined)[];
    /** Description that is appended to a specific version of a Config. */
    versionDescription?: string;
    voice?: Hume.empathicVoice.VoiceRef;
    /** Webhook config specifications for each subscriber. */
    webhooks?: (Hume.empathicVoice.PostedWebhookSpec | undefined)[];
}

```


## /src/api/resources/empathicVoice/resources/configs/client/requests/PostedConfigName.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         name: "Updated Weather Assistant Config Name"
 *     }
 */
export interface PostedConfigName {
    /** Name applied to all versions of a particular Config. */
    name: string;
}

```


## /src/api/resources/empathicVoice/resources/configs/client/requests/PostedConfigVersion.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../index.js";

/**
 * @example
 *     {
 *         versionDescription: "This is an updated version of the Weather Assistant Config.",
 *         eviVersion: "3",
 *         prompt: {
 *             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 *             version: 0
 *         },
 *         voice: {
 *             provider: "HUME_AI",
 *             name: "Ava Song"
 *         },
 *         languageModel: {
 *             modelProvider: "ANTHROPIC",
 *             modelResource: "claude-3-7-sonnet-latest",
 *             temperature: 1
 *         },
 *         ellmModel: {
 *             allowShortResponses: true
 *         },
 *         eventMessages: {
 *             onNewChat: {
 *                 enabled: false,
 *                 text: ""
 *             },
 *             onInactivityTimeout: {
 *                 enabled: false,
 *                 text: ""
 *             },
 *             onMaxDurationTimeout: {
 *                 enabled: false,
 *                 text: ""
 *             }
 *         }
 *     }
 */
export interface PostedConfigVersion {
    /** Built-in tool specification for a Config. */
    builtinTools?: (Hume.empathicVoice.PostedBuiltinTool | undefined)[];
    ellmModel?: Hume.empathicVoice.PostedEllmModel;
    eventMessages?: Hume.empathicVoice.PostedEventMessageSpecs;
    /** The version of the EVI used with this config. */
    eviVersion: string;
    languageModel?: Hume.empathicVoice.PostedLanguageModel;
    nudges?: Hume.empathicVoice.PostedNudgeSpec;
    prompt?: Hume.empathicVoice.PostedConfigPromptSpec;
    timeouts?: Hume.empathicVoice.PostedTimeoutSpecs;
    /** Tool specification for a Config. */
    tools?: (Hume.empathicVoice.PostedUserDefinedToolSpec | undefined)[];
    /** Description that is appended to a specific version of a Config. */
    versionDescription?: string;
    voice?: Hume.empathicVoice.VoiceRef;
    /** Webhook config specifications for each subscriber. */
    webhooks?: (Hume.empathicVoice.PostedWebhookSpec | undefined)[];
}

```


## /src/api/resources/empathicVoice/resources/configs/client/requests/PostedConfigVersionDescription.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         versionDescription: "This is an updated version_description."
 *     }
 */
export interface PostedConfigVersionDescription {
    /** Description that is appended to a specific version of a Config. */
    versionDescription?: string;
}

```


## /src/api/resources/empathicVoice/resources/configs/client/requests/index.ts
```typescript
export type { ConfigsListConfigsRequest } from "./ConfigsListConfigsRequest.js";
export type { ConfigsListConfigVersionsRequest } from "./ConfigsListConfigVersionsRequest.js";
export type { PostedConfig } from "./PostedConfig.js";
export type { PostedConfigName } from "./PostedConfigName.js";
export type { PostedConfigVersion } from "./PostedConfigVersion.js";
export type { PostedConfigVersionDescription } from "./PostedConfigVersionDescription.js";

```


## /src/api/resources/empathicVoice/resources/configs/index.ts
```typescript
export * from "./client/index.js";

```


## /src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";
import { ControlPlaneSocket } from "./Socket.js";

export declare namespace ControlPlaneClient {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}

    export interface ConnectArgs {
        chat_id: string;
        accessToken?: string | undefined;
        /** Arbitrary headers to send with the websocket connect request. */
        headers?: Record<string, string>;
        /** Enable debug mode on the websocket. Defaults to false. */
        debug?: boolean;
        /** Number of reconnect attempts. Defaults to 30. */
        reconnectAttempts?: number;
    }
}

export class ControlPlaneClient {
    protected readonly _options: ControlPlaneClient.Options;

    constructor(_options: ControlPlaneClient.Options = {}) {
        this._options = _options;
    }

    /**
     * Send a message to a specific chat.
     *
     * @param {string} chatId
     * @param {Hume.empathicVoice.ControlPlanePublishEvent} request
     * @param {ControlPlaneClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.UnprocessableEntityError}
     *
     * @example
     *     await client.empathicVoice.controlPlane.send("chat_id", {
     *         type: "session_settings"
     *     })
     */
    public send(
        chatId: string,
        request: Hume.empathicVoice.ControlPlanePublishEvent,
        requestOptions?: ControlPlaneClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__send(chatId, request, requestOptions));
    }

    private async __send(
        chatId: string,
        request: Hume.empathicVoice.ControlPlanePublishEvent,
        requestOptions?: ControlPlaneClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/chat/${core.url.encodePathParam(chatId)}/send`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.ControlPlanePublishEvent.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.empathicVoice.UnprocessableEntityError(
                        serializers.empathicVoice.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/chat/{chat_id}/send");
    }

    public async connect(args: ControlPlaneClient.ConnectArgs): Promise<ControlPlaneSocket> {
        const { chat_id, accessToken, headers, debug, reconnectAttempts } = args;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (accessToken != null) {
            _queryParams.access_token = accessToken;
        }

        const _headers: Record<string, unknown> = mergeHeaders(
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            headers,
        );
        const socket = new core.ReconnectingWebSocket({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).evi,
                `/chat/${core.url.encodePathParam(chat_id)}/connect`,
            ),
            protocols: [],
            queryParameters: _queryParams,
            headers: _headers,
            options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
        });
        return new ControlPlaneSocket({ socket });
    }
    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
        const apiKeyValue = core.Supplier.get(this._options.apiKey);
        // This `authHeaderValue` is manually added as if you don't provide it it will
        // be omitted from the headers which means it won't reach the logic in ws.ts that
        // extracts values from the headers and adds them to query parameters.
        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
    }
}

```


## /src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts.diff
```diff
diff --git a/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts b/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
index 0eec869..b5d6ea0 100644
--- a/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
+++ b/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
@@ -1,7 +1,8 @@
 // This file was auto-generated by Fern from our API Definition.
 
 import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
-import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
+import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
+import { mergeHeaders } from "../../../../../../core/headers.js";
 import * as core from "../../../../../../core/index.js";
 import * as environments from "../../../../../../environments.js";
 import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
@@ -11,13 +12,13 @@ import * as Hume from "../../../../../index.js";
 import { ControlPlaneSocket } from "./Socket.js";
 
 export declare namespace ControlPlaneClient {
-    export interface Options extends BaseClientOptions {}
+    export type Options = BaseClientOptions;
 
     export interface RequestOptions extends BaseRequestOptions {}
 
     export interface ConnectArgs {
-        chat_id: string;
-        accessToken?: string | undefined;
+        chatId: string;
+        accessToken?: string;
         /** Arbitrary headers to send with the websocket connect request. */
         headers?: Record<string, string>;
         /** Enable debug mode on the websocket. Defaults to false. */
@@ -28,16 +29,16 @@ export declare namespace ControlPlaneClient {
 }
 
 export class ControlPlaneClient {
-    protected readonly _options: ControlPlaneClient.Options;
+    protected readonly _options: NormalizedClientOptionsWithAuth<ControlPlaneClient.Options>;
 
-    constructor(_options: ControlPlaneClient.Options = {}) {
-        this._options = _options;
+    constructor(options: ControlPlaneClient.Options = {}) {
+        this._options = normalizeClientOptionsWithAuth(options);
     }
 
     /**
      * Send a message to a specific chat.
      *
-     * @param {string} chatId
+     * @param {string} chat_id
      * @param {Hume.empathicVoice.ControlPlanePublishEvent} request
      * @param {ControlPlaneClient.RequestOptions} requestOptions - Request-specific configuration.
      *
@@ -49,28 +50,29 @@ export class ControlPlaneClient {
      *     })
      */
     public send(
-        chatId: string,
+        chat_id: string,
         request: Hume.empathicVoice.ControlPlanePublishEvent,
         requestOptions?: ControlPlaneClient.RequestOptions,
     ): core.HttpResponsePromise<void> {
-        return core.HttpResponsePromise.fromPromise(this.__send(chatId, request, requestOptions));
+        return core.HttpResponsePromise.fromPromise(this.__send(chat_id, request, requestOptions));
     }
 
     private async __send(
-        chatId: string,
+        chat_id: string,
         request: Hume.empathicVoice.ControlPlanePublishEvent,
         requestOptions?: ControlPlaneClient.RequestOptions,
     ): Promise<core.WithRawResponse<void>> {
+        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
+            _authRequest.headers,
             this._options?.headers,
-            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
             requestOptions?.headers,
         );
         const _response = await (this._options.fetcher ?? core.fetcher)({
             url: core.url.join(
                 (await core.Supplier.get(this._options.baseUrl)) ??
                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
-                `v0/evi/chat/${core.url.encodePathParam(chatId)}/send`,
+                `v0/evi/chat/${core.url.encodePathParam(chat_id)}/send`,
             ),
             method: "POST",
             headers: _headers,
@@ -117,21 +119,16 @@ export class ControlPlaneClient {
     }
 
     public async connect(args: ControlPlaneClient.ConnectArgs): Promise<ControlPlaneSocket> {
-        const { chat_id, accessToken, headers, debug, reconnectAttempts } = args;
-        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
-        if (accessToken != null) {
-            _queryParams.access_token = accessToken;
-        }
-
-        const _headers: Record<string, unknown> = mergeHeaders(
-            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
-            headers,
-        );
+        const { chatId, accessToken, headers, debug, reconnectAttempts } = args;
+        const _queryParams: Record<string, unknown> = {
+            access_token: accessToken,
+        };
+        const _headers: Record<string, unknown> = { ...headers };
         const socket = new core.ReconnectingWebSocket({
             url: core.url.join(
                 (await core.Supplier.get(this._options.baseUrl)) ??
                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).evi,
-                `/chat/${core.url.encodePathParam(chat_id)}/connect`,
+                `/chat/${core.url.encodePathParam(chatId)}/connect`,
             ),
             protocols: [],
             queryParameters: _queryParams,
@@ -140,12 +137,4 @@ export class ControlPlaneClient {
         });
         return new ControlPlaneSocket({ socket });
     }
-    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
-        const apiKeyValue = core.Supplier.get(this._options.apiKey);
-        // This `authHeaderValue` is manually added as if you don't provide it it will
-        // be omitted from the headers which means it won't reach the logic in ws.ts that
-        // extracts values from the headers and adds them to query parameters.
-        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
-        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
-    }
 }

```


## /src/api/resources/empathicVoice/resources/controlPlane/client/Socket.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import * as core from "../../../../../../core/index.js";
import { fromJson } from "../../../../../../core/json.js";
import * as serializers from "../../../../../../serialization/index.js";
import { ControlPlanePublishEvent } from "../../../../../../serialization/resources/empathicVoice/types/ControlPlanePublishEvent.js";
import type * as Hume from "../../../../../index.js";

export declare namespace ControlPlaneSocket {
    export interface Args {
        socket: core.ReconnectingWebSocket;
    }

    export type Response = Hume.empathicVoice.SubscribeEvent;
    type EventHandlers = {
        open?: () => void;
        message?: (message: Response) => void;
        close?: (event: core.CloseEvent) => void;
        error?: (error: Error) => void;
    };
}

export class ControlPlaneSocket {
    public readonly socket: core.ReconnectingWebSocket;
    protected readonly eventHandlers: ControlPlaneSocket.EventHandlers = {};
    private handleOpen: () => void = () => {
        this.eventHandlers.open?.();
    };
    private handleMessage: (event: { data: string }) => void = (event) => {
        const data = fromJson(event.data);

        const parsedResponse = serializers.empathicVoice.ControlPlaneSocketResponse.parse(data, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        if (parsedResponse.ok) {
            this.eventHandlers.message?.(parsedResponse.value);
        } else {
            this.eventHandlers.error?.(new Error("Received unknown message type"));
        }
    };
    private handleClose: (event: core.CloseEvent) => void = (event) => {
        this.eventHandlers.close?.(event);
    };
    private handleError: (event: core.ErrorEvent) => void = (event) => {
        const message = event.message;
        this.eventHandlers.error?.(new Error(message));
    };

    constructor(args: ControlPlaneSocket.Args) {
        this.socket = args.socket;
        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);
    }

    /** The current state of the connection; this is one of the readyState constants. */
    get readyState(): number {
        return this.socket.readyState;
    }

    /**
     * @param event - The event to attach to.
     * @param callback - The callback to run when the event is triggered.
     * Usage:
     * ```typescript
     * this.on('open', () => {
     *     console.log('The websocket is open');
     * });
     * ```
     */
    public on<T extends keyof ControlPlaneSocket.EventHandlers>(
        event: T,
        callback: ControlPlaneSocket.EventHandlers[T],
    ): void {
        this.eventHandlers[event] = callback;
    }

    public sendPublish(message: Hume.empathicVoice.ControlPlanePublishEvent): void {
        this.assertSocketIsOpen();
        const jsonPayload = ControlPlanePublishEvent.jsonOrThrow(message, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        this.socket.send(JSON.stringify(jsonPayload));
    }

    /** Connect to the websocket and register event handlers. */
    public connect(): ControlPlaneSocket {
        this.socket.reconnect();

        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);

        return this;
    }

    /** Close the websocket and unregister event handlers. */
    public close(): void {
        this.socket.close();

        this.handleClose({ code: 1000 } as CloseEvent);

        this.socket.removeEventListener("open", this.handleOpen);
        this.socket.removeEventListener("message", this.handleMessage);
        this.socket.removeEventListener("close", this.handleClose);
        this.socket.removeEventListener("error", this.handleError);
    }

    /** Returns a promise that resolves when the websocket is open. */
    public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
        if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
            return this.socket;
        }

        return new Promise((resolve, reject) => {
            this.socket.addEventListener("open", () => {
                resolve(this.socket);
            });

            this.socket.addEventListener("error", (event: unknown) => {
                reject(event);
            });
        });
    }

    /** Asserts that the websocket is open. */
    private assertSocketIsOpen(): void {
        if (!this.socket) {
            throw new Error("Socket is not connected.");
        }

        if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
            throw new Error("Socket is not open.");
        }
    }

    /** Send a binary payload to the websocket. */
    protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
        this.socket.send(payload);
    }
}

```


## /src/api/resources/empathicVoice/resources/controlPlane/client/index.ts
```typescript
export {};

```


## /src/api/resources/empathicVoice/resources/controlPlane/index.ts
```typescript
export * from "./client/index.js";

```


## /src/api/resources/empathicVoice/resources/index.ts
```typescript
export * as chat from "./chat/index.js";
export * from "./chat/types/index.js";
export * from "./chatGroups/client/requests/index.js";
export * as chatGroups from "./chatGroups/index.js";
export * from "./chats/client/requests/index.js";
export * as chats from "./chats/index.js";
export * from "./configs/client/requests/index.js";
export * as configs from "./configs/index.js";
export * as controlPlane from "./controlPlane/index.js";
export * from "./prompts/client/requests/index.js";
export * as prompts from "./prompts/index.js";
export * from "./tools/client/requests/index.js";
export * as tools from "./tools/index.js";

```


## /src/api/resources/empathicVoice/resources/prompts/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace PromptsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class PromptsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<PromptsClient.Options>;

    constructor(options: PromptsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * @param {Hume.empathicVoice.PromptsListPromptsRequest} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.listPrompts({
     *         pageNumber: 0,
     *         pageSize: 2
     *     })
     */
    public async listPrompts(
        request: Hume.empathicVoice.PromptsListPromptsRequest = {},
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnPrompt | undefined, Hume.empathicVoice.ReturnPagedPrompts>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.PromptsListPromptsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedPrompts>> => {
                const { pageNumber, pageSize, restrictToMostRecent, name } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    restrict_to_most_recent: restrictToMostRecent,
                    name,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/evi/prompts",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedPrompts.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/prompts");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnPrompt | undefined, Hume.empathicVoice.ReturnPagedPrompts>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.promptsPage ?? []).length > 0,
            getItems: (response) => response?.promptsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {Hume.empathicVoice.PostedPrompt} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.createPrompt({
     *         name: "Weather Assistant Prompt",
     *         text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>"
     *     })
     */
    public createPrompt(
        request: Hume.empathicVoice.PostedPrompt,
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__createPrompt(request, requestOptions));
    }

    private async __createPrompt(
        request: Hume.empathicVoice.PostedPrompt,
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/evi/prompts",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedPrompt.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.prompts.createPrompt.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/prompts");
    }

    /**
     * @param {string} id
     * @param {Hume.empathicVoice.PromptsListPromptVersionsRequest} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.listPromptVersions("af699d45-2985-42cc-91b9-af9e5da3bac5")
     */
    public listPromptVersions(
        id: string,
        request: Hume.empathicVoice.PromptsListPromptVersionsRequest = {},
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPagedPrompts> {
        return core.HttpResponsePromise.fromPromise(this.__listPromptVersions(id, request, requestOptions));
    }

    private async __listPromptVersions(
        id: string,
        request: Hume.empathicVoice.PromptsListPromptVersionsRequest = {},
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedPrompts>> {
        const { pageNumber, pageSize, restrictToMostRecent } = request;
        const _queryParams: Record<string, unknown> = {
            page_number: pageNumber,
            page_size: pageSize,
            restrict_to_most_recent: restrictToMostRecent,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnPagedPrompts.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/prompts/{id}");
    }

    /**
     * @param {string} id - Identifier for a prompt. Formatted as a UUID.
     * @param {Hume.empathicVoice.PostedPromptVersion} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.createPromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", {
     *         text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
     *         versionDescription: "This is an updated version of the Weather Assistant Prompt."
     *     })
     */
    public createPromptVersion(
        id: string,
        request: Hume.empathicVoice.PostedPromptVersion,
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__createPromptVersion(id, request, requestOptions));
    }

    private async __createPromptVersion(
        id: string,
        request: Hume.empathicVoice.PostedPromptVersion,
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedPromptVersion.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.prompts.createPromptVersion.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/prompts/{id}");
    }

    /**
     * @param {string} id - Identifier for a prompt. Formatted as a UUID.
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.deletePrompt("af699d45-2985-42cc-91b9-af9e5da3bac5")
     */
    public deletePrompt(id: string, requestOptions?: PromptsClient.RequestOptions): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deletePrompt(id, requestOptions));
    }

    private async __deletePrompt(
        id: string,
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v0/evi/prompts/{id}");
    }

    /**
     * @param {string} id - Identifier for a prompt. Formatted as a UUID.
     * @param {Hume.empathicVoice.PostedPromptName} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.updatePromptName("af699d45-2985-42cc-91b9-af9e5da3bac5", {
     *         name: "Updated Weather Assistant Prompt Name"
     *     })
     */
    public updatePromptName(
        id: string,
        request: Hume.empathicVoice.PostedPromptName,
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<string> {
        return core.HttpResponsePromise.fromPromise(this.__updatePromptName(id, request, requestOptions));
    }

    private async __updatePromptName(
        id: string,
        request: Hume.empathicVoice.PostedPromptName,
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<string>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedPromptName.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "text",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as string, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/v0/evi/prompts/{id}");
    }

    /**
     * @param {string} id - Identifier for a prompt. Formatted as a UUID.
     * @param {number} version - Version number for a prompt. Version numbers should be integers.
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.getPromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", 0)
     */
    public getPromptVersion(
        id: string,
        version: number,
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__getPromptVersion(id, version, requestOptions));
    }

    private async __getPromptVersion(
        id: string,
        version: number,
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.prompts.getPromptVersion.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v0/evi/prompts/{id}/version/{version}",
        );
    }

    /**
     * @param {string} id - Identifier for a prompt. Formatted as a UUID.
     * @param {number} version - Version number for a prompt. Version numbers should be integers.
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.deletePromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", 1)
     */
    public deletePromptVersion(
        id: string,
        version: number,
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deletePromptVersion(id, version, requestOptions));
    }

    private async __deletePromptVersion(
        id: string,
        version: number,
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/v0/evi/prompts/{id}/version/{version}",
        );
    }

    /**
     * @param {string} id - Identifier for a prompt. Formatted as a UUID.
     * @param {number} version - Version number for a prompt. Version numbers should be integers.
     * @param {Hume.empathicVoice.PostedPromptVersionDescription} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.updatePromptDescription("af699d45-2985-42cc-91b9-af9e5da3bac5", 1, {
     *         versionDescription: "This is an updated version_description."
     *     })
     */
    public updatePromptDescription(
        id: string,
        version: number,
        request: Hume.empathicVoice.PostedPromptVersionDescription = {},
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | undefined> {
        return core.HttpResponsePromise.fromPromise(
            this.__updatePromptDescription(id, version, request, requestOptions),
        );
    }

    private async __updatePromptDescription(
        id: string,
        version: number,
        request: Hume.empathicVoice.PostedPromptVersionDescription = {},
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedPromptVersionDescription.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.prompts.updatePromptDescription.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v0/evi/prompts/{id}/version/{version}",
        );
    }
}

```


## /src/api/resources/empathicVoice/resources/prompts/client/index.ts
```typescript
export * from "./requests/index.js";

```


## /src/api/resources/empathicVoice/resources/prompts/client/requests/PostedPrompt.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         name: "Weather Assistant Prompt",
 *         text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>"
 *     }
 */
export interface PostedPrompt {
    /** Name applied to all versions of a particular Prompt. */
    name: string;
    /** Text used for this version of the Prompt. */
    text: string;
    /** Description that is appended to a specific version of a Prompt. */
    versionDescription?: string;
}

```


## /src/api/resources/empathicVoice/resources/prompts/client/requests/PostedPromptName.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         name: "Updated Weather Assistant Prompt Name"
 *     }
 */
export interface PostedPromptName {
    /** Name applied to all versions of a particular Prompt. */
    name: string;
}

```


## /src/api/resources/empathicVoice/resources/prompts/client/requests/PostedPromptVersion.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 *         versionDescription: "This is an updated version of the Weather Assistant Prompt."
 *     }
 */
export interface PostedPromptVersion {
    /** Text used for this version of the Prompt. */
    text: string;
    /** Description that is appended to a specific version of a Prompt. */
    versionDescription?: string;
}

```


## /src/api/resources/empathicVoice/resources/prompts/client/requests/PostedPromptVersionDescription.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         versionDescription: "This is an updated version_description."
 *     }
 */
export interface PostedPromptVersionDescription {
    /** Description that is appended to a specific version of a Prompt. */
    versionDescription?: string;
}

```


## /src/api/resources/empathicVoice/resources/prompts/client/requests/PromptsListPromptVersionsRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {}
 */
export interface PromptsListPromptVersionsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** Only include the most recent version of each prompt in the list. */
    restrictToMostRecent?: boolean;
}

```


## /src/api/resources/empathicVoice/resources/prompts/client/requests/PromptsListPromptsRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 2
 *     }
 */
export interface PromptsListPromptsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** Only include the most recent version of each prompt in the list. */
    restrictToMostRecent?: boolean;
    /** Filter to only include prompts with name. */
    name?: string;
}

```


## /src/api/resources/empathicVoice/resources/prompts/client/requests/index.ts
```typescript
export type { PostedPrompt } from "./PostedPrompt.js";
export type { PostedPromptName } from "./PostedPromptName.js";
export type { PostedPromptVersion } from "./PostedPromptVersion.js";
export type { PostedPromptVersionDescription } from "./PostedPromptVersionDescription.js";
export type { PromptsListPromptsRequest } from "./PromptsListPromptsRequest.js";
export type { PromptsListPromptVersionsRequest } from "./PromptsListPromptVersionsRequest.js";

```


## /src/api/resources/empathicVoice/resources/prompts/index.ts
```typescript
export * from "./client/index.js";

```


## /src/api/resources/empathicVoice/resources/tools/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace ToolsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class ToolsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ToolsClient.Options>;

    constructor(options: ToolsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * @param {Hume.empathicVoice.ToolsListToolsRequest} request
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.listTools({
     *         pageNumber: 0,
     *         pageSize: 2
     *     })
     */
    public async listTools(
        request: Hume.empathicVoice.ToolsListToolsRequest = {},
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<
        core.Page<Hume.empathicVoice.ReturnUserDefinedTool | undefined, Hume.empathicVoice.ReturnPagedUserDefinedTools>
    > {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ToolsListToolsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedUserDefinedTools>> => {
                const { pageNumber, pageSize, restrictToMostRecent, name } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    restrict_to_most_recent: restrictToMostRecent,
                    name,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/evi/tools",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedUserDefinedTools.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/tools");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<
            Hume.empathicVoice.ReturnUserDefinedTool | undefined,
            Hume.empathicVoice.ReturnPagedUserDefinedTools
        >({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.toolsPage ?? []).length > 0,
            getItems: (response) => response?.toolsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {Hume.empathicVoice.PostedUserDefinedTool} request
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.createTool({
     *         name: "get_current_weather",
     *         parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
     *         versionDescription: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
     *         description: "This tool is for getting the current weather.",
     *         fallbackContent: "Unable to fetch current weather."
     *     })
     */
    public createTool(
        request: Hume.empathicVoice.PostedUserDefinedTool,
        requestOptions?: ToolsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnUserDefinedTool | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__createTool(request, requestOptions));
    }

    private async __createTool(
        request: Hume.empathicVoice.PostedUserDefinedTool,
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnUserDefinedTool | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/evi/tools",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedUserDefinedTool.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.tools.createTool.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/tools");
    }

    /**
     * @param {string} id
     * @param {Hume.empathicVoice.ToolsListToolVersionsRequest} request
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.listToolVersions("00183a3f-79ba-413d-9f3b-609864268bea")
     */
    public async listToolVersions(
        id: string,
        request: Hume.empathicVoice.ToolsListToolVersionsRequest = {},
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<
        core.Page<Hume.empathicVoice.ReturnUserDefinedTool | undefined, Hume.empathicVoice.ReturnPagedUserDefinedTools>
    > {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ToolsListToolVersionsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedUserDefinedTools>> => {
                const { pageNumber, pageSize, restrictToMostRecent } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    restrict_to_most_recent: restrictToMostRecent,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        `v0/evi/tools/${core.url.encodePathParam(id)}`,
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedUserDefinedTools.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/tools/{id}");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<
            Hume.empathicVoice.ReturnUserDefinedTool | undefined,
            Hume.empathicVoice.ReturnPagedUserDefinedTools
        >({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.toolsPage ?? []).length > 0,
            getItems: (response) => response?.toolsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {string} id - Identifier for a tool. Formatted as a UUID.
     * @param {Hume.empathicVoice.PostedUserDefinedToolVersion} request
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.createToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", {
     *         parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\", \"kelvin\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
     *         versionDescription: "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
     *         fallbackContent: "Unable to fetch current weather.",
     *         description: "This tool is for getting the current weather."
     *     })
     */
    public createToolVersion(
        id: string,
        request: Hume.empathicVoice.PostedUserDefinedToolVersion,
        requestOptions?: ToolsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnUserDefinedTool | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__createToolVersion(id, request, requestOptions));
    }

    private async __createToolVersion(
        id: string,
        request: Hume.empathicVoice.PostedUserDefinedToolVersion,
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnUserDefinedTool | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/tools/${core.url.encodePathParam(id)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedUserDefinedToolVersion.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.tools.createToolVersion.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/tools/{id}");
    }

    /**
     * @param {string} id - Identifier for a tool. Formatted as a UUID.
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.deleteTool("00183a3f-79ba-413d-9f3b-609864268bea")
     */
    public deleteTool(id: string, requestOptions?: ToolsClient.RequestOptions): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteTool(id, requestOptions));
    }

    private async __deleteTool(
        id: string,
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/tools/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v0/evi/tools/{id}");
    }

    /**
     * @param {string} id - Identifier for a tool. Formatted as a UUID.
     * @param {Hume.empathicVoice.PostedUserDefinedToolName} request
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.updateToolName("00183a3f-79ba-413d-9f3b-609864268bea", {
     *         name: "get_current_temperature"
     *     })
     */
    public updateToolName(
        id: string,
        request: Hume.empathicVoice.PostedUserDefinedToolName,
        requestOptions?: ToolsClient.RequestOptions,
    ): core.HttpResponsePromise<string> {
        return core.HttpResponsePromise.fromPromise(this.__updateToolName(id, request, requestOptions));
    }

    private async __updateToolName(
        id: string,
        request: Hume.empathicVoice.PostedUserDefinedToolName,
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<string>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/tools/${core.url.encodePathParam(id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedUserDefinedToolName.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "text",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as string, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/v0/evi/tools/{id}");
    }

    /**
     * @param {string} id - Identifier for a tool. Formatted as a UUID.
     * @param {number} version - Version number for a tool. Version numbers should be integers.
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.getToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1)
     */
    public getToolVersion(
        id: string,
        version: number,
        requestOptions?: ToolsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnUserDefinedTool | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__getToolVersion(id, version, requestOptions));
    }

    private async __getToolVersion(
        id: string,
        version: number,
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnUserDefinedTool | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/tools/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.tools.getToolVersion.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v0/evi/tools/{id}/version/{version}",
        );
    }

    /**
     * @param {string} id - Identifier for a tool. Formatted as a UUID.
     * @param {number} version - Version number for a tool. Version numbers should be integers.
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.deleteToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1)
     */
    public deleteToolVersion(
        id: string,
        version: number,
        requestOptions?: ToolsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteToolVersion(id, version, requestOptions));
    }

    private async __deleteToolVersion(
        id: string,
        version: number,
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/tools/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/v0/evi/tools/{id}/version/{version}",
        );
    }

    /**
     * @param {string} id - Identifier for a tool. Formatted as a UUID.
     * @param {number} version - Version number for a tool. Version numbers should be integers.
     * @param {Hume.empathicVoice.PostedUserDefinedToolVersionDescription} request
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.updateToolDescription("00183a3f-79ba-413d-9f3b-609864268bea", 1, {
     *         versionDescription: "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region."
     *     })
     */
    public updateToolDescription(
        id: string,
        version: number,
        request: Hume.empathicVoice.PostedUserDefinedToolVersionDescription = {},
        requestOptions?: ToolsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnUserDefinedTool | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__updateToolDescription(id, version, request, requestOptions));
    }

    private async __updateToolDescription(
        id: string,
        version: number,
        request: Hume.empathicVoice.PostedUserDefinedToolVersionDescription = {},
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnUserDefinedTool | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/tools/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedUserDefinedToolVersionDescription.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.tools.updateToolDescription.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v0/evi/tools/{id}/version/{version}",
        );
    }
}

```


## /src/api/resources/empathicVoice/resources/tools/client/index.ts
```typescript
export * from "./requests/index.js";

```


## /src/api/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedTool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         name: "get_current_weather",
 *         parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
 *         versionDescription: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
 *         description: "This tool is for getting the current weather.",
 *         fallbackContent: "Unable to fetch current weather."
 *     }
 */
export interface PostedUserDefinedTool {
    /** Text describing what the tool does. */
    description?: string;
    /** Text to use if the tool fails to generate content. */
    fallbackContent?: string;
    /** Name applied to all versions of a particular Tool. */
    name: string;
    /** Stringified JSON defining the parameters used by this version of the Tool. */
    parameters: string;
    /** Description that is appended to a specific version of a Tool. */
    versionDescription?: string;
}

```


## /src/api/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolName.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         name: "get_current_temperature"
 *     }
 */
export interface PostedUserDefinedToolName {
    /** Name applied to all versions of a particular Tool. */
    name: string;
}

```


## /src/api/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolVersion.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\", \"kelvin\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
 *         versionDescription: "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
 *         fallbackContent: "Unable to fetch current weather.",
 *         description: "This tool is for getting the current weather."
 *     }
 */
export interface PostedUserDefinedToolVersion {
    /** Text describing what the tool does. */
    description?: string;
    /** Text to use if the tool fails to generate content. */
    fallbackContent?: string;
    /** Stringified JSON defining the parameters used by this version of the Tool. */
    parameters: string;
    /** Description that is appended to a specific version of a Tool. */
    versionDescription?: string;
}

```


## /src/api/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolVersionDescription.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         versionDescription: "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region."
 *     }
 */
export interface PostedUserDefinedToolVersionDescription {
    /** Description that is appended to a specific version of a Tool. */
    versionDescription?: string;
}

```


## /src/api/resources/empathicVoice/resources/tools/client/requests/ToolsListToolVersionsRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {}
 */
export interface ToolsListToolVersionsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** By default, `restrict_to_most_recent` is set to true, returning only the latest version of each tool. To include all versions of each tool in the list, set `restrict_to_most_recent` to false. */
    restrictToMostRecent?: boolean;
}

```


## /src/api/resources/empathicVoice/resources/tools/client/requests/ToolsListToolsRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 2
 *     }
 */
export interface ToolsListToolsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** By default, `restrict_to_most_recent` is set to true, returning only the latest version of each tool. To include all versions of each tool in the list, set `restrict_to_most_recent` to false. */
    restrictToMostRecent?: boolean;
    /** Filter to only include tools with name. */
    name?: string;
}

```


## /src/api/resources/empathicVoice/resources/tools/client/requests/index.ts
```typescript
export type { PostedUserDefinedTool } from "./PostedUserDefinedTool.js";
export type { PostedUserDefinedToolName } from "./PostedUserDefinedToolName.js";
export type { PostedUserDefinedToolVersion } from "./PostedUserDefinedToolVersion.js";
export type { PostedUserDefinedToolVersionDescription } from "./PostedUserDefinedToolVersionDescription.js";
export type { ToolsListToolsRequest } from "./ToolsListToolsRequest.js";
export type { ToolsListToolVersionsRequest } from "./ToolsListToolVersionsRequest.js";

```


## /src/api/resources/empathicVoice/resources/tools/index.ts
```typescript
export * from "./client/index.js";

```


## /src/api/resources/empathicVoice/types/AssistantEnd.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * When provided, the output is an assistant end message.
 */
export interface AssistantEnd {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /**
     * The type of message sent through the socket; for an Assistant End message, this must be `assistant_end`.
     *
     * This message indicates the conclusion of the assistant's response, signaling that the assistant has finished speaking for the current conversational turn.
     */
    type: "assistant_end";
}

```


## /src/api/resources/empathicVoice/types/AssistantInput.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * When provided, the input is spoken by EVI.
 */
export interface AssistantInput {
    customSessionId?: string;
    /**
     * Assistant text to synthesize into spoken audio and insert into the conversation.
     *
     * EVI uses this text to generate spoken audio using our proprietary expressive text-to-speech model. Our model adds appropriate emotional inflections and tones to the text based on the user's expressions and the context of the conversation. The synthesized audio is streamed back to the user as an [Assistant Message](/reference/empathic-voice-interface-evi/chat/chat#receive.Assistant%20Message.type).
     */
    text: string;
    /** The type of message sent through the socket; must be `assistant_input` for our server to correctly identify and process it as an Assistant Input message. */
    type: "assistant_input";
}

```


## /src/api/resources/empathicVoice/types/AssistantMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * When provided, the output is an assistant message.
 */
export interface AssistantMessage {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Indicates if this message was inserted into the conversation as text from an [Assistant Input message](/reference/empathic-voice-interface-evi/chat/chat#send.Assistant%20Input.text). */
    fromText: boolean;
    /** ID of the assistant message. Allows the Assistant Message to be tracked and referenced. */
    id?: string;
    /** Indicates if this message is a quick response or not. */
    isQuickResponse: boolean;
    /** Detected language of the message text. */
    language?: string;
    /** Transcript of the message. */
    message: Hume.empathicVoice.ChatMessage;
    /** Inference model results. */
    models: Hume.empathicVoice.Inference;
    /**
     * The type of message sent through the socket; for an Assistant Message, this must be `assistant_message`.
     *
     * This message contains both a transcript of the assistant's response and the expression measurement predictions of the assistant's audio output.
     */
    type: "assistant_message";
}

```


## /src/api/resources/empathicVoice/types/AssistantProsody.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * When provided, the output is an Assistant Prosody message.
 */
export interface AssistantProsody {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Unique identifier for the segment. */
    id?: string;
    /** Inference model results. */
    models: Hume.empathicVoice.Inference;
    /**
     * The type of message sent through the socket; for an Assistant Prosody message, this must be `assistant_PROSODY`.
     *
     * This message the expression measurement predictions of the assistant's audio output.
     */
    type: "assistant_prosody";
}

```


## /src/api/resources/empathicVoice/types/AudioConfiguration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface AudioConfiguration {
    /** Number of audio channels. */
    channels: number;
    /** Optional codec information. */
    codec?: string;
    /** Encoding format of the audio input, such as `linear16`. */
    encoding: Hume.empathicVoice.Encoding;
    /** Audio sample rate. Number of samples per second in the audio input, measured in Hertz. */
    sampleRate: number;
}

```


## /src/api/resources/empathicVoice/types/AudioInput.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * When provided, the input is audio.
 */
export interface AudioInput {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /**
     * Base64 encoded audio input to insert into the conversation.
     *
     * The content of an Audio Input message is treated as the user's speech to EVI and must be streamed continuously. Pre-recorded audio files are not supported.
     *
     * For optimal transcription quality, the audio data should be transmitted in small chunks.
     *
     * Hume recommends streaming audio with a buffer window of 20 milliseconds (ms), or 100 milliseconds (ms) for web applications.
     */
    data: string;
    /**
     * The type of message sent through the socket; must be `audio_input` for our server to correctly identify and process it as an Audio Input message.
     *
     * This message is used for sending audio input data to EVI for processing and expression measurement. Audio data should be sent as a continuous stream, encoded in Base64.
     */
    type: "audio_input";
}

```


## /src/api/resources/empathicVoice/types/AudioOutput.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * The type of message sent through the socket; for an Audio Output message, this must be `audio_output`.
 */
export interface AudioOutput {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Base64 encoded audio output. This encoded audio is transmitted to the client, where it can be decoded and played back as part of the user interaction. */
    data: string;
    /** ID of the audio output. Allows the Audio Output message to be tracked and referenced. */
    id: string;
    /** Index of the chunk of audio relative to the whole audio segment. */
    index: number;
    type: "audio_output";
}

```


## /src/api/resources/empathicVoice/types/BuiltInTool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const BuiltInTool = {
    WebSearch: "web_search",
    HangUp: "hang_up",
} as const;
export type BuiltInTool = (typeof BuiltInTool)[keyof typeof BuiltInTool];

```


## /src/api/resources/empathicVoice/types/BuiltinToolConfig.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface BuiltinToolConfig {
    /** Optional text passed to the supplemental LLM if the tool call fails. The LLM then uses this text to generate a response back to the user, ensuring continuity in the conversation. */
    fallbackContent?: string;
    name: Hume.empathicVoice.BuiltInTool;
}

```


## /src/api/resources/empathicVoice/types/ChatMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ChatMessage {
    /** Transcript of the message. */
    content?: string;
    /** Role of who is providing the message. */
    role: Hume.empathicVoice.Role;
    /** Function call name and arguments. */
    toolCall?: Hume.empathicVoice.ToolCallMessage;
    /** Function call response from client. */
    toolResult?: Hume.empathicVoice.ChatMessageToolResult;
}

```


## /src/api/resources/empathicVoice/types/ChatMessageToolResult.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Function call response from client.
 */
export type ChatMessageToolResult = Hume.empathicVoice.ToolResponseMessage | Hume.empathicVoice.ToolErrorMessage;

```


## /src/api/resources/empathicVoice/types/ChatMetadata.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * When provided, the output is a chat metadata message.
 */
export interface ChatMetadata {
    /**
     * ID of the Chat Group.
     *
     * Used to resume a Chat when passed in the [resumed_chat_group_id](/reference/empathic-voice-interface-evi/chat/chat#request.query.resumed_chat_group_id) query parameter of a subsequent connection request. This allows EVI to continue the conversation from where it left off within the Chat Group.
     *
     * Learn more about [supporting chat resumability](/docs/empathic-voice-interface-evi/faq#does-evi-support-chat-resumability) from the EVI FAQ.
     */
    chatGroupId: string;
    /** ID of the Chat session. Allows the Chat session to be tracked and referenced. */
    chatId: string;
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** ID of the initiating request. */
    requestId?: string;
    /**
     * The type of message sent through the socket; for a Chat Metadata message, this must be `chat_metadata`.
     *
     * The Chat Metadata message is the first message you receive after establishing a connection with EVI and contains important identifiers for the current Chat session.
     */
    type: "chat_metadata";
}

```


## /src/api/resources/empathicVoice/types/ConnectSessionSettings.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ConnectSessionSettings {
    /**
     * Configuration details for the audio input used during the session. Ensures the audio is being correctly set up for processing.
     *
     * This optional field is only required when the audio input is encoded in PCM Linear 16 (16-bit, little-endian, signed PCM WAV data). For detailed instructions on how to configure session settings for PCM Linear 16 audio, please refer to the [Session Settings section](/docs/empathic-voice-interface-evi/configuration#session-settings) on the EVI Configuration page.
     */
    audio?: Hume.empathicVoice.ConnectSessionSettingsAudio;
    /**
     * Allows developers to inject additional context into the conversation, which is appended to the end of user messages for the session.
     *
     * When included in a Session Settings message, the provided context can be used to remind the LLM of its role in every user message, prevent it from forgetting important details, or add new relevant information to the conversation.
     *
     * Set to `null` to disable context injection.
     */
    context?: Hume.empathicVoice.ConnectSessionSettingsContext;
    /**
     * Unique identifier for the session. Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions.
     *
     * If included, the response sent from Hume to your backend will include this ID. This allows you to correlate frontend users with their incoming messages.
     *
     * It is recommended to pass a `custom_session_id` if you are using a Custom Language Model. Please see our guide to [using a custom language model](/docs/empathic-voice-interface-evi/custom-language-model) with EVI to learn more.
     */
    customSessionId?: string;
    eventLimit?: number;
    /**
     * Third party API key for the supplemental language model.
     *
     * When provided, EVI will use this key instead of Hume's API key for the supplemental LLM. This allows you to bypass rate limits and utilize your own API key as needed.
     */
    languageModelApiKey?: string;
    /**
     * Instructions used to shape EVI's behavior, responses, and style for the session.
     *
     * When included in a Session Settings message, the provided Prompt overrides the existing one specified in the EVI configuration. If no Prompt was defined in the configuration, this Prompt will be the one used for the session.
     *
     * You can use the Prompt to define a specific goal or role for EVI, specifying how it should act or what it should focus on during the conversation. For example, EVI can be instructed to act as a customer support representative, a fitness coach, or a travel advisor, each with its own set of behaviors and response styles.
     *
     * For help writing a system prompt, see our [Prompting Guide](/docs/empathic-voice-interface-evi/prompting).
     */
    systemPrompt?: string;
    voiceId?: string;
    /**
     * This field allows you to assign values to dynamic variables referenced in your system prompt.
     *
     * Each key represents the variable name, and the corresponding value is the specific content you wish to assign to that variable within the session. While the values for variables can be strings, numbers, or booleans, the value will ultimately be converted to a string when injected into your system prompt.
     *
     * When used in query parameters, specify each variable using bracket notation: `session_settings[variables][key]=value`. For example: `session_settings[variables][name]=John&session_settings[variables][age]=30`.
     *
     * Using this field, you can personalize responses based on session-specific details. For more guidance, see our [guide on using dynamic variables](/docs/speech-to-speech-evi/features/dynamic-variables).
     */
    variables?: Record<string, Hume.empathicVoice.ConnectSessionSettingsVariablesValue>;
}

```


## /src/api/resources/empathicVoice/types/ConnectSessionSettingsAudio.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Configuration details for the audio input used during the session. Ensures the audio is being correctly set up for processing.
 *
 * This optional field is only required when the audio input is encoded in PCM Linear 16 (16-bit, little-endian, signed PCM WAV data). For detailed instructions on how to configure session settings for PCM Linear 16 audio, please refer to the [Session Settings section](/docs/empathic-voice-interface-evi/configuration#session-settings) on the EVI Configuration page.
 */
export interface ConnectSessionSettingsAudio {
    /** Number of audio channels. */
    channels?: number;
    /** Encoding format of the audio input, such as `linear16`. */
    encoding?: Hume.empathicVoice.Encoding;
    /** Audio sample rate. Number of samples per second in the audio input, measured in Hertz. */
    sampleRate?: number;
}

```


## /src/api/resources/empathicVoice/types/ConnectSessionSettingsContext.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Allows developers to inject additional context into the conversation, which is appended to the end of user messages for the session.
 *
 * When included in a Session Settings message, the provided context can be used to remind the LLM of its role in every user message, prevent it from forgetting important details, or add new relevant information to the conversation.
 *
 * Set to `null` to disable context injection.
 */
export interface ConnectSessionSettingsContext {
    /**
     * The context to be injected into the conversation. Helps inform the LLM's response by providing relevant information about the ongoing conversation.
     *
     * This text will be appended to the end of user messages based on the chosen persistence level. For example, if you want to remind EVI of its role as a helpful weather assistant, the context you insert will be appended to the end of user messages as `{Context: You are a helpful weather assistant}`.
     */
    text?: string;
    /**
     * The persistence level of the injected context. Specifies how long the injected context will remain active in the session.
     *
     * There are three possible context types:
     *
     * - **Persistent**: The context is appended to all user messages for the duration of the session.
     *
     * - **Temporary**: The context is appended only to the next user message.
     *
     *  - **Editable**: The original context is updated to reflect the new context.
     *
     *  If the type is not specified, it will default to `temporary`.
     */
    type?: Hume.empathicVoice.ContextType;
}

```


## /src/api/resources/empathicVoice/types/ConnectSessionSettingsVariablesValue.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type ConnectSessionSettingsVariablesValue = string | number | boolean;

```


## /src/api/resources/empathicVoice/types/Context.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface Context {
    /**
     * The context to be injected into the conversation. Helps inform the LLM's response by providing relevant information about the ongoing conversation.
     *
     * This text will be appended to the end of user messages based on the chosen persistence level. For example, if you want to remind EVI of its role as a helpful weather assistant, the context you insert will be appended to the end of user messages as `{Context: You are a helpful weather assistant}`.
     */
    text: string;
    /**
     * The persistence level of the injected context. Specifies how long the injected context will remain active in the session.
     *
     * There are three possible context types:
     *
     * - **Persistent**: The context is appended to all user messages for the duration of the session.
     *
     * - **Temporary**: The context is appended only to the next user message.
     *
     *  - **Editable**: The original context is updated to reflect the new context.
     *
     *  If the type is not specified, it will default to `temporary`.
     */
    type?: Hume.empathicVoice.ContextType;
}

```


## /src/api/resources/empathicVoice/types/ContextType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ContextType = {
    Persistent: "persistent",
    Temporary: "temporary",
} as const;
export type ContextType = (typeof ContextType)[keyof typeof ContextType];

```


## /src/api/resources/empathicVoice/types/ControlPlanePublishEvent.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type ControlPlanePublishEvent =
    | Hume.empathicVoice.SessionSettings
    | Hume.empathicVoice.UserInput
    | Hume.empathicVoice.AssistantInput
    | Hume.empathicVoice.ToolResponseMessage
    | Hume.empathicVoice.ToolErrorMessage
    | Hume.empathicVoice.PauseAssistantMessage
    | Hume.empathicVoice.ResumeAssistantMessage;

```


## /src/api/resources/empathicVoice/types/EmotionScores.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface EmotionScores {
    admiration: number;
    adoration: number;
    aestheticAppreciation: number;
    amusement: number;
    anger: number;
    anxiety: number;
    awe: number;
    awkwardness: number;
    boredom: number;
    calmness: number;
    concentration: number;
    confusion: number;
    contemplation: number;
    contempt: number;
    contentment: number;
    craving: number;
    desire: number;
    determination: number;
    disappointment: number;
    disgust: number;
    distress: number;
    doubt: number;
    ecstasy: number;
    embarrassment: number;
    empathicPain: number;
    entrancement: number;
    envy: number;
    excitement: number;
    fear: number;
    guilt: number;
    horror: number;
    interest: number;
    joy: number;
    love: number;
    nostalgia: number;
    pain: number;
    pride: number;
    realization: number;
    relief: number;
    romance: number;
    sadness: number;
    satisfaction: number;
    shame: number;
    surpriseNegative: number;
    surprisePositive: number;
    sympathy: number;
    tiredness: number;
    triumph: number;
}

```


## /src/api/resources/empathicVoice/types/Encoding.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type Encoding = "linear16";

```


## /src/api/resources/empathicVoice/types/ErrorLevel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type ErrorLevel = "warn";

```


## /src/api/resources/empathicVoice/types/ErrorResponse.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface ErrorResponse {
    code?: string;
    error?: string;
    message?: string;
}

```


## /src/api/resources/empathicVoice/types/HttpValidationError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface HttpValidationError {
    detail?: Hume.empathicVoice.ValidationError[];
}

```


## /src/api/resources/empathicVoice/types/Inference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface Inference {
    /**
     * Prosody model inference results.
     *
     * EVI uses the prosody model to measure 48 emotions related to speech and vocal characteristics within a given expression.
     */
    prosody?: Hume.empathicVoice.ProsodyInference;
}

```


## /src/api/resources/empathicVoice/types/JsonMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type JsonMessage =
    | Hume.empathicVoice.AssistantEnd
    | Hume.empathicVoice.AssistantMessage
    | Hume.empathicVoice.AssistantProsody
    | Hume.empathicVoice.ChatMetadata
    | Hume.empathicVoice.WebSocketError
    | Hume.empathicVoice.UserInterruption
    | Hume.empathicVoice.UserMessage
    | Hume.empathicVoice.ToolCallMessage
    | Hume.empathicVoice.ToolResponseMessage
    | Hume.empathicVoice.ToolErrorMessage
    | Hume.empathicVoice.SessionSettings;

```


## /src/api/resources/empathicVoice/types/LanguageModelType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const LanguageModelType = {
    Claude37SonnetLatest: "claude-3-7-sonnet-latest",
    Claude35SonnetLatest: "claude-3-5-sonnet-latest",
    Claude35HaikuLatest: "claude-3-5-haiku-latest",
    Claude35Sonnet20240620: "claude-3-5-sonnet-20240620",
    Claude3Opus20240229: "claude-3-opus-20240229",
    Claude3Sonnet20240229: "claude-3-sonnet-20240229",
    Claude3Haiku20240307: "claude-3-haiku-20240307",
    ClaudeSonnet420250514: "claude-sonnet-4-20250514",
    ClaudeSonnet4520250929: "claude-sonnet-4-5-20250929",
    ClaudeHaiku4520251001: "claude-haiku-4-5-20251001",
    UsAnthropicClaude35Haiku20241022V10: "us.anthropic.claude-3-5-haiku-20241022-v1:0",
    UsAnthropicClaude35Sonnet20240620V10: "us.anthropic.claude-3-5-sonnet-20240620-v1:0",
    UsAnthropicClaude3Haiku20240307V10: "us.anthropic.claude-3-haiku-20240307-v1:0",
    GptOss120B: "gpt-oss-120b",
    Qwen3235Ba22B: "qwen-3-235b-a22b",
    Qwen3235Ba22BInstruct2507: "qwen-3-235b-a22b-instruct-2507",
    Qwen3235Ba22BThinking2507: "qwen-3-235b-a22b-thinking-2507",
    Gemini15Pro: "gemini-1.5-pro",
    Gemini15Flash: "gemini-1.5-flash",
    Gemini15Pro002: "gemini-1.5-pro-002",
    Gemini15Flash002: "gemini-1.5-flash-002",
    Gemini20Flash: "gemini-2.0-flash",
    Gemini25Flash: "gemini-2.5-flash",
    Gemini25FlashPreview0417: "gemini-2.5-flash-preview-04-17",
    Gpt4Turbo: "gpt-4-turbo",
    Gpt4TurboPreview: "gpt-4-turbo-preview",
    Gpt35Turbo0125: "gpt-3.5-turbo-0125",
    Gpt35Turbo: "gpt-3.5-turbo",
    Gpt4O: "gpt-4o",
    Gpt4OMini: "gpt-4o-mini",
    Gpt41: "gpt-4.1",
    Gpt5: "gpt-5",
    Gpt5Mini: "gpt-5-mini",
    Gpt5Nano: "gpt-5-nano",
    Gpt4OPriority: "gpt-4o-priority",
    Gpt4OMiniPriority: "gpt-4o-mini-priority",
    Gpt41Priority: "gpt-4.1-priority",
    Gpt5Priority: "gpt-5-priority",
    Gpt5MiniPriority: "gpt-5-mini-priority",
    Gpt5NanoPriority: "gpt-5-nano-priority",
    Gemma7BIt: "gemma-7b-it",
    Llama38B8192: "llama3-8b-8192",
    Llama370B8192: "llama3-70b-8192",
    Llama3170BVersatile: "llama-3.1-70b-versatile",
    Llama3370BVersatile: "llama-3.3-70b-versatile",
    Llama318BInstant: "llama-3.1-8b-instant",
    MoonshotaiKimiK2Instruct: "moonshotai/kimi-k2-instruct",
    AccountsFireworksModelsMixtral8X7BInstruct: "accounts/fireworks/models/mixtral-8x7b-instruct",
    AccountsFireworksModelsLlamaV3P1405BInstruct: "accounts/fireworks/models/llama-v3p1-405b-instruct",
    AccountsFireworksModelsLlamaV3P170BInstruct: "accounts/fireworks/models/llama-v3p1-70b-instruct",
    AccountsFireworksModelsLlamaV3P18BInstruct: "accounts/fireworks/models/llama-v3p1-8b-instruct",
    Sonar: "sonar",
    SonarPro: "sonar-pro",
    Sambanova: "sambanova",
    DeepSeekR1DistillLlama70B: "DeepSeek-R1-Distill-Llama-70B",
    Llama4Maverick17B128EInstruct: "Llama-4-Maverick-17B-128E-Instruct",
    Qwen332B: "Qwen3-32B",
    Grok4FastNonReasoningLatest: "grok-4-fast-non-reasoning-latest",
    Ellm: "ellm",
    CustomLanguageModel: "custom-language-model",
    HumeEvi3WebSearch: "hume-evi-3-web-search",
} as const;
export type LanguageModelType = (typeof LanguageModelType)[keyof typeof LanguageModelType];

```


## /src/api/resources/empathicVoice/types/MillisecondInterval.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface MillisecondInterval {
    /** Start time of the interval in milliseconds. */
    begin: number;
    /** End time of the interval in milliseconds. */
    end: number;
}

```


## /src/api/resources/empathicVoice/types/ModelProviderEnum.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ModelProviderEnum = {
    Groq: "GROQ",
    OpenAi: "OPEN_AI",
    Fireworks: "FIREWORKS",
    Anthropic: "ANTHROPIC",
    CustomLanguageModel: "CUSTOM_LANGUAGE_MODEL",
    Google: "GOOGLE",
    HumeAi: "HUME_AI",
    AmazonBedrock: "AMAZON_BEDROCK",
    Perplexity: "PERPLEXITY",
    Sambanova: "SAMBANOVA",
    Cerebras: "CEREBRAS",
} as const;
export type ModelProviderEnum = (typeof ModelProviderEnum)[keyof typeof ModelProviderEnum];

```


## /src/api/resources/empathicVoice/types/PauseAssistantMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * Pause responses from EVI. Chat history is still saved and sent after resuming.
 */
export interface PauseAssistantMessage {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /**
     * The type of message sent through the socket; must be `pause_assistant_message` for our server to correctly identify and process it as a Pause Assistant message.
     *
     * Once this message is sent, EVI will not respond until a [Resume Assistant message](/reference/empathic-voice-interface-evi/chat/chat#send.Resume%20Assistant%20Message.type) is sent. When paused, EVI won't respond, but transcriptions of your audio inputs will still be recorded.
     */
    type: "pause_assistant_message";
}

```


## /src/api/resources/empathicVoice/types/PostedBuiltinTool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A configuration of a built-in tool to be posted to the server
 */
export interface PostedBuiltinTool {
    /** Text to use if the tool fails to generate content. */
    fallbackContent?: string;
    name: Hume.empathicVoice.PostedBuiltinToolName;
}

```


## /src/api/resources/empathicVoice/types/PostedBuiltinToolName.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const PostedBuiltinToolName = {
    WebSearch: "web_search",
    HangUp: "hang_up",
} as const;
export type PostedBuiltinToolName = (typeof PostedBuiltinToolName)[keyof typeof PostedBuiltinToolName];

```


## /src/api/resources/empathicVoice/types/PostedConfigPromptSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * Identifies which prompt to use in a a config OR how to create a new prompt to use in the config
 */
export interface PostedConfigPromptSpec {
    /** Identifier for a Prompt. Formatted as a UUID. */
    id?: string;
    /** Text used to create a new prompt for a particular config. */
    text?: string;
    /** Version number for a Prompt. Version numbers should be integers. The combination of configId and version number is unique. */
    version?: number;
}

```


## /src/api/resources/empathicVoice/types/PostedEllmModel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * A eLLM model configuration to be posted to the server
 */
export interface PostedEllmModel {
    /** Boolean indicating if the model is allowed to generate short responses. */
    allowShortResponses?: boolean;
}

```


## /src/api/resources/empathicVoice/types/PostedEventMessageSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * Settings for a specific event_message to be posted to the server
 */
export interface PostedEventMessageSpec {
    /** Boolean indicating if this event message is enabled. */
    enabled: boolean;
    /** Optional text that will be used as a verbatim event message. If the text is null and the event message is enabled, the system will generate a message based using the language model. */
    text?: string;
}

```


## /src/api/resources/empathicVoice/types/PostedEventMessageSpecs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Collection of event_message specs to be posted to the server
 */
export interface PostedEventMessageSpecs {
    onInactivityTimeout?: Hume.empathicVoice.PostedEventMessageSpec;
    onMaxDurationTimeout?: Hume.empathicVoice.PostedEventMessageSpec;
    onNewChat?: Hume.empathicVoice.PostedEventMessageSpec;
}

```


## /src/api/resources/empathicVoice/types/PostedLanguageModel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A LanguageModel to be posted to the server
 */
export interface PostedLanguageModel {
    modelProvider?: Hume.empathicVoice.ModelProviderEnum;
    modelResource?: Hume.empathicVoice.LanguageModelType;
    /** Model temperature. */
    temperature?: number;
}

```


## /src/api/resources/empathicVoice/types/PostedNudgeSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * A nudge specification posted to the server
 */
export interface PostedNudgeSpec {
    /** EVI will nudge user after inactivity */
    enabled?: boolean;
    /** Time interval in seconds after which the nudge will be sent. */
    intervalSecs?: number;
}

```


## /src/api/resources/empathicVoice/types/PostedTimeoutSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * Settings for a specific timeout to be posted to the server
 */
export interface PostedTimeoutSpec {
    /** Duration in seconds for the timeout. */
    durationSecs?: number;
    /** Boolean indicating if this event message is enabled. */
    enabled: boolean;
}

```


## /src/api/resources/empathicVoice/types/PostedTimeoutSpecs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Collection of timeout specs to be posted to the server
 */
export interface PostedTimeoutSpecs {
    inactivity?: Hume.empathicVoice.PostedTimeoutSpecsInactivity;
    maxDuration?: Hume.empathicVoice.PostedTimeoutSpecsMaxDuration;
}

```


## /src/api/resources/empathicVoice/types/PostedTimeoutSpecsInactivity.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface PostedTimeoutSpecsInactivity {
    durationSecs?: number;
    enabled: boolean;
}

```


## /src/api/resources/empathicVoice/types/PostedTimeoutSpecsMaxDuration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface PostedTimeoutSpecsMaxDuration {
    durationSecs?: number;
    enabled: boolean;
}

```


## /src/api/resources/empathicVoice/types/PostedUserDefinedToolSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * A specific tool identifier to be posted to the server
 */
export interface PostedUserDefinedToolSpec {
    /** Identifier for a Tool. Formatted as a UUID. */
    id: string;
    /** Version number for a Tool. Version numbers should be integers. The combination of configId and version number is unique. */
    version?: number;
}

```


## /src/api/resources/empathicVoice/types/PostedWebhookEventType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/** Events this URL is subscribed to */
export const PostedWebhookEventType = {
    ChatStarted: "chat_started",
    ChatEnded: "chat_ended",
    ToolCall: "tool_call",
} as const;
export type PostedWebhookEventType = (typeof PostedWebhookEventType)[keyof typeof PostedWebhookEventType];

```


## /src/api/resources/empathicVoice/types/PostedWebhookSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * URL and settings for a specific webhook to be posted to the server
 */
export interface PostedWebhookSpec {
    /** Events this URL is subscribed to */
    events: Hume.empathicVoice.PostedWebhookEventType[];
    /** URL to send the webhook to */
    url: string;
}

```


## /src/api/resources/empathicVoice/types/ProsodyInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ProsodyInference {
    /**
     * The confidence scores for 48 emotions within the detected expression of an audio sample.
     *
     * Scores typically range from 0 to 1, with higher values indicating a stronger confidence level in the measured attribute.
     *
     * See our guide on [interpreting expression measurement results](/docs/expression-measurement/faq#how-do-i-interpret-my-results) to learn more.
     */
    scores: Hume.empathicVoice.EmotionScores;
}

```


## /src/api/resources/empathicVoice/types/ResumeAssistantMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * Resume responses from EVI. Chat history sent while paused will now be sent.
 */
export interface ResumeAssistantMessage {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /**
     * The type of message sent through the socket; must be `resume_assistant_message` for our server to correctly identify and process it as a Resume Assistant message.
     *
     * Upon resuming, if any audio input was sent during the pause, EVI will retain context from all messages sent but only respond to the last user message. (e.g., If you ask EVI two questions while paused and then send a `resume_assistant_message`, EVI will respond to the second question and have added the first question to its conversation context.)
     */
    type: "resume_assistant_message";
}

```


## /src/api/resources/empathicVoice/types/ReturnBuiltinTool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A specific builtin tool version returned from the server
 */
export interface ReturnBuiltinTool {
    /** Text to use if the tool fails to generate content. */
    fallbackContent?: string;
    /** Name applied to all versions of a particular Tool. */
    name: string;
    toolType: Hume.empathicVoice.ReturnBuiltinToolToolType;
}

```


## /src/api/resources/empathicVoice/types/ReturnBuiltinToolToolType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnBuiltinToolToolType = {
    Builtin: "BUILTIN",
    Function: "FUNCTION",
} as const;
export type ReturnBuiltinToolToolType = (typeof ReturnBuiltinToolToolType)[keyof typeof ReturnBuiltinToolToolType];

```


## /src/api/resources/empathicVoice/types/ReturnChat.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A description of chat and its status
 */
export interface ReturnChat {
    /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
    chatGroupId: string;
    config?: Hume.empathicVoice.ReturnConfigSpec;
    /** The timestamp when the chat ended, formatted as a Unix epoch milliseconds. */
    endTimestamp?: number;
    /** The total number of events currently in this chat. */
    eventCount?: number;
    /** Identifier for a chat. Formatted as a UUID. */
    id: string;
    /** Stringified JSON with additional metadata about the chat. */
    metadata?: string;
    /** The timestamp when the chat started, formatted as a Unix epoch milliseconds. */
    startTimestamp: number;
    status: Hume.empathicVoice.ReturnChatStatus;
}

```


## /src/api/resources/empathicVoice/types/ReturnChatAudioReconstruction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * List of chat audio reconstructions returned for the specified page number and page size.
 */
export interface ReturnChatAudioReconstruction {
    /** Name of the chat audio reconstruction file. */
    filename?: string;
    /** Identifier for the chat. Formatted as a UUID. */
    id: string;
    /** The timestamp of the most recent status change for this audio reconstruction, formatted milliseconds since the Unix epoch. */
    modifiedAt?: number;
    /** Signed URL used to download the chat audio reconstruction file. */
    signedAudioUrl?: string;
    /** The timestamp when the signed URL will expire, formatted as a Unix epoch milliseconds. */
    signedUrlExpirationTimestampMillis?: number;
    status: Hume.empathicVoice.ReturnChatAudioReconstructionStatus;
    /** Identifier for the user that owns this chat. Formatted as a UUID. */
    userId: string;
}

```


## /src/api/resources/empathicVoice/types/ReturnChatAudioReconstructionStatus.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatAudioReconstructionStatus = {
    Queued: "QUEUED",
    InProgress: "IN_PROGRESS",
    Complete: "COMPLETE",
    Error: "ERROR",
    Cancelled: "CANCELLED",
} as const;
export type ReturnChatAudioReconstructionStatus =
    (typeof ReturnChatAudioReconstructionStatus)[keyof typeof ReturnChatAudioReconstructionStatus];

```


## /src/api/resources/empathicVoice/types/ReturnChatEvent.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A description of a single event in a chat returned from the server
 */
export interface ReturnChatEvent {
    /** Identifier for the chat this event occurred in. Formatted as a UUID. */
    chatId: string;
    /** Stringified JSON with data about emotional content/prosody of the event. */
    emotionFeatures?: string;
    /** Identifier for a chat event. Formatted as a UUID. */
    id: string;
    /** The text of the chat message, either transcribed from speaker audio or generated by the agent. */
    messageText?: string;
    /** Stringified JSON with additional metadata about the chat event. */
    metadata?: string;
    /** Identifier for a related chat event. Currently only seen on ASSISTANT_PROSODY events, to point back to the ASSISTANT_MESSAGE that generated these prosody scores */
    relatedEventId?: string;
    role: Hume.empathicVoice.ReturnChatEventRole;
    /** The timestamp when the chat event occurred, formatted as a Unix epoch milliseconds. */
    timestamp: number;
    type: Hume.empathicVoice.ReturnChatEventType;
}

```


## /src/api/resources/empathicVoice/types/ReturnChatEventRole.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatEventRole = {
    User: "USER",
    Agent: "AGENT",
    System: "SYSTEM",
    Tool: "TOOL",
} as const;
export type ReturnChatEventRole = (typeof ReturnChatEventRole)[keyof typeof ReturnChatEventRole];

```


## /src/api/resources/empathicVoice/types/ReturnChatEventType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatEventType = {
    FunctionCall: "FUNCTION_CALL",
    FunctionCallResponse: "FUNCTION_CALL_RESPONSE",
    ChatEndMessage: "CHAT_END_MESSAGE",
    AgentMessage: "AGENT_MESSAGE",
    SystemPrompt: "SYSTEM_PROMPT",
    UserRecordingStartMessage: "USER_RECORDING_START_MESSAGE",
    ResumeOnset: "RESUME_ONSET",
    UserInterruption: "USER_INTERRUPTION",
    ChatStartMessage: "CHAT_START_MESSAGE",
    PauseOnset: "PAUSE_ONSET",
    UserMessage: "USER_MESSAGE",
} as const;
export type ReturnChatEventType = (typeof ReturnChatEventType)[keyof typeof ReturnChatEventType];

```


## /src/api/resources/empathicVoice/types/ReturnChatGroup.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A description of chat_group and its status
 */
export interface ReturnChatGroup {
    active?: boolean;
    /** The timestamp when the first chat in this chat group started, formatted as a Unix epoch milliseconds. */
    firstStartTimestamp: number;
    /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
    id: string;
    /** The chat_id of the most recent chat in this chat group. Formatted as a UUID. */
    mostRecentChatId?: string;
    mostRecentConfig?: Hume.empathicVoice.ReturnConfigSpec;
    /** The timestamp when the most recent chat in this chat group started, formatted as a Unix epoch milliseconds. */
    mostRecentStartTimestamp: number;
    /** The total number of chats in this chat group. */
    numChats: number;
}

```


## /src/api/resources/empathicVoice/types/ReturnChatGroupPagedAudioReconstructions.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of chat reconstructions for a particular chatgroup
 */
export interface ReturnChatGroupPagedAudioReconstructions {
    /** List of chat audio reconstructions returned for the specified page number and page size. */
    audioReconstructionsPage: Hume.empathicVoice.ReturnChatAudioReconstruction[];
    /** Identifier for the chat group. Formatted as a UUID. */
    id: string;
    /** Total number of chats in this chatgroup */
    numChats: number;
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    paginationDirection: Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructionsPaginationDirection;
    /** The total number of pages in the collection. */
    totalPages: number;
    /** Identifier for the user that owns this chat. Formatted as a UUID. */
    userId: string;
}

```


## /src/api/resources/empathicVoice/types/ReturnChatGroupPagedAudioReconstructionsPaginationDirection.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatGroupPagedAudioReconstructionsPaginationDirection = {
    Asc: "ASC",
    Desc: "DESC",
} as const;
export type ReturnChatGroupPagedAudioReconstructionsPaginationDirection =
    (typeof ReturnChatGroupPagedAudioReconstructionsPaginationDirection)[keyof typeof ReturnChatGroupPagedAudioReconstructionsPaginationDirection];

```


## /src/api/resources/empathicVoice/types/ReturnChatGroupPagedChats.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A description of chat_group and its status with a paginated list of each chat in the chat_group
 */
export interface ReturnChatGroupPagedChats {
    active?: boolean;
    /** List of chats and their metadata returned for the specified page number and page size. */
    chatsPage: Hume.empathicVoice.ReturnChat[];
    /** The timestamp when the first chat in this chat group started, formatted as a Unix epoch milliseconds. */
    firstStartTimestamp: number;
    /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
    id: string;
    /** The timestamp when the most recent chat in this chat group started, formatted as a Unix epoch milliseconds. */
    mostRecentStartTimestamp: number;
    /** The total number of chats in this chat group. */
    numChats: number;
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    paginationDirection: Hume.empathicVoice.ReturnChatGroupPagedChatsPaginationDirection;
    /** The total number of pages in the collection. */
    totalPages: number;
}

```


## /src/api/resources/empathicVoice/types/ReturnChatGroupPagedChatsPaginationDirection.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatGroupPagedChatsPaginationDirection = {
    Asc: "ASC",
    Desc: "DESC",
} as const;
export type ReturnChatGroupPagedChatsPaginationDirection =
    (typeof ReturnChatGroupPagedChatsPaginationDirection)[keyof typeof ReturnChatGroupPagedChatsPaginationDirection];

```


## /src/api/resources/empathicVoice/types/ReturnChatGroupPagedEvents.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of chat events that occurred across chats in this chat_group from the server
 */
export interface ReturnChatGroupPagedEvents {
    /** List of chat_events returned for the specified page number and page size. */
    eventsPage: Hume.empathicVoice.ReturnChatEvent[];
    /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
    id: string;
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    paginationDirection: Hume.empathicVoice.ReturnChatGroupPagedEventsPaginationDirection;
    /** The total number of pages in the collection. */
    totalPages: number;
}

```


## /src/api/resources/empathicVoice/types/ReturnChatGroupPagedEventsPaginationDirection.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatGroupPagedEventsPaginationDirection = {
    Asc: "ASC",
    Desc: "DESC",
} as const;
export type ReturnChatGroupPagedEventsPaginationDirection =
    (typeof ReturnChatGroupPagedEventsPaginationDirection)[keyof typeof ReturnChatGroupPagedEventsPaginationDirection];

```


## /src/api/resources/empathicVoice/types/ReturnChatPagedEvents.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A description of chat status with a paginated list of chat events returned from the server
 */
export interface ReturnChatPagedEvents {
    /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
    chatGroupId: string;
    config?: Hume.empathicVoice.ReturnConfigSpec;
    /** The timestamp when the chat ended, formatted as a Unix epoch milliseconds. */
    endTimestamp?: number;
    /** List of chat events with the specified page number and page size. */
    eventsPage: Hume.empathicVoice.ReturnChatEvent[];
    /** Identifier for a chat. Formatted as a UUID. */
    id: string;
    /** Stringified JSON with additional metadata about the chat. */
    metadata?: string;
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    paginationDirection: Hume.empathicVoice.ReturnChatPagedEventsPaginationDirection;
    /** The timestamp when the chat started, formatted as a Unix epoch milliseconds. */
    startTimestamp: number;
    status: Hume.empathicVoice.ReturnChatPagedEventsStatus;
    /** The total number of pages in the collection. */
    totalPages: number;
}

```


## /src/api/resources/empathicVoice/types/ReturnChatPagedEventsPaginationDirection.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatPagedEventsPaginationDirection = {
    Asc: "ASC",
    Desc: "DESC",
} as const;
export type ReturnChatPagedEventsPaginationDirection =
    (typeof ReturnChatPagedEventsPaginationDirection)[keyof typeof ReturnChatPagedEventsPaginationDirection];

```


## /src/api/resources/empathicVoice/types/ReturnChatPagedEventsStatus.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatPagedEventsStatus = {
    Active: "ACTIVE",
    UserEnded: "USER_ENDED",
    UserTimeout: "USER_TIMEOUT",
    MaxDurationTimeout: "MAX_DURATION_TIMEOUT",
    InactivityTimeout: "INACTIVITY_TIMEOUT",
    Error: "ERROR",
} as const;
export type ReturnChatPagedEventsStatus =
    (typeof ReturnChatPagedEventsStatus)[keyof typeof ReturnChatPagedEventsStatus];

```


## /src/api/resources/empathicVoice/types/ReturnChatStatus.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatStatus = {
    Active: "ACTIVE",
    UserEnded: "USER_ENDED",
    UserTimeout: "USER_TIMEOUT",
    MaxDurationTimeout: "MAX_DURATION_TIMEOUT",
    InactivityTimeout: "INACTIVITY_TIMEOUT",
    Error: "ERROR",
} as const;
export type ReturnChatStatus = (typeof ReturnChatStatus)[keyof typeof ReturnChatStatus];

```


## /src/api/resources/empathicVoice/types/ReturnConfig.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A specific config version returned from the server
 */
export interface ReturnConfig {
    /** List of built-in tools associated with this config */
    builtinTools?: (Hume.empathicVoice.ReturnBuiltinTool | undefined)[];
    /** The timestamp when the first version of this config was created. */
    createdOn?: number;
    ellmModel?: Hume.empathicVoice.ReturnEllmModel;
    eventMessages?: Hume.empathicVoice.ReturnEventMessageSpecs;
    /** The version of the EVI used with this config. */
    eviVersion?: string;
    /** Identifier for a Config. Formatted as a UUID. */
    id?: string;
    languageModel?: Hume.empathicVoice.ReturnLanguageModel;
    /** The timestamp when this version of the config was created. */
    modifiedOn?: number;
    /** Name applied to all versions of a particular Config. */
    name?: string;
    nudges?: Hume.empathicVoice.ReturnNudgeSpec;
    prompt?: Hume.empathicVoice.ReturnPrompt;
    timeouts?: Hume.empathicVoice.ReturnTimeoutSpecs;
    /** List of user-defined tools associated with this config. */
    tools?: (Hume.empathicVoice.ReturnUserDefinedTool | undefined)[];
    /** Version number for a Config. Version numbers should be integers. The combination of configId and version number is unique. */
    version?: number;
    /** Description that is appended to a specific version of a Config. */
    versionDescription?: string;
    voice?: Hume.empathicVoice.ReturnVoice;
    /** Map of webhooks associated with this config. */
    webhooks?: (Hume.empathicVoice.ReturnWebhookSpec | undefined)[];
}

```


## /src/api/resources/empathicVoice/types/ReturnConfigSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * An id/version number for a specific config version
 */
export interface ReturnConfigSpec {
    /** Identifier for a Config. Formatted as a UUID. */
    id: string;
    /** Version number for a Config. Version numbers should be integers. The combination of configId and version number is unique. */
    version?: number;
}

```


## /src/api/resources/empathicVoice/types/ReturnEllmModel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * A specific eLLM Model configuration
 */
export interface ReturnEllmModel {
    /** Boolean indicating if the model is allowed to generate short responses. */
    allowShortResponses: boolean;
}

```


## /src/api/resources/empathicVoice/types/ReturnEventMessageSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * A specific event message configuration to be returned from the server
 */
export interface ReturnEventMessageSpec {
    /** Boolean indicating if this event message is enabled. */
    enabled: boolean;
    /** Optional text that will be used as a verbatim event message. If the text is null and the event message is enabled, the system will generate a message based using the language model. */
    text?: string;
}

```


## /src/api/resources/empathicVoice/types/ReturnEventMessageSpecs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Collection of event_message specs to be returned from the server
 */
export interface ReturnEventMessageSpecs {
    onInactivityTimeout?: Hume.empathicVoice.ReturnEventMessageSpec;
    onMaxDurationTimeout?: Hume.empathicVoice.ReturnEventMessageSpec;
    onNewChat?: Hume.empathicVoice.ReturnEventMessageSpec;
}

```


## /src/api/resources/empathicVoice/types/ReturnLanguageModel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A specific LanguageModel
 */
export interface ReturnLanguageModel {
    modelProvider?: Hume.empathicVoice.ModelProviderEnum;
    modelResource?: Hume.empathicVoice.LanguageModelType;
    /** Model temperature. */
    temperature?: number;
}

```


## /src/api/resources/empathicVoice/types/ReturnNudgeSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * A specific nudge configuration returned from the server
 */
export interface ReturnNudgeSpec {
    /** EVI will nudge user after inactivity */
    enabled: boolean;
    /** Time interval in seconds after which the nudge will be sent. */
    intervalSecs?: number;
}

```


## /src/api/resources/empathicVoice/types/ReturnPagedChatGroups.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of chat_groups returned from the server
 */
export interface ReturnPagedChatGroups {
    /** List of chat_groups and their metadata returned for the specified page number and page size. */
    chatGroupsPage: Hume.empathicVoice.ReturnChatGroup[];
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    paginationDirection: Hume.empathicVoice.ReturnPagedChatGroupsPaginationDirection;
    /** The total number of pages in the collection. */
    totalPages: number;
}

```


## /src/api/resources/empathicVoice/types/ReturnPagedChatGroupsPaginationDirection.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnPagedChatGroupsPaginationDirection = {
    Asc: "ASC",
    Desc: "DESC",
} as const;
export type ReturnPagedChatGroupsPaginationDirection =
    (typeof ReturnPagedChatGroupsPaginationDirection)[keyof typeof ReturnPagedChatGroupsPaginationDirection];

```


## /src/api/resources/empathicVoice/types/ReturnPagedChats.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of chats returned from the server
 */
export interface ReturnPagedChats {
    /** List of chats and their metadata returned for the specified page number and page size. */
    chatsPage: Hume.empathicVoice.ReturnChat[];
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    paginationDirection: Hume.empathicVoice.ReturnPagedChatsPaginationDirection;
    /** The total number of pages in the collection. */
    totalPages: number;
}

```


## /src/api/resources/empathicVoice/types/ReturnPagedChatsPaginationDirection.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnPagedChatsPaginationDirection = {
    Asc: "ASC",
    Desc: "DESC",
} as const;
export type ReturnPagedChatsPaginationDirection =
    (typeof ReturnPagedChatsPaginationDirection)[keyof typeof ReturnPagedChatsPaginationDirection];

```


## /src/api/resources/empathicVoice/types/ReturnPagedConfigs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of config versions returned from the server
 */
export interface ReturnPagedConfigs {
    /** List of prompts returned for the specified page number and page size. */
    configsPage?: Hume.empathicVoice.ReturnConfig[];
    /** The page number of the returned results. */
    pageNumber?: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize?: number;
    /** The total number of pages in the collection. */
    totalPages: number;
}

```


## /src/api/resources/empathicVoice/types/ReturnPagedPrompts.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of prompt versions returned from the server
 */
export interface ReturnPagedPrompts {
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    /** List of prompts returned for the specified page number and page size. */
    promptsPage: (Hume.empathicVoice.ReturnPrompt | undefined)[];
    /** The total number of pages in the collection. */
    totalPages: number;
}

```


## /src/api/resources/empathicVoice/types/ReturnPagedUserDefinedTools.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of user defined tool versions returned from the server
 */
export interface ReturnPagedUserDefinedTools {
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    /** List of tools returned for the specified page number and page size. */
    toolsPage: (Hume.empathicVoice.ReturnUserDefinedTool | undefined)[];
    /** The total number of pages in the collection. */
    totalPages: number;
}

```


## /src/api/resources/empathicVoice/types/ReturnPrompt.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * A specific prompt version returned from the server
 */
export interface ReturnPrompt {
    /** The timestamp when the first version of this prompt was created. */
    createdOn: number;
    /** Identifier for a Prompt. Formatted as a UUID. */
    id: string;
    /** The timestamp when this version of the prompt was created. */
    modifiedOn: number;
    /** Name applied to all versions of a particular Prompt. */
    name: string;
    /** Text used for this version of the Prompt. */
    text: string;
    /** Version number for a Prompt. Version numbers should be integers. The combination of configId and version number is unique. */
    version: number;
    /** Description that is appended to a specific version of a Prompt. */
    versionDescription?: string;
    /** Indicates whether this prompt is using a fixed version number or auto-updating to the latest version. Values from the VersionType enum. */
    versionType: string;
}

```


## /src/api/resources/empathicVoice/types/ReturnPromptVersionType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnPromptVersionType = {
    Fixed: "FIXED",
    Latest: "LATEST",
} as const;
export type ReturnPromptVersionType = (typeof ReturnPromptVersionType)[keyof typeof ReturnPromptVersionType];

```


## /src/api/resources/empathicVoice/types/ReturnTimeoutSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * A specific timeout configuration to be returned from the server
 */
export interface ReturnTimeoutSpec {
    /** Duration in seconds for the timeout. */
    durationSecs?: number;
    /** Boolean indicating if this event message is enabled. */
    enabled: boolean;
}

```


## /src/api/resources/empathicVoice/types/ReturnTimeoutSpecs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Collection of timeout specs to be returned from the server
 */
export interface ReturnTimeoutSpecs {
    inactivity: Hume.empathicVoice.ReturnTimeoutSpec;
    maxDuration: Hume.empathicVoice.ReturnTimeoutSpec;
}

```


## /src/api/resources/empathicVoice/types/ReturnUserDefinedTool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A specific tool version returned from the server
 */
export interface ReturnUserDefinedTool {
    /** The timestamp when the first version of this tool was created. */
    createdOn: number;
    /** Text describing what the tool does. */
    description?: string;
    /** Text to use if the tool fails to generate content. */
    fallbackContent?: string;
    /** Identifier for a Tool. Formatted as a UUID. */
    id: string;
    /** The timestamp when this version of the tool was created. */
    modifiedOn: number;
    /** Name applied to all versions of a particular Tool. */
    name: string;
    /** Stringified JSON defining the parameters used by this version of the Tool. */
    parameters: string;
    toolType: Hume.empathicVoice.ReturnUserDefinedToolToolType;
    /** Version number for a Tool. Version numbers should be integers. The combination of configId and version number is unique. */
    version: number;
    /** Description that is appended to a specific version of a Tool. */
    versionDescription?: string;
    versionType: Hume.empathicVoice.ReturnUserDefinedToolVersionType;
}

```


## /src/api/resources/empathicVoice/types/ReturnUserDefinedToolToolType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnUserDefinedToolToolType = {
    Builtin: "BUILTIN",
    Function: "FUNCTION",
} as const;
export type ReturnUserDefinedToolToolType =
    (typeof ReturnUserDefinedToolToolType)[keyof typeof ReturnUserDefinedToolToolType];

```


## /src/api/resources/empathicVoice/types/ReturnUserDefinedToolVersionType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ReturnUserDefinedToolVersionType = {
    Fixed: "FIXED",
    Latest: "LATEST",
} as const;
export type ReturnUserDefinedToolVersionType =
    (typeof ReturnUserDefinedToolVersionType)[keyof typeof ReturnUserDefinedToolVersionType];

```


## /src/api/resources/empathicVoice/types/ReturnVoice.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * An Octave voice available for text-to-speech
 */
export interface ReturnVoice {
    compatibleOctaveModels?: string[];
    /** ID of the voice in the `Voice Library`. */
    id: string;
    /** Name of the voice in the `Voice Library`. */
    name: string;
    provider: Hume.empathicVoice.VoiceProvider;
}

```


## /src/api/resources/empathicVoice/types/ReturnWebhookEventType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/** Events this URL is subscribed to */
export const ReturnWebhookEventType = {
    ChatStarted: "chat_started",
    ChatEnded: "chat_ended",
    ToolCall: "tool_call",
} as const;
export type ReturnWebhookEventType = (typeof ReturnWebhookEventType)[keyof typeof ReturnWebhookEventType];

```


## /src/api/resources/empathicVoice/types/ReturnWebhookSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Collection of webhook URL endpoints to be returned from the server
 */
export interface ReturnWebhookSpec {
    /** Events this URL is subscribed to */
    events: Hume.empathicVoice.ReturnWebhookEventType[];
    /** Webhook URL to send the event updates to */
    url: string;
}

```


## /src/api/resources/empathicVoice/types/Role.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const Role = {
    Assistant: "assistant",
    System: "system",
    User: "user",
    All: "all",
    Tool: "tool",
    Context: "context",
} as const;
export type Role = (typeof Role)[keyof typeof Role];

```


## /src/api/resources/empathicVoice/types/SessionSettings.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Settings for this chat session.
 */
export interface SessionSettings {
    /**
     * Configuration details for the audio input used during the session. Ensures the audio is being correctly set up for processing.
     *
     * This optional field is only required when the audio input is encoded in PCM Linear 16 (16-bit, little-endian, signed PCM WAV data). For detailed instructions on how to configure session settings for PCM Linear 16 audio, please refer to the [Session Settings section](/docs/empathic-voice-interface-evi/configuration#session-settings) on the EVI Configuration page.
     */
    audio?: Hume.empathicVoice.AudioConfiguration;
    /**
     * List of built-in tools to enable for the session.
     *
     * Tools are resources used by EVI to perform various tasks, such as searching the web or calling external APIs. Built-in tools, like web search, are natively integrated, while user-defined tools are created and invoked by the user. To learn more, see our [Tool Use Guide](/docs/empathic-voice-interface-evi/tool-use).
     *
     * Currently, the only built-in tool Hume provides is **Web Search**. When enabled, Web Search equips EVI with the ability to search the web for up-to-date information.
     */
    builtinTools?: Hume.empathicVoice.BuiltinToolConfig[];
    /**
     * Allows developers to inject additional context into the conversation, which is appended to the end of user messages for the session.
     *
     * When included in a Session Settings message, the provided context can be used to remind the LLM of its role in every user message, prevent it from forgetting important details, or add new relevant information to the conversation.
     *
     * Set to `null` to disable context injection.
     */
    context?: Hume.empathicVoice.Context;
    /**
     * Unique identifier for the session. Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions.
     *
     * If included, the response sent from Hume to your backend will include this ID. This allows you to correlate frontend users with their incoming messages.
     *
     * It is recommended to pass a `custom_session_id` if you are using a Custom Language Model. Please see our guide to [using a custom language model](/docs/empathic-voice-interface-evi/custom-language-model) with EVI to learn more.
     */
    customSessionId?: string;
    /**
     * Third party API key for the supplemental language model.
     *
     * When provided, EVI will use this key instead of Hume's API key for the supplemental LLM. This allows you to bypass rate limits and utilize your own API key as needed.
     */
    languageModelApiKey?: string;
    metadata?: Record<string, unknown>;
    /**
     * Instructions used to shape EVI's behavior, responses, and style for the session.
     *
     * When included in a Session Settings message, the provided Prompt overrides the existing one specified in the EVI configuration. If no Prompt was defined in the configuration, this Prompt will be the one used for the session.
     *
     * You can use the Prompt to define a specific goal or role for EVI, specifying how it should act or what it should focus on during the conversation. For example, EVI can be instructed to act as a customer support representative, a fitness coach, or a travel advisor, each with its own set of behaviors and response styles.
     *
     * For help writing a system prompt, see our [Prompting Guide](/docs/empathic-voice-interface-evi/prompting).
     */
    systemPrompt?: string;
    /**
     * List of user-defined tools to enable for the session.
     *
     * Tools are resources used by EVI to perform various tasks, such as searching the web or calling external APIs. Built-in tools, like web search, are natively integrated, while user-defined tools are created and invoked by the user. To learn more, see our [Tool Use Guide](/docs/empathic-voice-interface-evi/tool-use).
     */
    tools?: Hume.empathicVoice.Tool[];
    /**
     * The type of message sent through the socket; must be `session_settings` for our server to correctly identify and process it as a Session Settings message.
     *
     * Session settings are temporary and apply only to the current Chat session. These settings can be adjusted dynamically based on the requirements of each session to ensure optimal performance and user experience.
     *
     * For more information, please refer to the [Session Settings section](/docs/empathic-voice-interface-evi/configuration#session-settings) on the EVI Configuration page.
     */
    type: "session_settings";
    /** Dynamic values that can be used to populate EVI prompts. */
    variables?: Record<string, Hume.empathicVoice.SessionSettingsVariablesValue>;
    voiceId?: string;
}

```


## /src/api/resources/empathicVoice/types/SessionSettingsVariablesValue.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type SessionSettingsVariablesValue = string | number | boolean;

```


## /src/api/resources/empathicVoice/types/SubscribeEvent.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type SubscribeEvent =
    | Hume.empathicVoice.AssistantEnd
    | Hume.empathicVoice.AssistantMessage
    | Hume.empathicVoice.AssistantProsody
    | Hume.empathicVoice.AudioOutput
    | Hume.empathicVoice.ChatMetadata
    | Hume.empathicVoice.WebSocketError
    | Hume.empathicVoice.UserInterruption
    | Hume.empathicVoice.UserMessage
    | Hume.empathicVoice.ToolCallMessage
    | Hume.empathicVoice.ToolResponseMessage
    | Hume.empathicVoice.ToolErrorMessage
    | Hume.empathicVoice.SessionSettings;

```


## /src/api/resources/empathicVoice/types/Tool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface Tool {
    /** An optional description of what the tool does, used by the supplemental LLM to choose when and how to call the function. */
    description?: string;
    /** Optional text passed to the supplemental LLM if the tool call fails. The LLM then uses this text to generate a response back to the user, ensuring continuity in the conversation. */
    fallbackContent?: string;
    /** Name of the user-defined tool to be enabled. */
    name: string;
    /**
     * Parameters of the tool. Is a stringified JSON schema.
     *
     * These parameters define the inputs needed for the tool's execution, including the expected data type and description for each input field. Structured as a JSON schema, this format ensures the tool receives data in the expected format.
     */
    parameters: string;
    /** Type of tool. Set to `function` for user-defined tools. */
    type: Hume.empathicVoice.ToolType;
}

```


## /src/api/resources/empathicVoice/types/ToolCallMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * When provided, the output is a tool call.
 */
export interface ToolCallMessage {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Name of the tool called. */
    name: string;
    /** Parameters of the tool call. Is a stringified JSON schema. */
    parameters: string;
    /** Indicates whether a response to the tool call is required from the developer, either in the form of a [Tool Response message](/reference/empathic-voice-interface-evi/chat/chat#send.Tool%20Response%20Message.type) or a [Tool Error message](/reference/empathic-voice-interface-evi/chat/chat#send.Tool%20Error%20Message.type). */
    responseRequired: boolean;
    /**
     * The unique identifier for a specific tool call instance.
     *
     * This ID is used to track the request and response of a particular tool invocation, ensuring that the correct response is linked to the appropriate request.
     */
    toolCallId: string;
    /** Type of tool called. Either `builtin` for natively implemented tools, like web search, or `function` for user-defined tools. */
    toolType: Hume.empathicVoice.ToolType;
    /**
     * The type of message sent through the socket; for a Tool Call message, this must be `tool_call`.
     *
     * This message indicates that the supplemental LLM has detected a need to invoke the specified tool.
     */
    type: "tool_call";
}

```


## /src/api/resources/empathicVoice/types/ToolErrorMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * When provided, the output is a function call error.
 */
export interface ToolErrorMessage {
    /** Error code. Identifies the type of error encountered. */
    code?: string;
    /** Optional text passed to the supplemental LLM in place of the tool call result. The LLM then uses this text to generate a response back to the user, ensuring continuity in the conversation if the tool errors. */
    content?: string;
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Error message from the tool call, not exposed to the LLM or user. */
    error: string;
    /** Indicates the severity of an error; for a Tool Error message, this must be `warn` to signal an unexpected event. */
    level?: Hume.empathicVoice.ErrorLevel;
    /**
     * The unique identifier for a specific tool call instance.
     *
     * This ID is used to track the request and response of a particular tool invocation, ensuring that the Tool Error message is linked to the appropriate tool call request. The specified `tool_call_id` must match the one received in the [Tool Call message](/reference/empathic-voice-interface-evi/chat/chat#receive.Tool%20Call%20Message.type).
     */
    toolCallId: string;
    /** Type of tool called. Either `builtin` for natively implemented tools, like web search, or `function` for user-defined tools. */
    toolType?: Hume.empathicVoice.ToolType;
    /**
     * The type of message sent through the socket; for a Tool Error message, this must be `tool_error`.
     *
     * Upon receiving a [Tool Call message](/reference/empathic-voice-interface-evi/chat/chat#receive.Tool%20Call%20Message.type) and failing to invoke the function, this message is sent to notify EVI of the tool's failure.
     */
    type: "tool_error";
}

```


## /src/api/resources/empathicVoice/types/ToolResponseMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * When provided, the output is a function call response.
 */
export interface ToolResponseMessage {
    /** Return value of the tool call. Contains the output generated by the tool to pass back to EVI. */
    content: string;
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /**
     * The unique identifier for a specific tool call instance.
     *
     * This ID is used to track the request and response of a particular tool invocation, ensuring that the correct response is linked to the appropriate request. The specified `tool_call_id` must match the one received in the [Tool Call message](/reference/empathic-voice-interface-evi/chat/chat#receive.Tool%20Call%20Message.tool_call_id).
     */
    toolCallId: string;
    toolName?: string;
    toolType?: Hume.empathicVoice.ToolType;
    /**
     * The type of message sent through the socket; for a Tool Response message, this must be `tool_response`.
     *
     * Upon receiving a [Tool Call message](/reference/empathic-voice-interface-evi/chat/chat#receive.Tool%20Call%20Message.type) and successfully invoking the function, this message is sent to convey the result of the function call back to EVI.
     */
    type: "tool_response";
}

```


## /src/api/resources/empathicVoice/types/ToolType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const ToolType = {
    Builtin: "builtin",
    Function: "function",
} as const;
export type ToolType = (typeof ToolType)[keyof typeof ToolType];

```


## /src/api/resources/empathicVoice/types/UserInput.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * User text to insert into the conversation. Text sent through a User Input message is treated as the user's speech to EVI. EVI processes this input and provides a corresponding response.
 *
 * Expression measurement results are not available for User Input messages, as the prosody model relies on audio input and cannot process text alone.
 */
export interface UserInput {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /**
     * User text to insert into the conversation. Text sent through a User Input message is treated as the user's speech to EVI. EVI processes this input and provides a corresponding response.
     *
     * Expression measurement results are not available for User Input messages, as the prosody model relies on audio input and cannot process text alone.
     */
    text: string;
    /** The type of message sent through the socket; must be `user_input` for our server to correctly identify and process it as a User Input message. */
    type: "user_input";
}

```


## /src/api/resources/empathicVoice/types/UserInterruption.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * When provided, the output is an interruption.
 */
export interface UserInterruption {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Unix timestamp of the detected user interruption. */
    time: number;
    /**
     * The type of message sent through the socket; for a User Interruption message, this must be `user_interruption`.
     *
     * This message indicates the user has interrupted the assistant's response. EVI detects the interruption in real-time and sends this message to signal the interruption event. This message allows the system to stop the current audio playback, clear the audio queue, and prepare to handle new user input.
     */
    type: "user_interruption";
}

```


## /src/api/resources/empathicVoice/types/UserMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * When provided, the output is a user message.
 */
export interface UserMessage {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Indicates if this message was inserted into the conversation as text from a [User Input](/reference/empathic-voice-interface-evi/chat/chat#send.User%20Input.text) message. */
    fromText: boolean;
    /** Indicates if this message contains an immediate and unfinalized transcript of the user's audio input. If it does, words may be repeated across successive UserMessage messages as our transcription model becomes more confident about what was said with additional context. Interim messages are useful to detect if the user is interrupting during audio playback on the client. Even without a finalized transcription, along with `UserInterrupt` messages, interim `UserMessages` are useful for detecting if the user is interrupting during audio playback on the client, signaling to stop playback in your application. */
    interim: boolean;
    /** Detected language of the message text. */
    language?: string;
    /** Transcript of the message. */
    message: Hume.empathicVoice.ChatMessage;
    /** Inference model results. */
    models: Hume.empathicVoice.Inference;
    /** Start and End time of user message. */
    time: Hume.empathicVoice.MillisecondInterval;
    type: "user_message";
}

```


## /src/api/resources/empathicVoice/types/ValidationError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ValidationError {
    loc: Hume.empathicVoice.ValidationErrorLocItem[];
    msg: string;
    type: string;
}

```


## /src/api/resources/empathicVoice/types/ValidationErrorLocItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type ValidationErrorLocItem = string | number;

```


## /src/api/resources/empathicVoice/types/VoiceId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface VoiceId {
    /** The unique ID associated with the **Voice**. */
    id: string;
    /**
     * Specifies the source provider associated with the chosen voice.
     *
     * - **`HUME_AI`**: Select voices from Hume's [Voice Library](https://app.hume.ai/voices), containing a variety of preset, shared voices.
     * - **`CUSTOM_VOICE`**: Select from voices you've personally generated and saved in your account.
     *
     * If no provider is explicitly set, the default provider is `CUSTOM_VOICE`. When using voices from Hume's **Voice Library**, you must explicitly set the provider to `HUME_AI`.
     *
     * Preset voices from Hume's **Voice Library** are accessible by all users. In contrast, your custom voices are private and accessible only via requests authenticated with your API key.
     */
    provider?: Hume.empathicVoice.VoiceProvider;
}

```


## /src/api/resources/empathicVoice/types/VoiceName.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface VoiceName {
    /** The name of a **Voice**. */
    name: string;
    /**
     * Specifies the source provider associated with the chosen voice.
     *
     * - **`HUME_AI`**: Select voices from Hume's [Voice Library](https://app.hume.ai/voices), containing a variety of preset, shared voices.
     * - **`CUSTOM_VOICE`**: Select from voices you've personally generated and saved in your account.
     *
     * If no provider is explicitly set, the default provider is `CUSTOM_VOICE`. When using voices from Hume's **Voice Library**, you must explicitly set the provider to `HUME_AI`.
     *
     * Preset voices from Hume's **Voice Library** are accessible by all users. In contrast, your custom voices are private and accessible only via requests authenticated with your API key.
     */
    provider?: Hume.empathicVoice.VoiceProvider;
}

```


## /src/api/resources/empathicVoice/types/VoiceProvider.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const VoiceProvider = {
    HumeAi: "HUME_AI",
    CustomVoice: "CUSTOM_VOICE",
} as const;
export type VoiceProvider = (typeof VoiceProvider)[keyof typeof VoiceProvider];

```


## /src/api/resources/empathicVoice/types/VoiceRef.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type VoiceRef = Hume.empathicVoice.VoiceId | Hume.empathicVoice.VoiceName;

```


## /src/api/resources/empathicVoice/types/WebSocketError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * When provided, the output is an error message.
 */
export interface WebSocketError {
    /** Error code. Identifies the type of error encountered. */
    code: string;
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Detailed description of the error. */
    message: string;
    /** ID of the initiating request. */
    requestId?: string;
    /** Short, human-readable identifier and description for the error. See a complete list of error slugs on the [Errors page](/docs/resources/errors). */
    slug: string;
    /**
     * The type of message sent through the socket; for a Web Socket Error message, this must be `error`.
     *
     * This message indicates a disruption in the WebSocket connection, such as an unexpected disconnection, protocol error, or data transmission issue.
     */
    type: "error";
}

```


## /src/api/resources/empathicVoice/types/WebhookEvent.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type WebhookEvent =
    | Hume.empathicVoice.WebhookEventChatStarted
    | Hume.empathicVoice.WebhookEventChatEnded
    | Hume.empathicVoice.WebhookEventToolCall;

```


## /src/api/resources/empathicVoice/types/WebhookEventBase.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * Represents the fields common to all webhook events.
 */
export interface WebhookEventBase {
    /** Unique ID of the **Chat Group** associated with the **Chat** session. */
    chatGroupId: string;
    /** Unique ID of the **Chat** session. */
    chatId: string;
    /** Unique ID of the EVI **Config** used for the session. */
    configId?: string;
}

```


## /src/api/resources/empathicVoice/types/WebhookEventChatEnded.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface WebhookEventChatEnded extends Hume.empathicVoice.WebhookEventBase {
    /** Phone number of the caller in E.164 format (e.g., `+12223333333`). This field is included only if the Chat was created via the [Twilio phone calling](/docs/empathic-voice-interface-evi/phone-calling) integration. */
    callerNumber?: string;
    /** User-defined session ID. Relevant only when employing a [custom language model](/docs/empathic-voice-interface-evi/custom-language-model) in the EVI Config. */
    customSessionId?: string;
    /** Total duration of the session in seconds. */
    durationSeconds: number;
    /** Reason for the session's termination. */
    endReason: Hume.empathicVoice.WebhookEventChatStatus;
    /** Unix timestamp (in milliseconds) indicating when the session ended. */
    endTime: number;
    /** Always `chat_ended`. */
    eventName?: "chat_ended";
}

```


## /src/api/resources/empathicVoice/types/WebhookEventChatStartType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const WebhookEventChatStartType = {
    NewChatGroup: "new_chat_group",
    ResumedChatGroup: "resumed_chat_group",
} as const;
export type WebhookEventChatStartType = (typeof WebhookEventChatStartType)[keyof typeof WebhookEventChatStartType];

```


## /src/api/resources/empathicVoice/types/WebhookEventChatStarted.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface WebhookEventChatStarted extends Hume.empathicVoice.WebhookEventBase {
    /** Phone number of the caller in E.164 format (e.g., `+12223333333`). This field is included only if the Chat was created via the [Twilio phone calling](/docs/empathic-voice-interface-evi/phone-calling) integration. */
    callerNumber?: string;
    /** Indicates whether the chat is the first in a new Chat Group (`new_chat_group`) or the continuation of an existing chat group (`resumed_chat_group`). */
    chatStartType: Hume.empathicVoice.WebhookEventChatStartType;
    /** User-defined session ID. Relevant only when employing a [custom language model](/docs/empathic-voice-interface-evi/custom-language-model) in the EVI Config. */
    customSessionId?: string;
    /** Always `chat_started`. */
    eventName?: "chat_started";
    /** Unix timestamp (in milliseconds) indicating when the session started. */
    startTime: number;
}

```


## /src/api/resources/empathicVoice/types/WebhookEventChatStatus.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const WebhookEventChatStatus = {
    Active: "ACTIVE",
    UserEnded: "USER_ENDED",
    UserTimeout: "USER_TIMEOUT",
    InactivityTimeout: "INACTIVITY_TIMEOUT",
    MaxDurationTimeout: "MAX_DURATION_TIMEOUT",
    SilenceTimeout: "SILENCE_TIMEOUT",
    Error: "ERROR",
} as const;
export type WebhookEventChatStatus = (typeof WebhookEventChatStatus)[keyof typeof WebhookEventChatStatus];

```


## /src/api/resources/empathicVoice/types/WebhookEventToolCall.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface WebhookEventToolCall extends Hume.empathicVoice.WebhookEventBase {
    /** Phone number of the caller in E.164 format (e.g., `+12223333333`). This field is included only if the Chat was created via the [Twilio phone calling](/docs/empathic-voice-interface-evi/phone-calling) integration. */
    callerNumber?: string;
    /** User-defined session ID. Relevant only when employing a [custom language model](/docs/empathic-voice-interface-evi/custom-language-model) in the EVI Config. */
    customSessionId?: string;
    /** Always `tool_call`. */
    eventName?: "tool_call";
    /** Unix timestamp (in milliseconds) indicating when the tool call was triggered. */
    timestamp: number;
    /** The tool call. */
    toolCallMessage: Hume.empathicVoice.ToolCallMessage;
}

```


## /src/api/resources/empathicVoice/types/index.ts
```typescript
export * from "./AssistantEnd.js";
export * from "./AssistantInput.js";
export * from "./AssistantMessage.js";
export * from "./AssistantProsody.js";
export * from "./AudioConfiguration.js";
export * from "./AudioInput.js";
export * from "./AudioOutput.js";
export * from "./BuiltInTool.js";
export * from "./BuiltinToolConfig.js";
export * from "./ChatMessage.js";
export * from "./ChatMessageToolResult.js";
export * from "./ChatMetadata.js";
export * from "./ConnectSessionSettings.js";
export * from "./ConnectSessionSettingsAudio.js";
export * from "./ConnectSessionSettingsContext.js";
export * from "./ConnectSessionSettingsVariablesValue.js";
export * from "./Context.js";
export * from "./ContextType.js";
export * from "./ControlPlanePublishEvent.js";
export * from "./EmotionScores.js";
export * from "./Encoding.js";
export * from "./ErrorLevel.js";
export * from "./ErrorResponse.js";
export * from "./HttpValidationError.js";
export * from "./Inference.js";
export * from "./JsonMessage.js";
export * from "./LanguageModelType.js";
export * from "./MillisecondInterval.js";
export * from "./ModelProviderEnum.js";
export * from "./PauseAssistantMessage.js";
export * from "./PostedBuiltinTool.js";
export * from "./PostedBuiltinToolName.js";
export * from "./PostedConfigPromptSpec.js";
export * from "./PostedEllmModel.js";
export * from "./PostedEventMessageSpec.js";
export * from "./PostedEventMessageSpecs.js";
export * from "./PostedLanguageModel.js";
export * from "./PostedNudgeSpec.js";
export * from "./PostedTimeoutSpec.js";
export * from "./PostedTimeoutSpecs.js";
export * from "./PostedTimeoutSpecsInactivity.js";
export * from "./PostedTimeoutSpecsMaxDuration.js";
export * from "./PostedUserDefinedToolSpec.js";
export * from "./PostedWebhookEventType.js";
export * from "./PostedWebhookSpec.js";
export * from "./ProsodyInference.js";
export * from "./ResumeAssistantMessage.js";
export * from "./ReturnBuiltinTool.js";
export * from "./ReturnBuiltinToolToolType.js";
export * from "./ReturnChat.js";
export * from "./ReturnChatAudioReconstruction.js";
export * from "./ReturnChatAudioReconstructionStatus.js";
export * from "./ReturnChatEvent.js";
export * from "./ReturnChatEventRole.js";
export * from "./ReturnChatEventType.js";
export * from "./ReturnChatGroup.js";
export * from "./ReturnChatGroupPagedAudioReconstructions.js";
export * from "./ReturnChatGroupPagedAudioReconstructionsPaginationDirection.js";
export * from "./ReturnChatGroupPagedChats.js";
export * from "./ReturnChatGroupPagedChatsPaginationDirection.js";
export * from "./ReturnChatGroupPagedEvents.js";
export * from "./ReturnChatGroupPagedEventsPaginationDirection.js";
export * from "./ReturnChatPagedEvents.js";
export * from "./ReturnChatPagedEventsPaginationDirection.js";
export * from "./ReturnChatPagedEventsStatus.js";
export * from "./ReturnChatStatus.js";
export * from "./ReturnConfig.js";
export * from "./ReturnConfigSpec.js";
export * from "./ReturnEllmModel.js";
export * from "./ReturnEventMessageSpec.js";
export * from "./ReturnEventMessageSpecs.js";
export * from "./ReturnLanguageModel.js";
export * from "./ReturnNudgeSpec.js";
export * from "./ReturnPagedChatGroups.js";
export * from "./ReturnPagedChatGroupsPaginationDirection.js";
export * from "./ReturnPagedChats.js";
export * from "./ReturnPagedChatsPaginationDirection.js";
export * from "./ReturnPagedConfigs.js";
export * from "./ReturnPagedPrompts.js";
export * from "./ReturnPagedUserDefinedTools.js";
export * from "./ReturnPrompt.js";
export * from "./ReturnPromptVersionType.js";
export * from "./ReturnTimeoutSpec.js";
export * from "./ReturnTimeoutSpecs.js";
export * from "./ReturnUserDefinedTool.js";
export * from "./ReturnUserDefinedToolToolType.js";
export * from "./ReturnUserDefinedToolVersionType.js";
export * from "./ReturnVoice.js";
export * from "./ReturnWebhookEventType.js";
export * from "./ReturnWebhookSpec.js";
export * from "./Role.js";
export * from "./SessionSettings.js";
export * from "./SessionSettingsVariablesValue.js";
export * from "./SubscribeEvent.js";
export * from "./Tool.js";
export * from "./ToolCallMessage.js";
export * from "./ToolErrorMessage.js";
export * from "./ToolResponseMessage.js";
export * from "./ToolType.js";
export * from "./UserInput.js";
export * from "./UserInterruption.js";
export * from "./UserMessage.js";
export * from "./ValidationError.js";
export * from "./ValidationErrorLocItem.js";
export * from "./VoiceId.js";
export * from "./VoiceName.js";
export * from "./VoiceProvider.js";
export * from "./VoiceRef.js";
export * from "./WebhookEvent.js";
export * from "./WebhookEventBase.js";
export * from "./WebhookEventChatEnded.js";
export * from "./WebhookEventChatStarted.js";
export * from "./WebhookEventChatStartType.js";
export * from "./WebhookEventChatStatus.js";
export * from "./WebhookEventToolCall.js";
export * from "./WebSocketError.js";

```


## /src/api/resources/expressionMeasurement/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { BatchClient } from "../resources/batch/client/Client.js";

export declare namespace ExpressionMeasurementClient {
    export type Options = BaseClientOptions;
}

export class ExpressionMeasurementClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ExpressionMeasurementClient.Options>;
    protected _batch: BatchClient | undefined;

    constructor(options: ExpressionMeasurementClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    public get batch(): BatchClient {
        return (this._batch ??= new BatchClient(this._options));
    }
}

```


## /src/api/resources/expressionMeasurement/client/index.ts
```typescript
export {};

```


## /src/api/resources/expressionMeasurement/index.ts
```typescript
export * from "./client/index.js";
export * from "./resources/index.js";

```


## /src/api/resources/expressionMeasurement/resources/batch/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import { toJson } from "../../../../../../core/json.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import type * as Hume from "../../../../../index.js";

export declare namespace BatchClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class BatchClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<BatchClient.Options>;

    constructor(options: BatchClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Sort and filter jobs.
     *
     * @param {Hume.expressionMeasurement.batch.BatchListJobsRequest} request
     * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.listJobs()
     */
    public listJobs(
        request: Hume.expressionMeasurement.batch.BatchListJobsRequest = {},
        requestOptions?: BatchClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.UnionJob[]> {
        return core.HttpResponsePromise.fromPromise(this.__listJobs(request, requestOptions));
    }

    private async __listJobs(
        request: Hume.expressionMeasurement.batch.BatchListJobsRequest = {},
        requestOptions?: BatchClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.UnionJob[]>> {
        const { limit, status, when, timestampMs, sortBy, direction } = request;
        const _queryParams: Record<string, unknown> = {
            limit,
            status: Array.isArray(status)
                ? status.map((item) =>
                      serializers.expressionMeasurement.batch.Status.jsonOrThrow(item, {
                          unrecognizedObjectKeys: "strip",
                          omitUndefined: true,
                      }),
                  )
                : status != null
                  ? serializers.expressionMeasurement.batch.Status.jsonOrThrow(status, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    })
                  : undefined,
            when:
                when != null
                    ? serializers.expressionMeasurement.batch.When.jsonOrThrow(when, {
                          unrecognizedObjectKeys: "strip",
                          omitUndefined: true,
                      })
                    : undefined,
            timestamp_ms: timestampMs,
            sort_by:
                sortBy != null
                    ? serializers.expressionMeasurement.batch.SortBy.jsonOrThrow(sortBy, {
                          unrecognizedObjectKeys: "strip",
                          omitUndefined: true,
                      })
                    : undefined,
            direction:
                direction != null
                    ? serializers.expressionMeasurement.batch.Direction.jsonOrThrow(direction, {
                          unrecognizedObjectKeys: "strip",
                          omitUndefined: true,
                      })
                    : undefined,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/batch/jobs",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.expressionMeasurement.batch.listJobs.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/batch/jobs");
    }

    /**
     * Start a new measurement inference job.
     *
     * @param {Hume.expressionMeasurement.batch.InferenceBaseRequest} request
     * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.startInferenceJob({
     *         urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
     *         notify: true
     *     })
     */
    public startInferenceJob(
        request: Hume.expressionMeasurement.batch.InferenceBaseRequest,
        requestOptions?: BatchClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.JobId> {
        return core.HttpResponsePromise.fromPromise(this.__startInferenceJob(request, requestOptions));
    }

    private async __startInferenceJob(
        request: Hume.expressionMeasurement.batch.InferenceBaseRequest,
        requestOptions?: BatchClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.JobId>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/batch/jobs",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.expressionMeasurement.batch.InferenceBaseRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.expressionMeasurement.batch.JobId.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/batch/jobs");
    }

    /**
     * Get the request details and state of a given job.
     *
     * @param {string} id - The unique identifier for the job.
     * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.getJobDetails("job_id")
     */
    public getJobDetails(
        id: string,
        requestOptions?: BatchClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.UnionJob> {
        return core.HttpResponsePromise.fromPromise(this.__getJobDetails(id, requestOptions));
    }

    private async __getJobDetails(
        id: string,
        requestOptions?: BatchClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.UnionJob>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/batch/jobs/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.expressionMeasurement.batch.UnionJob.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/batch/jobs/{id}");
    }

    /**
     * Get the JSON predictions of a completed inference job.
     *
     * @param {string} id - The unique identifier for the job.
     * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.getJobPredictions("job_id")
     */
    public getJobPredictions(
        id: string,
        requestOptions?: BatchClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.UnionPredictResult[]> {
        return core.HttpResponsePromise.fromPromise(this.__getJobPredictions(id, requestOptions));
    }

    private async __getJobPredictions(
        id: string,
        requestOptions?: BatchClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.UnionPredictResult[]>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/batch/jobs/${core.url.encodePathParam(id)}/predictions`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.expressionMeasurement.batch.getJobPredictions.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v0/batch/jobs/{id}/predictions",
        );
    }

    /**
     * Get the artifacts ZIP of a completed inference job.
     */
    public getJobArtifacts(
        id: string,
        requestOptions?: BatchClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getJobArtifacts(id, requestOptions));
    }

    private async __getJobArtifacts(
        id: string,
        requestOptions?: BatchClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/batch/jobs/${core.url.encodePathParam(id)}/artifacts`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/batch/jobs/{id}/artifacts");
    }

    /**
     * Start a new batch inference job.
     *
     * @param {Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest} request
     * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.expressionMeasurement.batch.startInferenceJobFromLocalFile({
     *         file: [fs.createReadStream("/path/to/your/file")]
     *     })
     */
    public startInferenceJobFromLocalFile(
        request: Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest,
        requestOptions?: BatchClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.JobId> {
        return core.HttpResponsePromise.fromPromise(this.__startInferenceJobFromLocalFile(request, requestOptions));
    }

    private async __startInferenceJobFromLocalFile(
        request: Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest,
        requestOptions?: BatchClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.JobId>> {
        const _body = await core.newFormData();
        if (request.json != null) {
            _body.append(
                "json",
                toJson(
                    serializers.expressionMeasurement.batch.InferenceBaseRequest.jsonOrThrow(request.json, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    }),
                ),
            );
        }

        for (const _file of request.file) {
            await _body.appendFile("file", _file);
        }

        const _maybeEncodedRequest = await _body.getRequest();
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ..._maybeEncodedRequest.headers }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/batch/jobs",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.expressionMeasurement.batch.JobId.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/batch/jobs");
    }
}

```


## /src/api/resources/expressionMeasurement/resources/batch/client/index.ts
```typescript
export * from "./requests/index.js";

```


## /src/api/resources/expressionMeasurement/resources/batch/client/requests/BatchListJobsRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../index.js";

/**
 * @example
 *     {}
 */
export interface BatchListJobsRequest {
    /** The maximum number of jobs to include in the response. */
    limit?: number;
    /**
     * Include only jobs of this status in the response. There are four possible statuses:
     *
     * - `QUEUED`: The job has been received and is waiting to be processed.
     *
     * - `IN_PROGRESS`: The job is currently being processed.
     *
     * - `COMPLETED`: The job has finished processing.
     *
     * - `FAILED`: The job encountered an error and could not be completed successfully.
     */
    status?: Hume.expressionMeasurement.batch.Status | Hume.expressionMeasurement.batch.Status[];
    /** Specify whether to include jobs created before or after a given `timestamp_ms`. */
    when?: Hume.expressionMeasurement.batch.When;
    /**
     * Provide a timestamp in milliseconds to filter jobs.
     *
     *  When combined with the `when` parameter, you can filter jobs before or after the given timestamp. Defaults to the current Unix timestamp if one is not provided.
     */
    timestampMs?: number;
    /**
     * Specify which timestamp to sort the jobs by.
     *
     * - `created`: Sort jobs by the time of creation, indicated by `created_timestamp_ms`.
     *
     * - `started`: Sort jobs by the time processing started, indicated by `started_timestamp_ms`.
     *
     * - `ended`: Sort jobs by the time processing ended, indicated by `ended_timestamp_ms`.
     */
    sortBy?: Hume.expressionMeasurement.batch.SortBy;
    /**
     * Specify the order in which to sort the jobs. Defaults to descending order.
     *
     * - `asc`: Sort in ascending order (chronological, with the oldest records first).
     *
     * - `desc`: Sort in descending order (reverse-chronological, with the newest records first).
     */
    direction?: Hume.expressionMeasurement.batch.Direction;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/client/requests/BatchStartInferenceJobFromLocalFileRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../../../../core/index.js";
import type * as Hume from "../../../../../../index.js";

/**
 * @example
 *     {
 *         file: [fs.createReadStream("/path/to/your/file")]
 *     }
 */
export interface BatchStartInferenceJobFromLocalFileRequest {
    /** Stringified JSON object containing the inference job configuration. */
    json?: Hume.expressionMeasurement.batch.InferenceBaseRequest;
    /**
     * Local media files (see recommended input filetypes) to be processed.
     *
     * If you wish to supply more than 100 files, consider providing them as an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`).
     */
    file: core.file.Uploadable[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/client/requests/index.ts
```typescript
export type { BatchListJobsRequest } from "./BatchListJobsRequest.js";
export type { BatchStartInferenceJobFromLocalFileRequest } from "./BatchStartInferenceJobFromLocalFileRequest.js";

```


## /src/api/resources/expressionMeasurement/resources/batch/index.ts
```typescript
export * from "./client/index.js";
export * from "./types/index.js";

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Alternative.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type Alternative = "language_only";

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Bcp47Tag.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const Bcp47Tag = {
    Zh: "zh",
    Da: "da",
    Nl: "nl",
    En: "en",
    EnAu: "en-AU",
    EnIn: "en-IN",
    EnNz: "en-NZ",
    EnGb: "en-GB",
    Fr: "fr",
    FrCa: "fr-CA",
    De: "de",
    Hi: "hi",
    HiLatn: "hi-Latn",
    Id: "id",
    It: "it",
    Ja: "ja",
    Ko: "ko",
    No: "no",
    Pl: "pl",
    Pt: "pt",
    PtBr: "pt-BR",
    PtPt: "pt-PT",
    Ru: "ru",
    Es: "es",
    Es419: "es-419",
    Sv: "sv",
    Ta: "ta",
    Tr: "tr",
    Uk: "uk",
} as const;
export type Bcp47Tag = (typeof Bcp47Tag)[keyof typeof Bcp47Tag];

```


## /src/api/resources/expressionMeasurement/resources/batch/types/BoundingBox.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * A bounding box around a face.
 */
export interface BoundingBox {
    /** x-coordinate of bounding box top left corner. */
    x: number;
    /** y-coordinate of bounding box top left corner. */
    y: number;
    /** Bounding box width. */
    w: number;
    /** Bounding box height. */
    h: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/BurstPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface BurstPrediction {
    time: Hume.expressionMeasurement.batch.TimeInterval;
    /** A high-dimensional embedding in emotion space. */
    emotions: Hume.expressionMeasurement.batch.EmotionScore[];
    /** Modality-specific descriptive features and their scores. */
    descriptions: Hume.expressionMeasurement.batch.DescriptionsScore[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Classification.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type Classification = Record<string, unknown>;

```


## /src/api/resources/expressionMeasurement/resources/batch/types/CompletedEmbeddingGeneration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface CompletedEmbeddingGeneration {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
    /** When this job started (Unix timestamp in milliseconds). */
    startedTimestampMs: number;
    /** When this job ended (Unix timestamp in milliseconds). */
    endedTimestampMs: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/CompletedInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface CompletedInference {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
    /** When this job started (Unix timestamp in milliseconds). */
    startedTimestampMs: number;
    /** When this job ended (Unix timestamp in milliseconds). */
    endedTimestampMs: number;
    /** The number of predictions that were generated by this job. */
    numPredictions: number;
    /** The number of errors that occurred while running this job. */
    numErrors: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/CompletedState.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface CompletedState extends Hume.expressionMeasurement.batch.CompletedInference {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/CompletedTlInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface CompletedTlInference {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
    /** When this job started (Unix timestamp in milliseconds). */
    startedTimestampMs: number;
    /** When this job ended (Unix timestamp in milliseconds). */
    endedTimestampMs: number;
    /** The number of predictions that were generated by this job. */
    numPredictions: number;
    /** The number of errors that occurred while running this job. */
    numErrors: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/CompletedTraining.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface CompletedTraining {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
    /** When this job started (Unix timestamp in milliseconds). */
    startedTimestampMs: number;
    /** When this job ended (Unix timestamp in milliseconds). */
    endedTimestampMs: number;
    customModel: Hume.expressionMeasurement.batch.TrainingCustomModel;
    alternatives?: Record<string, Hume.expressionMeasurement.batch.TrainingCustomModel>;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/CustomModel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type CustomModel =
    | Hume.expressionMeasurement.batch.CustomModelId
    | Hume.expressionMeasurement.batch.CustomModelVersionId;

```


## /src/api/resources/expressionMeasurement/resources/batch/types/CustomModelId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface CustomModelId {
    id: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/CustomModelPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface CustomModelPrediction {
    output: Record<string, number>;
    error: string;
    taskType: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/CustomModelRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface CustomModelRequest {
    name: string;
    description?: string;
    tags?: Hume.expressionMeasurement.batch.Tag[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/CustomModelVersionId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface CustomModelVersionId {
    versionId: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/CustomModelsInferenceJob.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface CustomModelsInferenceJob extends Hume.expressionMeasurement.batch.JobTlInference {
    type: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/CustomModelsTrainingJob.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface CustomModelsTrainingJob extends Hume.expressionMeasurement.batch.JobTraining {
    type: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Dataset.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type Dataset = Hume.expressionMeasurement.batch.DatasetId | Hume.expressionMeasurement.batch.DatasetVersionId;

```


## /src/api/resources/expressionMeasurement/resources/batch/types/DatasetId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface DatasetId {
    id: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/DatasetVersionId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface DatasetVersionId {
    versionId: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/DescriptionsScore.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface DescriptionsScore {
    /** Name of the descriptive feature being expressed. */
    name: string;
    /** Embedding value for the descriptive feature being expressed. */
    score: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Direction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const Direction = {
    Asc: "asc",
    Desc: "desc",
} as const;
export type Direction = (typeof Direction)[keyof typeof Direction];

```


## /src/api/resources/expressionMeasurement/resources/batch/types/EmbeddingGenerationBaseRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface EmbeddingGenerationBaseRequest {
    /** File ID and File URL pairs for an asset registry file */
    registryFileDetails?: Hume.expressionMeasurement.batch.RegistryFileDetail[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/EmbeddingGenerationJob.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface EmbeddingGenerationJob extends Hume.expressionMeasurement.batch.JobEmbeddingGeneration {
    type: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/EmotionScore.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface EmotionScore {
    /** Name of the emotion being expressed. */
    name: string;
    /** Embedding value for the emotion being expressed. */
    score: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Error_.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface Error_ {
    /** An error message. */
    message: string;
    /** A file path relative to the top level source URL or file. */
    file: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/EvaluationArgs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface EvaluationArgs {
    validation?: Hume.expressionMeasurement.batch.ValidationArgs;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Face.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * The Facial Emotional Expression model analyzes human facial expressions in images and videos. Results will be provided per frame for video files.
 *
 * Recommended input file types: `.png`, `.jpeg`, `.mp4`
 */
export interface Face {
    /** Number of frames per second to process. Other frames will be omitted from the response. Set to `0` to process every frame. */
    fpsPred?: number;
    /** Face detection probability threshold. Faces detected with a probability less than this threshold will be omitted from the response. */
    probThreshold?: number;
    /** Whether to return identifiers for faces across frames. If `true`, unique identifiers will be assigned to face bounding boxes to differentiate different faces. If `false`, all faces will be tagged with an `unknown` ID. */
    identifyFaces?: boolean;
    /** Minimum bounding box side length in pixels to treat as a face. Faces detected with a bounding box side length in pixels less than this threshold will be omitted from the response. */
    minFaceSize?: number;
    facs?: Hume.expressionMeasurement.batch.Unconfigurable;
    descriptions?: Hume.expressionMeasurement.batch.Unconfigurable;
    /** Whether to extract and save the detected faces in the artifacts zip created by each job. */
    saveFaces?: boolean;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/FacePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface FacePrediction {
    /** Frame number */
    frame: number;
    /** Time in seconds when face detection occurred. */
    time: number;
    /** The predicted probability that a detected face was actually a face. */
    prob: number;
    box: Hume.expressionMeasurement.batch.BoundingBox;
    /** A high-dimensional embedding in emotion space. */
    emotions: Hume.expressionMeasurement.batch.EmotionScore[];
    /** FACS 2.0 features and their scores. */
    facs?: Hume.expressionMeasurement.batch.FacsScore[];
    /** Modality-specific descriptive features and their scores. */
    descriptions?: Hume.expressionMeasurement.batch.DescriptionsScore[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/FacemeshPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface FacemeshPrediction {
    /** A high-dimensional embedding in emotion space. */
    emotions: Hume.expressionMeasurement.batch.EmotionScore[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/FacsScore.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface FacsScore {
    /** Name of the FACS 2.0 feature being expressed. */
    name: string;
    /** Embedding value for the FACS 2.0 feature being expressed. */
    score: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Failed.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface Failed {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
    /** When this job started (Unix timestamp in milliseconds). */
    startedTimestampMs: number;
    /** When this job ended (Unix timestamp in milliseconds). */
    endedTimestampMs: number;
    /** An error message. */
    message: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/FailedState.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface FailedState extends Hume.expressionMeasurement.batch.Failed {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/File_.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * The list of files submitted for analysis.
 */
export interface File_ {
    /** The name of the file. */
    filename?: string;
    /** The content type of the file. */
    contentType?: string;
    /** The MD5 checksum of the file. */
    md5Sum: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Granularity.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * The granularity at which to generate predictions. The `granularity` field is ignored if transcription is not enabled or if the `window` field has been set.
 *
 * - `word`: At the word level, our model provides a separate output for each word, offering the most granular insight into emotional expression during speech.
 *
 * - `sentence`: At the sentence level of granularity, we annotate the emotional tone of each spoken sentence with our Prosody and Emotional Language models.
 *
 * - `utterance`: Utterance-level granularity is between word- and sentence-level. It takes into account natural pauses or breaks in speech, providing more rapidly updated measures of emotional expression within a flowing conversation. For text inputs, utterance-level granularity will produce results identical to sentence-level granularity.
 *
 * - `conversational_turn`: Conversational turn-level granularity provides a distinct output for each change in speaker. It captures the full sequence of words and sentences spoken uninterrupted by each person. This approach provides a higher-level view of the emotional dynamics in a multi-participant dialogue. For text inputs, specifying conversational turn-level granularity for our Emotional Language model will produce results for the entire passage.
 */
export const Granularity = {
    Word: "word",
    Sentence: "sentence",
    Utterance: "utterance",
    ConversationalTurn: "conversational_turn",
} as const;
export type Granularity = (typeof Granularity)[keyof typeof Granularity];

```


## /src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsBurstPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface GroupedPredictionsBurstPrediction {
    /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
    id: string;
    predictions: Hume.expressionMeasurement.batch.BurstPrediction[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsFacePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface GroupedPredictionsFacePrediction {
    /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
    id: string;
    predictions: Hume.expressionMeasurement.batch.FacePrediction[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsFacemeshPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface GroupedPredictionsFacemeshPrediction {
    /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
    id: string;
    predictions: Hume.expressionMeasurement.batch.FacemeshPrediction[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsLanguagePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface GroupedPredictionsLanguagePrediction {
    /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
    id: string;
    predictions: Hume.expressionMeasurement.batch.LanguagePrediction[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsNerPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface GroupedPredictionsNerPrediction {
    /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
    id: string;
    predictions: Hume.expressionMeasurement.batch.NerPrediction[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsProsodyPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface GroupedPredictionsProsodyPrediction {
    /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
    id: string;
    predictions: Hume.expressionMeasurement.batch.ProsodyPrediction[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/InProgress.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface InProgress {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
    /** When this job started (Unix timestamp in milliseconds). */
    startedTimestampMs: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/InProgressState.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InProgressState extends Hume.expressionMeasurement.batch.InProgress {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/InferenceBaseRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InferenceBaseRequest {
    /**
     * Specify the models to use for inference.
     *
     * If this field is not explicitly set, then all models will run by default.
     */
    models?: Hume.expressionMeasurement.batch.Models;
    transcription?: Hume.expressionMeasurement.batch.Transcription;
    /**
     * URLs to the media files to be processed. Each must be a valid public URL to a media file (see recommended input filetypes) or an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`) of media files.
     *
     * If you wish to supply more than 100 URLs, consider providing them as an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`).
     */
    urls?: string[];
    /** Text supplied directly to our Emotional Language and NER models for analysis. */
    text?: string[];
    /** If provided, a `POST` request will be made to the URL with the generated predictions on completion or the error message on failure. */
    callbackUrl?: string;
    /** Whether to send an email notification to the user upon job completion/failure. */
    notify?: boolean;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/InferenceJob.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InferenceJob extends Hume.expressionMeasurement.batch.JobInference {
    /**
     * Denotes the job type.
     *
     * Jobs created with the Expression Measurement API will have this field set to `INFERENCE`.
     */
    type: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/InferencePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InferencePrediction {
    /** A file path relative to the top level source URL or file. */
    file: string;
    models: Hume.expressionMeasurement.batch.ModelsPredictions;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/InferenceRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InferenceRequest {
    models?: Hume.expressionMeasurement.batch.Models;
    transcription?: Hume.expressionMeasurement.batch.Transcription;
    /**
     * URLs to the media files to be processed. Each must be a valid public URL to a media file (see recommended input filetypes) or an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`) of media files.
     *
     * If you wish to supply more than 100 URLs, consider providing them as an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`).
     */
    urls?: string[];
    /** Text to supply directly to our language and NER models. */
    text?: string[];
    /** If provided, a `POST` request will be made to the URL with the generated predictions on completion or the error message on failure. */
    callbackUrl?: string;
    /** Whether to send an email notification to the user upon job completion/failure. */
    notify?: boolean;
    files: Hume.expressionMeasurement.batch.File_[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/InferenceResults.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InferenceResults {
    predictions: Hume.expressionMeasurement.batch.InferencePrediction[];
    errors: Hume.expressionMeasurement.batch.Error_[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/InferenceSourcePredictResult.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InferenceSourcePredictResult {
    source: Hume.expressionMeasurement.batch.Source;
    results?: Hume.expressionMeasurement.batch.InferenceResults;
    /** An error message. */
    error?: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/JobEmbeddingGeneration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface JobEmbeddingGeneration {
    /** The ID associated with this job. */
    jobId: string;
    userId: string;
    request: Hume.expressionMeasurement.batch.EmbeddingGenerationBaseRequest;
    state: Hume.expressionMeasurement.batch.StateEmbeddingGeneration;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/JobId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface JobId {
    /** The ID of the started job. */
    jobId: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/JobInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface JobInference {
    /** The ID associated with this job. */
    jobId: string;
    /** The request that initiated the job. */
    request: Hume.expressionMeasurement.batch.InferenceRequest;
    /** The current state of the job. */
    state: Hume.expressionMeasurement.batch.StateInference;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/JobTlInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface JobTlInference {
    /** The ID associated with this job. */
    jobId: string;
    userId: string;
    request: Hume.expressionMeasurement.batch.TlInferenceBaseRequest;
    state: Hume.expressionMeasurement.batch.StateTlInference;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/JobTraining.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface JobTraining {
    /** The ID associated with this job. */
    jobId: string;
    userId: string;
    request: Hume.expressionMeasurement.batch.TrainingBaseRequest;
    state: Hume.expressionMeasurement.batch.StateTraining;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Language.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * The Emotional Language model analyzes passages of text. This also supports audio and video files by transcribing and then directly analyzing the transcribed text.
 *
 * Recommended input filetypes: `.txt`, `.mp3`, `.wav`, `.mp4`
 */
export interface Language {
    granularity?: Hume.expressionMeasurement.batch.Granularity;
    sentiment?: Hume.expressionMeasurement.batch.Unconfigurable;
    toxicity?: Hume.expressionMeasurement.batch.Unconfigurable;
    /** Whether to return identifiers for speakers over time. If `true`, unique identifiers will be assigned to spoken words to differentiate different speakers. If `false`, all speakers will be tagged with an `unknown` ID. */
    identifySpeakers?: boolean;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/LanguagePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface LanguagePrediction {
    /** A segment of text (like a word or a sentence). */
    text: string;
    position: Hume.expressionMeasurement.batch.PositionInterval;
    time?: Hume.expressionMeasurement.batch.TimeInterval;
    /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence in this text. */
    confidence?: number;
    /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence that this text was spoken by this speaker. */
    speakerConfidence?: number;
    /** A high-dimensional embedding in emotion space. */
    emotions: Hume.expressionMeasurement.batch.EmotionScore[];
    /**
     * Sentiment predictions returned as a distribution. This model predicts the probability that a given text could be interpreted as having each sentiment level from `1` (negative) to `9` (positive).
     *
     * Compared to returning one estimate of sentiment, this enables a more nuanced analysis of a text's meaning. For example, a text with very neutral sentiment would have an average rating of `5`. But also a text that could be interpreted as having very positive sentiment or very negative sentiment would also have an average rating of `5`. The average sentiment is less informative than the distribution over sentiment, so this API returns a value for each sentiment level.
     */
    sentiment?: Hume.expressionMeasurement.batch.SentimentScore[];
    /** Toxicity predictions returned as probabilities that the text can be classified into the following categories: `toxic`, `severe_toxic`, `obscene`, `threat`, `insult`, and `identity_hate`. */
    toxicity?: Hume.expressionMeasurement.batch.ToxicityScore[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Models.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * The models used for inference.
 */
export interface Models {
    face?: Hume.expressionMeasurement.batch.Face;
    burst?: Hume.expressionMeasurement.batch.Unconfigurable;
    prosody?: Hume.expressionMeasurement.batch.Prosody;
    language?: Hume.expressionMeasurement.batch.Language;
    ner?: Hume.expressionMeasurement.batch.Ner;
    facemesh?: Hume.expressionMeasurement.batch.Unconfigurable;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/ModelsPredictions.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface ModelsPredictions {
    face?: Hume.expressionMeasurement.batch.PredictionsOptionalNullFacePrediction;
    burst?: Hume.expressionMeasurement.batch.PredictionsOptionalNullBurstPrediction;
    prosody?: Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataProsodyPrediction;
    language?: Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataLanguagePrediction;
    ner?: Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataNerPrediction;
    facemesh?: Hume.expressionMeasurement.batch.PredictionsOptionalNullFacemeshPrediction;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Ner.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * The NER (Named-entity Recognition) model identifies real-world objects and concepts in passages of text. This also supports audio and video files by transcribing and then directly analyzing the transcribed text.
 *
 * Recommended input filetypes: `.txt`, `.mp3`, `.wav`, `.mp4`
 */
export interface Ner {
    /** Whether to return identifiers for speakers over time. If `true`, unique identifiers will be assigned to spoken words to differentiate different speakers. If `false`, all speakers will be tagged with an `unknown` ID. */
    identifySpeakers?: boolean;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/NerPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface NerPrediction {
    /** The recognized topic or entity. */
    entity: string;
    position: Hume.expressionMeasurement.batch.PositionInterval;
    /** Our NER model's relative confidence in the recognized topic or entity. */
    entityConfidence: number;
    /** A measure of how often the entity is linked to by other entities. */
    support: number;
    /** A URL which provides more information about the recognized topic or entity. */
    uri: string;
    /** The specific word to which the emotion predictions are linked. */
    linkWord: string;
    time?: Hume.expressionMeasurement.batch.TimeInterval;
    /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence in this text. */
    confidence?: number;
    /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence that this text was spoken by this speaker. */
    speakerConfidence?: number;
    /** A high-dimensional embedding in emotion space. */
    emotions: Hume.expressionMeasurement.batch.EmotionScore[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Null.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * No associated metadata for this model. Value will be `null`.
 */
export type Null = Record<string, unknown>;

```


## /src/api/resources/expressionMeasurement/resources/batch/types/PositionInterval.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * Position of a segment of text within a larger document, measured in characters. Uses zero-based indexing. The beginning index is inclusive and the end index is exclusive.
 */
export interface PositionInterval {
    /** The index of the first character in the text segment, inclusive. */
    begin: number;
    /** The index of the last character in the text segment, exclusive. */
    end: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullBurstPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface PredictionsOptionalNullBurstPrediction {
    metadata?: Hume.expressionMeasurement.batch.Null;
    groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsBurstPrediction[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullFacePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface PredictionsOptionalNullFacePrediction {
    metadata?: Hume.expressionMeasurement.batch.Null;
    groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsFacePrediction[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullFacemeshPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface PredictionsOptionalNullFacemeshPrediction {
    metadata?: Hume.expressionMeasurement.batch.Null;
    groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsFacemeshPrediction[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataLanguagePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface PredictionsOptionalTranscriptionMetadataLanguagePrediction {
    metadata?: Hume.expressionMeasurement.batch.TranscriptionMetadata;
    groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsLanguagePrediction[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataNerPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface PredictionsOptionalTranscriptionMetadataNerPrediction {
    metadata?: Hume.expressionMeasurement.batch.TranscriptionMetadata;
    groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsNerPrediction[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataProsodyPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface PredictionsOptionalTranscriptionMetadataProsodyPrediction {
    metadata?: Hume.expressionMeasurement.batch.TranscriptionMetadata;
    groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsProsodyPrediction[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Prosody.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * The Speech Prosody model analyzes the intonation, stress, and rhythm of spoken word.
 *
 * Recommended input file types: `.wav`, `.mp3`, `.mp4`
 */
export interface Prosody {
    granularity?: Hume.expressionMeasurement.batch.Granularity;
    window?: Hume.expressionMeasurement.batch.Window;
    /** Whether to return identifiers for speakers over time. If `true`, unique identifiers will be assigned to spoken words to differentiate different speakers. If `false`, all speakers will be tagged with an `unknown` ID. */
    identifySpeakers?: boolean;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/ProsodyPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface ProsodyPrediction {
    /** A segment of text (like a word or a sentence). */
    text?: string;
    time: Hume.expressionMeasurement.batch.TimeInterval;
    /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence in this text. */
    confidence?: number;
    /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence that this text was spoken by this speaker. */
    speakerConfidence?: number;
    /** A high-dimensional embedding in emotion space. */
    emotions: Hume.expressionMeasurement.batch.EmotionScore[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Queued.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface Queued {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/QueuedState.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface QueuedState extends Hume.expressionMeasurement.batch.Queued {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/RegistryFileDetail.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface RegistryFileDetail {
    /** File ID in the Asset Registry */
    fileId: string;
    /** URL to the file in the Asset Registry */
    fileUrl: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Regression.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type Regression = Record<string, unknown>;

```


## /src/api/resources/expressionMeasurement/resources/batch/types/SentimentScore.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface SentimentScore {
    /** Level of sentiment, ranging from `1` (negative) to `9` (positive) */
    name: string;
    /** Prediction for this level of sentiment */
    score: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/SortBy.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const SortBy = {
    Created: "created",
    Started: "started",
    Ended: "ended",
} as const;
export type SortBy = (typeof SortBy)[keyof typeof SortBy];

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Source.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type Source =
    | Hume.expressionMeasurement.batch.Source.Url
    | Hume.expressionMeasurement.batch.Source.File_
    | Hume.expressionMeasurement.batch.Source.Text;

export namespace Source {
    export interface Url extends Hume.expressionMeasurement.batch.SourceUrl {
        type: "url";
    }

    export interface File_ extends Hume.expressionMeasurement.batch.SourceFile {
        type: "file";
    }

    export interface Text extends Hume.expressionMeasurement.batch.SourceTextSource {
        type: "text";
    }
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/SourceFile.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface SourceFile extends Hume.expressionMeasurement.batch.File_ {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/SourceTextSource.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type SourceTextSource = {};

```


## /src/api/resources/expressionMeasurement/resources/batch/types/SourceUrl.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface SourceUrl extends Hume.expressionMeasurement.batch.Url {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGeneration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type StateEmbeddingGeneration =
    | Hume.expressionMeasurement.batch.StateEmbeddingGeneration.Queued
    | Hume.expressionMeasurement.batch.StateEmbeddingGeneration.InProgress
    | Hume.expressionMeasurement.batch.StateEmbeddingGeneration.Completed
    | Hume.expressionMeasurement.batch.StateEmbeddingGeneration.Failed;

export namespace StateEmbeddingGeneration {
    export interface Queued extends Hume.expressionMeasurement.batch.StateEmbeddingGenerationQueued {
        status: "QUEUED";
    }

    export interface InProgress extends Hume.expressionMeasurement.batch.StateEmbeddingGenerationInProgress {
        status: "IN_PROGRESS";
    }

    export interface Completed
        extends Hume.expressionMeasurement.batch.StateEmbeddingGenerationCompletedEmbeddingGeneration {
        status: "COMPLETED";
    }

    export interface Failed extends Hume.expressionMeasurement.batch.StateEmbeddingGenerationFailed {
        status: "FAILED";
    }
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationCompletedEmbeddingGeneration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateEmbeddingGenerationCompletedEmbeddingGeneration
    extends Hume.expressionMeasurement.batch.CompletedEmbeddingGeneration {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationFailed.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateEmbeddingGenerationFailed extends Hume.expressionMeasurement.batch.Failed {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationInProgress.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateEmbeddingGenerationInProgress extends Hume.expressionMeasurement.batch.InProgress {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationQueued.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateEmbeddingGenerationQueued extends Hume.expressionMeasurement.batch.Queued {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type StateInference =
    | Hume.expressionMeasurement.batch.StateInference.Queued
    | Hume.expressionMeasurement.batch.StateInference.InProgress
    | Hume.expressionMeasurement.batch.StateInference.Completed
    | Hume.expressionMeasurement.batch.StateInference.Failed;

export namespace StateInference {
    export interface Queued extends Hume.expressionMeasurement.batch.QueuedState {
        status: "QUEUED";
    }

    export interface InProgress extends Hume.expressionMeasurement.batch.InProgressState {
        status: "IN_PROGRESS";
    }

    export interface Completed extends Hume.expressionMeasurement.batch.CompletedState {
        status: "COMPLETED";
    }

    export interface Failed extends Hume.expressionMeasurement.batch.FailedState {
        status: "FAILED";
    }
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateTlInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type StateTlInference =
    | Hume.expressionMeasurement.batch.StateTlInference.Queued
    | Hume.expressionMeasurement.batch.StateTlInference.InProgress
    | Hume.expressionMeasurement.batch.StateTlInference.Completed
    | Hume.expressionMeasurement.batch.StateTlInference.Failed;

export namespace StateTlInference {
    export interface Queued extends Hume.expressionMeasurement.batch.StateTlInferenceQueued {
        status: "QUEUED";
    }

    export interface InProgress extends Hume.expressionMeasurement.batch.StateTlInferenceInProgress {
        status: "IN_PROGRESS";
    }

    export interface Completed extends Hume.expressionMeasurement.batch.StateTlInferenceCompletedTlInference {
        status: "COMPLETED";
    }

    export interface Failed extends Hume.expressionMeasurement.batch.StateTlInferenceFailed {
        status: "FAILED";
    }
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateTlInferenceCompletedTlInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTlInferenceCompletedTlInference extends Hume.expressionMeasurement.batch.CompletedTlInference {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateTlInferenceFailed.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTlInferenceFailed extends Hume.expressionMeasurement.batch.Failed {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateTlInferenceInProgress.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTlInferenceInProgress extends Hume.expressionMeasurement.batch.InProgress {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateTlInferenceQueued.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTlInferenceQueued extends Hume.expressionMeasurement.batch.Queued {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateTraining.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type StateTraining =
    | Hume.expressionMeasurement.batch.StateTraining.Queued
    | Hume.expressionMeasurement.batch.StateTraining.InProgress
    | Hume.expressionMeasurement.batch.StateTraining.Completed
    | Hume.expressionMeasurement.batch.StateTraining.Failed;

export namespace StateTraining {
    export interface Queued extends Hume.expressionMeasurement.batch.StateTrainingQueued {
        status: "QUEUED";
    }

    export interface InProgress extends Hume.expressionMeasurement.batch.StateTrainingInProgress {
        status: "IN_PROGRESS";
    }

    export interface Completed extends Hume.expressionMeasurement.batch.StateTrainingCompletedTraining {
        status: "COMPLETED";
    }

    export interface Failed extends Hume.expressionMeasurement.batch.StateTrainingFailed {
        status: "FAILED";
    }
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateTrainingCompletedTraining.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTrainingCompletedTraining extends Hume.expressionMeasurement.batch.CompletedTraining {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateTrainingFailed.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTrainingFailed extends Hume.expressionMeasurement.batch.Failed {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateTrainingInProgress.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTrainingInProgress extends Hume.expressionMeasurement.batch.InProgress {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/StateTrainingQueued.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTrainingQueued extends Hume.expressionMeasurement.batch.Queued {}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Status.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const Status = {
    Queued: "QUEUED",
    InProgress: "IN_PROGRESS",
    Completed: "COMPLETED",
    Failed: "FAILED",
} as const;
export type Status = (typeof Status)[keyof typeof Status];

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Tag.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface Tag {
    key: string;
    value: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Target.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type Target = number | number | string;

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Task.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type Task =
    | Hume.expressionMeasurement.batch.Task.Classification
    | Hume.expressionMeasurement.batch.Task.Regression;

export namespace Task {
    export interface Classification extends Hume.expressionMeasurement.batch.TaskClassification {
        type: "classification";
    }

    export interface Regression extends Hume.expressionMeasurement.batch.TaskRegression {
        type: "regression";
    }
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/TaskClassification.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type TaskClassification = {};

```


## /src/api/resources/expressionMeasurement/resources/batch/types/TaskRegression.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type TaskRegression = {};

```


## /src/api/resources/expressionMeasurement/resources/batch/types/TextSource.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type TextSource = Record<string, unknown>;

```


## /src/api/resources/expressionMeasurement/resources/batch/types/TimeInterval.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * A time range with a beginning and end, measured in seconds.
 */
export interface TimeInterval {
    /** Beginning of time range in seconds. */
    begin: number;
    /** End of time range in seconds. */
    end: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/TlInferenceBaseRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface TlInferenceBaseRequest {
    customModel: Hume.expressionMeasurement.batch.CustomModel;
    /**
     * URLs to the media files to be processed. Each must be a valid public URL to a media file (see recommended input filetypes) or an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`) of media files.
     *
     * If you wish to supply more than 100 URLs, consider providing them as an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`).
     */
    urls?: string[];
    /** If provided, a `POST` request will be made to the URL with the generated predictions on completion or the error message on failure. */
    callbackUrl?: string;
    /** Whether to send an email notification to the user upon job completion/failure. */
    notify?: boolean;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/TlInferencePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface TlInferencePrediction {
    /** A file path relative to the top level source URL or file. */
    file: string;
    fileType: string;
    customModels: Record<string, Hume.expressionMeasurement.batch.CustomModelPrediction>;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/TlInferenceResults.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface TlInferenceResults {
    predictions: Hume.expressionMeasurement.batch.TlInferencePrediction[];
    errors: Hume.expressionMeasurement.batch.Error_[];
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/TlInferenceSourcePredictResult.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface TlInferenceSourcePredictResult {
    source: Hume.expressionMeasurement.batch.Source;
    results?: Hume.expressionMeasurement.batch.TlInferenceResults;
    /** An error message. */
    error?: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/ToxicityScore.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface ToxicityScore {
    /** Category of toxicity. */
    name: string;
    /** Prediction for this category of toxicity */
    score: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/TrainingBaseRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface TrainingBaseRequest {
    customModel: Hume.expressionMeasurement.batch.CustomModelRequest;
    dataset: Hume.expressionMeasurement.batch.Dataset;
    targetFeature?: string;
    task?: Hume.expressionMeasurement.batch.Task;
    evaluation?: Hume.expressionMeasurement.batch.EvaluationArgs;
    alternatives?: Hume.expressionMeasurement.batch.Alternative[];
    callbackUrl?: string;
    notify?: boolean;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/TrainingCustomModel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface TrainingCustomModel {
    id: string;
    versionId?: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Transcription.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * Transcription-related configuration options.
 *
 * To disable transcription, explicitly set this field to `null`.
 */
export interface Transcription {
    /**
     * By default, we use an automated language detection method for our Speech Prosody, Language, and NER models. However, if you know what language is being spoken in your media samples, you can specify it via its BCP-47 tag and potentially obtain more accurate results.
     *
     * You can specify any of the following languages:
     * - Chinese: `zh`
     * - Danish: `da`
     * - Dutch: `nl`
     * - English: `en`
     * - English (Australia): `en-AU`
     * - English (India): `en-IN`
     * - English (New Zealand): `en-NZ`
     * - English (United Kingdom): `en-GB`
     * - French: `fr`
     * - French (Canada): `fr-CA`
     * - German: `de`
     * - Hindi: `hi`
     * - Hindi (Roman Script): `hi-Latn`
     * - Indonesian: `id`
     * - Italian: `it`
     * - Japanese: `ja`
     * - Korean: `ko`
     * - Norwegian: `no`
     * - Polish: `pl`
     * - Portuguese: `pt`
     * - Portuguese (Brazil): `pt-BR`
     * - Portuguese (Portugal): `pt-PT`
     * - Russian: `ru`
     * - Spanish: `es`
     * - Spanish (Latin America): `es-419`
     * - Swedish: `sv`
     * - Tamil: `ta`
     * - Turkish: `tr`
     * - Ukrainian: `uk`
     */
    language?: Hume.expressionMeasurement.batch.Bcp47Tag;
    /** Whether to return identifiers for speakers over time. If `true`, unique identifiers will be assigned to spoken words to differentiate different speakers. If `false`, all speakers will be tagged with an `unknown` ID. */
    identifySpeakers?: boolean;
    /** Transcript confidence threshold. Transcripts generated with a confidence less than this threshold will be considered invalid and not used as an input for model inference. */
    confidenceThreshold?: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/TranscriptionMetadata.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * Transcription metadata for your media file.
 */
export interface TranscriptionMetadata {
    /** Value between `0.0` and `1.0` indicating our transcription model's relative confidence in the transcription of your media file. */
    confidence: number;
    detectedLanguage?: Hume.expressionMeasurement.batch.Bcp47Tag;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Type.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const Type = {
    EmbeddingGeneration: "EMBEDDING_GENERATION",
    Inference: "INFERENCE",
    TlInference: "TL_INFERENCE",
    Training: "TRAINING",
} as const;
export type Type = (typeof Type)[keyof typeof Type];

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Unconfigurable.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * To include predictions for this model type, set this field to `{}`. It is currently not configurable further.
 */
export type Unconfigurable = Record<string, unknown>;

```


## /src/api/resources/expressionMeasurement/resources/batch/types/UnionJob.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type UnionJob = Hume.expressionMeasurement.batch.InferenceJob;

```


## /src/api/resources/expressionMeasurement/resources/batch/types/UnionPredictResult.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type UnionPredictResult = Hume.expressionMeasurement.batch.InferenceSourcePredictResult;

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Url.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface Url {
    /** The URL of the source media file. */
    url: string;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/ValidationArgs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface ValidationArgs {
    positiveLabel?: Hume.expressionMeasurement.batch.Target;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/When.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const When = {
    CreatedBefore: "created_before",
    CreatedAfter: "created_after",
} as const;
export type When = (typeof When)[keyof typeof When];

```


## /src/api/resources/expressionMeasurement/resources/batch/types/Window.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * Generate predictions based on time.
 *
 * Setting the `window` field allows for a 'sliding window' approach, where a fixed-size window moves across the audio or video file in defined steps. This enables continuous analysis of prosody within subsets of the file, providing dynamic and localized insights into emotional expression.
 */
export interface Window {
    /** The length of the sliding window. */
    length?: number;
    /** The step size of the sliding window. */
    step?: number;
}

```


## /src/api/resources/expressionMeasurement/resources/batch/types/index.ts
```typescript
export * from "./Alternative.js";
export * from "./Bcp47Tag.js";
export * from "./BoundingBox.js";
export * from "./BurstPrediction.js";
export * from "./Classification.js";
export * from "./CompletedEmbeddingGeneration.js";
export * from "./CompletedInference.js";
export * from "./CompletedState.js";
export * from "./CompletedTlInference.js";
export * from "./CompletedTraining.js";
export * from "./CustomModel.js";
export * from "./CustomModelId.js";
export * from "./CustomModelPrediction.js";
export * from "./CustomModelRequest.js";
export * from "./CustomModelsInferenceJob.js";
export * from "./CustomModelsTrainingJob.js";
export * from "./CustomModelVersionId.js";
export * from "./Dataset.js";
export * from "./DatasetId.js";
export * from "./DatasetVersionId.js";
export * from "./DescriptionsScore.js";
export * from "./Direction.js";
export * from "./EmbeddingGenerationBaseRequest.js";
export * from "./EmbeddingGenerationJob.js";
export * from "./EmotionScore.js";
export * from "./Error_.js";
export * from "./EvaluationArgs.js";
export * from "./Face.js";
export * from "./FacemeshPrediction.js";
export * from "./FacePrediction.js";
export * from "./FacsScore.js";
export * from "./Failed.js";
export * from "./FailedState.js";
export * from "./File_.js";
export * from "./Granularity.js";
export * from "./GroupedPredictionsBurstPrediction.js";
export * from "./GroupedPredictionsFacemeshPrediction.js";
export * from "./GroupedPredictionsFacePrediction.js";
export * from "./GroupedPredictionsLanguagePrediction.js";
export * from "./GroupedPredictionsNerPrediction.js";
export * from "./GroupedPredictionsProsodyPrediction.js";
export * from "./InferenceBaseRequest.js";
export * from "./InferenceJob.js";
export * from "./InferencePrediction.js";
export * from "./InferenceRequest.js";
export * from "./InferenceResults.js";
export * from "./InferenceSourcePredictResult.js";
export * from "./InProgress.js";
export * from "./InProgressState.js";
export * from "./JobEmbeddingGeneration.js";
export * from "./JobId.js";
export * from "./JobInference.js";
export * from "./JobTlInference.js";
export * from "./JobTraining.js";
export * from "./Language.js";
export * from "./LanguagePrediction.js";
export * from "./Models.js";
export * from "./ModelsPredictions.js";
export * from "./Ner.js";
export * from "./NerPrediction.js";
export * from "./Null.js";
export * from "./PositionInterval.js";
export * from "./PredictionsOptionalNullBurstPrediction.js";
export * from "./PredictionsOptionalNullFacemeshPrediction.js";
export * from "./PredictionsOptionalNullFacePrediction.js";
export * from "./PredictionsOptionalTranscriptionMetadataLanguagePrediction.js";
export * from "./PredictionsOptionalTranscriptionMetadataNerPrediction.js";
export * from "./PredictionsOptionalTranscriptionMetadataProsodyPrediction.js";
export * from "./Prosody.js";
export * from "./ProsodyPrediction.js";
export * from "./Queued.js";
export * from "./QueuedState.js";
export * from "./RegistryFileDetail.js";
export * from "./Regression.js";
export * from "./SentimentScore.js";
export * from "./SortBy.js";
export * from "./Source.js";
export * from "./SourceFile.js";
export * from "./SourceTextSource.js";
export * from "./SourceUrl.js";
export * from "./StateEmbeddingGeneration.js";
export * from "./StateEmbeddingGenerationCompletedEmbeddingGeneration.js";
export * from "./StateEmbeddingGenerationFailed.js";
export * from "./StateEmbeddingGenerationInProgress.js";
export * from "./StateEmbeddingGenerationQueued.js";
export * from "./StateInference.js";
export * from "./StateTlInference.js";
export * from "./StateTlInferenceCompletedTlInference.js";
export * from "./StateTlInferenceFailed.js";
export * from "./StateTlInferenceInProgress.js";
export * from "./StateTlInferenceQueued.js";
export * from "./StateTraining.js";
export * from "./StateTrainingCompletedTraining.js";
export * from "./StateTrainingFailed.js";
export * from "./StateTrainingInProgress.js";
export * from "./StateTrainingQueued.js";
export * from "./Status.js";
export * from "./Tag.js";
export * from "./Target.js";
export * from "./Task.js";
export * from "./TaskClassification.js";
export * from "./TaskRegression.js";
export * from "./TextSource.js";
export * from "./TimeInterval.js";
export * from "./TlInferenceBaseRequest.js";
export * from "./TlInferencePrediction.js";
export * from "./TlInferenceResults.js";
export * from "./TlInferenceSourcePredictResult.js";
export * from "./ToxicityScore.js";
export * from "./TrainingBaseRequest.js";
export * from "./TrainingCustomModel.js";
export * from "./Transcription.js";
export * from "./TranscriptionMetadata.js";
export * from "./Type.js";
export * from "./Unconfigurable.js";
export * from "./UnionJob.js";
export * from "./UnionPredictResult.js";
export * from "./Url.js";
export * from "./ValidationArgs.js";
export * from "./When.js";
export * from "./Window.js";

```


## /src/api/resources/expressionMeasurement/resources/index.ts
```typescript
export * as batch from "./batch/index.js";
export * as stream from "./stream/index.js";

```


## /src/api/resources/expressionMeasurement/resources/stream/index.ts
```typescript
export * from "./resources/index.js";
export * from "./types/index.js";

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/index.ts
```typescript
export * as stream from "./stream/index.js";
export * from "./stream/types/index.js";

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions } from "../../../../../../../../BaseClient.js";
import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../../../core/headers.js";
import * as core from "../../../../../../../../core/index.js";
import * as environments from "../../../../../../../../environments.js";
import { StreamSocket } from "./Socket.js";

export declare namespace StreamClient {
    export type Options = BaseClientOptions;

    export interface ConnectArgs {
        "X-Hume-Api-Key": string;
        /** Arbitrary headers to send with the websocket connect request. */
        headers?: Record<string, string>;
        /** Enable debug mode on the websocket. Defaults to false. */
        debug?: boolean;
        /** Number of reconnect attempts. Defaults to 30. */
        reconnectAttempts?: number;
    }
}

export class StreamClient {
    protected readonly _options: NormalizedClientOptions<StreamClient.Options>;

    constructor(options: StreamClient.Options = {}) {
        this._options = normalizeClientOptions(options);
    }

    public async connect(args: StreamClient.ConnectArgs): Promise<StreamSocket> {
        const { headers, debug, reconnectAttempts } = args;
        const _headers: Record<string, unknown> = mergeHeaders(
            mergeOnlyDefinedHeaders({ "X-Hume-Api-Key": args["X-Hume-Api-Key"] }),
            headers,
        );
        const socket = new core.ReconnectingWebSocket({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).stream,
                "/models",
            ),
            protocols: [],
            queryParameters: {},
            headers: _headers,
            options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
        });
        return new StreamSocket({ socket });
    }
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/client/Socket.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import * as core from "../../../../../../../../core/index.js";
import { fromJson } from "../../../../../../../../core/json.js";
import * as serializers from "../../../../../../../../serialization/index.js";
import { StreamModelsEndpointPayload } from "../../../../../../../../serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelsEndpointPayload.js";
import type * as Hume from "../../../../../../../index.js";

export declare namespace StreamSocket {
    export interface Args {
        socket: core.ReconnectingWebSocket;
    }

    export type Response = Hume.expressionMeasurement.stream.SubscribeEvent;
    type EventHandlers = {
        open?: () => void;
        message?: (message: Response) => void;
        close?: (event: core.CloseEvent) => void;
        error?: (error: Error) => void;
    };
}

export class StreamSocket {
    public readonly socket: core.ReconnectingWebSocket;
    protected readonly eventHandlers: StreamSocket.EventHandlers = {};
    private handleOpen: () => void = () => {
        this.eventHandlers.open?.();
    };
    private handleMessage: (event: { data: string }) => void = (event) => {
        const data = fromJson(event.data);

        const parsedResponse = serializers.expressionMeasurement.stream.StreamSocketResponse.parse(data, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        if (parsedResponse.ok) {
            this.eventHandlers.message?.(parsedResponse.value);
        } else {
            this.eventHandlers.error?.(new Error("Received unknown message type"));
        }
    };
    private handleClose: (event: core.CloseEvent) => void = (event) => {
        this.eventHandlers.close?.(event);
    };
    private handleError: (event: core.ErrorEvent) => void = (event) => {
        const message = event.message;
        this.eventHandlers.error?.(new Error(message));
    };

    constructor(args: StreamSocket.Args) {
        this.socket = args.socket;
        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);
    }

    /** The current state of the connection; this is one of the readyState constants. */
    get readyState(): number {
        return this.socket.readyState;
    }

    /**
     * @param event - The event to attach to.
     * @param callback - The callback to run when the event is triggered.
     * Usage:
     * ```typescript
     * this.on('open', () => {
     *     console.log('The websocket is open');
     * });
     * ```
     */
    public on<T extends keyof StreamSocket.EventHandlers>(event: T, callback: StreamSocket.EventHandlers[T]): void {
        this.eventHandlers[event] = callback;
    }

    public sendPublish(message: Hume.expressionMeasurement.stream.StreamModelsEndpointPayload): void {
        this.assertSocketIsOpen();
        const jsonPayload = StreamModelsEndpointPayload.jsonOrThrow(message, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        this.socket.send(JSON.stringify(jsonPayload));
    }

    /** Connect to the websocket and register event handlers. */
    public connect(): StreamSocket {
        this.socket.reconnect();

        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);

        return this;
    }

    /** Close the websocket and unregister event handlers. */
    public close(): void {
        this.socket.close();

        this.handleClose({ code: 1000 } as CloseEvent);

        this.socket.removeEventListener("open", this.handleOpen);
        this.socket.removeEventListener("message", this.handleMessage);
        this.socket.removeEventListener("close", this.handleClose);
        this.socket.removeEventListener("error", this.handleError);
    }

    /** Returns a promise that resolves when the websocket is open. */
    public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
        if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
            return this.socket;
        }

        return new Promise((resolve, reject) => {
            this.socket.addEventListener("open", () => {
                resolve(this.socket);
            });

            this.socket.addEventListener("error", (event: unknown) => {
                reject(event);
            });
        });
    }

    /** Asserts that the websocket is open. */
    private assertSocketIsOpen(): void {
        if (!this.socket) {
            throw new Error("Socket is not connected.");
        }

        if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
            throw new Error("Socket is not open.");
        }
    }

    /** Send a binary payload to the websocket. */
    protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
        this.socket.send(payload);
    }
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/client/index.ts
```typescript
export {};

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/index.ts
```typescript
export * from "./client/index.js";
export * from "./types/index.js";

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/Config.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Configuration used to specify which models should be used and with what settings.
 */
export interface Config {
    /**
     * Configuration for the vocal burst emotion model.
     *
     * Note: Model configuration is not currently available in streaming.
     *
     * Please use the default configuration by passing an empty object `{}`.
     */
    burst?: Record<string, unknown>;
    /**
     * Configuration for the facial expression emotion model.
     *
     * Note: Using the `reset_stream` parameter does not have any effect on face identification. A single face identifier cache is maintained over a full session whether `reset_stream` is used or not.
     */
    face?: Hume.expressionMeasurement.stream.StreamFace;
    /**
     * Configuration for the facemesh emotion model.
     *
     * Note: Model configuration is not currently available in streaming.
     *
     * Please use the default configuration by passing an empty object `{}`.
     */
    facemesh?: Record<string, unknown>;
    /** Configuration for the language emotion model. */
    language?: Hume.expressionMeasurement.stream.StreamLanguage;
    /**
     * Configuration for the speech prosody emotion model.
     *
     * Note: Model configuration is not currently available in streaming.
     *
     * Please use the default configuration by passing an empty object `{}`.
     */
    prosody?: Record<string, unknown>;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/JobDetails.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * If the job_details flag was set in the request, details about the current streaming job will be returned in the response body.
 */
export interface JobDetails {
    /** ID of the current streaming job. */
    jobId?: string;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamErrorMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Error message
 */
export interface StreamErrorMessage {
    /** Error message text. */
    error?: string;
    /** Unique identifier for the error. */
    code?: string;
    /** If a payload ID was passed in the request, the same payload ID will be sent back in the response body. */
    payloadId?: string;
    /** If the job_details flag was set in the request, details about the current streaming job will be returned in the response body. */
    jobDetails?: Hume.expressionMeasurement.stream.JobDetails;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamFace.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * Configuration for the facial expression emotion model.
 *
 * Note: Using the `reset_stream` parameter does not have any effect on face identification. A single face identifier cache is maintained over a full session whether `reset_stream` is used or not.
 */
export interface StreamFace {
    /** Configuration for FACS predictions. If missing or null, no FACS predictions will be generated. */
    facs?: Record<string, unknown>;
    /** Configuration for Descriptions predictions. If missing or null, no Descriptions predictions will be generated. */
    descriptions?: Record<string, unknown>;
    /** Whether to return identifiers for faces across frames. If true, unique identifiers will be assigned to face bounding boxes to differentiate different faces. If false, all faces will be tagged with an "unknown" ID. */
    identifyFaces?: boolean;
    /** Number of frames per second to process. Other frames will be omitted from the response. */
    fpsPred?: number;
    /** Face detection probability threshold. Faces detected with a probability less than this threshold will be omitted from the response. */
    probThreshold?: number;
    /** Minimum bounding box side length in pixels to treat as a face. Faces detected with a bounding box side length in pixels less than this threshold will be omitted from the response. */
    minFaceSize?: number;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamLanguage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * Configuration for the language emotion model.
 */
export interface StreamLanguage {
    /** Configuration for sentiment predictions. If missing or null, no sentiment predictions will be generated. */
    sentiment?: Record<string, unknown>;
    /** Configuration for toxicity predictions. If missing or null, no toxicity predictions will be generated. */
    toxicity?: Record<string, unknown>;
    /** The granularity at which to generate predictions. Values are `word`, `sentence`, `utterance`, or `passage`. To get a single prediction for the entire text of your streaming payload use `passage`. Default value is `word`. */
    granularity?: string;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictions.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Model predictions
 */
export interface StreamModelPredictions {
    /** If a payload ID was passed in the request, the same payload ID will be sent back in the response body. */
    payloadId?: string;
    /** If the job_details flag was set in the request, details about the current streaming job will be returned in the response body. */
    jobDetails?: Hume.expressionMeasurement.stream.StreamModelPredictionsJobDetails;
    /** Response for the vocal burst emotion model. */
    burst?: Hume.expressionMeasurement.stream.StreamModelPredictionsBurst;
    /** Response for the facial expression emotion model. */
    face?: Hume.expressionMeasurement.stream.StreamModelPredictionsFace;
    /** Response for the facemesh emotion model. */
    facemesh?: Hume.expressionMeasurement.stream.StreamModelPredictionsFacemesh;
    /** Response for the language emotion model. */
    language?: Hume.expressionMeasurement.stream.StreamModelPredictionsLanguage;
    /** Response for the speech prosody emotion model. */
    prosody?: Hume.expressionMeasurement.stream.StreamModelPredictionsProsody;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsBurst.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Response for the vocal burst emotion model.
 */
export interface StreamModelPredictionsBurst {
    predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsBurstPredictionsItem[];
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsBurstPredictionsItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

export interface StreamModelPredictionsBurstPredictionsItem {
    time?: Hume.expressionMeasurement.stream.TimeRange;
    emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFace.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Response for the facial expression emotion model.
 */
export interface StreamModelPredictionsFace {
    predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsFacePredictionsItem[];
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacePredictionsItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

export interface StreamModelPredictionsFacePredictionsItem {
    /** Frame number */
    frame?: number;
    /** Time in seconds when face detection occurred. */
    time?: number;
    bbox?: Hume.expressionMeasurement.stream.StreamBoundingBox;
    /** The predicted probability that a detected face was actually a face. */
    prob?: number;
    /** Identifier for a face. Not that this defaults to `unknown` unless face identification is enabled in the face model configuration. */
    faceId?: string;
    emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
    facs?: Hume.expressionMeasurement.stream.EmotionEmbedding;
    descriptions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacemesh.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Response for the facemesh emotion model.
 */
export interface StreamModelPredictionsFacemesh {
    predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsFacemeshPredictionsItem[];
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacemeshPredictionsItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

export interface StreamModelPredictionsFacemeshPredictionsItem {
    emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsJobDetails.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * If the job_details flag was set in the request, details about the current streaming job will be returned in the response body.
 */
export interface StreamModelPredictionsJobDetails {
    /** ID of the current streaming job. */
    jobId?: string;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsLanguage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Response for the language emotion model.
 */
export interface StreamModelPredictionsLanguage {
    predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsLanguagePredictionsItem[];
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsLanguagePredictionsItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

export interface StreamModelPredictionsLanguagePredictionsItem {
    /** A segment of text (like a word or a sentence). */
    text?: string;
    position?: Hume.expressionMeasurement.stream.TextPosition;
    emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
    sentiment?: Hume.expressionMeasurement.stream.Sentiment;
    toxicity?: Hume.expressionMeasurement.stream.Toxicity;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsProsody.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Response for the speech prosody emotion model.
 */
export interface StreamModelPredictionsProsody {
    predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsProsodyPredictionsItem[];
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsProsodyPredictionsItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

export interface StreamModelPredictionsProsodyPredictionsItem {
    time?: Hume.expressionMeasurement.stream.TimeRange;
    emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelsEndpointPayload.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Models endpoint payload
 */
export interface StreamModelsEndpointPayload {
    data?: string;
    /** Configuration used to specify which models should be used and with what settings. */
    models?: Hume.expressionMeasurement.stream.Config;
    /**
     * Length in milliseconds of streaming sliding window.
     *
     * Extending the length of this window will prepend media context from past payloads into the current payload.
     *
     * For example, if on the first payload you send 500ms of data and on the second payload you send an additional 500ms of data, a window of at least 1000ms will allow the model to process all 1000ms of stream data.
     *
     * A window of 600ms would append the full 500ms of the second payload to the last 100ms of the first payload.
     *
     * Note: This feature is currently only supported for audio data and audio models. For other file types and models this parameter will be ignored.
     */
    streamWindowMs?: number;
    /**
     * Whether to reset the streaming sliding window before processing the current payload.
     *
     * If this parameter is set to `true` then past context will be deleted before processing the current payload.
     *
     * Use reset_stream when one audio file is done being processed and you do not want context to leak across files.
     */
    resetStream?: boolean;
    /**
     * Set to `true` to enable the data parameter to be parsed as raw text rather than base64 encoded bytes.
     * This parameter is useful if you want to send text to be processed by the language model, but it cannot be used with other file types like audio, image, or video.
     */
    rawText?: boolean;
    /**
     * Set to `true` to get details about the job.
     *
     * This parameter can be set in the same payload as data or it can be set without data and models configuration to get the job details between payloads.
     *
     * This parameter is useful to get the unique job ID.
     */
    jobDetails?: boolean;
    /**
     * Pass an arbitrary string as the payload ID and get it back at the top level of the socket response.
     *
     * This can be useful if you have multiple requests running asynchronously and want to disambiguate responses as they are received.
     */
    payloadId?: string;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamWarningMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Warning message
 */
export interface StreamWarningMessage {
    /** Warning message text. */
    warning?: string;
    /** Unique identifier for the error. */
    code?: string;
    /** If a payload ID was passed in the request, the same payload ID will be sent back in the response body. */
    payloadId?: string;
    /** If the job_details flag was set in the request, details about the current streaming job will be returned in the response body. */
    jobDetails?: Hume.expressionMeasurement.stream.StreamWarningMessageJobDetails;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamWarningMessageJobDetails.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * If the job_details flag was set in the request, details about the current streaming job will be returned in the response body.
 */
export interface StreamWarningMessageJobDetails {
    /** ID of the current streaming job. */
    jobId?: string;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/SubscribeEvent.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

export type SubscribeEvent =
    /**
     * Model predictions */
    | Hume.expressionMeasurement.stream.StreamModelPredictions
    /**
     * Error message */
    | Hume.expressionMeasurement.stream.StreamErrorMessage
    /**
     * Warning message */
    | Hume.expressionMeasurement.stream.StreamWarningMessage;

```


## /src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/index.ts
```typescript
export * from "./Config.js";
export * from "./JobDetails.js";
export * from "./StreamErrorMessage.js";
export * from "./StreamFace.js";
export * from "./StreamLanguage.js";
export * from "./StreamModelPredictions.js";
export * from "./StreamModelPredictionsBurst.js";
export * from "./StreamModelPredictionsBurstPredictionsItem.js";
export * from "./StreamModelPredictionsFace.js";
export * from "./StreamModelPredictionsFacemesh.js";
export * from "./StreamModelPredictionsFacemeshPredictionsItem.js";
export * from "./StreamModelPredictionsFacePredictionsItem.js";
export * from "./StreamModelPredictionsJobDetails.js";
export * from "./StreamModelPredictionsLanguage.js";
export * from "./StreamModelPredictionsLanguagePredictionsItem.js";
export * from "./StreamModelPredictionsProsody.js";
export * from "./StreamModelPredictionsProsodyPredictionsItem.js";
export * from "./StreamModelsEndpointPayload.js";
export * from "./StreamWarningMessage.js";
export * from "./StreamWarningMessageJobDetails.js";
export * from "./SubscribeEvent.js";

```


## /src/api/resources/expressionMeasurement/resources/stream/types/EmotionEmbedding.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * A high-dimensional embedding in emotion space.
 */
export type EmotionEmbedding = Hume.expressionMeasurement.stream.EmotionEmbeddingItem[];

```


## /src/api/resources/expressionMeasurement/resources/stream/types/EmotionEmbeddingItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface EmotionEmbeddingItem {
    /** Name of the emotion being expressed. */
    name?: string;
    /** Embedding value for the emotion being expressed. */
    score?: number;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/types/Sentiment.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * Sentiment predictions returned as a distribution. This model predicts the probability that a given text could be interpreted as having each sentiment level from 1 (negative) to 9 (positive).
 *
 * Compared to returning one estimate of sentiment, this enables a more nuanced analysis of a text's meaning. For example, a text with very neutral sentiment would have an average rating of 5. But also a text that could be interpreted as having very positive sentiment or very negative sentiment would also have an average rating of 5. The average sentiment is less informative than the distribution over sentiment, so this API returns a value for each sentiment level.
 */
export type Sentiment = Hume.expressionMeasurement.stream.SentimentItem[];

```


## /src/api/resources/expressionMeasurement/resources/stream/types/SentimentItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface SentimentItem {
    /** Level of sentiment, ranging from 1 (negative) to 9 (positive) */
    name?: string;
    /** Prediction for this level of sentiment */
    score?: number;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/types/StreamBoundingBox.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * A bounding box around a face.
 */
export interface StreamBoundingBox {
    /** x-coordinate of bounding box top left corner. */
    x?: number;
    /** y-coordinate of bounding box top left corner. */
    y?: number;
    /** Bounding box width. */
    w?: number;
    /** Bounding box height. */
    h?: number;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/types/TextPosition.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * Position of a segment of text within a larger document, measured in characters. Uses zero-based indexing. The beginning index is inclusive and the end index is exclusive.
 */
export interface TextPosition {
    /** The index of the first character in the text segment, inclusive. */
    begin?: number;
    /** The index of the last character in the text segment, exclusive. */
    end?: number;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/types/TimeRange.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * A time range with a beginning and end, measured in seconds.
 */
export interface TimeRange {
    /** Beginning of time range in seconds. */
    begin?: number;
    /** End of time range in seconds. */
    end?: number;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/types/Toxicity.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * Toxicity predictions returned as probabilities that the text can be classified into the following categories: toxic, severe_toxic, obscene, threat, insult, and identity_hate.
 */
export type Toxicity = Hume.expressionMeasurement.stream.ToxicityItem[];

```


## /src/api/resources/expressionMeasurement/resources/stream/types/ToxicityItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface ToxicityItem {
    /** Category of toxicity. */
    name?: string;
    /** Prediction for this category of toxicity */
    score?: number;
}

```


## /src/api/resources/expressionMeasurement/resources/stream/types/index.ts
```typescript
export * from "./EmotionEmbedding.js";
export * from "./EmotionEmbeddingItem.js";
export * from "./Sentiment.js";
export * from "./SentimentItem.js";
export * from "./StreamBoundingBox.js";
export * from "./TextPosition.js";
export * from "./TimeRange.js";
export * from "./Toxicity.js";
export * from "./ToxicityItem.js";

```


## /src/api/resources/index.ts
```typescript
export * as empathicVoice from "./empathicVoice/index.js";
export * as expressionMeasurement from "./expressionMeasurement/index.js";
export * as tts from "./tts/index.js";

```


## /src/api/resources/tts/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import { toJson } from "../../../../core/json.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as serializers from "../../../../serialization/index.js";
import * as Hume from "../../../index.js";
import { StreamInputClient } from "../resources/streamInput/client/Client.js";
import { VoicesClient } from "../resources/voices/client/Client.js";

export declare namespace TtsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class TtsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<TtsClient.Options>;
    protected _voices: VoicesClient | undefined;
    protected _streamInput: StreamInputClient | undefined;

    constructor(options: TtsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    public get voices(): VoicesClient {
        return (this._voices ??= new VoicesClient(this._options));
    }

    public get streamInput(): StreamInputClient {
        return (this._streamInput ??= new StreamInputClient(this._options));
    }

    /**
     * Synthesizes one or more input texts into speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
     *
     * The response includes the base64-encoded audio and metadata in JSON format.
     *
     * @param {Hume.tts.PostedTts} request
     * @param {TtsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.tts.UnprocessableEntityError}
     *
     * @example
     *     await client.tts.synthesizeJson({
     *         context: {
     *             utterances: [{
     *                     text: "How can people see beauty so differently?",
     *                     description: "A curious student with a clear and respectful tone, seeking clarification on Hume's ideas with a straightforward question."
     *                 }]
     *         },
     *         format: {
     *             type: "mp3"
     *         },
     *         numGenerations: 1,
     *         utterances: [{
     *                 text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
     *                 description: "Middle-aged masculine voice with a clear, rhythmic Scots lilt, rounded vowels, and a warm, steady tone with an articulate, academic quality."
     *             }]
     *     })
     */
    public synthesizeJson(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.tts.ReturnTts> {
        return core.HttpResponsePromise.fromPromise(this.__synthesizeJson(request, requestOptions));
    }

    private async __synthesizeJson(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.tts.ReturnTts>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.tts.PostedTts.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.tts.ReturnTts.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts");
    }

    /**
     * Synthesizes one or more input texts into speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
     *
     * The response contains the generated audio file in the requested format.
     * @throws {@link Hume.tts.UnprocessableEntityError}
     */
    public synthesizeFile(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__synthesizeFile(request, requestOptions));
    }

    private async __synthesizeFile(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/file",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.tts.PostedTts.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts/file");
    }

    /**
     * Streams synthesized speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
     * @throws {@link Hume.tts.UnprocessableEntityError}
     */
    public synthesizeFileStreaming(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__synthesizeFileStreaming(request, requestOptions));
    }

    private async __synthesizeFileStreaming(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/stream/file",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.tts.PostedTts.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts/stream/file");
    }

    /**
     * Streams synthesized speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
     *
     * The response is a stream of JSON objects including audio encoded in base64.
     */
    public synthesizeJsonStreaming(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): core.HttpResponsePromise<core.Stream<Hume.tts.TtsOutput>> {
        return core.HttpResponsePromise.fromPromise(this.__synthesizeJsonStreaming(request, requestOptions));
    }

    private async __synthesizeJsonStreaming(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.Stream<Hume.tts.TtsOutput>>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<ReadableStream>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/stream/json",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.tts.PostedTts.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "sse",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: new core.Stream({
                    stream: _response.body,
                    parse: async (data) => {
                        return serializers.tts.TtsOutput.parseOrThrow(data, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        });
                    },
                    signal: requestOptions?.abortSignal,
                    eventShape: {
                        type: "json",
                        messageTerminator: "\n",
                    },
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts/stream/json");
    }

    /**
     * @throws {@link Hume.tts.UnprocessableEntityError}
     */
    public convertVoiceFile(
        request: Hume.tts.ConvertVoiceFileRequest,
        requestOptions?: TtsClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__convertVoiceFile(request, requestOptions));
    }

    private async __convertVoiceFile(
        request: Hume.tts.ConvertVoiceFileRequest,
        requestOptions?: TtsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _body = await core.newFormData();
        if (request.stripHeaders != null) {
            _body.append("strip_headers", request.stripHeaders?.toString());
        }

        await _body.appendFile("audio", request.audio);
        if (request.context != null) {
            _body.append(
                "context",
                (() => {
                    const mapped = serializers.tts.PostedContext.jsonOrThrow(request.context, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    });
                    return typeof mapped === "string" ? mapped : toJson(mapped);
                })(),
            );
        }

        if (request.voice != null) {
            _body.append(
                "voice",
                (() => {
                    const mapped = serializers.tts.PostedUtteranceVoice.jsonOrThrow(request.voice, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    });
                    return typeof mapped === "string" ? mapped : toJson(mapped);
                })(),
            );
        }

        if (request.format != null) {
            _body.append(
                "format",
                (() => {
                    const mapped = serializers.tts.Format.jsonOrThrow(request.format, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    });
                    return typeof mapped === "string" ? mapped : toJson(mapped);
                })(),
            );
        }

        if (request.includeTimestampTypes != null) {
            for (const _item of request.includeTimestampTypes) {
                _body.append(
                    "include_timestamp_types",
                    serializers.tts.TimestampType.jsonOrThrow(_item, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    }),
                );
            }
        }

        const _maybeEncodedRequest = await _body.getRequest();
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ..._maybeEncodedRequest.headers }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/voice_conversion/file",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v0/tts/voice_conversion/file",
        );
    }

    public convertVoiceJson(
        request: Hume.tts.ConvertVoiceJsonRequest,
        requestOptions?: TtsClient.RequestOptions,
    ): core.HttpResponsePromise<core.Stream<Hume.tts.TtsOutput>> {
        return core.HttpResponsePromise.fromPromise(this.__convertVoiceJson(request, requestOptions));
    }

    private async __convertVoiceJson(
        request: Hume.tts.ConvertVoiceJsonRequest,
        requestOptions?: TtsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.Stream<Hume.tts.TtsOutput>>> {
        const _body = await core.newFormData();
        if (request.stripHeaders != null) {
            _body.append("strip_headers", request.stripHeaders?.toString());
        }

        if (request.audio != null) {
            await _body.appendFile("audio", request.audio);
        }

        if (request.context != null) {
            _body.append(
                "context",
                (() => {
                    const mapped = serializers.tts.PostedContext.jsonOrThrow(request.context, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    });
                    return typeof mapped === "string" ? mapped : toJson(mapped);
                })(),
            );
        }

        if (request.voice != null) {
            _body.append(
                "voice",
                (() => {
                    const mapped = serializers.tts.PostedUtteranceVoice.jsonOrThrow(request.voice, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    });
                    return typeof mapped === "string" ? mapped : toJson(mapped);
                })(),
            );
        }

        if (request.format != null) {
            _body.append(
                "format",
                (() => {
                    const mapped = serializers.tts.Format.jsonOrThrow(request.format, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    });
                    return typeof mapped === "string" ? mapped : toJson(mapped);
                })(),
            );
        }

        if (request.includeTimestampTypes != null) {
            for (const _item of request.includeTimestampTypes) {
                _body.append(
                    "include_timestamp_types",
                    serializers.tts.TimestampType.jsonOrThrow(_item, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    }),
                );
            }
        }

        const _maybeEncodedRequest = await _body.getRequest();
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ..._maybeEncodedRequest.headers }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<ReadableStream>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/voice_conversion/json",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            responseType: "sse",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: new core.Stream({
                    stream: _response.body,
                    parse: async (data) => {
                        return serializers.tts.TtsOutput.parseOrThrow(data, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        });
                    },
                    signal: requestOptions?.abortSignal,
                    eventShape: {
                        type: "json",
                        messageTerminator: "\n",
                    },
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v0/tts/voice_conversion/json",
        );
    }
}

```


## /src/api/resources/tts/client/index.ts
```typescript
export * from "./requests/index.js";

```


## /src/api/resources/tts/client/requests/ConvertVoiceFileRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../../core/index.js";
import type * as Hume from "../../../../index.js";

export interface ConvertVoiceFileRequest {
    /** If enabled, the audio for all the chunks of a generation, once concatenated together, will constitute a single audio file. Otherwise, if disabled, each chunk's audio will be its own audio file, each with its own headers (if applicable). */
    stripHeaders?: boolean;
    audio: core.file.Uploadable;
    /** Utterances to use as context for generating consistent speech style and prosody across multiple requests. These will not be converted to speech output. */
    context?: Hume.tts.PostedContext;
    voice?: Hume.tts.PostedUtteranceVoice;
    /** Specifies the output audio file format. */
    format?: Hume.tts.Format;
    /** The set of timestamp types to include in the response. When used in multipart/form-data, specify each value using bracket notation: `include_timestamp_types[0]=word&include_timestamp_types[1]=phoneme`. Only supported for Octave 2 requests. */
    includeTimestampTypes?: Hume.tts.TimestampType[];
}

```


## /src/api/resources/tts/client/requests/ConvertVoiceJsonRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../../core/index.js";
import type * as Hume from "../../../../index.js";

/**
 * @example
 *     {}
 */
export interface ConvertVoiceJsonRequest {
    /** If enabled, the audio for all the chunks of a generation, once concatenated together, will constitute a single audio file. Otherwise, if disabled, each chunk's audio will be its own audio file, each with its own headers (if applicable). */
    stripHeaders?: boolean;
    audio?: core.file.Uploadable | undefined;
    /** Utterances to use as context for generating consistent speech style and prosody across multiple requests. These will not be converted to speech output. */
    context?: Hume.tts.PostedContext;
    voice?: Hume.tts.PostedUtteranceVoice;
    /** Specifies the output audio file format. */
    format?: Hume.tts.Format;
    /** The set of timestamp types to include in the response. When used in multipart/form-data, specify each value using bracket notation: `include_timestamp_types[0]=word&include_timestamp_types[1]=phoneme`. Only supported for Octave 2 requests. */
    includeTimestampTypes?: Hume.tts.TimestampType[];
}

```


## /src/api/resources/tts/client/requests/index.ts
```typescript
export type { ConvertVoiceFileRequest } from "./ConvertVoiceFileRequest.js";
export type { ConvertVoiceJsonRequest } from "./ConvertVoiceJsonRequest.js";

```


## /src/api/resources/tts/errors/BadRequestError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../core/index.js";
import * as errors from "../../../../errors/index.js";
import type * as Hume from "../../../index.js";

export class BadRequestError extends errors.HumeError {
    constructor(body: Hume.tts.ErrorResponse, rawResponse?: core.RawResponse) {
        super({
            message: "BadRequestError",
            statusCode: 400,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }

        this.name = this.constructor.name;
    }
}

```


## /src/api/resources/tts/errors/UnprocessableEntityError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../core/index.js";
import * as errors from "../../../../errors/index.js";
import type * as Hume from "../../../index.js";

export class UnprocessableEntityError extends errors.HumeError {
    constructor(body: Hume.tts.HttpValidationError, rawResponse?: core.RawResponse) {
        super({
            message: "UnprocessableEntityError",
            statusCode: 422,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }

        this.name = this.constructor.name;
    }
}

```


## /src/api/resources/tts/errors/index.ts
```typescript
export * from "./BadRequestError.js";
export * from "./UnprocessableEntityError.js";

```


## /src/api/resources/tts/index.ts
```typescript
export * from "./client/index.js";
export * from "./errors/index.js";
export * from "./resources/index.js";
export * from "./types/index.js";

```


## /src/api/resources/tts/resources/index.ts
```typescript
export * as streamInput from "./streamInput/index.js";
export * from "./voices/client/requests/index.js";
export * as voices from "./voices/index.js";

```


## /src/api/resources/tts/resources/streamInput/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import * as serializers from "../../../../../../serialization/index.js";
import type * as Hume from "../../../../../index.js";
import { StreamInputSocket } from "./Socket.js";

export declare namespace StreamInputClient {
    export interface Options extends BaseClientOptions {}

    export interface ConnectArgs {
        accessToken?: string;
        contextGenerationId?: string;
        formatType?: Hume.tts.AudioFormatType;
        includeTimestampTypes?: Hume.tts.TimestampType | Hume.tts.TimestampType[];
        instantMode?: boolean;
        noBinary?: boolean;
        stripHeaders?: boolean;
        version?: Hume.tts.OctaveVersion;
        apiKey?: string;
        /** Arbitrary headers to send with the websocket connect request. */
        headers?: Record<string, string>;
        /** Enable debug mode on the websocket. Defaults to false. */
        debug?: boolean;
        /** Number of reconnect attempts. Defaults to 30. */
        reconnectAttempts?: number;
    }
}

export class StreamInputClient {
    protected readonly _options: NormalizedClientOptions<StreamInputClient.Options>;

    constructor(options: StreamInputClient.Options = {}) {
        this._options = normalizeClientOptions(options);
    }

    public async connect(args: StreamInputClient.ConnectArgs = {}): Promise<StreamInputSocket> {
        const {
            accessToken,
            contextGenerationId,
            formatType,
            includeTimestampTypes,
            instantMode,
            noBinary,
            stripHeaders,
            version,
            apiKey,
            headers,
            debug,
            reconnectAttempts,
        } = args;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (accessToken != null) {
            _queryParams.access_token = accessToken;
        }

        if (contextGenerationId != null) {
            _queryParams.context_generation_id = contextGenerationId;
        }

        if (formatType != null) {
            _queryParams.format_type = serializers.tts.AudioFormatType.jsonOrThrow(formatType, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            });
        }

        if (includeTimestampTypes != null) {
            if (Array.isArray(includeTimestampTypes)) {
                _queryParams.include_timestamp_types = includeTimestampTypes.map((item) =>
                    serializers.tts.TimestampType.jsonOrThrow(item, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    }),
                );
            } else {
                _queryParams.include_timestamp_types = serializers.tts.TimestampType.jsonOrThrow(
                    includeTimestampTypes,
                    {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    },
                );
            }
        }

        if (instantMode != null) {
            _queryParams.instant_mode = instantMode.toString();
        }

        if (noBinary != null) {
            _queryParams.no_binary = noBinary.toString();
        }

        if (stripHeaders != null) {
            _queryParams.strip_headers = stripHeaders.toString();
        }

        if (version != null) {
            _queryParams.version = serializers.tts.OctaveVersion.jsonOrThrow(version, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            });
        }

        if (apiKey != null) {
            _queryParams.api_key = apiKey;
        }

        const _headers: Record<string, unknown> = mergeHeaders(
            mergeOnlyDefinedHeaders({
                ...(await this._getCustomAuthorizationHeaders()),
            }),
            headers,
        );
        const socket = new core.ReconnectingWebSocket({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).tts,
                "/stream/input",
            ),
            protocols: [],
            queryParameters: _queryParams,
            headers: _headers,
            options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
        });
        return new StreamInputSocket({ socket });
    }

    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
        const apiKeyValue = core.Supplier.get(this._options.apiKey);
        // This `authHeaderValue` is manually added as if you don't provide it it will
        // be omitted from the headers which means it won't reach the logic in ws.ts that
        // extracts values from the headers and adds them to query parameters.
        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
    }
}

```


## /src/api/resources/tts/resources/streamInput/client/Client.ts.diff
```diff
diff --git a/src/api/resources/tts/resources/streamInput/client/Client.ts b/src/api/resources/tts/resources/streamInput/client/Client.ts
index e8477c1..4e3ef08 100644
--- a/src/api/resources/tts/resources/streamInput/client/Client.ts
+++ b/src/api/resources/tts/resources/streamInput/client/Client.ts
@@ -2,7 +2,6 @@
 
 import type { BaseClientOptions } from "../../../../../../BaseClient.js";
 import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
-import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
 import * as core from "../../../../../../core/index.js";
 import * as environments from "../../../../../../environments.js";
 import * as serializers from "../../../../../../serialization/index.js";
@@ -10,7 +9,7 @@ import type * as Hume from "../../../../../index.js";
 import { StreamInputSocket } from "./Socket.js";
 
 export declare namespace StreamInputClient {
-    export interface Options extends BaseClientOptions {}
+    export type Options = BaseClientOptions;
 
     export interface ConnectArgs {
         accessToken?: string;
@@ -53,70 +52,42 @@ export class StreamInputClient {
             debug,
             reconnectAttempts,
         } = args;
-        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
-        if (accessToken != null) {
-            _queryParams.access_token = accessToken;
-        }
-
-        if (contextGenerationId != null) {
-            _queryParams.context_generation_id = contextGenerationId;
-        }
-
-        if (formatType != null) {
-            _queryParams.format_type = serializers.tts.AudioFormatType.jsonOrThrow(formatType, {
-                unrecognizedObjectKeys: "strip",
-                omitUndefined: true,
-            });
-        }
-
-        if (includeTimestampTypes != null) {
-            if (Array.isArray(includeTimestampTypes)) {
-                _queryParams.include_timestamp_types = includeTimestampTypes.map((item) =>
-                    serializers.tts.TimestampType.jsonOrThrow(item, {
+        const _queryParams: Record<string, unknown> = {
+            access_token: accessToken,
+            context_generation_id: contextGenerationId,
+            format_type:
+                formatType != null
+                    ? serializers.tts.AudioFormatType.jsonOrThrow(formatType, {
+                          unrecognizedObjectKeys: "strip",
+                          omitUndefined: true,
+                      })
+                    : undefined,
+            include_timestamp_types: Array.isArray(includeTimestampTypes)
+                ? includeTimestampTypes.map((item) =>
+                      serializers.tts.TimestampType.jsonOrThrow(item, {
+                          unrecognizedObjectKeys: "strip",
+                          omitUndefined: true,
+                      }),
+                  )
+                : includeTimestampTypes != null
+                  ? serializers.tts.TimestampType.jsonOrThrow(includeTimestampTypes, {
                         unrecognizedObjectKeys: "strip",
                         omitUndefined: true,
-                    }),
-                );
-            } else {
-                _queryParams.include_timestamp_types = serializers.tts.TimestampType.jsonOrThrow(
-                    includeTimestampTypes,
-                    {
-                        unrecognizedObjectKeys: "strip",
-                        omitUndefined: true,
-                    },
-                );
-            }
-        }
-
-        if (instantMode != null) {
-            _queryParams.instant_mode = instantMode.toString();
-        }
-
-        if (noBinary != null) {
-            _queryParams.no_binary = noBinary.toString();
-        }
-
-        if (stripHeaders != null) {
-            _queryParams.strip_headers = stripHeaders.toString();
-        }
-
-        if (version != null) {
-            _queryParams.version = serializers.tts.OctaveVersion.jsonOrThrow(version, {
-                unrecognizedObjectKeys: "strip",
-                omitUndefined: true,
-            });
-        }
-
-        if (apiKey != null) {
-            _queryParams.api_key = apiKey;
-        }
-
-        const _headers: Record<string, unknown> = mergeHeaders(
-            mergeOnlyDefinedHeaders({
-                ...(await this._getCustomAuthorizationHeaders()),
-            }),
-            headers,
-        );
+                    })
+                  : undefined,
+            instant_mode: instantMode,
+            no_binary: noBinary,
+            strip_headers: stripHeaders,
+            version:
+                version != null
+                    ? serializers.tts.OctaveVersion.jsonOrThrow(version, {
+                          unrecognizedObjectKeys: "strip",
+                          omitUndefined: true,
+                      })
+                    : undefined,
+            api_key: apiKey,
+        };
+        const _headers: Record<string, unknown> = { ...headers };
         const socket = new core.ReconnectingWebSocket({
             url: core.url.join(
                 (await core.Supplier.get(this._options.baseUrl)) ??
@@ -130,13 +101,4 @@ export class StreamInputClient {
         });
         return new StreamInputSocket({ socket });
     }
-
-    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
-        const apiKeyValue = core.Supplier.get(this._options.apiKey);
-        // This `authHeaderValue` is manually added as if you don't provide it it will
-        // be omitted from the headers which means it won't reach the logic in ws.ts that
-        // extracts values from the headers and adds them to query parameters.
-        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
-        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
-    }
 }

```


## /src/api/resources/tts/resources/streamInput/client/Socket.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import * as core from "../../../../../../core/index.js";
import { fromJson } from "../../../../../../core/json.js";
import * as serializers from "../../../../../../serialization/index.js";
import { PublishTts } from "../../../../../../serialization/resources/tts/types/PublishTts.js";
import type * as Hume from "../../../../../index.js";

export declare namespace StreamInputSocket {
    export interface Args {
        socket: core.ReconnectingWebSocket;
    }

    export type Response = Hume.tts.TtsOutput;
    type EventHandlers = {
        open?: () => void;
        message?: (message: Response) => void;
        close?: (event: core.CloseEvent) => void;
        error?: (error: Error) => void;
    };
}

export class StreamInputSocket {
    public readonly socket: core.ReconnectingWebSocket;
    protected readonly eventHandlers: StreamInputSocket.EventHandlers = {};
    private handleOpen: () => void = () => {
        this.eventHandlers.open?.();
    };
    private handleMessage: (event: { data: string }) => void = (event) => {
        const data = fromJson(event.data);

        const parsedResponse = serializers.tts.StreamInputSocketResponse.parse(data, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        if (parsedResponse.ok) {
            this.eventHandlers.message?.(parsedResponse.value);
        } else {
            this.eventHandlers.error?.(new Error("Received unknown message type"));
        }
    };
    private handleClose: (event: core.CloseEvent) => void = (event) => {
        this.eventHandlers.close?.(event);
    };
    private handleError: (event: core.ErrorEvent) => void = (event) => {
        const message = event.message;
        this.eventHandlers.error?.(new Error(message));
    };

    constructor(args: StreamInputSocket.Args) {
        this.socket = args.socket;
        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);
    }

    /** The current state of the connection; this is one of the readyState constants. */
    get readyState(): number {
        return this.socket.readyState;
    }

    /**
     * @param event - The event to attach to.
     * @param callback - The callback to run when the event is triggered.
     * Usage:
     * ```typescript
     * this.on('open', () => {
     *     console.log('The websocket is open');
     * });
     * ```
     */
    public on<T extends keyof StreamInputSocket.EventHandlers>(
        event: T,
        callback: StreamInputSocket.EventHandlers[T],
    ): void {
        this.eventHandlers[event] = callback;
    }

    public sendPublish(message: Hume.tts.PublishTts): void {
        this.assertSocketIsOpen();
        const jsonPayload = PublishTts.jsonOrThrow(message, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        this.socket.send(JSON.stringify(jsonPayload));
    }

    /** Connect to the websocket and register event handlers. */
    public connect(): StreamInputSocket {
        this.socket.reconnect();

        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);

        return this;
    }

    /** Close the websocket and unregister event handlers. */
    public close(): void {
        this.socket.close();

        this.handleClose({ code: 1000 } as CloseEvent);

        this.socket.removeEventListener("open", this.handleOpen);
        this.socket.removeEventListener("message", this.handleMessage);
        this.socket.removeEventListener("close", this.handleClose);
        this.socket.removeEventListener("error", this.handleError);
    }

    /** Returns a promise that resolves when the websocket is open. */
    public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
        if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
            return this.socket;
        }

        return new Promise((resolve, reject) => {
            this.socket.addEventListener("open", () => {
                resolve(this.socket);
            });

            this.socket.addEventListener("error", (event: unknown) => {
                reject(event);
            });
        });
    }

    /** Asserts that the websocket is open. */
    private assertSocketIsOpen(): void {
        if (!this.socket) {
            throw new Error("Socket is not connected.");
        }

        if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
            throw new Error("Socket is not open.");
        }
    }

    /** Send a binary payload to the websocket. */
    protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
        this.socket.send(payload);
    }
}

```


## /src/api/resources/tts/resources/streamInput/client/index.ts
```typescript
export {};

```


## /src/api/resources/tts/resources/streamInput/index.ts
```typescript
export * from "./client/index.js";

```


## /src/api/resources/tts/resources/voices/client/Client.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace VoicesClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class VoicesClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<VoicesClient.Options>;

    constructor(options: VoicesClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Lists voices you have saved in your account, or voices from the [Voice Library](https://app.hume.ai/voices).
     *
     * @param {Hume.tts.VoicesListRequest} request
     * @param {VoicesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.tts.BadRequestError}
     *
     * @example
     *     await client.tts.voices.list({
     *         provider: "CUSTOM_VOICE"
     *     })
     */
    public async list(
        request: Hume.tts.VoicesListRequest,
        requestOptions?: VoicesClient.RequestOptions,
    ): Promise<core.Page<Hume.tts.ReturnVoice, Hume.tts.ReturnPagedVoices>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (request: Hume.tts.VoicesListRequest): Promise<core.WithRawResponse<Hume.tts.ReturnPagedVoices>> => {
                const { provider, pageNumber, pageSize, ascendingOrder, filterTag } = request;
                const _queryParams: Record<string, unknown> = {
                    provider: serializers.tts.VoiceProvider.jsonOrThrow(provider, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    }),
                    page_number: pageNumber,
                    page_size: pageSize,
                    ascending_order: ascendingOrder,
                    filter_tag: filterTag,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/tts/voices",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.tts.ReturnPagedVoices.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.tts.BadRequestError(
                                serializers.tts.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/tts/voices");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.tts.ReturnVoice, Hume.tts.ReturnPagedVoices>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.voicesPage ?? []).length > 0,
            getItems: (response) => response?.voicesPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * Saves a new custom voice to your account using the specified TTS generation ID.
     *
     * Once saved, this voice can be reused in subsequent TTS requests, ensuring consistent speech style and prosody. For more details on voice creation, see the [Voices Guide](/docs/text-to-speech-tts/voices).
     *
     * @param {Hume.tts.PostedVoice} request
     * @param {VoicesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.tts.UnprocessableEntityError}
     *
     * @example
     *     await client.tts.voices.create({
     *         generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
     *         name: "David Hume"
     *     })
     */
    public create(
        request: Hume.tts.PostedVoice,
        requestOptions?: VoicesClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.tts.ReturnVoice> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: Hume.tts.PostedVoice,
        requestOptions?: VoicesClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.tts.ReturnVoice>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/voices",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.tts.PostedVoice.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.tts.ReturnVoice.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts/voices");
    }

    /**
     * Deletes a previously generated custom voice.
     *
     * @param {Hume.tts.VoicesDeleteRequest} request
     * @param {VoicesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.tts.BadRequestError}
     *
     * @example
     *     await client.tts.voices.delete({
     *         name: "David Hume"
     *     })
     */
    public delete(
        request: Hume.tts.VoicesDeleteRequest,
        requestOptions?: VoicesClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: Hume.tts.VoicesDeleteRequest,
        requestOptions?: VoicesClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const { name } = request;
        const _queryParams: Record<string, unknown> = {
            name,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/voices",
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.tts.BadRequestError(
                        serializers.tts.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v0/tts/voices");
    }
}

```


## /src/api/resources/tts/resources/voices/client/index.ts
```typescript
export * from "./requests/index.js";

```


## /src/api/resources/tts/resources/voices/client/requests/PostedVoice.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
 *         name: "David Hume"
 *     }
 */
export interface PostedVoice {
    /** A unique ID associated with this TTS generation that can be used as context for generating consistent speech style and prosody across multiple requests. */
    generationId: string;
    /** The name of a **Voice**. */
    name: string;
}

```


## /src/api/resources/tts/resources/voices/client/requests/VoicesDeleteRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         name: "David Hume"
 *     }
 */
export interface VoicesDeleteRequest {
    /** Name of the voice to delete */
    name: string;
}

```


## /src/api/resources/tts/resources/voices/client/requests/VoicesListRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../index.js";

/**
 * @example
 *     {
 *         provider: "CUSTOM_VOICE"
 *     }
 */
export interface VoicesListRequest {
    /**
     * Specify the voice provider to filter voices returned by the endpoint:
     *
     * - **`HUME_AI`**: Lists preset, shared voices from Hume's [Voice Library](https://app.hume.ai/voices).
     * - **`CUSTOM_VOICE`**: Lists custom voices created and saved to your account.
     */
    provider: Hume.tts.VoiceProvider;
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    ascendingOrder?: boolean;
    filterTag?: string | string[];
}

```


## /src/api/resources/tts/resources/voices/client/requests/index.ts
```typescript
export type { PostedVoice } from "./PostedVoice.js";
export type { VoicesDeleteRequest } from "./VoicesDeleteRequest.js";
export type { VoicesListRequest } from "./VoicesListRequest.js";

```


## /src/api/resources/tts/resources/voices/index.ts
```typescript
export * from "./client/index.js";

```


## /src/api/resources/tts/types/AudioEncoding.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Encoding information about the generated audio, including the `format` and `sample_rate`.
 */
export interface AudioEncoding {
    /** Format for the output audio. */
    format: Hume.tts.AudioFormatType;
    /** The sample rate (`Hz`) of the generated audio. The default sample rate is `48000 Hz`. */
    sampleRate: number;
}

```


## /src/api/resources/tts/types/AudioFormatType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const AudioFormatType = {
    Mp3: "mp3",
    Pcm: "pcm",
    Wav: "wav",
} as const;
export type AudioFormatType = (typeof AudioFormatType)[keyof typeof AudioFormatType];

```


## /src/api/resources/tts/types/ErrorResponse.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface ErrorResponse {
    code?: string;
    error?: string;
    message?: string;
}

```


## /src/api/resources/tts/types/Format.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Specifies the output audio file format.
 */
export type Format = Hume.tts.FormatMp3 | Hume.tts.FormatPcm | Hume.tts.FormatWav;

```


## /src/api/resources/tts/types/FormatMp3.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface FormatMp3 {
    type: "mp3";
}

```


## /src/api/resources/tts/types/FormatPcm.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface FormatPcm {
    type: "pcm";
}

```


## /src/api/resources/tts/types/FormatWav.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface FormatWav {
    type: "wav";
}

```


## /src/api/resources/tts/types/HttpValidationError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface HttpValidationError {
    detail?: Hume.tts.ValidationError[];
}

```


## /src/api/resources/tts/types/MillisecondInterval.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface MillisecondInterval {
    /** Start time of the interval in milliseconds. */
    begin: number;
    /** End time of the interval in milliseconds. */
    end: number;
}

```


## /src/api/resources/tts/types/OctaveVersion.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

/**
 * Selects the Octave model version used to synthesize speech for this request. If you omit this field, Hume
 * automatically routes the request to the most appropriate model. Setting a specific version ensures stable and
 * repeatable behavior across requests.
 *
 * Use `2` to opt into the latest Octave capabilities. When you specify version `2`, you must also provide a
 * `voice`. Requests that set `version: 2` without a voice will be rejected.
 *
 * For a comparison of Octave versions, see the
 * [Octave versions](/docs/text-to-speech-tts/overview#octave-versions) section in the TTS overview.
 */
export const OctaveVersion = {
    One: "1",
    Two: "2",
} as const;
export type OctaveVersion = (typeof OctaveVersion)[keyof typeof OctaveVersion];

```


## /src/api/resources/tts/types/PostedContext.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Utterances to use as context for generating consistent speech style and prosody across multiple requests. These will not be converted to speech output.
 */
export type PostedContext = Hume.tts.PostedContextWithGenerationId | Hume.tts.PostedContextWithUtterances;

```


## /src/api/resources/tts/types/PostedContextWithGenerationId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface PostedContextWithGenerationId {
    /** The ID of a prior TTS generation to use as context for generating consistent speech style and prosody across multiple requests. Including context may increase audio generation times. */
    generationId: string;
}

```


## /src/api/resources/tts/types/PostedContextWithUtterances.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface PostedContextWithUtterances {
    utterances: Hume.tts.PostedUtterance[];
}

```


## /src/api/resources/tts/types/PostedTts.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface PostedTts {
    /** Utterances to use as context for generating consistent speech style and prosody across multiple requests. These will not be converted to speech output. */
    context?: Hume.tts.PostedContext;
    /** Specifies the output audio file format. */
    format?: Hume.tts.Format;
    /** The set of timestamp types to include in the response. Only supported for Octave 2 requests. */
    includeTimestampTypes?: Hume.tts.TimestampType[];
    /**
     * Number of audio generations to produce from the input utterances.
     *
     * Using `num_generations` enables faster processing than issuing multiple sequential requests. Additionally, specifying `num_generations` allows prosody continuation across all generations without repeating context, ensuring each generation sounds slightly different while maintaining contextual consistency.
     */
    numGenerations?: number;
    /**
     * Controls how audio output is segmented in the response.
     *
     * - When **enabled** (`true`), input utterances are automatically split into natural-sounding speech segments.
     *
     * - When **disabled** (`false`), the response maintains a strict one-to-one mapping between input utterances and output snippets.
     *
     * This setting affects how the `snippets` array is structured in the response, which may be important for applications that need to track the relationship between input text and generated audio segments. When setting to `false`, avoid including utterances with long `text`, as this can result in distorted output.
     */
    splitUtterances?: boolean;
    /** If enabled, the audio for all the chunks of a generation, once concatenated together, will constitute a single audio file. Otherwise, if disabled, each chunk's audio will be its own audio file, each with its own headers (if applicable). */
    stripHeaders?: boolean;
    /**
     * A list of **Utterances** to be converted to speech output.
     *
     * An **Utterance** is a unit of input for [Octave](/docs/text-to-speech-tts/overview), and includes input `text`, an optional `description` to serve as the prompt for how the speech should be delivered, an optional `voice` specification, and additional controls to guide delivery for `speed` and `trailing_silence`.
     */
    utterances: Hume.tts.PostedUtterance[];
    /**
     * Selects the Octave model version used to synthesize speech for this request. If you omit this field, Hume automatically routes the request to the most appropriate model. Setting a specific version ensures stable and repeatable behavior across requests.
     *
     * Use `2` to opt into the latest Octave capabilities. When you specify version `2`, you must also provide a `voice`. Requests that set `version: 2` without a voice will be rejected.
     *
     * For a comparison of Octave versions, see the [Octave versions](/docs/text-to-speech-tts/overview#octave-versions) section in the TTS overview.
     */
    version?: Hume.tts.OctaveVersion;
    instantMode?: boolean;
}

```


## /src/api/resources/tts/types/PostedUtterance.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface PostedUtterance {
    /**
     * Natural language instructions describing how the synthesized speech should sound, including but not limited to tone, intonation, pacing, and accent.
     *
     * **This field behaves differently depending on whether a voice is specified**:
     * - **Voice specified**: the description will serve as acting directions for delivery. Keep directions concise—100 characters or fewer—for best results. See our guide on [acting instructions](/docs/text-to-speech-tts/acting-instructions).
     * - **Voice not specified**: the description will serve as a voice prompt for generating a voice. See our [prompting guide](/docs/text-to-speech-tts/prompting) for design tips.
     */
    description?: string;
    /** Speed multiplier for the synthesized speech. Extreme values below 0.75 and above 1.5 may sometimes cause instability to the generated output. */
    speed?: number;
    /** The input text to be synthesized into speech. */
    text: string;
    /** Duration of trailing silence (in seconds) to add to this utterance */
    trailingSilence?: number;
    /**
     * The `name` or `id` associated with a **Voice** from the **Voice Library** to be used as the speaker for this and all subsequent `utterances`, until the `voice` field is updated again.
     *
     *  See our [voices guide](/docs/text-to-speech-tts/voices) for more details on generating and specifying **Voices**.
     */
    voice?: Hume.tts.PostedUtteranceVoice;
}

```


## /src/api/resources/tts/types/PostedUtteranceVoice.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type PostedUtteranceVoice = Hume.tts.PostedUtteranceVoiceWithId | Hume.tts.PostedUtteranceVoiceWithName;

```


## /src/api/resources/tts/types/PostedUtteranceVoiceWithId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface PostedUtteranceVoiceWithId {
    /** The unique ID associated with the **Voice**. */
    id: string;
    /**
     * Specifies the source provider associated with the chosen voice.
     *
     * - **`HUME_AI`**: Select voices from Hume's [Voice Library](https://app.hume.ai/voices), containing a variety of preset, shared voices.
     * - **`CUSTOM_VOICE`**: Select from voices you've personally generated and saved in your account.
     *
     * If no provider is explicitly set, the default provider is `CUSTOM_VOICE`. When using voices from Hume's **Voice Library**, you must explicitly set the provider to `HUME_AI`.
     *
     * Preset voices from Hume's **Voice Library** are accessible by all users. In contrast, your custom voices are private and accessible only via requests authenticated with your API key.
     */
    provider?: Hume.tts.VoiceProvider;
}

```


## /src/api/resources/tts/types/PostedUtteranceVoiceWithName.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface PostedUtteranceVoiceWithName {
    /** The name of a **Voice**. */
    name: string;
    /**
     * Specifies the source provider associated with the chosen voice.
     *
     * - **`HUME_AI`**: Select voices from Hume's [Voice Library](https://app.hume.ai/voices), containing a variety of preset, shared voices.
     * - **`CUSTOM_VOICE`**: Select from voices you've personally generated and saved in your account.
     *
     * If no provider is explicitly set, the default provider is `CUSTOM_VOICE`. When using voices from Hume's **Voice Library**, you must explicitly set the provider to `HUME_AI`.
     *
     * Preset voices from Hume's **Voice Library** are accessible by all users. In contrast, your custom voices are private and accessible only via requests authenticated with your API key.
     */
    provider?: Hume.tts.VoiceProvider;
}

```


## /src/api/resources/tts/types/PublishTts.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Input message type for the TTS stream.
 */
export interface PublishTts {
    /** Force the generation of audio and close the stream. */
    close?: boolean;
    /**
     * Natural language instructions describing how the synthesized speech should sound, including but not limited to tone, intonation, pacing, and accent.
     *
     * **This field behaves differently depending on whether a voice is specified**:
     * - **Voice specified**: the description will serve as acting directions for delivery. Keep directions concise—100 characters or fewer—for best results. See our guide on [acting instructions](/docs/text-to-speech-tts/acting-instructions).
     * - **Voice not specified**: the description will serve as a voice prompt for generating a voice. See our [prompting guide](/docs/text-to-speech-tts/prompting) for design tips.
     */
    description?: string;
    /** Force the generation of audio regardless of how much text has been supplied. */
    flush?: boolean;
    /** Speed multiplier for the synthesized speech. Extreme values below 0.75 and above 1.5 may sometimes cause instability to the generated output. */
    speed?: number;
    /** The input text to be synthesized into speech. */
    text?: string;
    /** Duration of trailing silence (in seconds) to add to this utterance */
    trailingSilence?: number;
    /**
     * The `name` or `id` associated with a **Voice** from the **Voice Library** to be used as the speaker for this and all subsequent `utterances`, until the `voice` field is updated again.
     *
     *  See our [voices guide](/docs/text-to-speech-tts/voices) for more details on generating and specifying **Voices**.
     */
    voice?: Hume.tts.PostedUtteranceVoice;
}

```


## /src/api/resources/tts/types/ReturnGeneration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ReturnGeneration {
    /** The generated audio output in the requested format, encoded as a base64 string. */
    audio: string;
    /** Duration of the generated audio in seconds. */
    duration: number;
    encoding: Hume.tts.AudioEncoding;
    /** Size of the generated audio in bytes. */
    fileSize: number;
    /** A unique ID associated with this TTS generation that can be used as context for generating consistent speech style and prosody across multiple requests. */
    generationId: string;
    /** A list of snippet groups where each group corresponds to an utterance in the request. Each group contains segmented snippets that represent the original utterance divided into more natural-sounding units optimized for speech delivery. */
    snippets: Hume.tts.Snippet[][];
}

```


## /src/api/resources/tts/types/ReturnPagedVoices.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list Octave voices available for text-to-speech
 */
export interface ReturnPagedVoices {
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    /** The total number of pages in the collection. */
    totalPages: number;
    /** List of voices returned for the specified `page_number` and `page_size`. */
    voicesPage: Hume.tts.ReturnVoice[];
}

```


## /src/api/resources/tts/types/ReturnTts.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ReturnTts {
    generations: Hume.tts.ReturnGeneration[];
    /** A unique ID associated with this request for tracking and troubleshooting. Use this ID when contacting [support](/support) for troubleshooting assistance. */
    requestId?: string;
}

```


## /src/api/resources/tts/types/ReturnVoice.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * An Octave voice available for text-to-speech
 */
export interface ReturnVoice {
    compatibleOctaveModels?: string[];
    /** ID of the voice in the `Voice Library`. */
    id: string;
    /** Name of the voice in the `Voice Library`. */
    name: string;
    /**
     * The provider associated with the created voice.
     *
     * Voices created through this endpoint will always have the provider set to `CUSTOM_VOICE`, indicating a custom voice stored in your account.
     */
    provider: Hume.tts.VoiceProvider;
}

```


## /src/api/resources/tts/types/Snippet.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface Snippet {
    /** The segmented audio output in the requested format, encoded as a base64 string. */
    audio: string;
    /** The generation ID this snippet corresponds to. */
    generationId: string;
    /** A unique ID associated with this **Snippet**. */
    id: string;
    /** The text for this **Snippet**. */
    text: string;
    /** A list of word or phoneme level timestamps for the generated audio. Timestamps are only returned for Octave 2 requests. */
    timestamps: Hume.tts.Timestamp[];
    /** The transcribed text of the generated audio. It is only present if `instant_mode` is set to `false`. */
    transcribedText?: string;
    /** The index of the utterance in the request this snippet corresponds to. */
    utteranceIndex?: number;
}

```


## /src/api/resources/tts/types/SnippetAudioChunk.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Metadata for a chunk of generated audio.
 */
export interface SnippetAudioChunk {
    /** The generated audio output chunk in the requested format. */
    audio: string;
    /** The generated audio output format. */
    audioFormat: Hume.tts.AudioFormatType;
    /** The index of the audio chunk in the snippet. */
    chunkIndex: number;
    /** The generation ID of the parent snippet that this chunk corresponds to. */
    generationId: string;
    /** Whether or not this is the last chunk streamed back from the decoder for one input snippet. */
    isLastChunk: boolean;
    /** ID of the initiating request. */
    requestId: string;
    snippet?: Hume.tts.Snippet;
    /** The ID of the parent snippet that this chunk corresponds to. */
    snippetId: string;
    /** The text of the parent snippet that this chunk corresponds to. */
    text: string;
    /** The transcribed text of the generated audio of the parent snippet that this chunk corresponds to. It is only present if `instant_mode` is set to `false`. */
    transcribedText?: string;
    type: "audio";
    /** The index of the utterance in the request that the parent snippet of this chunk corresponds to. */
    utteranceIndex?: number;
}

```


## /src/api/resources/tts/types/Timestamp.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface Timestamp {
    /** The word or phoneme text that the timestamp corresponds to. */
    text: string;
    /** The start and end timestamps for the word or phoneme in milliseconds. */
    time: Hume.tts.MillisecondInterval;
    type: Hume.tts.TimestampType;
}

```


## /src/api/resources/tts/types/TimestampMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A word or phoneme level timestamp for the generated audio.
 */
export interface TimestampMessage {
    /** The generation ID of the parent snippet that this chunk corresponds to. */
    generationId: string;
    /** ID of the initiating request. */
    requestId: string;
    /** The ID of the parent snippet that this chunk corresponds to. */
    snippetId: string;
    /** A word or phoneme level timestamp for the generated audio. */
    timestamp: Hume.tts.Timestamp;
    type: "timestamp";
}

```


## /src/api/resources/tts/types/TimestampType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const TimestampType = {
    Word: "word",
    Phoneme: "phoneme",
} as const;
export type TimestampType = (typeof TimestampType)[keyof typeof TimestampType];

```


## /src/api/resources/tts/types/TtsOutput.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type TtsOutput = Hume.tts.SnippetAudioChunk | Hume.tts.TimestampMessage;

```


## /src/api/resources/tts/types/ValidationError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ValidationError {
    loc: Hume.tts.ValidationErrorLocItem[];
    msg: string;
    type: string;
}

```


## /src/api/resources/tts/types/ValidationErrorLocItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export type ValidationErrorLocItem = string | number;

```


## /src/api/resources/tts/types/VoiceProvider.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export const VoiceProvider = {
    HumeAi: "HUME_AI",
    CustomVoice: "CUSTOM_VOICE",
} as const;
export type VoiceProvider = (typeof VoiceProvider)[keyof typeof VoiceProvider];

```


## /src/api/resources/tts/types/index.ts
```typescript
export * from "./AudioEncoding.js";
export * from "./AudioFormatType.js";
export * from "./ErrorResponse.js";
export * from "./Format.js";
export * from "./FormatMp3.js";
export * from "./FormatPcm.js";
export * from "./FormatWav.js";
export * from "./HttpValidationError.js";
export * from "./MillisecondInterval.js";
export * from "./OctaveVersion.js";
export * from "./PostedContext.js";
export * from "./PostedContextWithGenerationId.js";
export * from "./PostedContextWithUtterances.js";
export * from "./PostedTts.js";
export * from "./PostedUtterance.js";
export * from "./PostedUtteranceVoice.js";
export * from "./PostedUtteranceVoiceWithId.js";
export * from "./PostedUtteranceVoiceWithName.js";
export * from "./PublishTts.js";
export * from "./ReturnGeneration.js";
export * from "./ReturnPagedVoices.js";
export * from "./ReturnTts.js";
export * from "./ReturnVoice.js";
export * from "./Snippet.js";
export * from "./SnippetAudioChunk.js";
export * from "./Timestamp.js";
export * from "./TimestampMessage.js";
export * from "./TimestampType.js";
export * from "./TtsOutput.js";
export * from "./ValidationError.js";
export * from "./ValidationErrorLocItem.js";
export * from "./VoiceProvider.js";

```


## /src/auth/HeaderAuthProvider.ts
```typescript
/**
 * THIS FILE IS MANUALLY MAINTAINED: see .fernignore
 *
 * Custom HeaderAuthProvider that supports both apiKey and accessToken authentication.
 * When accessToken is provided to HumeClient, the wrapper converts it to an
 * Authorization: Bearer header. This provider checks for both apiKey and the
 * Authorization header to support both auth methods.
 */

import * as core from "../core/index.js";
import * as errors from "../errors/index.js";

export namespace HeaderAuthProvider {
    export type AuthOptions = {
        apiKey?: core.Supplier<string | undefined>;
    };

    export type Options = {
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    } & AuthOptions;
}

export class HeaderAuthProvider implements core.AuthProvider {
    private readonly options: HeaderAuthProvider.Options;

    constructor(options: HeaderAuthProvider.Options) {
        this.options = options;
    }

    public static canCreate(options: HeaderAuthProvider.Options): boolean {
        return options.apiKey != null || HeaderAuthProvider.hasAuthorizationHeader(options.headers);
    }

    private static hasAuthorizationHeader(
        headers: Record<string, string | core.Supplier<string | null | undefined> | null | undefined> | undefined,
    ): boolean {
        if (!headers) return false;
        return Object.keys(headers).some((key) => key.toLowerCase() === "authorization");
    }

    public async getAuthRequest(_arg?: { endpointMetadata?: core.EndpointMetadata }): Promise<core.AuthRequest> {
        // Check apiKey first (preferred method)
        const apiKey = await core.Supplier.get(this.options.apiKey);
        if (apiKey != null) {
            return { headers: { "X-Hume-Api-Key": apiKey } };
        }

        // Check for Authorization header (from accessToken)
        if (this.options.headers) {
            const authKey = Object.keys(this.options.headers).find((key) => key.toLowerCase() === "authorization");
            if (authKey) {
                const authValue = await core.Supplier.get(this.options.headers[authKey]);
                if (authValue != null) {
                    return { headers: { Authorization: authValue } };
                }
            }
        }

        throw new errors.HumeError({
            message: "Please provide either 'apiKey' or 'accessToken' when initializing the client",
        });
    }
}

```


## /src/auth/HeaderAuthProvider.ts.diff
```diff
diff --git a/src/auth/HeaderAuthProvider.ts b/src/auth/HeaderAuthProvider.ts
index 8089bcc..83c2e42 100644
--- a/src/auth/HeaderAuthProvider.ts
+++ b/src/auth/HeaderAuthProvider.ts
@@ -1,24 +1,10 @@
-/**
- * THIS FILE IS MANUALLY MAINTAINED: see .fernignore
- *
- * Custom HeaderAuthProvider that supports both apiKey and accessToken authentication.
- * When accessToken is provided to HumeClient, the wrapper converts it to an
- * Authorization: Bearer header. This provider checks for both apiKey and the
- * Authorization header to support both auth methods.
- */
+// This file was auto-generated by Fern from our API Definition.
 
 import * as core from "../core/index.js";
 import * as errors from "../errors/index.js";
 
-export namespace HeaderAuthProvider {
-    export type AuthOptions = {
-        apiKey?: core.Supplier<string | undefined>;
-    };
-
-    export type Options = {
-        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
-    } & AuthOptions;
-}
+const PARAM_KEY = "apiKey" as const;
+const HEADER_NAME = "X-Hume-Api-Key" as const;
 
 export class HeaderAuthProvider implements core.AuthProvider {
     private readonly options: HeaderAuthProvider.Options;
@@ -27,37 +13,36 @@ export class HeaderAuthProvider implements core.AuthProvider {
         this.options = options;
     }
 
-    public static canCreate(options: HeaderAuthProvider.Options): boolean {
-        return options.apiKey != null || HeaderAuthProvider.hasAuthorizationHeader(options.headers);
-    }
-
-    private static hasAuthorizationHeader(
-        headers: Record<string, string | core.Supplier<string | null | undefined> | null | undefined> | undefined,
-    ): boolean {
-        if (!headers) return false;
-        return Object.keys(headers).some((key) => key.toLowerCase() === "authorization");
+    public static canCreate(options: Partial<HeaderAuthProvider.Options>): boolean {
+        return options?.[PARAM_KEY] != null;
     }
 
-    public async getAuthRequest(_arg?: { endpointMetadata?: core.EndpointMetadata }): Promise<core.AuthRequest> {
-        // Check apiKey first (preferred method)
-        const apiKey = await core.Supplier.get(this.options.apiKey);
-        if (apiKey != null) {
-            return { headers: { "X-Hume-Api-Key": apiKey } };
+    public async getAuthRequest({
+        endpointMetadata,
+    }: {
+        endpointMetadata?: core.EndpointMetadata;
+    } = {}): Promise<core.AuthRequest> {
+        const headerValue = await core.Supplier.get(this.options[PARAM_KEY]);
+        if (headerValue == null) {
+            throw new errors.HumeError({
+                message: HeaderAuthProvider.AUTH_CONFIG_ERROR_MESSAGE,
+            });
         }
 
-        // Check for Authorization header (from accessToken)
-        if (this.options.headers) {
-            const authKey = Object.keys(this.options.headers).find((key) => key.toLowerCase() === "authorization");
-            if (authKey) {
-                const authValue = await core.Supplier.get(this.options.headers[authKey]);
-                if (authValue != null) {
-                    return { headers: { Authorization: authValue } };
-                }
-            }
-        }
+        return {
+            headers: { [HEADER_NAME]: headerValue },
+        };
+    }
+}
 
-        throw new errors.HumeError({
-            message: "Please provide either 'apiKey' or 'accessToken' when initializing the client",
-        });
+export namespace HeaderAuthProvider {
+    export const AUTH_SCHEME = "HeaderAuthScheme" as const;
+    export const AUTH_CONFIG_ERROR_MESSAGE: string =
+        `Please provide '${PARAM_KEY}' when initializing the client` as const;
+    export type Options = AuthOptions;
+    export type AuthOptions = { [PARAM_KEY]: core.Supplier<string> };
+
+    export function createInstance(options: Options): core.AuthProvider {
+        return new HeaderAuthProvider(options);
     }
 }

```


## /src/auth/index.ts
```typescript
export { HeaderAuthProvider } from "./HeaderAuthProvider.js";

```


## /src/core/auth/AuthProvider.ts
```typescript
import type { EndpointMetadata } from "../fetcher/EndpointMetadata.js";
import type { AuthRequest } from "./AuthRequest.js";

export interface AuthProvider {
    getAuthRequest(arg?: { endpointMetadata?: EndpointMetadata }): Promise<AuthRequest>;
}

```


## /src/core/auth/AuthRequest.ts
```typescript
/**
 * Request parameters for authentication requests.
 */
export interface AuthRequest {
    /**
     * The headers to be included in the request.
     */
    headers: Record<string, string>;
}

```


## /src/core/auth/BasicAuth.ts
```typescript
import { base64Decode, base64Encode } from "../base64.js";

export interface BasicAuth {
    username: string;
    password: string;
}

const BASIC_AUTH_HEADER_PREFIX = /^Basic /i;

export const BasicAuth = {
    toAuthorizationHeader: (basicAuth: BasicAuth | undefined): string | undefined => {
        if (basicAuth == null) {
            return undefined;
        }
        const token = base64Encode(`${basicAuth.username}:${basicAuth.password}`);
        return `Basic ${token}`;
    },
    fromAuthorizationHeader: (header: string): BasicAuth => {
        const credentials = header.replace(BASIC_AUTH_HEADER_PREFIX, "");
        const decoded = base64Decode(credentials);
        const [username, ...passwordParts] = decoded.split(":");
        const password = passwordParts.length > 0 ? passwordParts.join(":") : undefined;

        if (username == null || password == null) {
            throw new Error("Invalid basic auth");
        }
        return {
            username,
            password,
        };
    },
};

```


## /src/core/auth/BearerToken.ts
```typescript
export type BearerToken = string;

const BEARER_AUTH_HEADER_PREFIX = /^Bearer /i;

function toAuthorizationHeader(token: string | undefined): string | undefined {
    if (token == null) {
        return undefined;
    }
    return `Bearer ${token}`;
}

export const BearerToken: {
    toAuthorizationHeader: typeof toAuthorizationHeader;
    fromAuthorizationHeader: (header: string) => BearerToken;
} = {
    toAuthorizationHeader: toAuthorizationHeader,
    fromAuthorizationHeader: (header: string): BearerToken => {
        return header.replace(BEARER_AUTH_HEADER_PREFIX, "").trim() as BearerToken;
    },
};

```


## /src/core/auth/NoOpAuthProvider.ts
```typescript
import type { AuthProvider } from "./AuthProvider.js";
import type { AuthRequest } from "./AuthRequest.js";

export class NoOpAuthProvider implements AuthProvider {
    public getAuthRequest(): Promise<AuthRequest> {
        return Promise.resolve({ headers: {} });
    }
}

```


## /src/core/auth/index.ts
```typescript
export type { AuthProvider } from "./AuthProvider.js";
export type { AuthRequest } from "./AuthRequest.js";
export { BasicAuth } from "./BasicAuth.js";
export { BearerToken } from "./BearerToken.js";
export { NoOpAuthProvider } from "./NoOpAuthProvider.js";

```


## /src/core/base64.ts
```typescript
function base64ToBytes(base64: string): Uint8Array {
    const binString = atob(base64);
    return Uint8Array.from(binString, (m) => m.codePointAt(0)!);
}

function bytesToBase64(bytes: Uint8Array): string {
    const binString = String.fromCodePoint(...bytes);
    return btoa(binString);
}

export function base64Encode(input: string): string {
    if (typeof Buffer !== "undefined") {
        return Buffer.from(input, "utf8").toString("base64");
    }

    const bytes = new TextEncoder().encode(input);
    return bytesToBase64(bytes);
}

export function base64Decode(input: string): string {
    if (typeof Buffer !== "undefined") {
        return Buffer.from(input, "base64").toString("utf8");
    }

    const bytes = base64ToBytes(input);
    return new TextDecoder().decode(bytes);
}

```


## /src/core/exports.ts
```typescript
export * from "./file/exports.js";
export * from "./logging/exports.js";
export * from "./pagination/exports.js";
export * from "./websocket/exports.js";

```


## /src/core/fetcher/APIResponse.ts
```typescript
import type { RawResponse } from "./RawResponse.js";

/**
 * The response of an API call.
 * It is a successful response or a failed response.
 */
export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
    ok: true;
    body: T;
    /**
     * @deprecated Use `rawResponse` instead
     */
    headers?: Record<string, any>;
    rawResponse: RawResponse;
}

export interface FailedResponse<T> {
    ok: false;
    error: T;
    rawResponse: RawResponse;
}

```


## /src/core/fetcher/BinaryResponse.ts
```typescript
export type BinaryResponse = {
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/bodyUsed) */
    bodyUsed: Response["bodyUsed"];
    /**
     * Returns a ReadableStream of the response body.
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/body)
     */
    stream: () => Response["body"];
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/arrayBuffer) */
    arrayBuffer: () => ReturnType<Response["arrayBuffer"]>;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/blob) */
    blob: () => ReturnType<Response["blob"]>;
    /**
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/bytes)
     * Some versions of the Fetch API may not support this method.
     */
    bytes?(): ReturnType<Response["bytes"]>;
};

export function getBinaryResponse(response: Response): BinaryResponse {
    const binaryResponse: BinaryResponse = {
        get bodyUsed() {
            return response.bodyUsed;
        },
        stream: () => response.body,
        arrayBuffer: response.arrayBuffer.bind(response),
        blob: response.blob.bind(response),
    };
    if ("bytes" in response && typeof response.bytes === "function") {
        binaryResponse.bytes = response.bytes.bind(response);
    }

    return binaryResponse;
}

```


## /src/core/fetcher/EndpointMetadata.ts
```typescript
export type SecuritySchemeKey = string;
/**
 * A collection of security schemes, where the key is the name of the security scheme and the value is the list of scopes required for that scheme.
 * All schemes in the collection must be satisfied for authentication to be successful.
 */
export type SecuritySchemeCollection = Record<SecuritySchemeKey, AuthScope[]>;
export type AuthScope = string;
export type EndpointMetadata = {
    /**
     * An array of security scheme collections. Each collection represents an alternative way to authenticate.
     */
    security?: SecuritySchemeCollection[];
};

```


## /src/core/fetcher/EndpointSupplier.ts
```typescript
import type { EndpointMetadata } from "./EndpointMetadata.js";
import type { Supplier } from "./Supplier.js";

type EndpointSupplierFn<T> = (arg: { endpointMetadata?: EndpointMetadata }) => T | Promise<T>;
export type EndpointSupplier<T> = Supplier<T> | EndpointSupplierFn<T>;
export const EndpointSupplier = {
    get: async <T>(supplier: EndpointSupplier<T>, arg: { endpointMetadata?: EndpointMetadata }): Promise<T> => {
        if (typeof supplier === "function") {
            return (supplier as EndpointSupplierFn<T>)(arg);
        } else {
            return supplier;
        }
    },
};

```


## /src/core/fetcher/Fetcher.ts
```typescript
import { toJson } from "../json.js";
import { createLogger, type LogConfig, type Logger } from "../logging/logger.js";
import type { APIResponse } from "./APIResponse.js";
import { createRequestUrl } from "./createRequestUrl.js";
import type { EndpointMetadata } from "./EndpointMetadata.js";
import { EndpointSupplier } from "./EndpointSupplier.js";
import { getErrorResponseBody } from "./getErrorResponseBody.js";
import { getFetchFn } from "./getFetchFn.js";
import { getRequestBody } from "./getRequestBody.js";
import { getResponseBody } from "./getResponseBody.js";
import { Headers } from "./Headers.js";
import { makeRequest } from "./makeRequest.js";
import { abortRawResponse, toRawResponse, unknownRawResponse } from "./RawResponse.js";
import { requestWithRetries } from "./requestWithRetries.js";

export type FetchFunction = <R = unknown>(args: Fetcher.Args) => Promise<APIResponse<R, Fetcher.Error>>;

export declare namespace Fetcher {
    export interface Args {
        url: string;
        method: string;
        contentType?: string;
        headers?: Record<string, unknown>;
        queryParameters?: Record<string, unknown>;
        body?: unknown;
        timeoutMs?: number;
        maxRetries?: number;
        withCredentials?: boolean;
        abortSignal?: AbortSignal;
        requestType?: "json" | "file" | "bytes" | "form" | "other";
        responseType?: "json" | "blob" | "sse" | "streaming" | "text" | "arrayBuffer" | "binary-response";
        duplex?: "half";
        endpointMetadata?: EndpointMetadata;
        fetchFn?: typeof fetch;
        logging?: LogConfig | Logger;
    }

    export type Error = FailedStatusCodeError | NonJsonError | BodyIsNullError | TimeoutError | UnknownError;

    export interface FailedStatusCodeError {
        reason: "status-code";
        statusCode: number;
        body: unknown;
    }

    export interface NonJsonError {
        reason: "non-json";
        statusCode: number;
        rawBody: string;
    }

    export interface BodyIsNullError {
        reason: "body-is-null";
        statusCode: number;
    }

    export interface TimeoutError {
        reason: "timeout";
    }

    export interface UnknownError {
        reason: "unknown";
        errorMessage: string;
    }
}

const SENSITIVE_HEADERS = new Set([
    "authorization",
    "www-authenticate",
    "x-api-key",
    "api-key",
    "apikey",
    "x-api-token",
    "x-auth-token",
    "auth-token",
    "cookie",
    "set-cookie",
    "proxy-authorization",
    "proxy-authenticate",
    "x-csrf-token",
    "x-xsrf-token",
    "x-session-token",
    "x-access-token",
]);

function redactHeaders(headers: Headers | Record<string, string>): Record<string, string> {
    const filtered: Record<string, string> = {};
    for (const [key, value] of headers instanceof Headers ? headers.entries() : Object.entries(headers)) {
        if (SENSITIVE_HEADERS.has(key.toLowerCase())) {
            filtered[key] = "[REDACTED]";
        } else {
            filtered[key] = value;
        }
    }
    return filtered;
}

const SENSITIVE_QUERY_PARAMS = new Set([
    "api_key",
    "api-key",
    "apikey",
    "token",
    "access_token",
    "access-token",
    "auth_token",
    "auth-token",
    "password",
    "passwd",
    "secret",
    "api_secret",
    "api-secret",
    "apisecret",
    "key",
    "session",
    "session_id",
    "session-id",
]);

function redactQueryParameters(queryParameters?: Record<string, unknown>): Record<string, unknown> | undefined {
    if (queryParameters == null) {
        return queryParameters;
    }
    const redacted: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(queryParameters)) {
        if (SENSITIVE_QUERY_PARAMS.has(key.toLowerCase())) {
            redacted[key] = "[REDACTED]";
        } else {
            redacted[key] = value;
        }
    }
    return redacted;
}

function redactUrl(url: string): string {
    const protocolIndex = url.indexOf("://");
    if (protocolIndex === -1) return url;

    const afterProtocol = protocolIndex + 3;

    // Find the first delimiter that marks the end of the authority section
    const pathStart = url.indexOf("/", afterProtocol);
    let queryStart = url.indexOf("?", afterProtocol);
    let fragmentStart = url.indexOf("#", afterProtocol);

    const firstDelimiter = Math.min(
        pathStart === -1 ? url.length : pathStart,
        queryStart === -1 ? url.length : queryStart,
        fragmentStart === -1 ? url.length : fragmentStart,
    );

    // Find the LAST @ before the delimiter (handles multiple @ in credentials)
    let atIndex = -1;
    for (let i = afterProtocol; i < firstDelimiter; i++) {
        if (url[i] === "@") {
            atIndex = i;
        }
    }

    if (atIndex !== -1) {
        url = `${url.slice(0, afterProtocol)}[REDACTED]@${url.slice(atIndex + 1)}`;
    }

    // Recalculate queryStart since url might have changed
    queryStart = url.indexOf("?");
    if (queryStart === -1) return url;

    fragmentStart = url.indexOf("#", queryStart);
    const queryEnd = fragmentStart !== -1 ? fragmentStart : url.length;
    const queryString = url.slice(queryStart + 1, queryEnd);

    if (queryString.length === 0) return url;

    // FAST PATH: Quick check if any sensitive keywords present
    // Using indexOf is faster than regex for simple substring matching
    const lower = queryString.toLowerCase();
    const hasSensitive =
        lower.includes("token") ||
        lower.includes("key") ||
        lower.includes("password") ||
        lower.includes("passwd") ||
        lower.includes("secret") ||
        lower.includes("session") ||
        lower.includes("auth");

    if (!hasSensitive) {
        return url;
    }

    // SLOW PATH: Parse and redact
    const redactedParams: string[] = [];
    const params = queryString.split("&");

    for (const param of params) {
        const equalIndex = param.indexOf("=");
        if (equalIndex === -1) {
            redactedParams.push(param);
            continue;
        }

        const key = param.slice(0, equalIndex);
        let shouldRedact = SENSITIVE_QUERY_PARAMS.has(key.toLowerCase());

        if (!shouldRedact && key.includes("%")) {
            try {
                const decodedKey = decodeURIComponent(key);
                shouldRedact = SENSITIVE_QUERY_PARAMS.has(decodedKey.toLowerCase());
            } catch {}
        }

        redactedParams.push(shouldRedact ? `${key}=[REDACTED]` : param);
    }

    return url.slice(0, queryStart + 1) + redactedParams.join("&") + url.slice(queryEnd);
}

async function getHeaders(args: Fetcher.Args): Promise<Headers> {
    const newHeaders: Headers = new Headers();

    newHeaders.set(
        "Accept",
        args.responseType === "json" ? "application/json" : args.responseType === "text" ? "text/plain" : "*/*",
    );
    if (args.body !== undefined && args.contentType != null) {
        newHeaders.set("Content-Type", args.contentType);
    }

    if (args.headers == null) {
        return newHeaders;
    }

    for (const [key, value] of Object.entries(args.headers)) {
        const result = await EndpointSupplier.get(value, { endpointMetadata: args.endpointMetadata ?? {} });
        if (typeof result === "string") {
            newHeaders.set(key, result);
            continue;
        }
        if (result == null) {
            continue;
        }
        newHeaders.set(key, `${result}`);
    }
    return newHeaders;
}

export async function fetcherImpl<R = unknown>(args: Fetcher.Args): Promise<APIResponse<R, Fetcher.Error>> {
    const url = createRequestUrl(args.url, args.queryParameters);
    const requestBody: BodyInit | undefined = await getRequestBody({
        body: args.body,
        type: args.requestType ?? "other",
    });
    const fetchFn = args.fetchFn ?? (await getFetchFn());
    const headers = await getHeaders(args);
    const logger = createLogger(args.logging);

    if (logger.isDebug()) {
        const metadata = {
            method: args.method,
            url: redactUrl(url),
            headers: redactHeaders(headers),
            queryParameters: redactQueryParameters(args.queryParameters),
            hasBody: requestBody != null,
        };
        logger.debug("Making HTTP request", metadata);
    }

    try {
        const response = await requestWithRetries(
            async () =>
                makeRequest(
                    fetchFn,
                    url,
                    args.method,
                    headers,
                    requestBody,
                    args.timeoutMs,
                    args.abortSignal,
                    args.withCredentials,
                    args.duplex,
                ),
            args.maxRetries,
        );

        if (response.status >= 200 && response.status < 400) {
            if (logger.isDebug()) {
                const metadata = {
                    method: args.method,
                    url: redactUrl(url),
                    statusCode: response.status,
                    responseHeaders: redactHeaders(response.headers),
                };
                logger.debug("HTTP request succeeded", metadata);
            }
            const body = await getResponseBody(response, args.responseType);
            return {
                ok: true,
                body: body as R,
                headers: response.headers,
                rawResponse: toRawResponse(response),
            };
        } else {
            if (logger.isError()) {
                const metadata = {
                    method: args.method,
                    url: redactUrl(url),
                    statusCode: response.status,
                    responseHeaders: redactHeaders(Object.fromEntries(response.headers.entries())),
                };
                logger.error("HTTP request failed with error status", metadata);
            }
            return {
                ok: false,
                error: {
                    reason: "status-code",
                    statusCode: response.status,
                    body: await getErrorResponseBody(response),
                },
                rawResponse: toRawResponse(response),
            };
        }
    } catch (error) {
        if (args.abortSignal?.aborted) {
            if (logger.isError()) {
                const metadata = {
                    method: args.method,
                    url: redactUrl(url),
                };
                logger.error("HTTP request was aborted", metadata);
            }
            return {
                ok: false,
                error: {
                    reason: "unknown",
                    errorMessage: "The user aborted a request",
                },
                rawResponse: abortRawResponse,
            };
        } else if (error instanceof Error && error.name === "AbortError") {
            if (logger.isError()) {
                const metadata = {
                    method: args.method,
                    url: redactUrl(url),
                    timeoutMs: args.timeoutMs,
                };
                logger.error("HTTP request timed out", metadata);
            }
            return {
                ok: false,
                error: {
                    reason: "timeout",
                },
                rawResponse: abortRawResponse,
            };
        } else if (error instanceof Error) {
            if (logger.isError()) {
                const metadata = {
                    method: args.method,
                    url: redactUrl(url),
                    errorMessage: error.message,
                };
                logger.error("HTTP request failed with error", metadata);
            }
            return {
                ok: false,
                error: {
                    reason: "unknown",
                    errorMessage: error.message,
                },
                rawResponse: unknownRawResponse,
            };
        }

        if (logger.isError()) {
            const metadata = {
                method: args.method,
                url: redactUrl(url),
                error: toJson(error),
            };
            logger.error("HTTP request failed with unknown error", metadata);
        }
        return {
            ok: false,
            error: {
                reason: "unknown",
                errorMessage: toJson(error),
            },
            rawResponse: unknownRawResponse,
        };
    }
}

export const fetcher: FetchFunction = fetcherImpl;

```


## /src/core/fetcher/Headers.ts
```typescript
let Headers: typeof globalThis.Headers;

if (typeof globalThis.Headers !== "undefined") {
    Headers = globalThis.Headers;
} else {
    Headers = class Headers implements Headers {
        private headers: Map<string, string[]>;

        constructor(init?: HeadersInit) {
            this.headers = new Map();

            if (init) {
                if (init instanceof Headers) {
                    init.forEach((value, key) => this.append(key, value));
                } else if (Array.isArray(init)) {
                    for (const [key, value] of init) {
                        if (typeof key === "string" && typeof value === "string") {
                            this.append(key, value);
                        } else {
                            throw new TypeError("Each header entry must be a [string, string] tuple");
                        }
                    }
                } else {
                    for (const [key, value] of Object.entries(init)) {
                        if (typeof value === "string") {
                            this.append(key, value);
                        } else {
                            throw new TypeError("Header values must be strings");
                        }
                    }
                }
            }
        }

        append(name: string, value: string): void {
            const key = name.toLowerCase();
            const existing = this.headers.get(key) || [];
            this.headers.set(key, [...existing, value]);
        }

        delete(name: string): void {
            const key = name.toLowerCase();
            this.headers.delete(key);
        }

        get(name: string): string | null {
            const key = name.toLowerCase();
            const values = this.headers.get(key);
            return values ? values.join(", ") : null;
        }

        has(name: string): boolean {
            const key = name.toLowerCase();
            return this.headers.has(key);
        }

        set(name: string, value: string): void {
            const key = name.toLowerCase();
            this.headers.set(key, [value]);
        }

        forEach(callbackfn: (value: string, key: string, parent: Headers) => void, thisArg?: unknown): void {
            const boundCallback = thisArg ? callbackfn.bind(thisArg) : callbackfn;
            this.headers.forEach((values, key) => boundCallback(values.join(", "), key, this));
        }

        getSetCookie(): string[] {
            return this.headers.get("set-cookie") || [];
        }

        *entries(): HeadersIterator<[string, string]> {
            for (const [key, values] of this.headers.entries()) {
                yield [key, values.join(", ")];
            }
        }

        *keys(): HeadersIterator<string> {
            yield* this.headers.keys();
        }

        *values(): HeadersIterator<string> {
            for (const values of this.headers.values()) {
                yield values.join(", ");
            }
        }

        [Symbol.iterator](): HeadersIterator<[string, string]> {
            return this.entries();
        }
    };
}

export { Headers };

```


## /src/core/fetcher/HttpResponsePromise.ts
```typescript
import type { WithRawResponse } from "./RawResponse.js";

/**
 * A promise that returns the parsed response and lets you retrieve the raw response too.
 */
export class HttpResponsePromise<T> extends Promise<T> {
    private innerPromise: Promise<WithRawResponse<T>>;
    private unwrappedPromise: Promise<T> | undefined;

    private constructor(promise: Promise<WithRawResponse<T>>) {
        // Initialize with a no-op to avoid premature parsing
        super((resolve) => {
            resolve(undefined as unknown as T);
        });
        this.innerPromise = promise;
    }

    /**
     * Creates an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @param args - Arguments to pass to the function.
     * @returns An `HttpResponsePromise` instance.
     */
    public static fromFunction<F extends (...args: never[]) => Promise<WithRawResponse<T>>, T>(
        fn: F,
        ...args: Parameters<F>
    ): HttpResponsePromise<T> {
        return new HttpResponsePromise<T>(fn(...args));
    }

    /**
     * Creates a function that returns an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @returns A function that returns an `HttpResponsePromise` instance.
     */
    public static interceptFunction<
        F extends (...args: never[]) => Promise<WithRawResponse<T>>,
        T = Awaited<ReturnType<F>>["data"],
    >(fn: F): (...args: Parameters<F>) => HttpResponsePromise<T> {
        return (...args: Parameters<F>): HttpResponsePromise<T> => {
            return HttpResponsePromise.fromPromise<T>(fn(...args));
        };
    }

    /**
     * Creates an `HttpResponsePromise` from an existing promise.
     *
     * @param promise - A promise resolving to a `WithRawResponse` object.
     * @returns An `HttpResponsePromise` instance.
     */
    public static fromPromise<T>(promise: Promise<WithRawResponse<T>>): HttpResponsePromise<T> {
        return new HttpResponsePromise<T>(promise);
    }

    /**
     * Creates an `HttpResponsePromise` from an executor function.
     *
     * @param executor - A function that takes resolve and reject callbacks to create a promise.
     * @returns An `HttpResponsePromise` instance.
     */
    public static fromExecutor<T>(
        executor: (resolve: (value: WithRawResponse<T>) => void, reject: (reason?: unknown) => void) => void,
    ): HttpResponsePromise<T> {
        const promise = new Promise<WithRawResponse<T>>(executor);
        return new HttpResponsePromise<T>(promise);
    }

    /**
     * Creates an `HttpResponsePromise` from a resolved result.
     *
     * @param result - A `WithRawResponse` object to resolve immediately.
     * @returns An `HttpResponsePromise` instance.
     */
    public static fromResult<T>(result: WithRawResponse<T>): HttpResponsePromise<T> {
        const promise = Promise.resolve(result);
        return new HttpResponsePromise<T>(promise);
    }

    private unwrap(): Promise<T> {
        if (!this.unwrappedPromise) {
            this.unwrappedPromise = this.innerPromise.then(({ data }) => data);
        }
        return this.unwrappedPromise;
    }

    /** @inheritdoc */
    public override then<TResult1 = T, TResult2 = never>(
        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
        onrejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null,
    ): Promise<TResult1 | TResult2> {
        return this.unwrap().then(onfulfilled, onrejected);
    }

    /** @inheritdoc */
    public override catch<TResult = never>(
        onrejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | null,
    ): Promise<T | TResult> {
        return this.unwrap().catch(onrejected);
    }

    /** @inheritdoc */
    public override finally(onfinally?: (() => void) | null): Promise<T> {
        return this.unwrap().finally(onfinally);
    }

    /**
     * Retrieves the data and raw response.
     *
     * @returns A promise resolving to a `WithRawResponse` object.
     */
    public async withRawResponse(): Promise<WithRawResponse<T>> {
        return await this.innerPromise;
    }
}

```


## /src/core/fetcher/RawResponse.ts
```typescript
import { Headers } from "./Headers.js";

/**
 * The raw response from the fetch call excluding the body.
 */
export type RawResponse = Omit<
    {
        [K in keyof Response as Response[K] extends Function ? never : K]: Response[K]; // strips out functions
    },
    "ok" | "body" | "bodyUsed"
>; // strips out body and bodyUsed

/**
 * A raw response indicating that the request was aborted.
 */
export const abortRawResponse: RawResponse = {
    headers: new Headers(),
    redirected: false,
    status: 499,
    statusText: "Client Closed Request",
    type: "error",
    url: "",
} as const;

/**
 * A raw response indicating an unknown error.
 */
export const unknownRawResponse: RawResponse = {
    headers: new Headers(),
    redirected: false,
    status: 0,
    statusText: "Unknown Error",
    type: "error",
    url: "",
} as const;

/**
 * Converts a `RawResponse` object into a `RawResponse` by extracting its properties,
 * excluding the `body` and `bodyUsed` fields.
 *
 * @param response - The `RawResponse` object to convert.
 * @returns A `RawResponse` object containing the extracted properties of the input response.
 */
export function toRawResponse(response: Response): RawResponse {
    return {
        headers: response.headers,
        redirected: response.redirected,
        status: response.status,
        statusText: response.statusText,
        type: response.type,
        url: response.url,
    };
}

/**
 * Creates a `RawResponse` from a standard `Response` object.
 */
export interface WithRawResponse<T> {
    readonly data: T;
    readonly rawResponse: RawResponse;
}

```


## /src/core/fetcher/Supplier.ts
```typescript
/** THIS FILE IS MANUALLY MAINAINED: see .fernignore */
export type Supplier<T> = T | (() => T);

export const Supplier = {
    get: <T>(supplier: Supplier<T>): T => {
        if (typeof supplier === "function") {
            return (supplier as () => T)();
        } else {
            return supplier;
        }
    },
    map: <T, U, R = U>(supplier: Supplier<T>, f: (value: T) => R): Supplier<R> => {
        if (typeof supplier === "function") {
            return () => f(Supplier.get(supplier));
        } else {
            return f(supplier);
        }
    },
};

```


## /src/core/fetcher/Supplier.ts.diff
```diff
diff --git a/src/core/fetcher/Supplier.ts b/src/core/fetcher/Supplier.ts
index aa95dd8..867c931 100644
--- a/src/core/fetcher/Supplier.ts
+++ b/src/core/fetcher/Supplier.ts
@@ -1,19 +1,11 @@
-/** THIS FILE IS MANUALLY MAINAINED: see .fernignore */
-export type Supplier<T> = T | (() => T);
+export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);
 
 export const Supplier = {
-    get: <T>(supplier: Supplier<T>): T => {
+    get: async <T>(supplier: Supplier<T>): Promise<T> => {
         if (typeof supplier === "function") {
             return (supplier as () => T)();
         } else {
             return supplier;
         }
     },
-    map: <T, U, R = U>(supplier: Supplier<T>, f: (value: T) => R): Supplier<R> => {
-        if (typeof supplier === "function") {
-            return () => f(Supplier.get(supplier));
-        } else {
-            return f(supplier);
-        }
-    },
 };

```


## /src/core/fetcher/createRequestUrl.ts
```typescript
import { toQueryString } from "../url/qs.js";

export function createRequestUrl(baseUrl: string, queryParameters?: Record<string, unknown>): string {
    const queryString = toQueryString(queryParameters, { arrayFormat: "repeat" });
    return queryString ? `${baseUrl}?${queryString}` : baseUrl;
}

```


## /src/core/fetcher/getErrorResponseBody.ts
```typescript
import { fromJson } from "../json.js";
import { getResponseBody } from "./getResponseBody.js";

export async function getErrorResponseBody(response: Response): Promise<unknown> {
    let contentType = response.headers.get("Content-Type")?.toLowerCase();
    if (contentType == null || contentType.length === 0) {
        return getResponseBody(response);
    }

    if (contentType.indexOf(";") !== -1) {
        contentType = contentType.split(";")[0]?.trim() ?? "";
    }
    switch (contentType) {
        case "application/hal+json":
        case "application/json":
        case "application/ld+json":
        case "application/problem+json":
        case "application/vnd.api+json":
        case "text/json": {
            const text = await response.text();
            return text.length > 0 ? fromJson(text) : undefined;
        }
        default:
            if (contentType.startsWith("application/vnd.") && contentType.endsWith("+json")) {
                const text = await response.text();
                return text.length > 0 ? fromJson(text) : undefined;
            }

            // Fallback to plain text if content type is not recognized
            // Even if no body is present, the response will be an empty string
            return await response.text();
    }
}

```


## /src/core/fetcher/getFetchFn.ts
```typescript
export async function getFetchFn(): Promise<typeof fetch> {
    return fetch;
}

```


## /src/core/fetcher/getHeader.ts
```typescript
export function getHeader(headers: Record<string, any>, header: string): string | undefined {
    for (const [headerKey, headerValue] of Object.entries(headers)) {
        if (headerKey.toLowerCase() === header.toLowerCase()) {
            return headerValue;
        }
    }
    return undefined;
}

```


## /src/core/fetcher/getRequestBody.ts
```typescript
import { toJson } from "../json.js";
import { toQueryString } from "../url/qs.js";

export declare namespace GetRequestBody {
    interface Args {
        body: unknown;
        type: "json" | "file" | "bytes" | "form" | "other";
    }
}

export async function getRequestBody({ body, type }: GetRequestBody.Args): Promise<BodyInit | undefined> {
    if (type === "form") {
        return toQueryString(body, { arrayFormat: "repeat", encode: true });
    }
    if (type.includes("json")) {
        return toJson(body);
    } else {
        return body as BodyInit;
    }
}

```


## /src/core/fetcher/getResponseBody.ts
```typescript
import { fromJson } from "../json.js";
import { getBinaryResponse } from "./BinaryResponse.js";

export async function getResponseBody(response: Response, responseType?: string): Promise<unknown> {
    switch (responseType) {
        case "binary-response":
            return getBinaryResponse(response);
        case "blob":
            return await response.blob();
        case "arrayBuffer":
            return await response.arrayBuffer();
        case "sse":
            if (response.body == null) {
                return {
                    ok: false,
                    error: {
                        reason: "body-is-null",
                        statusCode: response.status,
                    },
                };
            }
            return response.body;
        case "streaming":
            if (response.body == null) {
                return {
                    ok: false,
                    error: {
                        reason: "body-is-null",
                        statusCode: response.status,
                    },
                };
            }

            return response.body;

        case "text":
            return await response.text();
    }

    // if responseType is "json" or not specified, try to parse as JSON
    const text = await response.text();
    if (text.length > 0) {
        try {
            const responseBody = fromJson(text);
            return responseBody;
        } catch (_err) {
            return {
                ok: false,
                error: {
                    reason: "non-json",
                    statusCode: response.status,
                    rawBody: text,
                },
            };
        }
    }
    return undefined;
}

```


## /src/core/fetcher/index.ts
```typescript
export type { APIResponse } from "./APIResponse.js";
export type { BinaryResponse } from "./BinaryResponse.js";
export type { EndpointMetadata } from "./EndpointMetadata.js";
export { EndpointSupplier } from "./EndpointSupplier.js";
export type { Fetcher, FetchFunction } from "./Fetcher.js";
export { fetcher } from "./Fetcher.js";
export { getHeader } from "./getHeader.js";
export { HttpResponsePromise } from "./HttpResponsePromise.js";
export type { RawResponse, WithRawResponse } from "./RawResponse.js";
export { abortRawResponse, toRawResponse, unknownRawResponse } from "./RawResponse.js";
export { Supplier } from "./Supplier.js";

```


## /src/core/fetcher/makeRequest.ts
```typescript
import { anySignal, getTimeoutSignal } from "./signals.js";

export const makeRequest = async (
    fetchFn: (url: string, init: RequestInit) => Promise<Response>,
    url: string,
    method: string,
    headers: Headers | Record<string, string>,
    requestBody: BodyInit | undefined,
    timeoutMs?: number,
    abortSignal?: AbortSignal,
    withCredentials?: boolean,
    duplex?: "half",
): Promise<Response> => {
    const signals: AbortSignal[] = [];

    let timeoutAbortId: ReturnType<typeof setTimeout> | undefined;
    if (timeoutMs != null) {
        const { signal, abortId } = getTimeoutSignal(timeoutMs);
        timeoutAbortId = abortId;
        signals.push(signal);
    }

    if (abortSignal != null) {
        signals.push(abortSignal);
    }
    const newSignals = anySignal(signals);
    const response = await fetchFn(url, {
        method: method,
        headers,
        body: requestBody,
        signal: newSignals,
        credentials: withCredentials ? "include" : undefined,
        // @ts-ignore
        duplex,
    });

    if (timeoutAbortId != null) {
        clearTimeout(timeoutAbortId);
    }

    return response;
};

```


## /src/core/fetcher/requestWithRetries.ts
```typescript
const INITIAL_RETRY_DELAY = 1000; // in milliseconds
const MAX_RETRY_DELAY = 60000; // in milliseconds
const DEFAULT_MAX_RETRIES = 2;
const JITTER_FACTOR = 0.2; // 20% random jitter

function addPositiveJitter(delay: number): number {
    const jitterMultiplier = 1 + Math.random() * JITTER_FACTOR;
    return delay * jitterMultiplier;
}

function addSymmetricJitter(delay: number): number {
    const jitterMultiplier = 1 + (Math.random() - 0.5) * JITTER_FACTOR;
    return delay * jitterMultiplier;
}

function getRetryDelayFromHeaders(response: Response, retryAttempt: number): number {
    const retryAfter = response.headers.get("Retry-After");
    if (retryAfter) {
        const retryAfterSeconds = parseInt(retryAfter, 10);
        if (!Number.isNaN(retryAfterSeconds) && retryAfterSeconds > 0) {
            return Math.min(retryAfterSeconds * 1000, MAX_RETRY_DELAY);
        }

        const retryAfterDate = new Date(retryAfter);
        if (!Number.isNaN(retryAfterDate.getTime())) {
            const delay = retryAfterDate.getTime() - Date.now();
            if (delay > 0) {
                return Math.min(Math.max(delay, 0), MAX_RETRY_DELAY);
            }
        }
    }

    const rateLimitReset = response.headers.get("X-RateLimit-Reset");
    if (rateLimitReset) {
        const resetTime = parseInt(rateLimitReset, 10);
        if (!Number.isNaN(resetTime)) {
            const delay = resetTime * 1000 - Date.now();
            if (delay > 0) {
                return addPositiveJitter(Math.min(delay, MAX_RETRY_DELAY));
            }
        }
    }

    return addSymmetricJitter(Math.min(INITIAL_RETRY_DELAY * 2 ** retryAttempt, MAX_RETRY_DELAY));
}

export async function requestWithRetries(
    requestFn: () => Promise<Response>,
    maxRetries: number = DEFAULT_MAX_RETRIES,
): Promise<Response> {
    let response: Response = await requestFn();

    for (let i = 0; i < maxRetries; ++i) {
        if ([408, 429].includes(response.status) || response.status >= 500) {
            const delay = getRetryDelayFromHeaders(response, i);

            await new Promise((resolve) => setTimeout(resolve, delay));
            response = await requestFn();
        } else {
            break;
        }
    }
    return response!;
}

```


## /src/core/fetcher/signals.ts
```typescript
const TIMEOUT = "timeout";

export function getTimeoutSignal(timeoutMs: number): { signal: AbortSignal; abortId: ReturnType<typeof setTimeout> } {
    const controller = new AbortController();
    const abortId = setTimeout(() => controller.abort(TIMEOUT), timeoutMs);
    return { signal: controller.signal, abortId };
}

export function anySignal(...args: AbortSignal[] | [AbortSignal[]]): AbortSignal {
    const signals = (args.length === 1 && Array.isArray(args[0]) ? args[0] : args) as AbortSignal[];

    const controller = new AbortController();

    for (const signal of signals) {
        if (signal.aborted) {
            controller.abort((signal as any)?.reason);
            break;
        }

        signal.addEventListener("abort", () => controller.abort((signal as any)?.reason), {
            signal: controller.signal,
        });
    }

    return controller.signal;
}

```


## /src/core/file/exports.ts
```typescript
export type { Uploadable } from "./types.js";

```


## /src/core/file/file.ts
```typescript
import type { Uploadable } from "./types.js";

export async function toBinaryUploadRequest(
    file: Uploadable,
): Promise<{ body: Uploadable.FileLike; headers?: Record<string, string> }> {
    const { data, filename, contentLength, contentType } = await getFileWithMetadata(file);
    const request = {
        body: data,
        headers: {} as Record<string, string>,
    };
    if (filename) {
        request.headers["Content-Disposition"] = `attachment; filename="${filename}"`;
    }
    if (contentType) {
        request.headers["Content-Type"] = contentType;
    }
    if (contentLength != null) {
        request.headers["Content-Length"] = contentLength.toString();
    }
    return request;
}

export async function toMultipartDataPart(
    file: Uploadable,
): Promise<{ data: Uploadable.FileLike; filename?: string; contentType?: string }> {
    const { data, filename, contentType } = await getFileWithMetadata(file, {
        noSniffFileSize: true,
    });
    return {
        data,
        filename,
        contentType,
    };
}

async function getFileWithMetadata(
    file: Uploadable,
    { noSniffFileSize }: { noSniffFileSize?: boolean } = {},
): Promise<Uploadable.WithMetadata> {
    if (isFileLike(file)) {
        return getFileWithMetadata(
            {
                data: file,
            },
            { noSniffFileSize },
        );
    }

    if ("path" in file) {
        const fs = await import("fs");
        if (!fs || !fs.createReadStream) {
            throw new Error("File path uploads are not supported in this environment.");
        }
        const data = fs.createReadStream(file.path);
        const contentLength =
            file.contentLength ?? (noSniffFileSize === true ? undefined : await tryGetFileSizeFromPath(file.path));
        const filename = file.filename ?? getNameFromPath(file.path);
        return {
            data,
            filename,
            contentType: file.contentType,
            contentLength,
        };
    }
    if ("data" in file) {
        const data = file.data;
        const contentLength =
            file.contentLength ??
            (await tryGetContentLengthFromFileLike(data, {
                noSniffFileSize,
            }));
        const filename = file.filename ?? tryGetNameFromFileLike(data);
        return {
            data,
            filename,
            contentType: file.contentType ?? tryGetContentTypeFromFileLike(data),
            contentLength,
        };
    }

    throw new Error(`Invalid FileUpload of type ${typeof file}: ${JSON.stringify(file)}`);
}

function isFileLike(value: unknown): value is Uploadable.FileLike {
    return (
        isBuffer(value) ||
        isArrayBufferView(value) ||
        isArrayBuffer(value) ||
        isUint8Array(value) ||
        isBlob(value) ||
        isFile(value) ||
        isStreamLike(value) ||
        isReadableStream(value)
    );
}

async function tryGetFileSizeFromPath(path: string): Promise<number | undefined> {
    try {
        const fs = await import("fs");
        if (!fs || !fs.promises || !fs.promises.stat) {
            return undefined;
        }
        const fileStat = await fs.promises.stat(path);
        return fileStat.size;
    } catch (_fallbackError) {
        return undefined;
    }
}

function tryGetNameFromFileLike(data: Uploadable.FileLike): string | undefined {
    if (isNamedValue(data)) {
        return data.name;
    }
    if (isPathedValue(data)) {
        return getNameFromPath(data.path.toString());
    }
    return undefined;
}

async function tryGetContentLengthFromFileLike(
    data: Uploadable.FileLike,
    { noSniffFileSize }: { noSniffFileSize?: boolean } = {},
): Promise<number | undefined> {
    if (isBuffer(data)) {
        return data.length;
    }
    if (isArrayBufferView(data)) {
        return data.byteLength;
    }
    if (isArrayBuffer(data)) {
        return data.byteLength;
    }
    if (isBlob(data)) {
        return data.size;
    }
    if (isFile(data)) {
        return data.size;
    }
    if (noSniffFileSize === true) {
        return undefined;
    }
    if (isPathedValue(data)) {
        return await tryGetFileSizeFromPath(data.path.toString());
    }
    return undefined;
}

function tryGetContentTypeFromFileLike(data: Uploadable.FileLike): string | undefined {
    if (isBlob(data)) {
        return data.type;
    }
    if (isFile(data)) {
        return data.type;
    }

    return undefined;
}

function getNameFromPath(path: string): string | undefined {
    const lastForwardSlash = path.lastIndexOf("/");
    const lastBackSlash = path.lastIndexOf("\\");
    const lastSlashIndex = Math.max(lastForwardSlash, lastBackSlash);
    return lastSlashIndex >= 0 ? path.substring(lastSlashIndex + 1) : path;
}

type NamedValue = {
    name: string;
} & unknown;

type PathedValue = {
    path: string | { toString(): string };
} & unknown;

type StreamLike = {
    read?: () => unknown;
    pipe?: (dest: unknown) => unknown;
} & unknown;

function isNamedValue(value: unknown): value is NamedValue {
    return typeof value === "object" && value != null && "name" in value;
}

function isPathedValue(value: unknown): value is PathedValue {
    return typeof value === "object" && value != null && "path" in value;
}

function isStreamLike(value: unknown): value is StreamLike {
    return typeof value === "object" && value != null && ("read" in value || "pipe" in value);
}

function isReadableStream(value: unknown): value is ReadableStream {
    return typeof value === "object" && value != null && "getReader" in value;
}

function isBuffer(value: unknown): value is Buffer {
    return typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(value);
}

function isArrayBufferView(value: unknown): value is ArrayBufferView {
    return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
}

function isArrayBuffer(value: unknown): value is ArrayBuffer {
    return typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer;
}

function isUint8Array(value: unknown): value is Uint8Array {
    return typeof Uint8Array !== "undefined" && value instanceof Uint8Array;
}

function isBlob(value: unknown): value is Blob {
    return typeof Blob !== "undefined" && value instanceof Blob;
}

function isFile(value: unknown): value is File {
    return typeof File !== "undefined" && value instanceof File;
}

```


## /src/core/file/index.ts
```typescript
export * from "./file.js";
export * from "./types.js";

```


## /src/core/file/types.ts
```typescript
/**
 * A file that can be uploaded. Can be a file-like object (stream, buffer, blob, etc.),
 * a path to a file, or an object with a file-like object and metadata.
 */
export type Uploadable = Uploadable.FileLike | Uploadable.FromPath | Uploadable.WithMetadata;

export namespace Uploadable {
    /**
     * Various file-like objects that can be used to upload a file.
     */
    export type FileLike =
        | ArrayBuffer
        | ArrayBufferLike
        | ArrayBufferView
        | Uint8Array
        | import("buffer").Buffer
        | import("buffer").Blob
        | import("buffer").File
        | import("stream").Readable
        | import("stream/web").ReadableStream
        | globalThis.Blob
        | globalThis.File
        | ReadableStream;

    /**
     * A file path with optional metadata, used for uploading a file from the file system.
     */
    export type FromPath = {
        /** The path to the file to upload */
        path: string;
        /**
         * Optional override for the file name (defaults to basename of path).
         * This is used to set the `Content-Disposition` header in upload requests.
         */
        filename?: string;
        /**
         * Optional MIME type of the file (e.g., 'image/jpeg', 'text/plain').
         * This is used to set the `Content-Type` header in upload requests.
         */
        contentType?: string;
        /**
         * Optional file size in bytes.
         * If not provided, the file size will be determined from the file system.
         * The content length is used to set the `Content-Length` header in upload requests.
         */
        contentLength?: number;
    };

    /**
     * A file-like object with metadata, used for uploading files.
     */
    export type WithMetadata = {
        /** The file data */
        data: FileLike;
        /**
         * Optional override for the file name (defaults to basename of path).
         * This is used to set the `Content-Disposition` header in upload requests.
         */
        filename?: string;
        /**
         * Optional MIME type of the file (e.g., 'image/jpeg', 'text/plain').
         * This is used to set the `Content-Type` header in upload requests.
         *
         * If not provided, the content type may be determined from the data itself.
         * * If the data is a `File`, `Blob`, or similar, the content type will be determined from the file itself, if the type is set.
         * * Any other data type will not have a content type set, and the upload request will use `Content-Type: application/octet-stream` instead.
         */
        contentType?: string;
        /**
         * Optional file size in bytes.
         * The content length is used to set the `Content-Length` header in upload requests.
         * If the content length is not provided and cannot be determined, the upload request will not include the `Content-Length` header, but will use `Transfer-Encoding: chunked` instead.
         *
         * If not provided, the file size will be determined depending on the data type.
         * * If the data is of type `fs.ReadStream` (`createReadStream`), the size will be determined from the file system.
         * * If the data is a `Buffer`, `ArrayBuffer`, `Uint8Array`, `Blob`, `File`, or similar, the size will be determined from the data itself.
         * * If the data is a `Readable` or `ReadableStream`, the size will not be determined.
         */
        contentLength?: number;
    };
}

```


## /src/core/form-data-utils/FormDataWrapper.ts
```typescript
import { toMultipartDataPart, type Uploadable } from "../../core/file/index.js";
import { toJson } from "../../core/json.js";
import { RUNTIME } from "../runtime/index.js";

interface FormDataRequest<Body> {
    body: Body;
    headers: Record<string, string>;
    duplex?: "half";
}

export async function newFormData(): Promise<FormDataWrapper> {
    return new FormDataWrapper();
}

export class FormDataWrapper {
    private fd: FormData = new FormData();

    public async setup(): Promise<void> {
        // noop
    }

    public append(key: string, value: unknown): void {
        this.fd.append(key, String(value));
    }

    public async appendFile(key: string, value: Uploadable): Promise<void> {
        const { data, filename, contentType } = await toMultipartDataPart(value);
        const blob = await convertToBlob(data, contentType);
        if (filename) {
            this.fd.append(key, blob, filename);
        } else {
            this.fd.append(key, blob);
        }
    }

    public getRequest(): FormDataRequest<FormData> {
        return {
            body: this.fd,
            headers: {},
            duplex: "half" as const,
        };
    }
}

type StreamLike = {
    read?: () => unknown;
    pipe?: (dest: unknown) => unknown;
} & unknown;

function isStreamLike(value: unknown): value is StreamLike {
    return typeof value === "object" && value != null && ("read" in value || "pipe" in value);
}

function isReadableStream(value: unknown): value is ReadableStream {
    return typeof value === "object" && value != null && "getReader" in value;
}

function isBuffer(value: unknown): value is Buffer {
    return typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(value);
}

function isArrayBufferView(value: unknown): value is ArrayBufferView {
    return ArrayBuffer.isView(value);
}

async function streamToBuffer(stream: unknown): Promise<Buffer> {
    if (RUNTIME.type === "node") {
        const { Readable } = await import("stream");

        if (stream instanceof Readable) {
            const chunks: Buffer[] = [];
            for await (const chunk of stream) {
                chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
            }
            return Buffer.concat(chunks);
        }
    }

    if (isReadableStream(stream)) {
        const reader = stream.getReader();
        const chunks: Uint8Array[] = [];

        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                chunks.push(value);
            }
        } finally {
            reader.releaseLock();
        }

        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
            result.set(chunk, offset);
            offset += chunk.length;
        }

        return Buffer.from(result);
    }

    throw new Error(
        `Unsupported stream type: ${typeof stream}. Expected Node.js Readable stream or Web ReadableStream.`,
    );
}

async function convertToBlob(value: unknown, contentType?: string): Promise<Blob> {
    if (isStreamLike(value) || isReadableStream(value)) {
        const buffer = await streamToBuffer(value);
        return new Blob([buffer], { type: contentType });
    }

    if (value instanceof Blob) {
        return value;
    }

    if (isBuffer(value)) {
        return new Blob([value], { type: contentType });
    }

    if (value instanceof ArrayBuffer) {
        return new Blob([value], { type: contentType });
    }

    if (isArrayBufferView(value)) {
        return new Blob([value], { type: contentType });
    }

    if (typeof value === "string") {
        return new Blob([value], { type: contentType });
    }

    if (typeof value === "object" && value !== null) {
        return new Blob([toJson(value)], { type: contentType ?? "application/json" });
    }

    return new Blob([String(value)], { type: contentType });
}

```


## /src/core/form-data-utils/encodeAsFormParameter.ts
```typescript
import { toQueryString } from "../url/qs.js";

export function encodeAsFormParameter(value: unknown): Record<string, string> {
    const stringified = toQueryString(value, { encode: false });

    const keyValuePairs = stringified.split("&").map((pair) => {
        const [key, value] = pair.split("=");
        return [key, value] as const;
    });

    return Object.fromEntries(keyValuePairs);
}

```


## /src/core/form-data-utils/index.ts
```typescript
export { encodeAsFormParameter } from "./encodeAsFormParameter.js";
export * from "./FormDataWrapper.js";

```


## /src/core/headers.ts
```typescript
export function mergeHeaders(...headersArray: (Record<string, unknown> | null | undefined)[]): Record<string, unknown> {
    const result: Record<string, unknown> = {};

    for (const [key, value] of headersArray
        .filter((headers) => headers != null)
        .flatMap((headers) => Object.entries(headers))) {
        const insensitiveKey = key.toLowerCase();
        if (value != null) {
            result[insensitiveKey] = value;
        } else if (insensitiveKey in result) {
            delete result[insensitiveKey];
        }
    }

    return result;
}

export function mergeOnlyDefinedHeaders(
    ...headersArray: (Record<string, unknown> | null | undefined)[]
): Record<string, unknown> {
    const result: Record<string, unknown> = {};

    for (const [key, value] of headersArray
        .filter((headers) => headers != null)
        .flatMap((headers) => Object.entries(headers))) {
        const insensitiveKey = key.toLowerCase();
        if (value != null) {
            result[insensitiveKey] = value;
        }
    }

    return result;
}

```


## /src/core/index.ts
```typescript
export * from "./auth/index.js";
export * from "./base64.js";
export * from "./fetcher/index.js";
export * as file from "./file/index.js";
export * from "./form-data-utils/index.js";
export * as logging from "./logging/index.js";
export * from "./pagination/index.js";
export * from "./runtime/index.js";
export * as serialization from "./schemas/index.js";
export * from "./stream/index.js";
export * as url from "./url/index.js";
export * from "./utils/index.js";
export * from "./websocket/index.js";

```


## /src/core/json.ts
```typescript
/**
 * Serialize a value to JSON
 * @param value A JavaScript value, usually an object or array, to be converted.
 * @param replacer A function that transforms the results.
 * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
 * @returns JSON string
 */
export const toJson = (
    value: unknown,
    replacer?: (this: unknown, key: string, value: unknown) => unknown,
    space?: string | number,
): string => {
    return JSON.stringify(value, replacer, space);
};

/**
 * Parse JSON string to object, array, or other type
 * @param text A valid JSON string.
 * @param reviver A function that transforms the results. This function is called for each member of the object. If a member contains nested objects, the nested objects are transformed before the parent object is.
 * @returns Parsed object, array, or other type
 */
export function fromJson<T = unknown>(
    text: string,
    reviver?: (this: unknown, key: string, value: unknown) => unknown,
): T {
    return JSON.parse(text, reviver);
}

```


## /src/core/logging/exports.ts
```typescript
import * as logger from "./logger.js";

export namespace logging {
    /**
     * Configuration for logger instances.
     */
    export type LogConfig = logger.LogConfig;
    export type LogLevel = logger.LogLevel;
    export const LogLevel: typeof logger.LogLevel = logger.LogLevel;
    export type ILogger = logger.ILogger;
    /**
     * Console logger implementation that outputs to the console.
     */
    export type ConsoleLogger = logger.ConsoleLogger;
    /**
     * Console logger implementation that outputs to the console.
     */
    export const ConsoleLogger: typeof logger.ConsoleLogger = logger.ConsoleLogger;
}

```


## /src/core/logging/index.ts
```typescript
export * from "./logger.js";

```


## /src/core/logging/logger.ts
```typescript
export const LogLevel = {
    Debug: "debug",
    Info: "info",
    Warn: "warn",
    Error: "error",
} as const;
export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];
const logLevelMap: Record<LogLevel, number> = {
    [LogLevel.Debug]: 1,
    [LogLevel.Info]: 2,
    [LogLevel.Warn]: 3,
    [LogLevel.Error]: 4,
};

export interface ILogger {
    /**
     * Logs a debug message.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    debug(message: string, ...args: unknown[]): void;
    /**
     * Logs an info message.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    info(message: string, ...args: unknown[]): void;
    /**
     * Logs a warning message.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    warn(message: string, ...args: unknown[]): void;
    /**
     * Logs an error message.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    error(message: string, ...args: unknown[]): void;
}

/**
 * Configuration for logger initialization.
 */
export interface LogConfig {
    /**
     * Minimum log level to output.
     * @default LogLevel.Info
     */
    level?: LogLevel;
    /**
     * Logger implementation to use.
     * @default new ConsoleLogger()
     */
    logger?: ILogger;
    /**
     * Whether logging should be silenced.
     * @default true
     */
    silent?: boolean;
}

/**
 * Default console-based logger implementation.
 */
export class ConsoleLogger implements ILogger {
    debug(message: string, ...args: unknown[]): void {
        console.debug(message, ...args);
    }
    info(message: string, ...args: unknown[]): void {
        console.info(message, ...args);
    }
    warn(message: string, ...args: unknown[]): void {
        console.warn(message, ...args);
    }
    error(message: string, ...args: unknown[]): void {
        console.error(message, ...args);
    }
}

/**
 * Logger class that provides level-based logging functionality.
 */
export class Logger {
    private readonly level: number;
    private readonly logger: ILogger;
    private readonly silent: boolean;

    /**
     * Creates a new logger instance.
     * @param config - Logger configuration
     */
    constructor(config: Required<LogConfig>) {
        this.level = logLevelMap[config.level];
        this.logger = config.logger;
        this.silent = config.silent;
    }

    /**
     * Checks if a log level should be output based on configuration.
     * @param level - The log level to check
     * @returns True if the level should be logged
     */
    public shouldLog(level: LogLevel): boolean {
        return !this.silent && this.level <= logLevelMap[level];
    }

    /**
     * Checks if debug logging is enabled.
     * @returns True if debug logs should be output
     */
    public isDebug(): boolean {
        return this.shouldLog(LogLevel.Debug);
    }

    /**
     * Logs a debug message if debug logging is enabled.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    public debug(message: string, ...args: unknown[]): void {
        if (this.isDebug()) {
            this.logger.debug(message, ...args);
        }
    }

    /**
     * Checks if info logging is enabled.
     * @returns True if info logs should be output
     */
    public isInfo(): boolean {
        return this.shouldLog(LogLevel.Info);
    }

    /**
     * Logs an info message if info logging is enabled.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    public info(message: string, ...args: unknown[]): void {
        if (this.isInfo()) {
            this.logger.info(message, ...args);
        }
    }

    /**
     * Checks if warning logging is enabled.
     * @returns True if warning logs should be output
     */
    public isWarn(): boolean {
        return this.shouldLog(LogLevel.Warn);
    }

    /**
     * Logs a warning message if warning logging is enabled.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    public warn(message: string, ...args: unknown[]): void {
        if (this.isWarn()) {
            this.logger.warn(message, ...args);
        }
    }

    /**
     * Checks if error logging is enabled.
     * @returns True if error logs should be output
     */
    public isError(): boolean {
        return this.shouldLog(LogLevel.Error);
    }

    /**
     * Logs an error message if error logging is enabled.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    public error(message: string, ...args: unknown[]): void {
        if (this.isError()) {
            this.logger.error(message, ...args);
        }
    }
}

export function createLogger(config?: LogConfig | Logger): Logger {
    if (config == null) {
        return defaultLogger;
    }
    if (config instanceof Logger) {
        return config;
    }
    config = config ?? {};
    config.level ??= LogLevel.Info;
    config.logger ??= new ConsoleLogger();
    config.silent ??= true;
    return new Logger(config as Required<LogConfig>);
}

const defaultLogger: Logger = new Logger({
    level: LogLevel.Info,
    logger: new ConsoleLogger(),
    silent: true,
});

```


## /src/core/pagination/CustomPager.ts
```typescript
import type { BaseRequestOptions, NormalizedClientOptions } from "../../BaseClient.js";
import type { APIResponse } from "../fetcher/APIResponse.js";
import type { Fetcher } from "../fetcher/Fetcher.js";
import type { RawResponse } from "../fetcher/index.js";

/**
 *
 * @template TItem The type of the items in the page.
 * @template TResponse The type of the API response.
 */
export class CustomPager<TItem, TResponse> implements AsyncIterable<TItem> {
    /** The items from the current page */
    public data: TItem[];
    /** The raw HTTP response */
    public rawResponse: RawResponse;
    /** The parsed response object */
    public response: TResponse;

    private sendRequest: (request: Fetcher.Args) => Promise<APIResponse<TResponse, Fetcher.Error>>;
    private nextRequest?: Fetcher.Args;
    private previousRequest?: Fetcher.Args;
    private _hasNextPage: boolean;
    private _hasPreviousPage: boolean;

    constructor(args: {
        response: TResponse;
        rawResponse: RawResponse;
        items: TItem[];
        hasNextPage: boolean;
        hasPreviousPage: boolean;
        nextRequest?: Fetcher.Args;
        previousRequest?: Fetcher.Args;
        sendRequest: (request: Fetcher.Args) => Promise<APIResponse<TResponse, Fetcher.Error>>;
    }) {
        this.response = args.response;
        this.rawResponse = args.rawResponse;
        this.data = args.items;
        this._hasNextPage = args.hasNextPage;
        this._hasPreviousPage = args.hasPreviousPage;
        this.nextRequest = args.nextRequest;
        this.previousRequest = args.previousRequest;
        this.sendRequest = args.sendRequest;
    }

    /**
     * @returns whether there is a next page to load
     */
    public hasNextPage(): boolean {
        return this._hasNextPage;
    }

    /**
     * @returns whether there is a previous page to load
     */
    public hasPreviousPage(): boolean {
        return this._hasPreviousPage;
    }

    /**
     * Returns the current page data.
     * This is an alias for the `data` property for consistency with other pagination APIs.
     *
     * @returns the items from the current page
     */
    public getCurrentPage(): TItem[] {
        return this.data;
    }

    /**
     * Retrieves the next page of results.
     * @returns this pager with updated data
     * @throws Error if there is no next page
     */
    public async getNextPage(): Promise<this> {
        if (!this._hasNextPage || !this.nextRequest) {
            throw new Error("No next page available");
        }
        const response = await this.sendRequest(this.nextRequest);
        if (!response.ok) {
            const reason =
                response.error.reason === "status-code" ? `HTTP ${response.error.statusCode}` : response.error.reason;
            throw new Error(`Failed to fetch next page: ${reason}`);
        }
        const data = response.body;
        const rawResponse = response.rawResponse;
        const parsed = await parse<TItem, TResponse>({ request: this.nextRequest, data, rawResponse });
        this.response = data;
        this.rawResponse = rawResponse;
        this.data = parsed.items;
        this._hasNextPage = parsed.hasNextPage;
        this._hasPreviousPage = parsed.hasPreviousPage;
        this.nextRequest = parsed.nextRequest;
        this.previousRequest = parsed.previousRequest;
        return this;
    }

    /**
     * Retrieves the previous page of results.
     * @returns this pager with updated data
     * @throws Error if there is no previous page
     */
    public async getPreviousPage(): Promise<this> {
        if (!this._hasPreviousPage || !this.previousRequest) {
            throw new Error("No previous page available");
        }
        const response = await this.sendRequest(this.previousRequest);
        if (!response.ok) {
            const reason =
                response.error.reason === "status-code" ? `HTTP ${response.error.statusCode}` : response.error.reason;
            throw new Error(`Failed to fetch previous page: ${reason}`);
        }
        const data = response.body;
        const rawResponse = response.rawResponse;
        const parsed = await parse<TItem, TResponse>({ request: this.previousRequest, data, rawResponse });
        this.response = data;
        this.rawResponse = rawResponse;
        this.data = parsed.items;
        this._hasNextPage = parsed.hasNextPage;
        this._hasPreviousPage = parsed.hasPreviousPage;
        this.nextRequest = parsed.nextRequest;
        this.previousRequest = parsed.previousRequest;
        return this;
    }

    private async *iterMessages(): AsyncGenerator<TItem, void> {
        for (const item of this.data) {
            yield item;
        }

        while (this.hasNextPage()) {
            await this.getNextPage();
            for (const item of this.data) {
                yield item;
            }
        }
    }

    async *[Symbol.asyncIterator](): AsyncIterator<TItem, void, unknown> {
        for await (const message of this.iterMessages()) {
            yield message;
        }
    }
}

export async function createCustomPager<TItem, TResponse>({
    sendRequest,
    initialHttpRequest,
    clientOptions,
}: {
    sendRequest: (request: Fetcher.Args) => Promise<APIResponse<TResponse, Fetcher.Error>>;
    initialHttpRequest: Fetcher.Args;
    clientOptions: NormalizedClientOptions;
    requestOptions?: BaseRequestOptions;
}): Promise<CustomPager<TItem, TResponse>> {
    const response = await sendRequest(initialHttpRequest);
    if (!response.ok) {
        const reason =
            response.error.reason === "status-code" ? `HTTP ${response.error.statusCode}` : response.error.reason;
        throw new Error(`Failed to fetch initial page: ${reason}`);
    }
    const data = response.body;
    const rawResponse = response.rawResponse;
    const parsed = await parse<TItem, TResponse>({ request: initialHttpRequest, data, rawResponse });
    return new CustomPager({
        response: data,
        rawResponse,
        items: parsed.items,
        hasNextPage: parsed.hasNextPage,
        hasPreviousPage: parsed.hasPreviousPage,
        nextRequest: parsed.nextRequest,
        previousRequest: parsed.previousRequest,
        sendRequest: sendRequest,
    });
}

async function parse<TItem, TResponse>(_args: {
    request: Fetcher.Args;
    data: TResponse;
    rawResponse: RawResponse;
}): Promise<{
    nextRequest?: Fetcher.Args;
    hasNextPage: boolean;
    previousRequest?: Fetcher.Args;
    hasPreviousPage: boolean;
    items: TItem[];
}> {
    // Placeholder implementation.
    // TODO: Replace this with actual parsing logic.
    return {
        items: [],
        hasNextPage: false,
        hasPreviousPage: false,
    };
}

```


## /src/core/pagination/Page.ts
```typescript
import type { HttpResponsePromise, RawResponse } from "../fetcher/index.js";

/**
 * A page of results from a paginated API.
 *
 * @template T The type of the items in the page.
 * @template R The type of the API response.
 */
export class Page<T, R = unknown> implements AsyncIterable<T> {
    public data: T[];
    public rawResponse: RawResponse;
    public response: R;

    private _hasNextPage: (response: R) => boolean;
    private getItems: (response: R) => T[];
    private loadNextPage: (response: R) => HttpResponsePromise<R>;

    constructor({
        response,
        rawResponse,
        hasNextPage,
        getItems,
        loadPage,
    }: {
        response: R;
        rawResponse: RawResponse;
        hasNextPage: (response: R) => boolean;
        getItems: (response: R) => T[];
        loadPage: (response: R) => HttpResponsePromise<R>;
    }) {
        this.response = response;
        this.rawResponse = rawResponse;
        this.data = getItems(response);
        this._hasNextPage = hasNextPage;
        this.getItems = getItems;
        this.loadNextPage = loadPage;
    }

    /**
     * Retrieves the next page
     * @returns this
     */
    public async getNextPage(): Promise<this> {
        const { data, rawResponse } = await this.loadNextPage(this.response).withRawResponse();
        this.response = data;
        this.rawResponse = rawResponse;
        this.data = this.getItems(this.response);
        return this;
    }

    /**
     * @returns whether there is a next page to load
     */
    public hasNextPage(): boolean {
        return this._hasNextPage(this.response);
    }

    private async *iterMessages(): AsyncGenerator<T, void> {
        for (const item of this.data) {
            yield item;
        }

        while (this.hasNextPage()) {
            await this.getNextPage();
            for (const item of this.data) {
                yield item;
            }
        }
    }

    async *[Symbol.asyncIterator](): AsyncIterator<T, void, any> {
        for await (const message of this.iterMessages()) {
            yield message;
        }
    }
}

```


## /src/core/pagination/exports.ts
```typescript
export type { Page } from "./Page.js";

```


## /src/core/pagination/index.ts
```typescript
export { CustomPager, createCustomPager } from "./CustomPager.js";
export { Page } from "./Page.js";

```


## /src/core/runtime/index.ts
```typescript
export { RUNTIME } from "./runtime.js";

```


## /src/core/runtime/runtime.ts
```typescript
interface DenoGlobal {
    version: {
        deno: string;
    };
}

interface BunGlobal {
    version: string;
}

declare const Deno: DenoGlobal | undefined;
declare const Bun: BunGlobal | undefined;
declare const EdgeRuntime: string | undefined;
declare const self: typeof globalThis.self & {
    importScripts?: unknown;
};

/**
 * A constant that indicates which environment and version the SDK is running in.
 */
export const RUNTIME: Runtime = evaluateRuntime();

export interface Runtime {
    type: "browser" | "web-worker" | "deno" | "bun" | "node" | "react-native" | "unknown" | "workerd" | "edge-runtime";
    version?: string;
    parsedVersion?: number;
}

function evaluateRuntime(): Runtime {
    /**
     * A constant that indicates whether the environment the code is running is a Web Browser.
     */
    const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    if (isBrowser) {
        return {
            type: "browser",
            version: window.navigator.userAgent,
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Cloudflare.
     * https://developers.cloudflare.com/workers/runtime-apis/web-standards/#navigatoruseragent
     */
    const isCloudflare = typeof globalThis !== "undefined" && globalThis?.navigator?.userAgent === "Cloudflare-Workers";
    if (isCloudflare) {
        return {
            type: "workerd",
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Edge Runtime.
     * https://vercel.com/docs/functions/runtimes/edge-runtime#check-if-you're-running-on-the-edge-runtime
     */
    const isEdgeRuntime = typeof EdgeRuntime === "string";
    if (isEdgeRuntime) {
        return {
            type: "edge-runtime",
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is a Web Worker.
     */
    const isWebWorker =
        typeof self === "object" &&
        typeof self?.importScripts === "function" &&
        (self.constructor?.name === "DedicatedWorkerGlobalScope" ||
            self.constructor?.name === "ServiceWorkerGlobalScope" ||
            self.constructor?.name === "SharedWorkerGlobalScope");
    if (isWebWorker) {
        return {
            type: "web-worker",
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Deno.
     * FYI Deno spoofs process.versions.node, see https://deno.land/std@0.177.0/node/process.ts?s=versions
     */
    const isDeno =
        typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    if (isDeno) {
        return {
            type: "deno",
            version: Deno.version.deno,
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Bun.sh.
     */
    const isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    if (isBun) {
        return {
            type: "bun",
            version: Bun.version,
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is in React-Native.
     * This check should come before Node.js detection since React Native may have a process polyfill.
     * https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js
     */
    const isReactNative = typeof navigator !== "undefined" && navigator?.product === "ReactNative";
    if (isReactNative) {
        return {
            type: "react-native",
        };
    }

    /**
     * A constant that indicates whether the environment the code is running is Node.JS.
     */
    const isNode =
        typeof process !== "undefined" &&
        "version" in process &&
        !!process.version &&
        "versions" in process &&
        !!process.versions?.node;
    if (isNode) {
        return {
            type: "node",
            version: process.versions.node,
            parsedVersion: Number(process.versions.node.split(".")[0]),
        };
    }

    return {
        type: "unknown",
    };
}

```


## /src/core/schemas/Schema.ts
```typescript
import type { SchemaUtils } from "./builders/index.js";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
    parse: (raw: unknown, opts?: SchemaOptions) => MaybeValid<Parsed>;
    json: (parsed: unknown, opts?: SchemaOptions) => MaybeValid<Raw>;
    getType: () => SchemaType | SchemaType;
}

export const SchemaType = {
    BIGINT: "bigint",
    DATE: "date",
    ENUM: "enum",
    LIST: "list",
    STRING_LITERAL: "stringLiteral",
    BOOLEAN_LITERAL: "booleanLiteral",
    OBJECT: "object",
    ANY: "any",
    BOOLEAN: "boolean",
    NUMBER: "number",
    STRING: "string",
    UNKNOWN: "unknown",
    NEVER: "never",
    RECORD: "record",
    SET: "set",
    UNION: "union",
    UNDISCRIMINATED_UNION: "undiscriminatedUnion",
    NULLABLE: "nullable",
    OPTIONAL: "optional",
    OPTIONAL_NULLABLE: "optionalNullable",
} as const;

export type SchemaType = (typeof SchemaType)[keyof typeof SchemaType];

export type MaybeValid<T> = Valid<T> | Invalid;

export interface Valid<T> {
    ok: true;
    value: T;
}

export interface Invalid {
    ok: false;
    errors: ValidationError[];
}

export interface ValidationError {
    path: string[];
    message: string;
}

export interface SchemaOptions {
    /**
     * how to handle unrecognized keys in objects
     *
     * @default "fail"
     */
    unrecognizedObjectKeys?: "fail" | "passthrough" | "strip";

    /**
     * whether to fail when an unrecognized discriminant value is
     * encountered in a union
     *
     * @default false
     */
    allowUnrecognizedUnionMembers?: boolean;

    /**
     * whether to fail when an unrecognized enum value is encountered
     *
     * @default false
     */
    allowUnrecognizedEnumValues?: boolean;

    /**
     * whether to allow data that doesn't conform to the schema.
     * invalid data is passed through without transformation.
     *
     * when this is enabled, .parse() and .json() will always
     * return `ok: true`. `.parseOrThrow()` and `.jsonOrThrow()`
     * will never fail.
     *
     * @default false
     */
    skipValidation?: boolean;

    /**
     * each validation failure contains a "path" property, which is
     * the breadcrumbs to the offending node in the JSON. you can supply
     * a prefix that is prepended to all the errors' paths. this can be
     * helpful for zurg's internal debug logging.
     */
    breadcrumbsPrefix?: string[];

    /**
     * whether to send 'null' for optional properties explicitly set to 'undefined'.
     */
    omitUndefined?: boolean;
}

```


## /src/core/schemas/builders/bigint/bigint.ts
```typescript
import { type BaseSchema, type Schema, SchemaType } from "../../Schema.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
import { getSchemaUtils } from "../schema-utils/index.js";

export function bigint(): Schema<bigint | number, bigint> {
    const baseSchema: BaseSchema<bigint | number, bigint> = {
        parse: (raw, { breadcrumbsPrefix = [] } = {}) => {
            if (typeof raw === "bigint") {
                return {
                    ok: true,
                    value: raw,
                };
            }
            if (typeof raw === "number") {
                return {
                    ok: true,
                    value: BigInt(raw),
                };
            }
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: getErrorMessageForIncorrectType(raw, "bigint | number"),
                    },
                ],
            };
        },
        json: (bigint, { breadcrumbsPrefix = [] } = {}) => {
            if (typeof bigint !== "bigint") {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: getErrorMessageForIncorrectType(bigint, "bigint"),
                        },
                    ],
                };
            }
            return {
                ok: true,
                value: bigint,
            };
        },
        getType: () => SchemaType.BIGINT,
    };

    return {
        ...maybeSkipValidation(baseSchema),
        ...getSchemaUtils(baseSchema),
    };
}

```


## /src/core/schemas/builders/bigint/index.ts
```typescript
export { bigint } from "./bigint.js";

```


## /src/core/schemas/builders/date/date.ts
```typescript
import { type BaseSchema, type Schema, SchemaType } from "../../Schema.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
import { getSchemaUtils } from "../schema-utils/index.js";

// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime
const ISO_8601_REGEX =
    /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;

export function date(): Schema<string, Date> {
    const baseSchema: BaseSchema<string, Date> = {
        parse: (raw, { breadcrumbsPrefix = [] } = {}) => {
            if (typeof raw !== "string") {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: getErrorMessageForIncorrectType(raw, "string"),
                        },
                    ],
                };
            }
            if (!ISO_8601_REGEX.test(raw)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: getErrorMessageForIncorrectType(raw, "ISO 8601 date string"),
                        },
                    ],
                };
            }
            return {
                ok: true,
                value: new Date(raw),
            };
        },
        json: (date, { breadcrumbsPrefix = [] } = {}) => {
            if (date instanceof Date) {
                return {
                    ok: true,
                    value: date.toISOString(),
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: getErrorMessageForIncorrectType(date, "Date object"),
                        },
                    ],
                };
            }
        },
        getType: () => SchemaType.DATE,
    };

    return {
        ...maybeSkipValidation(baseSchema),
        ...getSchemaUtils(baseSchema),
    };
}

```


## /src/core/schemas/builders/date/index.ts
```typescript
export { date } from "./date.js";

```


## /src/core/schemas/builders/enum/enum.ts
```typescript
import { type Schema, SchemaType } from "../../Schema.js";
import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";

export function enum_<U extends string, E extends U[]>(values: E): Schema<E[number], E[number]> {
    const validValues = new Set<string>(values);

    const schemaCreator = createIdentitySchemaCreator(
        SchemaType.ENUM,
        (value, { allowUnrecognizedEnumValues, breadcrumbsPrefix = [] } = {}) => {
            if (typeof value !== "string") {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: getErrorMessageForIncorrectType(value, "string"),
                        },
                    ],
                };
            }

            if (!validValues.has(value) && !allowUnrecognizedEnumValues) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: getErrorMessageForIncorrectType(value, "enum"),
                        },
                    ],
                };
            }

            return {
                ok: true,
                value: value as U,
            };
        },
    );

    return schemaCreator();
}

```


## /src/core/schemas/builders/enum/index.ts
```typescript
export { enum_ } from "./enum.js";

```


## /src/core/schemas/builders/index.ts
```typescript
export * from "./bigint/index.js";
export * from "./date/index.js";
export * from "./enum/index.js";
export * from "./lazy/index.js";
export * from "./list/index.js";
export * from "./literals/index.js";
export * from "./object/index.js";
export * from "./object-like/index.js";
export * from "./primitives/index.js";
export * from "./record/index.js";
export * from "./schema-utils/index.js";
export * from "./set/index.js";
export * from "./undiscriminated-union/index.js";
export * from "./union/index.js";

```


## /src/core/schemas/builders/lazy/index.ts
```typescript
export type { SchemaGetter } from "./lazy.js";
export { lazy } from "./lazy.js";
export { lazyObject } from "./lazyObject.js";

```


## /src/core/schemas/builders/lazy/lazy.ts
```typescript
import type { BaseSchema, Schema } from "../../Schema.js";
import { getSchemaUtils } from "../schema-utils/index.js";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
    const baseSchema = constructLazyBaseSchema(getter);
    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function constructLazyBaseSchema<Raw, Parsed>(
    getter: SchemaGetter<Schema<Raw, Parsed>>,
): BaseSchema<Raw, Parsed> {
    return {
        parse: (raw, opts) => getMemoizedSchema(getter).parse(raw, opts),
        json: (parsed, opts) => getMemoizedSchema(getter).json(parsed, opts),
        getType: () => getMemoizedSchema(getter).getType(),
    };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export function getMemoizedSchema<SchemaType extends Schema<any, any>>(getter: SchemaGetter<SchemaType>): SchemaType {
    const castedGetter = getter as MemoizedGetter<SchemaType>;
    if (castedGetter.__zurg_memoized == null) {
        castedGetter.__zurg_memoized = getter();
    }
    return castedGetter.__zurg_memoized;
}

```


## /src/core/schemas/builders/lazy/lazyObject.ts
```typescript
import { getObjectUtils } from "../object/index.js";
import type { BaseObjectSchema, ObjectSchema } from "../object/types.js";
import { getObjectLikeUtils } from "../object-like/index.js";
import { getSchemaUtils } from "../schema-utils/index.js";
import { constructLazyBaseSchema, getMemoizedSchema, type SchemaGetter } from "./lazy.js";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
    const baseSchema: BaseObjectSchema<Raw, Parsed> = {
        ...constructLazyBaseSchema(getter),
        _getRawProperties: () => getMemoizedSchema(getter)._getRawProperties(),
        _getParsedProperties: () => getMemoizedSchema(getter)._getParsedProperties(),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}

```


## /src/core/schemas/builders/list/index.ts
```typescript
export { list } from "./list.js";

```


## /src/core/schemas/builders/list/list.ts
```typescript
import { type BaseSchema, type MaybeValid, type Schema, SchemaType, type ValidationError } from "../../Schema.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
import { getSchemaUtils } from "../schema-utils/index.js";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
    const baseSchema: BaseSchema<Raw[], Parsed[]> = {
        parse: (raw, opts) =>
            validateAndTransformArray(raw, (item, index) =>
                schema.parse(item, {
                    ...opts,
                    breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `[${index}]`],
                }),
            ),
        json: (parsed, opts) =>
            validateAndTransformArray(parsed, (item, index) =>
                schema.json(item, {
                    ...opts,
                    breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `[${index}]`],
                }),
            ),
        getType: () => SchemaType.LIST,
    };

    return {
        ...maybeSkipValidation(baseSchema),
        ...getSchemaUtils(baseSchema),
    };
}

function validateAndTransformArray<Raw, Parsed>(
    value: unknown,
    transformItem: (item: Raw, index: number) => MaybeValid<Parsed>,
): MaybeValid<Parsed[]> {
    if (!Array.isArray(value)) {
        return {
            ok: false,
            errors: [
                {
                    message: getErrorMessageForIncorrectType(value, "list"),
                    path: [],
                },
            ],
        };
    }

    const maybeValidItems = value.map((item, index) => transformItem(item, index));

    return maybeValidItems.reduce<MaybeValid<Parsed[]>>(
        (acc, item) => {
            if (acc.ok && item.ok) {
                return {
                    ok: true,
                    value: [...acc.value, item.value],
                };
            }

            const errors: ValidationError[] = [];
            if (!acc.ok) {
                errors.push(...acc.errors);
            }
            if (!item.ok) {
                errors.push(...item.errors);
            }

            return {
                ok: false,
                errors,
            };
        },
        { ok: true, value: [] },
    );
}

```


## /src/core/schemas/builders/literals/booleanLiteral.ts
```typescript
import { type Schema, SchemaType } from "../../Schema.js";
import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";

export function booleanLiteral<V extends boolean>(literal: V): Schema<V, V> {
    const schemaCreator = createIdentitySchemaCreator(
        SchemaType.BOOLEAN_LITERAL,
        (value, { breadcrumbsPrefix = [] } = {}) => {
            if (value === literal) {
                return {
                    ok: true,
                    value: literal,
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: getErrorMessageForIncorrectType(value, `${literal.toString()}`),
                        },
                    ],
                };
            }
        },
    );

    return schemaCreator();
}

```


## /src/core/schemas/builders/literals/index.ts
```typescript
export { booleanLiteral } from "./booleanLiteral.js";
export { stringLiteral } from "./stringLiteral.js";

```


## /src/core/schemas/builders/literals/stringLiteral.ts
```typescript
import { type Schema, SchemaType } from "../../Schema.js";
import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";

export function stringLiteral<V extends string>(literal: V): Schema<V, V> {
    const schemaCreator = createIdentitySchemaCreator(
        SchemaType.STRING_LITERAL,
        (value, { breadcrumbsPrefix = [] } = {}) => {
            if (value === literal) {
                return {
                    ok: true,
                    value: literal,
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: getErrorMessageForIncorrectType(value, `"${literal}"`),
                        },
                    ],
                };
            }
        },
    );

    return schemaCreator();
}

```


## /src/core/schemas/builders/object-like/getObjectLikeUtils.ts
```typescript
import type { BaseSchema } from "../../Schema.js";
import { filterObject } from "../../utils/filterObject.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
import { isPlainObject } from "../../utils/isPlainObject.js";
import { getSchemaUtils } from "../schema-utils/index.js";
import type { ObjectLikeSchema, ObjectLikeUtils } from "./types.js";

export function getObjectLikeUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): ObjectLikeUtils<Raw, Parsed> {
    return {
        withParsedProperties: (properties) => withParsedProperties(schema, properties),
    };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withParsedProperties<RawObjectShape, ParsedObjectShape, Properties>(
    objectLike: BaseSchema<RawObjectShape, ParsedObjectShape>,
    properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) },
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
    const objectSchema: BaseSchema<RawObjectShape, ParsedObjectShape & Properties> = {
        parse: (raw, opts) => {
            const parsedObject = objectLike.parse(raw, opts);
            if (!parsedObject.ok) {
                return parsedObject;
            }

            const additionalProperties = Object.entries(properties).reduce<Record<string, any>>(
                (processed, [key, value]) => {
                    return {
                        ...processed,
                        [key]: typeof value === "function" ? value(parsedObject.value) : value,
                    };
                },
                {},
            );

            return {
                ok: true,
                value: {
                    ...parsedObject.value,
                    ...(additionalProperties as Properties),
                },
            };
        },

        json: (parsed, opts) => {
            if (!isPlainObject(parsed)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: opts?.breadcrumbsPrefix ?? [],
                            message: getErrorMessageForIncorrectType(parsed, "object"),
                        },
                    ],
                };
            }

            // strip out added properties
            const addedPropertyKeys = new Set(Object.keys(properties));
            const parsedWithoutAddedProperties = filterObject(
                parsed,
                Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key)),
            );

            return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
        },

        getType: () => objectLike.getType(),
    };

    return {
        ...objectSchema,
        ...getSchemaUtils(objectSchema),
        ...getObjectLikeUtils(objectSchema),
    };
}

```


## /src/core/schemas/builders/object-like/index.ts
```typescript
export { getObjectLikeUtils, withParsedProperties } from "./getObjectLikeUtils.js";
export type { ObjectLikeSchema, ObjectLikeUtils } from "./types.js";

```


## /src/core/schemas/builders/object-like/types.ts
```typescript
import type { BaseSchema, Schema } from "../../Schema.js";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
    BaseSchema<Raw, Parsed> &
    ObjectLikeUtils<Raw, Parsed>;

export interface ObjectLikeUtils<Raw, Parsed> {
    withParsedProperties: <T extends Record<string, any>>(
        properties: {
            [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
        },
    ) => ObjectLikeSchema<Raw, Parsed & T>;
}

```


## /src/core/schemas/builders/object/index.ts
```typescript
export { getObjectUtils, object } from "./object.js";
export type {
    inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas,
    inferParsedObjectWithoutOptionalPropertiesFromPropertySchemas,
} from "./objectWithoutOptionalProperties.js";
export { objectWithoutOptionalProperties } from "./objectWithoutOptionalProperties.js";
export type { Property } from "./property.js";
export { isProperty, property } from "./property.js";
export type {
    BaseObjectSchema,
    inferObjectSchemaFromPropertySchemas,
    inferParsedObject,
    inferParsedObjectFromPropertySchemas,
    inferParsedPropertySchema,
    inferRawKey,
    inferRawObject,
    inferRawObjectFromPropertySchemas,
    inferRawPropertySchema,
    ObjectSchema,
    ObjectUtils,
    PropertySchemas,
} from "./types.js";

```


## /src/core/schemas/builders/object/object.ts
```typescript
import { type MaybeValid, type Schema, SchemaType, type ValidationError } from "../../Schema.js";
import { entries } from "../../utils/entries.js";
import { filterObject } from "../../utils/filterObject.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
import { isPlainObject } from "../../utils/isPlainObject.js";
import { keys } from "../../utils/keys.js";
import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
import { partition } from "../../utils/partition.js";
import { getObjectLikeUtils } from "../object-like/index.js";
import { getSchemaUtils } from "../schema-utils/index.js";
import { isProperty } from "./property.js";
import type {
    BaseObjectSchema,
    inferObjectSchemaFromPropertySchemas,
    inferParsedObjectFromPropertySchemas,
    inferRawObjectFromPropertySchemas,
    ObjectSchema,
    ObjectUtils,
    PropertySchemas,
} from "./types.js";

interface ObjectPropertyWithRawKey {
    rawKey: string;
    parsedKey: string;
    valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
    schemas: T,
): inferObjectSchemaFromPropertySchemas<T> {
    const baseSchema: BaseObjectSchema<
        inferRawObjectFromPropertySchemas<T>,
        inferParsedObjectFromPropertySchemas<T>
    > = {
        _getRawProperties: () =>
            Object.entries(schemas).map(([parsedKey, propertySchema]) =>
                isProperty(propertySchema) ? propertySchema.rawKey : parsedKey,
            ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[],
        _getParsedProperties: () => keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[],

        parse: (raw, opts) => {
            const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};
            const requiredKeys: string[] = [];

            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
                const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;

                const property: ObjectPropertyWithRawKey = {
                    rawKey,
                    parsedKey: parsedKey as string,
                    valueSchema,
                };

                rawKeyToProperty[rawKey] = property;

                if (isSchemaRequired(valueSchema)) {
                    requiredKeys.push(rawKey);
                }
            }

            return validateAndTransformObject({
                value: raw,
                requiredKeys,
                getProperty: (rawKey) => {
                    const property = rawKeyToProperty[rawKey];
                    if (property == null) {
                        return undefined;
                    }
                    return {
                        transformedKey: property.parsedKey,
                        transform: (propertyValue) =>
                            property.valueSchema.parse(propertyValue, {
                                ...opts,
                                breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), rawKey],
                            }),
                    };
                },
                unrecognizedObjectKeys: opts?.unrecognizedObjectKeys,
                skipValidation: opts?.skipValidation,
                breadcrumbsPrefix: opts?.breadcrumbsPrefix,
                omitUndefined: opts?.omitUndefined,
            });
        },

        json: (parsed, opts) => {
            const requiredKeys: string[] = [];

            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;

                if (isSchemaRequired(valueSchema)) {
                    requiredKeys.push(parsedKey as string);
                }
            }

            return validateAndTransformObject({
                value: parsed,
                requiredKeys,
                getProperty: (
                    parsedKey,
                ): { transformedKey: string; transform: (propertyValue: object) => MaybeValid<any> } | undefined => {
                    const property = schemas[parsedKey as keyof T];

                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    if (property == null) {
                        return undefined;
                    }

                    if (isProperty(property)) {
                        return {
                            transformedKey: property.rawKey,
                            transform: (propertyValue) =>
                                property.valueSchema.json(propertyValue, {
                                    ...opts,
                                    breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), parsedKey],
                                }),
                        };
                    } else {
                        return {
                            transformedKey: parsedKey,
                            transform: (propertyValue) =>
                                property.json(propertyValue, {
                                    ...opts,
                                    breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), parsedKey],
                                }),
                        };
                    }
                },
                unrecognizedObjectKeys: opts?.unrecognizedObjectKeys,
                skipValidation: opts?.skipValidation,
                breadcrumbsPrefix: opts?.breadcrumbsPrefix,
                omitUndefined: opts?.omitUndefined,
            });
        },

        getType: () => SchemaType.OBJECT,
    };

    return {
        ...maybeSkipValidation(baseSchema),
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}

function validateAndTransformObject<Transformed>({
    value,
    requiredKeys,
    getProperty,
    unrecognizedObjectKeys = "fail",
    skipValidation = false,
    breadcrumbsPrefix = [],
}: {
    value: unknown;
    requiredKeys: string[];
    getProperty: (
        preTransformedKey: string,
    ) => { transformedKey: string; transform: (propertyValue: object) => MaybeValid<any> } | undefined;
    unrecognizedObjectKeys: "fail" | "passthrough" | "strip" | undefined;
    skipValidation: boolean | undefined;
    breadcrumbsPrefix: string[] | undefined;
    omitUndefined: boolean | undefined;
}): MaybeValid<Transformed> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: getErrorMessageForIncorrectType(value, "object"),
                },
            ],
        };
    }

    const missingRequiredKeys = new Set(requiredKeys);
    const errors: ValidationError[] = [];
    const transformed: Record<string | number | symbol, any> = {};

    for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {
        const property = getProperty(preTransformedKey);

        if (property != null) {
            missingRequiredKeys.delete(preTransformedKey);

            const value = property.transform(preTransformedItemValue as object);
            if (value.ok) {
                transformed[property.transformedKey] = value.value;
            } else {
                transformed[preTransformedKey] = preTransformedItemValue;
                errors.push(...value.errors);
            }
        } else {
            switch (unrecognizedObjectKeys) {
                case "fail":
                    errors.push({
                        path: [...breadcrumbsPrefix, preTransformedKey],
                        message: `Unexpected key "${preTransformedKey}"`,
                    });
                    break;
                case "strip":
                    break;
                case "passthrough":
                    transformed[preTransformedKey] = preTransformedItemValue;
                    break;
            }
        }
    }

    errors.push(
        ...requiredKeys
            .filter((key) => missingRequiredKeys.has(key))
            .map((key) => ({
                path: breadcrumbsPrefix,
                message: `Missing required key "${key}"`,
            })),
    );

    if (errors.length === 0 || skipValidation) {
        return {
            ok: true,
            value: transformed as Transformed,
        };
    } else {
        return {
            ok: false,
            errors,
        };
    }
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
    return {
        extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
            const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
                _getParsedProperties: () => [...schema._getParsedProperties(), ...extension._getParsedProperties()],
                _getRawProperties: () => [...schema._getRawProperties(), ...extension._getRawProperties()],
                parse: (raw, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: extension._getRawProperties(),
                        value: raw,
                        transformBase: (rawBase) => schema.parse(rawBase, opts),
                        transformExtension: (rawExtension) => extension.parse(rawExtension, opts),
                        breadcrumbsPrefix: opts?.breadcrumbsPrefix,
                    });
                },
                json: (parsed, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: extension._getParsedProperties(),
                        value: parsed,
                        transformBase: (parsedBase) => schema.json(parsedBase, opts),
                        transformExtension: (parsedExtension) => extension.json(parsedExtension, opts),
                        breadcrumbsPrefix: opts?.breadcrumbsPrefix,
                    });
                },
                getType: () => SchemaType.OBJECT,
            };

            return {
                ...baseSchema,
                ...getSchemaUtils(baseSchema),
                ...getObjectLikeUtils(baseSchema),
                ...getObjectUtils(baseSchema),
            };
        },
        passthrough: () => {
            const baseSchema: BaseObjectSchema<Raw & { [key: string]: unknown }, Parsed & { [key: string]: unknown }> =
                {
                    _getParsedProperties: () => schema._getParsedProperties(),
                    _getRawProperties: () => schema._getRawProperties(),
                    parse: (raw, opts) => {
                        const transformed = schema.parse(raw, { ...opts, unrecognizedObjectKeys: "passthrough" });
                        if (!transformed.ok) {
                            return transformed;
                        }
                        return {
                            ok: true,
                            value: {
                                ...(raw as any),
                                ...transformed.value,
                            },
                        };
                    },
                    json: (parsed, opts) => {
                        const transformed = schema.json(parsed, { ...opts, unrecognizedObjectKeys: "passthrough" });
                        if (!transformed.ok) {
                            return transformed;
                        }
                        return {
                            ok: true,
                            value: {
                                ...(parsed as any),
                                ...transformed.value,
                            },
                        };
                    },
                    getType: () => SchemaType.OBJECT,
                };

            return {
                ...baseSchema,
                ...getSchemaUtils(baseSchema),
                ...getObjectLikeUtils(baseSchema),
                ...getObjectUtils(baseSchema),
            };
        },
    };
}

function validateAndTransformExtendedObject<PreTransformedExtension, TransformedBase, TransformedExtension>({
    extensionKeys,
    value,
    transformBase,
    transformExtension,
    breadcrumbsPrefix = [],
}: {
    extensionKeys: (keyof PreTransformedExtension)[];
    value: unknown;
    transformBase: (value: object) => MaybeValid<TransformedBase>;
    transformExtension: (value: object) => MaybeValid<TransformedExtension>;
    breadcrumbsPrefix?: string[];
}): MaybeValid<TransformedBase & TransformedExtension> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: getErrorMessageForIncorrectType(value, "object"),
                },
            ],
        };
    }

    const extensionPropertiesSet = new Set(extensionKeys);
    const [extensionProperties, baseProperties] = partition(keys(value), (key) =>
        extensionPropertiesSet.has(key as keyof PreTransformedExtension),
    );

    const transformedBase = transformBase(filterObject(value, baseProperties));
    const transformedExtension = transformExtension(filterObject(value, extensionProperties));

    if (transformedBase.ok && transformedExtension.ok) {
        return {
            ok: true,
            value: {
                ...transformedBase.value,
                ...transformedExtension.value,
            },
        };
    } else {
        return {
            ok: false,
            errors: [
                ...(transformedBase.ok ? [] : transformedBase.errors),
                ...(transformedExtension.ok ? [] : transformedExtension.errors),
            ],
        };
    }
}

function isSchemaRequired(schema: Schema<any, any>): boolean {
    return !isSchemaOptional(schema);
}

function isSchemaOptional(schema: Schema<any, any>): boolean {
    switch (schema.getType()) {
        case SchemaType.ANY:
        case SchemaType.UNKNOWN:
        case SchemaType.OPTIONAL:
        case SchemaType.OPTIONAL_NULLABLE:
            return true;
        default:
            return false;
    }
}

```


## /src/core/schemas/builders/object/objectWithoutOptionalProperties.ts
```typescript
import { object } from "./object.js";
import type {
    inferParsedPropertySchema,
    inferRawObjectFromPropertySchemas,
    ObjectSchema,
    PropertySchemas,
} from "./types.js";

export function objectWithoutOptionalProperties<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
    schemas: T,
): inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas<T> {
    return object(schemas) as unknown as inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas<T>;
}

export type inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    ObjectSchema<
        inferRawObjectFromPropertySchemas<T>,
        inferParsedObjectWithoutOptionalPropertiesFromPropertySchemas<T>
    >;

export type inferParsedObjectWithoutOptionalPropertiesFromPropertySchemas<T extends PropertySchemas<keyof T>> = {
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
};

```


## /src/core/schemas/builders/object/property.ts
```typescript
import type { Schema } from "../../Schema.js";

export function property<RawKey extends string, RawValue, ParsedValue>(
    rawKey: RawKey,
    valueSchema: Schema<RawValue, ParsedValue>,
): Property<RawKey, RawValue, ParsedValue> {
    return {
        rawKey,
        valueSchema,
        isProperty: true,
    };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
    rawKey: RawKey;
    valueSchema: Schema<RawValue, ParsedValue>;
    isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return (maybeProperty as O).isProperty;
}

```


## /src/core/schemas/builders/object/types.ts
```typescript
import type { BaseSchema, inferParsed, inferRaw, Schema } from "../../Schema.js";
import type { addQuestionMarksToNullableProperties } from "../../utils/addQuestionMarksToNullableProperties.js";
import type { ObjectLikeUtils } from "../object-like/index.js";
import type { SchemaUtils } from "../schema-utils/index.js";
import type { Property } from "./property.js";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
    ObjectLikeUtils<Raw, Parsed> &
    ObjectUtils<Raw, Parsed> &
    SchemaUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseSchema<Raw, Parsed> {
    _getRawProperties: () => (keyof Raw)[];
    _getParsedProperties: () => (keyof Parsed)[];
}

export interface ObjectUtils<Raw, Parsed> {
    extend: <RawExtension, ParsedExtension>(
        schemas: ObjectSchema<RawExtension, ParsedExtension>,
    ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
    passthrough: () => ObjectSchema<Raw & { [key: string]: unknown }, Parsed & { [key: string]: unknown }>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
    ? Parsed
    : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
    inferRawObjectFromPropertySchemas<T>,
    inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
    }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [K in keyof T]: inferParsedPropertySchema<T[K]>;
    }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
    ParsedKeys,
    Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    infer Raw,
    any
>
    ? Raw
    : P extends Schema<any, any>
      ? inferRaw<P>
      : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    any,
    infer Parsed
>
    ? Parsed
    : P extends Schema<any, any>
      ? inferParsed<P>
      : never;

export type inferRawKey<
    ParsedKey extends string | number | symbol,
    P extends Property<any, any, any> | Schema<any, any>,
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;

```


## /src/core/schemas/builders/primitives/any.ts
```typescript
import { type Schema, SchemaType } from "../../Schema.js";
import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";

export const any: () => Schema<any, any> = createIdentitySchemaCreator<any>(SchemaType.ANY, (value) => ({
    ok: true,
    value,
}));

```


## /src/core/schemas/builders/primitives/boolean.ts
```typescript
import { type Schema, SchemaType } from "../../Schema.js";
import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";

export const boolean: () => Schema<boolean, boolean> = createIdentitySchemaCreator<boolean>(
    SchemaType.BOOLEAN,
    (value, { breadcrumbsPrefix = [] } = {}) => {
        if (typeof value === "boolean") {
            return {
                ok: true,
                value,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: getErrorMessageForIncorrectType(value, "boolean"),
                    },
                ],
            };
        }
    },
);

```


## /src/core/schemas/builders/primitives/index.ts
```typescript
export { any } from "./any.js";
export { boolean } from "./boolean.js";
export { never } from "./never.js";
export { number } from "./number.js";
export { string } from "./string.js";
export { unknown } from "./unknown.js";

```


## /src/core/schemas/builders/primitives/never.ts
```typescript
import { type Schema, SchemaType } from "../../Schema.js";
import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";

export const never: () => Schema<never, never> = createIdentitySchemaCreator<never>(
    SchemaType.NEVER,
    (_value, { breadcrumbsPrefix = [] } = {}) => ({
        ok: false,
        errors: [
            {
                path: breadcrumbsPrefix,
                message: "Expected never",
            },
        ],
    }),
);

```


## /src/core/schemas/builders/primitives/number.ts
```typescript
import { type Schema, SchemaType } from "../../Schema.js";
import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";

export const number: () => Schema<number, number> = createIdentitySchemaCreator<number>(
    SchemaType.NUMBER,
    (value, { breadcrumbsPrefix = [] } = {}) => {
        if (typeof value === "number") {
            return {
                ok: true,
                value,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: getErrorMessageForIncorrectType(value, "number"),
                    },
                ],
            };
        }
    },
);

```


## /src/core/schemas/builders/primitives/string.ts
```typescript
import { type Schema, SchemaType } from "../../Schema.js";
import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";

export const string: () => Schema<string, string> = createIdentitySchemaCreator<string>(
    SchemaType.STRING,
    (value, { breadcrumbsPrefix = [] } = {}) => {
        if (typeof value === "string") {
            return {
                ok: true,
                value,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: getErrorMessageForIncorrectType(value, "string"),
                    },
                ],
            };
        }
    },
);

```


## /src/core/schemas/builders/primitives/unknown.ts
```typescript
import { type Schema, SchemaType } from "../../Schema.js";
import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";

export const unknown: () => Schema<unknown, unknown> = createIdentitySchemaCreator<unknown>(
    SchemaType.UNKNOWN,
    (value) => ({ ok: true, value }),
);

```


## /src/core/schemas/builders/record/index.ts
```typescript
export { record } from "./record.js";
export type { BaseRecordSchema, RecordSchema } from "./types.js";

```


## /src/core/schemas/builders/record/record.ts
```typescript
import { type MaybeValid, type Schema, SchemaType, type ValidationError } from "../../Schema.js";
import { entries } from "../../utils/entries.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
import { isPlainObject } from "../../utils/isPlainObject.js";
import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
import { getSchemaUtils } from "../schema-utils/index.js";
import type { BaseRecordSchema, RecordSchema } from "./types.js";

export function record<RawKey extends string | number, RawValue, ParsedValue, ParsedKey extends string | number>(
    keySchema: Schema<RawKey, ParsedKey>,
    valueSchema: Schema<RawValue, ParsedValue>,
): RecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> {
    const baseSchema: BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> = {
        parse: (raw, opts) => {
            return validateAndTransformRecord({
                value: raw,
                isKeyNumeric: keySchema.getType() === SchemaType.NUMBER,
                transformKey: (key) =>
                    keySchema.parse(key, {
                        ...opts,
                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key} (key)`],
                    }),
                transformValue: (value, key) =>
                    valueSchema.parse(value, {
                        ...opts,
                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key}`],
                    }),
                breadcrumbsPrefix: opts?.breadcrumbsPrefix,
            });
        },
        json: (parsed, opts) => {
            return validateAndTransformRecord({
                value: parsed,
                isKeyNumeric: keySchema.getType() === SchemaType.NUMBER,
                transformKey: (key) =>
                    keySchema.json(key, {
                        ...opts,
                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key} (key)`],
                    }),
                transformValue: (value, key) =>
                    valueSchema.json(value, {
                        ...opts,
                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key}`],
                    }),
                breadcrumbsPrefix: opts?.breadcrumbsPrefix,
            });
        },
        getType: () => SchemaType.RECORD,
    };

    return {
        ...maybeSkipValidation(baseSchema),
        ...getSchemaUtils(baseSchema),
    };
}

function validateAndTransformRecord<TransformedKey extends string | number, TransformedValue>({
    value,
    isKeyNumeric,
    transformKey,
    transformValue,
    breadcrumbsPrefix = [],
}: {
    value: unknown;
    isKeyNumeric: boolean;
    transformKey: (key: string | number) => MaybeValid<TransformedKey>;
    transformValue: (value: unknown, key: string | number) => MaybeValid<TransformedValue>;
    breadcrumbsPrefix: string[] | undefined;
}): MaybeValid<Record<TransformedKey, TransformedValue>> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: getErrorMessageForIncorrectType(value, "object"),
                },
            ],
        };
    }

    return entries(value).reduce<MaybeValid<Record<TransformedKey, TransformedValue>>>(
        (accPromise, [stringKey, value]) => {
            if (value === undefined) {
                return accPromise;
            }

            const acc = accPromise;

            let key: string | number = stringKey;
            if (isKeyNumeric) {
                const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
                if (!Number.isNaN(numberKey)) {
                    key = numberKey;
                }
            }
            const transformedKey = transformKey(key);

            const transformedValue = transformValue(value, key);

            if (acc.ok && transformedKey.ok && transformedValue.ok) {
                return {
                    ok: true,
                    value: {
                        ...acc.value,
                        [transformedKey.value]: transformedValue.value,
                    },
                };
            }

            const errors: ValidationError[] = [];
            if (!acc.ok) {
                errors.push(...acc.errors);
            }
            if (!transformedKey.ok) {
                errors.push(...transformedKey.errors);
            }
            if (!transformedValue.ok) {
                errors.push(...transformedValue.errors);
            }

            return {
                ok: false,
                errors,
            };
        },
        { ok: true, value: {} as Record<TransformedKey, TransformedValue> },
    );
}

```


## /src/core/schemas/builders/record/types.ts
```typescript
import type { BaseSchema } from "../../Schema.js";
import type { SchemaUtils } from "../schema-utils/index.js";

export type RecordSchema<
    RawKey extends string | number,
    RawValue,
    ParsedKey extends string | number,
    ParsedValue,
> = BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> &
    SchemaUtils<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>>;

export type BaseRecordSchema<
    RawKey extends string | number,
    RawValue,
    ParsedKey extends string | number,
    ParsedValue,
> = BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>>;

```


## /src/core/schemas/builders/schema-utils/JsonError.ts
```typescript
import type { ValidationError } from "../../Schema.js";
import { stringifyValidationError } from "./stringifyValidationErrors.js";

export class JsonError extends Error {
    constructor(public readonly errors: ValidationError[]) {
        super(errors.map(stringifyValidationError).join("; "));
        Object.setPrototypeOf(this, JsonError.prototype);
    }
}

```


## /src/core/schemas/builders/schema-utils/ParseError.ts
```typescript
import type { ValidationError } from "../../Schema.js";
import { stringifyValidationError } from "./stringifyValidationErrors.js";

export class ParseError extends Error {
    constructor(public readonly errors: ValidationError[]) {
        super(errors.map(stringifyValidationError).join("; "));
        Object.setPrototypeOf(this, ParseError.prototype);
    }
}

```


## /src/core/schemas/builders/schema-utils/getSchemaUtils.ts
```typescript
import { type BaseSchema, type Schema, type SchemaOptions, SchemaType } from "../../Schema.js";
import { JsonError } from "./JsonError.js";
import { ParseError } from "./ParseError.js";

export interface SchemaUtils<Raw, Parsed> {
    nullable: () => Schema<Raw | null, Parsed | null>;
    optional: () => Schema<Raw | null | undefined, Parsed | undefined>;
    optionalNullable: () => Schema<Raw | null | undefined, Parsed | null | undefined>;
    transform: <Transformed>(transformer: SchemaTransformer<Parsed, Transformed>) => Schema<Raw, Transformed>;
    parseOrThrow: (raw: unknown, opts?: SchemaOptions) => Parsed;
    jsonOrThrow: (raw: unknown, opts?: SchemaOptions) => Raw;
}

export interface SchemaTransformer<Parsed, Transformed> {
    transform: (parsed: Parsed) => Transformed;
    untransform: (transformed: any) => Parsed;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
    return {
        nullable: () => nullable(schema),
        optional: () => optional(schema),
        optionalNullable: () => optionalNullable(schema),
        transform: (transformer) => transform(schema, transformer),
        parseOrThrow: (raw, opts) => {
            const parsed = schema.parse(raw, opts);
            if (parsed.ok) {
                return parsed.value;
            }
            throw new ParseError(parsed.errors);
        },
        jsonOrThrow: (parsed, opts) => {
            const raw = schema.json(parsed, opts);
            if (raw.ok) {
                return raw.value;
            }
            throw new JsonError(raw.errors);
        },
    };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function nullable<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): Schema<Raw | null, Parsed | null> {
    const baseSchema: BaseSchema<Raw | null, Parsed | null> = {
        parse: (raw, opts) => {
            if (raw == null) {
                return {
                    ok: true,
                    value: null,
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts) => {
            if (parsed == null) {
                return {
                    ok: true,
                    value: null,
                };
            }
            return schema.json(parsed, opts);
        },
        getType: () => SchemaType.NULLABLE,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function optional<Raw, Parsed>(
    schema: BaseSchema<Raw, Parsed>,
): Schema<Raw | null | undefined, Parsed | undefined> {
    const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
        parse: (raw, opts) => {
            if (raw == null) {
                return {
                    ok: true,
                    value: undefined,
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts) => {
            if (opts?.omitUndefined && parsed === undefined) {
                return {
                    ok: true,
                    value: undefined,
                };
            }
            if (parsed == null) {
                return {
                    ok: true,
                    value: null,
                };
            }
            return schema.json(parsed, opts);
        },
        getType: () => SchemaType.OPTIONAL,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function optionalNullable<Raw, Parsed>(
    schema: BaseSchema<Raw, Parsed>,
): Schema<Raw | null | undefined, Parsed | null | undefined> {
    const baseSchema: BaseSchema<Raw | null | undefined, Parsed | null | undefined> = {
        parse: (raw, opts) => {
            if (raw === undefined) {
                return {
                    ok: true,
                    value: undefined,
                };
            }
            if (raw === null) {
                return {
                    ok: true,
                    value: null,
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts) => {
            if (parsed === undefined) {
                return {
                    ok: true,
                    value: undefined,
                };
            }
            if (parsed === null) {
                return {
                    ok: true,
                    value: null,
                };
            }
            return schema.json(parsed, opts);
        },
        getType: () => SchemaType.OPTIONAL_NULLABLE,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function transform<Raw, Parsed, Transformed>(
    schema: BaseSchema<Raw, Parsed>,
    transformer: SchemaTransformer<Parsed, Transformed>,
): Schema<Raw, Transformed> {
    const baseSchema: BaseSchema<Raw, Transformed> = {
        parse: (raw, opts) => {
            const parsed = schema.parse(raw, opts);
            if (!parsed.ok) {
                return parsed;
            }
            return {
                ok: true,
                value: transformer.transform(parsed.value),
            };
        },
        json: (transformed, opts) => {
            const parsed = transformer.untransform(transformed);
            return schema.json(parsed, opts);
        },
        getType: () => schema.getType(),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

```


## /src/core/schemas/builders/schema-utils/index.ts
```typescript
export type { SchemaUtils } from "./getSchemaUtils.js";
export { getSchemaUtils, optional, transform } from "./getSchemaUtils.js";
export { JsonError } from "./JsonError.js";
export { ParseError } from "./ParseError.js";

```


## /src/core/schemas/builders/schema-utils/stringifyValidationErrors.ts
```typescript
import type { ValidationError } from "../../Schema.js";

export function stringifyValidationError(error: ValidationError): string {
    if (error.path.length === 0) {
        return error.message;
    }
    return `${error.path.join(" -> ")}: ${error.message}`;
}

```


## /src/core/schemas/builders/set/index.ts
```typescript
export { set } from "./set.js";

```


## /src/core/schemas/builders/set/set.ts
```typescript
import { type BaseSchema, type Schema, SchemaType } from "../../Schema.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
import { list } from "../list/index.js";
import { getSchemaUtils } from "../schema-utils/index.js";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
    const listSchema = list(schema);
    const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
        parse: (raw, opts) => {
            const parsedList = listSchema.parse(raw, opts);
            if (parsedList.ok) {
                return {
                    ok: true,
                    value: new Set(parsedList.value),
                };
            } else {
                return parsedList;
            }
        },
        json: (parsed, opts) => {
            if (!(parsed instanceof Set)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: opts?.breadcrumbsPrefix ?? [],
                            message: getErrorMessageForIncorrectType(parsed, "Set"),
                        },
                    ],
                };
            }
            const jsonList = listSchema.json([...parsed], opts);
            return jsonList;
        },
        getType: () => SchemaType.SET,
    };

    return {
        ...maybeSkipValidation(baseSchema),
        ...getSchemaUtils(baseSchema),
    };
}

```


## /src/core/schemas/builders/undiscriminated-union/index.ts
```typescript
export type {
    inferParsedUnidiscriminatedUnionSchema,
    inferRawUnidiscriminatedUnionSchema,
    UndiscriminatedUnionSchema,
} from "./types.js";
export { undiscriminatedUnion } from "./undiscriminatedUnion.js";

```


## /src/core/schemas/builders/undiscriminated-union/types.ts
```typescript
import type { inferParsed, inferRaw, Schema } from "../../Schema.js";

export type UndiscriminatedUnionSchema<Schemas extends [...Schema[]]> = Schema<
    inferRawUnidiscriminatedUnionSchema<Schemas>,
    inferParsedUnidiscriminatedUnionSchema<Schemas>
>;

export type inferRawUnidiscriminatedUnionSchema<Schemas extends [...Schema[]]> = inferRaw<Schemas[number]>;

export type inferParsedUnidiscriminatedUnionSchema<Schemas extends [...Schema[]]> = inferParsed<Schemas[number]>;

```


## /src/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.ts
```typescript
import {
    type BaseSchema,
    type MaybeValid,
    type Schema,
    type SchemaOptions,
    SchemaType,
    type ValidationError,
} from "../../Schema.js";
import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
import { getSchemaUtils } from "../schema-utils/index.js";
import type { inferParsedUnidiscriminatedUnionSchema, inferRawUnidiscriminatedUnionSchema } from "./types.js";

export function undiscriminatedUnion<Schemas extends [Schema<any, any>, ...Schema<any, any>[]]>(
    schemas: Schemas,
): Schema<inferRawUnidiscriminatedUnionSchema<Schemas>, inferParsedUnidiscriminatedUnionSchema<Schemas>> {
    const baseSchema: BaseSchema<
        inferRawUnidiscriminatedUnionSchema<Schemas>,
        inferParsedUnidiscriminatedUnionSchema<Schemas>
    > = {
        parse: (raw, opts) => {
            return validateAndTransformUndiscriminatedUnion<inferParsedUnidiscriminatedUnionSchema<Schemas>>(
                (schema, opts) => schema.parse(raw, opts),
                schemas,
                opts,
            );
        },
        json: (parsed, opts) => {
            return validateAndTransformUndiscriminatedUnion<inferRawUnidiscriminatedUnionSchema<Schemas>>(
                (schema, opts) => schema.json(parsed, opts),
                schemas,
                opts,
            );
        },
        getType: () => SchemaType.UNDISCRIMINATED_UNION,
    };

    return {
        ...maybeSkipValidation(baseSchema),
        ...getSchemaUtils(baseSchema),
    };
}

function validateAndTransformUndiscriminatedUnion<Transformed>(
    transform: (schema: Schema<any, any>, opts: SchemaOptions) => MaybeValid<Transformed>,
    schemas: Schema<any, any>[],
    opts: SchemaOptions | undefined,
): MaybeValid<Transformed> {
    const errors: ValidationError[] = [];
    for (const [index, schema] of schemas.entries()) {
        const transformed = transform(schema, { ...opts, skipValidation: false });
        if (transformed.ok) {
            return transformed;
        } else {
            for (const error of transformed.errors) {
                errors.push({
                    path: error.path,
                    message: `[Variant ${index}] ${error.message}`,
                });
            }
        }
    }

    return {
        ok: false,
        errors,
    };
}

```


## /src/core/schemas/builders/union/discriminant.ts
```typescript
export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
    parsedDiscriminant: ParsedDiscriminant,
    rawDiscriminant: RawDiscriminant,
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
    return {
        parsedDiscriminant,
        rawDiscriminant,
    };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
    parsedDiscriminant: ParsedDiscriminant;
    rawDiscriminant: RawDiscriminant;
}

```


## /src/core/schemas/builders/union/index.ts
```typescript
export type { Discriminant } from "./discriminant.js";
export { discriminant } from "./discriminant.js";
export type {
    inferParsedDiscriminant,
    inferParsedUnion,
    inferRawDiscriminant,
    inferRawUnion,
    UnionSubtypes,
} from "./types.js";
export { union } from "./union.js";

```


## /src/core/schemas/builders/union/types.ts
```typescript
import type { inferParsedObject, inferRawObject, ObjectSchema } from "../object/index.js";
import type { Discriminant } from "./discriminant.js";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
    [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<infer Raw, any>
      ? Raw
      : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<any, infer Parsed>
      ? Parsed
      : never;

```


## /src/core/schemas/builders/union/union.ts
```typescript
import { type BaseSchema, type MaybeValid, SchemaType } from "../../Schema.js";
import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
import { isPlainObject } from "../../utils/isPlainObject.js";
import { keys } from "../../utils/keys.js";
import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
import { enum_ } from "../enum/index.js";
import type { ObjectSchema } from "../object/index.js";
import { getObjectLikeUtils, type ObjectLikeSchema } from "../object-like/index.js";
import { getSchemaUtils } from "../schema-utils/index.js";
import type { Discriminant } from "./discriminant.js";
import type {
    inferParsedDiscriminant,
    inferParsedUnion,
    inferRawDiscriminant,
    inferRawUnion,
    UnionSubtypes,
} from "./types.js";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
    discriminant: D,
    union: U,
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
    const rawDiscriminant =
        typeof discriminant === "string" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
    const parsedDiscriminant =
        typeof discriminant === "string"
            ? discriminant
            : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

    const discriminantValueSchema = enum_(keys(union) as string[]);

    const baseSchema: BaseSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
        parse: (raw, opts) => {
            return transformAndValidateUnion({
                value: raw,
                discriminant: rawDiscriminant,
                transformedDiscriminant: parsedDiscriminant,
                transformDiscriminantValue: (discriminantValue) =>
                    discriminantValueSchema.parse(discriminantValue, {
                        allowUnrecognizedEnumValues: opts?.allowUnrecognizedUnionMembers,
                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), rawDiscriminant],
                    }),
                getAdditionalPropertiesSchema: (discriminantValue) => union[discriminantValue],
                allowUnrecognizedUnionMembers: opts?.allowUnrecognizedUnionMembers,
                transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema) =>
                    additionalPropertiesSchema.parse(additionalProperties, opts),
                breadcrumbsPrefix: opts?.breadcrumbsPrefix,
            });
        },
        json: (parsed, opts) => {
            return transformAndValidateUnion({
                value: parsed,
                discriminant: parsedDiscriminant,
                transformedDiscriminant: rawDiscriminant,
                transformDiscriminantValue: (discriminantValue) =>
                    discriminantValueSchema.json(discriminantValue, {
                        allowUnrecognizedEnumValues: opts?.allowUnrecognizedUnionMembers,
                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), parsedDiscriminant],
                    }),
                getAdditionalPropertiesSchema: (discriminantValue) => union[discriminantValue],
                allowUnrecognizedUnionMembers: opts?.allowUnrecognizedUnionMembers,
                transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema) =>
                    additionalPropertiesSchema.json(additionalProperties, opts),
                breadcrumbsPrefix: opts?.breadcrumbsPrefix,
            });
        },
        getType: () => SchemaType.UNION,
    };

    return {
        ...maybeSkipValidation(baseSchema),
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
    };
}

function transformAndValidateUnion<
    TransformedDiscriminant extends string,
    TransformedDiscriminantValue extends string,
    TransformedAdditionalProperties,
>({
    value,
    discriminant,
    transformedDiscriminant,
    transformDiscriminantValue,
    getAdditionalPropertiesSchema,
    allowUnrecognizedUnionMembers = false,
    transformAdditionalProperties,
    breadcrumbsPrefix = [],
}: {
    value: unknown;
    discriminant: string;
    transformedDiscriminant: TransformedDiscriminant;
    transformDiscriminantValue: (discriminantValue: unknown) => MaybeValid<TransformedDiscriminantValue>;
    getAdditionalPropertiesSchema: (discriminantValue: string) => ObjectSchema<any, any> | undefined;
    allowUnrecognizedUnionMembers: boolean | undefined;
    transformAdditionalProperties: (
        additionalProperties: unknown,
        additionalPropertiesSchema: ObjectSchema<any, any>,
    ) => MaybeValid<TransformedAdditionalProperties>;
    breadcrumbsPrefix: string[] | undefined;
}): MaybeValid<Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: getErrorMessageForIncorrectType(value, "object"),
                },
            ],
        };
    }

    const { [discriminant]: discriminantValue, ...additionalProperties } = value;

    if (discriminantValue == null) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: `Missing discriminant ("${discriminant}")`,
                },
            ],
        };
    }

    const transformedDiscriminantValue = transformDiscriminantValue(discriminantValue);
    if (!transformedDiscriminantValue.ok) {
        return {
            ok: false,
            errors: transformedDiscriminantValue.errors,
        };
    }

    const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);

    if (additionalPropertiesSchema == null) {
        if (allowUnrecognizedUnionMembers) {
            return {
                ok: true,
                value: {
                    [transformedDiscriminant]: transformedDiscriminantValue.value,
                    ...additionalProperties,
                } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [...breadcrumbsPrefix, discriminant],
                        message: "Unexpected discriminant value",
                    },
                ],
            };
        }
    }

    const transformedAdditionalProperties = transformAdditionalProperties(
        additionalProperties,
        additionalPropertiesSchema,
    );
    if (!transformedAdditionalProperties.ok) {
        return transformedAdditionalProperties;
    }

    return {
        ok: true,
        value: {
            [transformedDiscriminant]: discriminantValue,
            ...transformedAdditionalProperties.value,
        } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,
    };
}

```


## /src/core/schemas/index.ts
```typescript
export * from "./builders/index.js";
export type { inferParsed, inferRaw, Schema, SchemaOptions } from "./Schema.js";

```


## /src/core/schemas/utils/MaybePromise.ts
```typescript
export type MaybePromise<T> = T | Promise<T>;

```


## /src/core/schemas/utils/addQuestionMarksToNullableProperties.ts
```typescript
export type addQuestionMarksToNullableProperties<T> = {
    [K in OptionalKeys<T>]?: T[K];
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
    [K in keyof T]-?: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = Exclude<keyof T, OptionalKeys<T>>;

```


## /src/core/schemas/utils/createIdentitySchemaCreator.ts
```typescript
import { getSchemaUtils } from "../builders/schema-utils/index.js";
import type { BaseSchema, MaybeValid, Schema, SchemaOptions, SchemaType } from "../Schema.js";
import { maybeSkipValidation } from "./maybeSkipValidation.js";

export function createIdentitySchemaCreator<T>(
    schemaType: SchemaType,
    validate: (value: unknown, opts?: SchemaOptions) => MaybeValid<T>,
): () => Schema<T, T> {
    return () => {
        const baseSchema: BaseSchema<T, T> = {
            parse: validate,
            json: validate,
            getType: () => schemaType,
        };

        return {
            ...maybeSkipValidation(baseSchema),
            ...getSchemaUtils(baseSchema),
        };
    };
}

```


## /src/core/schemas/utils/entries.ts
```typescript
export function entries<T extends object>(object: T): [keyof T, T[keyof T]][] {
    return Object.entries(object) as [keyof T, T[keyof T]][];
}

```


## /src/core/schemas/utils/filterObject.ts
```typescript
export function filterObject<T extends object, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
    const keysToIncludeSet = new Set(keysToInclude);
    return Object.entries(obj).reduce(
        (acc, [key, value]) => {
            if (keysToIncludeSet.has(key as K)) {
                acc[key as K] = value as T[K];
            }
            return acc;
            // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        },
        {} as Pick<T, K>,
    );
}

```


## /src/core/schemas/utils/getErrorMessageForIncorrectType.ts
```typescript
export function getErrorMessageForIncorrectType(value: unknown, expectedType: string): string {
    return `Expected ${expectedType}. Received ${getTypeAsString(value)}.`;
}

function getTypeAsString(value: unknown): string {
    if (Array.isArray(value)) {
        return "list";
    }
    if (value === null) {
        return "null";
    }
    if (value instanceof BigInt) {
        return "BigInt";
    }
    switch (typeof value) {
        case "string":
            return `"${value}"`;
        case "bigint":
        case "number":
        case "boolean":
        case "undefined":
            return `${value}`;
    }
    return typeof value;
}

```


## /src/core/schemas/utils/isPlainObject.ts
```typescript
// borrowed from https://github.com/lodash/lodash/blob/master/isPlainObject.js
export function isPlainObject(value: unknown): value is Record<string, unknown> {
    if (typeof value !== "object" || value === null) {
        return false;
    }

    if (Object.getPrototypeOf(value) === null) {
        return true;
    }

    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }

    return Object.getPrototypeOf(value) === proto;
}

```


## /src/core/schemas/utils/keys.ts
```typescript
export function keys<T extends object>(object: T): (keyof T)[] {
    return Object.keys(object) as (keyof T)[];
}

```


## /src/core/schemas/utils/maybeSkipValidation.ts
```typescript
import type { BaseSchema, MaybeValid, SchemaOptions } from "../Schema.js";

export function maybeSkipValidation<S extends BaseSchema<Raw, Parsed>, Raw, Parsed>(schema: S): S {
    return {
        ...schema,
        json: transformAndMaybeSkipValidation(schema.json),
        parse: transformAndMaybeSkipValidation(schema.parse),
    };
}

function transformAndMaybeSkipValidation<T>(
    transform: (value: unknown, opts?: SchemaOptions) => MaybeValid<T>,
): (value: unknown, opts?: SchemaOptions) => MaybeValid<T> {
    return (value, opts): MaybeValid<T> => {
        const transformed = transform(value, opts);
        const { skipValidation = false } = opts ?? {};
        if (!transformed.ok && skipValidation) {
            // biome-ignore lint/suspicious/noConsole: allow console
            console.warn(
                [
                    "Failed to validate.",
                    ...transformed.errors.map(
                        (error) =>
                            "  - " +
                            (error.path.length > 0 ? `${error.path.join(".")}: ${error.message}` : error.message),
                    ),
                ].join("\n"),
            );

            return {
                ok: true,
                value: value as T,
            };
        } else {
            return transformed;
        }
    };
}

```


## /src/core/schemas/utils/partition.ts
```typescript
export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
    const trueItems: T[] = [],
        falseItems: T[] = [];
    for (const item of items) {
        if (predicate(item)) {
            trueItems.push(item);
        } else {
            falseItems.push(item);
        }
    }
    return [trueItems, falseItems];
}

```


## /src/core/stream/Stream.ts
```typescript
import { RUNTIME } from "../runtime/index.js";

export declare namespace Stream {
    interface Args {
        /**
         * The HTTP response stream to read from.
         */

        stream: ReadableStream;

        /**
         * The event shape to use for parsing the stream data.
         */
        eventShape: JsonEvent | SseEvent;
        /**
         * An abort signal to stop the stream.
         */
        signal?: AbortSignal;
    }

    interface JsonEvent {
        type: "json";
        messageTerminator: string;
    }

    interface SseEvent {
        type: "sse";
        streamTerminator?: string;
    }
}

const DATA_PREFIX = "data:";

export class Stream<T> implements AsyncIterable<T> {
    private stream: ReadableStream;

    private parse: (val: unknown) => Promise<T>;
    /**
     * The prefix to use for each message. For example,
     * for SSE, the prefix is "data: ".
     */
    private prefix: string | undefined;
    private messageTerminator: string;
    private streamTerminator: string | undefined;
    private controller: AbortController = new AbortController();
    private decoder: TextDecoder | undefined;

    constructor({ stream, parse, eventShape, signal }: Stream.Args & { parse: (val: unknown) => Promise<T> }) {
        this.stream = stream;
        this.parse = parse;
        if (eventShape.type === "sse") {
            this.prefix = DATA_PREFIX;
            this.messageTerminator = "\n";
            this.streamTerminator = eventShape.streamTerminator;
        } else {
            this.messageTerminator = eventShape.messageTerminator;
        }
        signal?.addEventListener("abort", () => this.controller.abort());

        // Initialize shared TextDecoder
        if (typeof TextDecoder !== "undefined") {
            this.decoder = new TextDecoder("utf-8");
        }
    }

    private async *iterMessages(): AsyncGenerator<T, void> {
        this.controller.signal;
        const stream = readableStreamAsyncIterable<any>(this.stream);
        let buf = "";
        let prefixSeen = false;
        for await (const chunk of stream) {
            buf += this.decodeChunk(chunk);

            let terminatorIndex: number;
            while ((terminatorIndex = buf.indexOf(this.messageTerminator)) >= 0) {
                let line = buf.slice(0, terminatorIndex);
                buf = buf.slice(terminatorIndex + this.messageTerminator.length);

                if (!line.trim()) {
                    continue;
                }

                if (!prefixSeen && this.prefix != null) {
                    const prefixIndex = line.indexOf(this.prefix);
                    if (prefixIndex === -1) {
                        continue;
                    }
                    prefixSeen = true;
                    line = line.slice(prefixIndex + this.prefix.length);
                }

                if (this.streamTerminator != null && line.includes(this.streamTerminator)) {
                    return;
                }
                const message = await this.parse(JSON.parse(line));
                yield message;
                prefixSeen = false;
            }
        }
    }

    async *[Symbol.asyncIterator](): AsyncIterator<T, void, unknown> {
        for await (const message of this.iterMessages()) {
            yield message;
        }
    }

    private decodeChunk(chunk: any): string {
        let decoded = "";
        // If TextDecoder is available, use the streaming decoder instance
        if (this.decoder != null) {
            decoded += this.decoder.decode(chunk, { stream: true });
        }
        // Buffer is present in Node.js environment
        else if (RUNTIME.type === "node" && typeof chunk !== "undefined") {
            decoded += Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
        }
        return decoded;
    }
}

/**
 * Browser polyfill for ReadableStream
 */
// biome-ignore lint/suspicious/noExplicitAny: allow explicit any
export function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {
    if (stream[Symbol.asyncIterator]) {
        return stream;
    }

    const reader = stream.getReader();
    return {
        async next() {
            try {
                const result = await reader.read();
                if (result?.done) {
                    reader.releaseLock();
                } // release lock when stream becomes closed
                return result;
            } catch (e) {
                reader.releaseLock(); // release lock when stream becomes errored
                throw e;
            }
        },
        async return() {
            const cancelPromise = reader.cancel();
            reader.releaseLock();
            await cancelPromise;
            return { done: true, value: undefined };
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}

```


## /src/core/stream/index.ts
```typescript
export { Stream } from "./Stream.js";

```


## /src/core/url/encodePathParam.ts
```typescript
export function encodePathParam(param: unknown): string {
    if (param === null) {
        return "null";
    }
    const typeofParam = typeof param;
    switch (typeofParam) {
        case "undefined":
            return "undefined";
        case "string":
        case "number":
        case "boolean":
            break;
        default:
            param = String(param);
            break;
    }
    return encodeURIComponent(param as string | number | boolean);
}

```


## /src/core/url/index.ts
```typescript
export { encodePathParam } from "./encodePathParam.js";
export { join } from "./join.js";
export { toQueryString } from "./qs.js";

```


## /src/core/url/join.ts
```typescript
export function join(base: string, ...segments: string[]): string {
    if (!base) {
        return "";
    }

    if (segments.length === 0) {
        return base;
    }

    if (base.includes("://")) {
        let url: URL;
        try {
            url = new URL(base);
        } catch {
            return joinPath(base, ...segments);
        }

        const lastSegment = segments[segments.length - 1];
        const shouldPreserveTrailingSlash = lastSegment?.endsWith("/");

        for (const segment of segments) {
            const cleanSegment = trimSlashes(segment);
            if (cleanSegment) {
                url.pathname = joinPathSegments(url.pathname, cleanSegment);
            }
        }

        if (shouldPreserveTrailingSlash && !url.pathname.endsWith("/")) {
            url.pathname += "/";
        }

        return url.toString();
    }

    return joinPath(base, ...segments);
}

function joinPath(base: string, ...segments: string[]): string {
    if (segments.length === 0) {
        return base;
    }

    let result = base;

    const lastSegment = segments[segments.length - 1];
    const shouldPreserveTrailingSlash = lastSegment?.endsWith("/");

    for (const segment of segments) {
        const cleanSegment = trimSlashes(segment);
        if (cleanSegment) {
            result = joinPathSegments(result, cleanSegment);
        }
    }

    if (shouldPreserveTrailingSlash && !result.endsWith("/")) {
        result += "/";
    }

    return result;
}

function joinPathSegments(left: string, right: string): string {
    if (left.endsWith("/")) {
        return left + right;
    }
    return `${left}/${right}`;
}

function trimSlashes(str: string): string {
    if (!str) return str;

    let start = 0;
    let end = str.length;

    if (str.startsWith("/")) start = 1;
    if (str.endsWith("/")) end = str.length - 1;

    return start === 0 && end === str.length ? str : str.slice(start, end);
}

```


## /src/core/url/qs.ts
```typescript
interface QueryStringOptions {
    arrayFormat?: "indices" | "repeat";
    encode?: boolean;
}

const defaultQsOptions: Required<QueryStringOptions> = {
    arrayFormat: "indices",
    encode: true,
} as const;

function encodeValue(value: unknown, shouldEncode: boolean): string {
    if (value === undefined) {
        return "";
    }
    if (value === null) {
        return "";
    }
    const stringValue = String(value);
    return shouldEncode ? encodeURIComponent(stringValue) : stringValue;
}

function stringifyObject(obj: Record<string, unknown>, prefix = "", options: Required<QueryStringOptions>): string[] {
    const parts: string[] = [];

    for (const [key, value] of Object.entries(obj)) {
        const fullKey = prefix ? `${prefix}[${key}]` : key;

        if (value === undefined) {
            continue;
        }

        if (Array.isArray(value)) {
            if (value.length === 0) {
                continue;
            }
            for (let i = 0; i < value.length; i++) {
                const item = value[i];
                if (item === undefined) {
                    continue;
                }
                if (typeof item === "object" && !Array.isArray(item) && item !== null) {
                    const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i}]` : fullKey;
                    parts.push(...stringifyObject(item as Record<string, unknown>, arrayKey, options));
                } else {
                    const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i}]` : fullKey;
                    const encodedKey = options.encode ? encodeURIComponent(arrayKey) : arrayKey;
                    parts.push(`${encodedKey}=${encodeValue(item, options.encode)}`);
                }
            }
        } else if (typeof value === "object" && value !== null) {
            if (Object.keys(value as Record<string, unknown>).length === 0) {
                continue;
            }
            parts.push(...stringifyObject(value as Record<string, unknown>, fullKey, options));
        } else {
            const encodedKey = options.encode ? encodeURIComponent(fullKey) : fullKey;
            parts.push(`${encodedKey}=${encodeValue(value, options.encode)}`);
        }
    }

    return parts;
}

export function toQueryString(obj: unknown, options?: QueryStringOptions): string {
    if (obj == null || typeof obj !== "object") {
        return "";
    }

    const parts = stringifyObject(obj as Record<string, unknown>, "", {
        ...defaultQsOptions,
        ...options,
    });
    return parts.join("&");
}

```


## /src/core/utils/index.ts
```typescript
export { setObjectProperty } from "./setObjectProperty.js";

```


## /src/core/utils/setObjectProperty.ts
```typescript
/**
 * Sets the value at path of object. If a portion of path doesn’t exist it’s created. This is
 * inspired by Lodash's set function, but is simplified to accommodate our use case.
 * For more details, see https://lodash.com/docs/4.17.15#set.
 *
 * @param object The object to modify.
 * @param path The path of the property to set.
 * @param value The value to set.
 * @return Returns object.
 */
export function setObjectProperty<T extends object>(object: T, path: string, value: any): T {
    if (object == null) {
        return object;
    }

    const keys: string[] = path.split(".");
    if (keys.length === 0) {
        // Invalid path; do nothing.
        return object;
    }

    let current: Record<string, any> = object;
    for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        if (key == null) {
            // Unreachable.
            continue;
        }
        if (!current[key] || typeof current[key] !== "object") {
            current[key] = {};
        }
        current = current[key] as Record<string, any>;
    }

    const lastKey = keys[keys.length - 1];
    if (lastKey == null) {
        // Unreachable.
        return object;
    }

    current[lastKey] = value;
    return object;
}

```


## /src/core/websocket/events.ts
```typescript
export class Event {
    public target: any;
    public type: string;
    constructor(type: string, target: any) {
        this.target = target;
        this.type = type;
    }
}

export class ErrorEvent extends Event {
    public message: string;
    public error: Error;
    constructor(error: Error, target: any) {
        super("error", target);
        this.message = error.message;
        this.error = error;
    }
}

export class CloseEvent extends Event {
    public code: number;
    public reason: string;
    public wasClean = true;
    constructor(code = 1000, reason = "", target: any) {
        super("close", target);
        this.code = code;
        this.reason = reason;
    }
}
export interface WebSocketEventMap {
    close: CloseEvent;
    error: ErrorEvent;
    message: MessageEvent;
    open: Event;
}

export interface WebSocketEventListenerMap {
    close: (event: CloseEvent) => void | { handleEvent: (event: CloseEvent) => void };
    error: (event: ErrorEvent) => void | { handleEvent: (event: ErrorEvent) => void };
    message: (event: MessageEvent) => void | { handleEvent: (event: MessageEvent) => void };
    open: (event: Event) => void | { handleEvent: (event: Event) => void };
}

```


## /src/core/websocket/exports.ts
```typescript
import type * as events from "./events.js";
import type * as ws from "./ws.js";

export type ReconnectingWebSocket = typeof ws.ReconnectingWebSocket;
export declare namespace ReconnectingWebSocket {
    export type Event = events.Event;
    export type CloseEvent = events.CloseEvent;
    export type ErrorEvent = events.ErrorEvent;
}

```


## /src/core/websocket/index.ts
```typescript
export * from "./ws.js";

```


## /src/core/websocket/ws.ts
```typescript
import { WebSocket as NodeWebSocket } from "ws";

import { RUNTIME } from "../runtime/index.js";
import { toQueryString } from "../url/qs.js";
import * as Events from "./events.js";
import { SDK_VERSION } from "../../version.js";

const getGlobalWebSocket = (): WebSocket | undefined => {
    if (typeof WebSocket !== "undefined") {
        // @ts-ignore
        return WebSocket;
    } else if (RUNTIME.type === "node") {
        return NodeWebSocket as unknown as WebSocket;
    }
    return undefined;
};

/**
 * Returns true if given argument looks like a WebSocket class
 */
const isWebSocket = (w: any) => typeof w !== "undefined" && !!w && w.CLOSING === 2;

export type Event = Events.Event;
export type ErrorEvent = Events.ErrorEvent;
export type CloseEvent = Events.CloseEvent;

export declare namespace ReconnectingWebSocket {
    export interface Args {
        url: string;
        protocols?: string | string[];
        options?: ReconnectingWebSocket.Options;
        headers?: Record<string, unknown>;
        queryParameters?: Record<string, string | string[] | object | object[] | null | undefined>;
    }

    export type Options = {
        WebSocket?: any;
        maxReconnectionDelay?: number;
        minReconnectionDelay?: number;
        reconnectionDelayGrowFactor?: number;
        minUptime?: number;
        connectionTimeout?: number;
        maxRetries?: number;
        maxEnqueuedMessages?: number;
        startClosed?: boolean;
        debug?: boolean;
    };

    export type UrlProvider = string | (() => string) | (() => Promise<string>);

    export type Message = string | ArrayBuffer | Blob | ArrayBufferView;

    export type ListenersMap = {
        error: Array<Events.WebSocketEventListenerMap["error"]>;
        message: Array<Events.WebSocketEventListenerMap["message"]>;
        open: Array<Events.WebSocketEventListenerMap["open"]>;
        close: Array<Events.WebSocketEventListenerMap["close"]>;
    };
}

const DEFAULT_OPTIONS = {
    maxReconnectionDelay: 10000,
    minReconnectionDelay: 1000 + Math.random() * 4000,
    minUptime: 5000,
    reconnectionDelayGrowFactor: 1.3,
    connectionTimeout: 4000,
    maxRetries: Infinity,
    maxEnqueuedMessages: Infinity,
    startClosed: false,
    debug: false,
};

function addApiKeyFromHeader({
    headers,
    queryParameters,
}: {
    headers: Record<string, any> | undefined;
    queryParameters: Record<string, any> | undefined;
}) {
    const apiKeyValue = Object.entries(headers ?? {}).find(([k]) => k.toLowerCase() === "x-hume-api-key")?.[1];
    if (apiKeyValue && !queryParameters?.["api_key"]) {
        return { ...queryParameters, api_key: apiKeyValue };
    }
    return queryParameters;
}

function addAccessTokenFromHeader({
    headers,
    queryParameters,
}: {
    headers: Record<string, any> | undefined;
    queryParameters: Record<string, any> | undefined;
}) {
    const authHeaderValue = headers?.["Authorization"] || headers?.["authorization"];
    if (!authHeaderValue) {
        return queryParameters;
    }
    if (!authHeaderValue.startsWith("Bearer ")) {
        return queryParameters;
    }
    if (queryParameters?.["access_token"]) {
        return queryParameters;
    }
    const token = authHeaderValue.substring("Bearer ".length);
    return { ...queryParameters, access_token: token };
}

function addSdkTracking(queryParameters: Record<string, any> | undefined) {
    return {
        ...queryParameters,
        fernSdkLanguage: "JavaScript",
        fernSdkVersion: SDK_VERSION,
    };
}

export class ReconnectingWebSocket {
    private _ws?: WebSocket;
    private _listeners: ReconnectingWebSocket.ListenersMap = {
        error: [],
        message: [],
        open: [],
        close: [],
    };
    private _retryCount = -1;
    private _uptimeTimeout: any;
    private _connectTimeout: any;
    private _shouldReconnect = true;
    private _connectLock = false;
    private _binaryType: BinaryType = "blob";
    private _closeCalled = false;
    private _messageQueue: ReconnectingWebSocket.Message[] = [];

    private readonly _url: ReconnectingWebSocket.UrlProvider;
    private readonly _protocols?: string | string[];
    private readonly _options: ReconnectingWebSocket.Options;
    private readonly _headers?: Record<string, any>;
    private readonly _queryParameters?: Record<string, any>;

    constructor({ url, protocols, options, headers, queryParameters }: ReconnectingWebSocket.Args) {
        this._url = url;
        this._protocols = protocols;
        this._options = options ?? DEFAULT_OPTIONS;
        this._headers = headers;
        this._queryParameters = addSdkTracking(
            addAccessTokenFromHeader({
                headers,
                queryParameters: addApiKeyFromHeader({
                    headers,
                    queryParameters,
                }),
            }),
        );

        if (this._options.startClosed) {
            this._shouldReconnect = false;
        }
        this._connect();
    }

    static get CONNECTING() {
        return 0;
    }
    static get OPEN() {
        return 1;
    }
    static get CLOSING() {
        return 2;
    }
    static get CLOSED() {
        return 3;
    }

    get CONNECTING(): number {
        return ReconnectingWebSocket.CONNECTING;
    }
    get OPEN(): number {
        return ReconnectingWebSocket.OPEN;
    }
    get CLOSING(): number {
        return ReconnectingWebSocket.CLOSING;
    }
    get CLOSED(): number {
        return ReconnectingWebSocket.CLOSED;
    }

    get binaryType() {
        return this._ws ? this._ws.binaryType : this._binaryType;
    }

    set binaryType(value: BinaryType) {
        this._binaryType = value;
        if (this._ws) {
            this._ws.binaryType = value;
        }
    }

    /**
     * Returns the number or connection retries
     */
    get retryCount(): number {
        return Math.max(this._retryCount, 0);
    }

    /**
     * The number of bytes of data that have been queued using calls to send() but not yet
     * transmitted to the network. This value resets to zero once all queued data has been sent.
     * This value does not reset to zero when the connection is closed; if you keep calling send(),
     * this will continue to climb. Read only
     */
    get bufferedAmount(): number {
        const bytes = this._messageQueue.reduce((acc, message) => {
            if (typeof message === "string") {
                acc += message.length; // not byte size
            } else if (message instanceof Blob) {
                acc += message.size;
            } else {
                acc += message.byteLength;
            }
            return acc;
        }, 0);
        return bytes + (this._ws ? this._ws.bufferedAmount : 0);
    }

    /**
     * The extensions selected by the server. This is currently only the empty string or a list of
     * extensions as negotiated by the connection
     */
    get extensions(): string {
        return this._ws ? this._ws.extensions : "";
    }

    /**
     * A string indicating the name of the sub-protocol the server selected;
     * this will be one of the strings specified in the protocols parameter when creating the
     * WebSocket object
     */
    get protocol(): string {
        return this._ws ? this._ws.protocol : "";
    }

    /**
     * The current state of the connection; this is one of the Ready state constants
     */
    get readyState(): number {
        if (this._ws) {
            return this._ws.readyState;
        }
        return this._options.startClosed ? ReconnectingWebSocket.CLOSED : ReconnectingWebSocket.CONNECTING;
    }

    /**
     * The URL as resolved by the constructor
     */
    get url(): string {
        return this._ws ? this._ws.url : "";
    }

    /**
     * An event listener to be called when the WebSocket connection's readyState changes to CLOSED
     */
    public onclose: ((event: Events.CloseEvent) => void) | null = null;

    /**
     * An event listener to be called when an error occurs
     */
    public onerror: ((event: Events.ErrorEvent) => void) | null = null;

    /**
     * An event listener to be called when a message is received from the server
     */
    public onmessage: ((event: MessageEvent) => void) | null = null;

    /**
     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
     * this indicates that the connection is ready to send and receive data
     */
    public onopen: ((event: Event) => void) | null = null;

    /**
     * Closes the WebSocket connection or connection attempt, if any. If the connection is already
     * CLOSED, this method does nothing
     */
    public close(code = 1000, reason?: string): void {
        this._closeCalled = true;
        this._shouldReconnect = false;
        this._clearTimeouts();
        if (!this._ws) {
            this._debug("close enqueued: no ws instance");
            return;
        }
        if (this._ws.readyState === this.CLOSED) {
            this._debug("close: already closed");
            return;
        }
        this._ws.close(code, reason);
    }

    /**
     * Closes the WebSocket connection or connection attempt and connects again.
     * Resets retry counter;
     */
    public reconnect(code?: number, reason?: string): void {
        this._shouldReconnect = true;
        this._closeCalled = false;
        this._retryCount = -1;
        if (!this._ws || this._ws.readyState === this.CLOSED) {
            this._connect();
        } else {
            this._disconnect(code, reason);
            this._connect();
        }
    }

    /**
     * Enqueue specified data to be transmitted to the server over the WebSocket connection
     */
    public send(data: ReconnectingWebSocket.Message): void {
        if (this._ws && this._ws.readyState === this.OPEN) {
            this._debug("send", data);
            this._ws.send(data);
        } else {
            const { maxEnqueuedMessages = DEFAULT_OPTIONS.maxEnqueuedMessages } = this._options;
            if (this._messageQueue.length < maxEnqueuedMessages) {
                this._debug("enqueue", data);
                this._messageQueue.push(data);
            }
        }
    }

    /**
     * Register an event handler of a specific event type
     */
    public addEventListener<T extends keyof Events.WebSocketEventListenerMap>(
        type: T,
        listener: Events.WebSocketEventListenerMap[T],
    ): void {
        if (this._listeners[type]) {
            // @ts-ignore
            this._listeners[type].push(listener);
        }
    }

    public dispatchEvent(event: Event) {
        const listeners = this._listeners[event.type as keyof Events.WebSocketEventListenerMap];
        if (listeners) {
            for (const listener of listeners) {
                this._callEventListener(event, listener);
            }
        }
        return true;
    }

    /**
     * Removes an event listener
     */
    public removeEventListener<T extends keyof Events.WebSocketEventListenerMap>(
        type: T,
        listener: Events.WebSocketEventListenerMap[T],
    ): void {
        if (this._listeners[type]) {
            // @ts-ignore
            this._listeners[type] = this._listeners[type].filter(
                // @ts-ignore
                (l) => l !== listener,
            );
        }
    }

    private _debug(...args: any[]) {
        if (this._options.debug) {
            // not using spread because compiled version uses Symbols
            // tslint:disable-next-line
            // biome-ignore lint/suspicious/noConsole: allow console
            console.log.apply(console, ["RWS>", ...args]);
        }
    }

    private _getNextDelay() {
        const {
            reconnectionDelayGrowFactor = DEFAULT_OPTIONS.reconnectionDelayGrowFactor,
            minReconnectionDelay = DEFAULT_OPTIONS.minReconnectionDelay,
            maxReconnectionDelay = DEFAULT_OPTIONS.maxReconnectionDelay,
        } = this._options;
        let delay = 0;
        if (this._retryCount > 0) {
            delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
            if (delay > maxReconnectionDelay) {
                delay = maxReconnectionDelay;
            }
        }
        this._debug("next delay", delay);
        return delay;
    }

    private _wait(): Promise<void> {
        return new Promise((resolve) => {
            setTimeout(resolve, this._getNextDelay());
        });
    }

    private _getNextUrl(urlProvider: ReconnectingWebSocket.UrlProvider): Promise<string> {
        if (typeof urlProvider === "string") {
            return Promise.resolve(urlProvider);
        }
        if (typeof urlProvider === "function") {
            const url = urlProvider();
            if (typeof url === "string") {
                return Promise.resolve(url);
            }
            // @ts-ignore redundant check
            if (url.then) {
                return url;
            }
        }
        throw Error("Invalid URL");
    }

    private _connect() {
        if (this._connectLock || !this._shouldReconnect) {
            return;
        }
        this._connectLock = true;

        const {
            maxRetries = DEFAULT_OPTIONS.maxRetries,
            connectionTimeout = DEFAULT_OPTIONS.connectionTimeout,
            WebSocket = getGlobalWebSocket(),
        } = this._options;

        if (this._retryCount >= maxRetries) {
            this._debug("max retries reached", this._retryCount, ">=", maxRetries);
            return;
        }

        this._retryCount++;

        this._debug("connect", this._retryCount);
        this._removeListeners();
        if (!isWebSocket(WebSocket)) {
            throw Error("No valid WebSocket class provided");
        }
        this._wait()
            .then(() => this._getNextUrl(this._url))
            .then((url) => {
                if (this._closeCalled) {
                    return;
                }
                const options: Record<string, unknown> = {};
                if (this._headers) {
                    options.headers = this._headers;
                }
                if (this._queryParameters && Object.keys(this._queryParameters).length > 0) {
                    const queryString = toQueryString(this._queryParameters, { arrayFormat: "repeat" });
                    if (queryString) {
                        url = `${url}?${queryString}`;
                    }
                }
                this._ws = new WebSocket(url, this._protocols, options);
                this._ws!.binaryType = this._binaryType;
                this._connectLock = false;
                this._addListeners();

                this._connectTimeout = setTimeout(() => this._handleTimeout(), connectionTimeout);
            });
    }

    private _handleTimeout() {
        this._debug("timeout event");
        this._handleError(new Events.ErrorEvent(Error("TIMEOUT"), this));
    }

    private _disconnect(code = 1000, reason?: string) {
        this._clearTimeouts();
        if (!this._ws) {
            return;
        }
        this._removeListeners();
        try {
            this._ws.close(code, reason);
            this._handleClose(new Events.CloseEvent(code, reason, this));
        } catch (error) {
            // ignore
        }
    }

    private _acceptOpen() {
        this._debug("accept open");
        this._retryCount = 0;
    }

    private _callEventListener<T extends keyof Events.WebSocketEventListenerMap>(
        event: Events.WebSocketEventMap[T],
        listener: Events.WebSocketEventListenerMap[T],
    ) {
        if ("handleEvent" in listener) {
            // @ts-ignore
            listener.handleEvent(event);
        } else {
            // @ts-ignore
            listener(event);
        }
    }

    private _handleOpen = (event: Event) => {
        this._debug("open event");
        const { minUptime = DEFAULT_OPTIONS.minUptime } = this._options;

        clearTimeout(this._connectTimeout);
        this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);

        this._ws!.binaryType = this._binaryType;

        // send enqueued messages (messages sent before websocket open event)
        this._messageQueue.forEach((message) => this._ws?.send(message));
        this._messageQueue = [];

        if (this.onopen) {
            this.onopen(event);
        }
        this._listeners.open.forEach((listener) => this._callEventListener(event, listener));
    };

    private _handleMessage = (event: MessageEvent) => {
        this._debug("message event");

        if (this.onmessage) {
            this.onmessage(event);
        }
        this._listeners.message.forEach((listener) => this._callEventListener(event, listener));
    };

    private _handleError = (event: Events.ErrorEvent) => {
        this._debug("error event", event.message);
        this._disconnect(undefined, event.message === "TIMEOUT" ? "timeout" : undefined);

        if (this.onerror) {
            this.onerror(event);
        }
        this._debug("exec error listeners");
        this._listeners.error.forEach((listener) => this._callEventListener(event, listener));

        this._connect();
    };

    private _handleClose = (event: Events.CloseEvent) => {
        this._debug("close event");
        this._clearTimeouts();

        if (event.code === 1000) {
            this._shouldReconnect = false;
        }

        if (this._shouldReconnect) {
            this._connect();
        }

        if (this.onclose) {
            this.onclose(event);
        }
        this._listeners.close.forEach((listener) => this._callEventListener(event, listener));
    };

    private _removeListeners() {
        if (!this._ws) {
            return;
        }
        this._debug("removeListeners");
        this._ws.removeEventListener("open", this._handleOpen);
        this._ws.removeEventListener("close", this._handleClose);
        this._ws.removeEventListener("message", this._handleMessage);
        // @ts-ignore
        this._ws.removeEventListener("error", this._handleError);
    }

    private _addListeners() {
        if (!this._ws) {
            return;
        }
        this._debug("addListeners");
        this._ws.addEventListener("open", this._handleOpen);
        this._ws.addEventListener("close", this._handleClose);
        this._ws.addEventListener("message", this._handleMessage);
        // @ts-ignore
        this._ws.addEventListener("error", this._handleError);
    }

    private _clearTimeouts() {
        clearTimeout(this._connectTimeout);
        clearTimeout(this._uptimeTimeout);
    }
}

```


## /src/core/websocket/ws.ts.diff
```diff
diff --git a/src/core/websocket/ws.ts b/src/core/websocket/ws.ts
index 9a16477..6089558 100644
--- a/src/core/websocket/ws.ts
+++ b/src/core/websocket/ws.ts
@@ -3,7 +3,6 @@ import { WebSocket as NodeWebSocket } from "ws";
 import { RUNTIME } from "../runtime/index.js";
 import { toQueryString } from "../url/qs.js";
 import * as Events from "./events.js";
-import { SDK_VERSION } from "../../version.js";
 
 const getGlobalWebSocket = (): WebSocket | undefined => {
     if (typeof WebSocket !== "undefined") {
@@ -30,7 +29,7 @@ export declare namespace ReconnectingWebSocket {
         protocols?: string | string[];
         options?: ReconnectingWebSocket.Options;
         headers?: Record<string, unknown>;
-        queryParameters?: Record<string, string | string[] | object | object[] | null | undefined>;
+        queryParameters?: Record<string, unknown>;
     }
 
     export type Options = {
@@ -70,49 +69,6 @@ const DEFAULT_OPTIONS = {
     debug: false,
 };
 
-function addApiKeyFromHeader({
-    headers,
-    queryParameters,
-}: {
-    headers: Record<string, any> | undefined;
-    queryParameters: Record<string, any> | undefined;
-}) {
-    const apiKeyValue = Object.entries(headers ?? {}).find(([k]) => k.toLowerCase() === "x-hume-api-key")?.[1];
-    if (apiKeyValue && !queryParameters?.["api_key"]) {
-        return { ...queryParameters, api_key: apiKeyValue };
-    }
-    return queryParameters;
-}
-
-function addAccessTokenFromHeader({
-    headers,
-    queryParameters,
-}: {
-    headers: Record<string, any> | undefined;
-    queryParameters: Record<string, any> | undefined;
-}) {
-    const authHeaderValue = headers?.["Authorization"] || headers?.["authorization"];
-    if (!authHeaderValue) {
-        return queryParameters;
-    }
-    if (!authHeaderValue.startsWith("Bearer ")) {
-        return queryParameters;
-    }
-    if (queryParameters?.["access_token"]) {
-        return queryParameters;
-    }
-    const token = authHeaderValue.substring("Bearer ".length);
-    return { ...queryParameters, access_token: token };
-}
-
-function addSdkTracking(queryParameters: Record<string, any> | undefined) {
-    return {
-        ...queryParameters,
-        fernSdkLanguage: "JavaScript",
-        fernSdkVersion: SDK_VERSION,
-    };
-}
-
 export class ReconnectingWebSocket {
     private _ws?: WebSocket;
     private _listeners: ReconnectingWebSocket.ListenersMap = {
@@ -141,47 +97,22 @@ export class ReconnectingWebSocket {
         this._protocols = protocols;
         this._options = options ?? DEFAULT_OPTIONS;
         this._headers = headers;
-        this._queryParameters = addSdkTracking(
-            addAccessTokenFromHeader({
-                headers,
-                queryParameters: addApiKeyFromHeader({
-                    headers,
-                    queryParameters,
-                }),
-            }),
-        );
-
+        this._queryParameters = queryParameters;
         if (this._options.startClosed) {
             this._shouldReconnect = false;
         }
         this._connect();
     }
 
-    static get CONNECTING() {
-        return 0;
-    }
-    static get OPEN() {
-        return 1;
-    }
-    static get CLOSING() {
-        return 2;
-    }
-    static get CLOSED() {
-        return 3;
-    }
+    public static readonly CONNECTING = 0;
+    public static readonly OPEN = 1;
+    public static readonly CLOSING = 2;
+    public static readonly CLOSED = 3;
 
-    get CONNECTING(): number {
-        return ReconnectingWebSocket.CONNECTING;
-    }
-    get OPEN(): number {
-        return ReconnectingWebSocket.OPEN;
-    }
-    get CLOSING(): number {
-        return ReconnectingWebSocket.CLOSING;
-    }
-    get CLOSED(): number {
-        return ReconnectingWebSocket.CLOSED;
-    }
+    public readonly CONNECTING: typeof ReconnectingWebSocket.CONNECTING = ReconnectingWebSocket.CONNECTING;
+    public readonly OPEN: typeof ReconnectingWebSocket.OPEN = ReconnectingWebSocket.OPEN;
+    public readonly CLOSING: typeof ReconnectingWebSocket.CLOSING = ReconnectingWebSocket.CLOSING;
+    public readonly CLOSED: typeof ReconnectingWebSocket.CLOSED = ReconnectingWebSocket.CLOSED;
 
     get binaryType() {
         return this._ws ? this._ws.binaryType : this._binaryType;
@@ -383,7 +314,7 @@ export class ReconnectingWebSocket {
         } = this._options;
         let delay = 0;
         if (this._retryCount > 0) {
-            delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
+            delay = minReconnectionDelay * reconnectionDelayGrowFactor ** (this._retryCount - 1);
             if (delay > maxReconnectionDelay) {
                 delay = maxReconnectionDelay;
             }
@@ -478,7 +409,7 @@ export class ReconnectingWebSocket {
         try {
             this._ws.close(code, reason);
             this._handleClose(new Events.CloseEvent(code, reason, this));
-        } catch (error) {
+        } catch (_error) {
             // ignore
         }
     }

```


## /src/environments.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export interface HumeEnvironmentUrls {
    base: string;
    evi: string;
    tts: string;
    stream: string;
}

export const HumeEnvironment = {
    Prod: {
        base: "https://api.hume.ai",
        evi: "wss://api.hume.ai/v0/evi",
        tts: "wss://api.hume.ai/v0/tts",
        stream: "wss://api.hume.ai/v0/stream",
    },
} as const;

export type HumeEnvironment = typeof HumeEnvironment.Prod;

```


## /src/errors/HumeError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../core/index.js";
import { toJson } from "../core/json.js";

export class HumeError extends Error {
    public readonly statusCode?: number;
    public readonly body?: unknown;
    public readonly rawResponse?: core.RawResponse;

    constructor({
        message,
        statusCode,
        body,
        rawResponse,
    }: {
        message?: string;
        statusCode?: number;
        body?: unknown;
        rawResponse?: core.RawResponse;
    }) {
        super(buildMessage({ message, statusCode, body }));
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }

        this.name = this.constructor.name;
        this.statusCode = statusCode;
        this.body = body;
        this.rawResponse = rawResponse;
    }
}

function buildMessage({
    message,
    statusCode,
    body,
}: {
    message: string | undefined;
    statusCode: number | undefined;
    body: unknown | undefined;
}): string {
    const lines: string[] = [];
    if (message != null) {
        lines.push(message);
    }

    if (statusCode != null) {
        lines.push(`Status code: ${statusCode.toString()}`);
    }

    if (body != null) {
        lines.push(`Body: ${toJson(body, undefined, 2)}`);
    }

    return lines.join("\n");
}

```


## /src/errors/HumeTimeoutError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

export class HumeTimeoutError extends Error {
    constructor(message: string) {
        super(message);
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }

        this.name = this.constructor.name;
    }
}

```


## /src/errors/handleNonStatusCodeError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../core/index.js";
import * as errors from "./index.js";

export function handleNonStatusCodeError(
    error: core.Fetcher.Error,
    rawResponse: core.RawResponse,
    method: string,
    path: string,
): never {
    switch (error.reason) {
        case "non-json":
            throw new errors.HumeError({
                statusCode: error.statusCode,
                body: error.rawBody,
                rawResponse: rawResponse,
            });
        case "body-is-null":
            throw new errors.HumeError({
                statusCode: error.statusCode,
                rawResponse: rawResponse,
            });
        case "timeout":
            throw new errors.HumeTimeoutError(`Timeout exceeded when calling ${method} ${path}.`);
        case "unknown":
            throw new errors.HumeError({
                message: error.errorMessage,
                rawResponse: rawResponse,
            });
        default:
            throw new errors.HumeError({
                message: "Unknown error",
                rawResponse: rawResponse,
            });
    }
}

```


## /src/errors/index.ts
```typescript
export { HumeError } from "./HumeError.js";
export { HumeTimeoutError } from "./HumeTimeoutError.js";

```


## /src/exports.ts
```typescript
export * from "./core/exports.js";

```


## /src/index.ts
```typescript
export * as Hume from "./api/index.js";
export * as serialization from "./serialization/index.js";
export { HumeError, HumeTimeoutError } from "./errors/index.js";
export { HumeEnvironment } from "./environments.js";
export type { HumeEnvironmentUrls } from "./environments.js";
export * from "./exports.js";

export * from "./wrapper/index.js";

```


## /src/index.ts.diff
```diff
diff --git a/src/index.ts b/src/index.ts
index 4d19902..c814670 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -1,8 +1,7 @@
 export * as Hume from "./api/index.js";
-export * as serialization from "./serialization/index.js";
+export type { BaseClientOptions, BaseRequestOptions } from "./BaseClient.js";
+export { HumeClient } from "./Client.js";
+export { HumeEnvironment, type HumeEnvironmentUrls } from "./environments.js";
 export { HumeError, HumeTimeoutError } from "./errors/index.js";
-export { HumeEnvironment } from "./environments.js";
-export type { HumeEnvironmentUrls } from "./environments.js";
 export * from "./exports.js";
-
-export * from "./wrapper/index.js";
+export * as serialization from "./serialization/index.js";

```


## /src/serialization/index.ts
```typescript
export * from "./resources/index.js";

```


## /src/serialization/resources/empathicVoice/index.ts
```typescript
export * from "./resources/index.js";
export * from "./types/index.js";

```


## /src/serialization/resources/empathicVoice/resources/chat/client/index.ts
```typescript
export * from "./socket/index.js";

```


## /src/serialization/resources/empathicVoice/resources/chat/client/socket/ChatSocketResponse.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";
import { SubscribeEvent } from "../../../../types/SubscribeEvent.js";

export const ChatSocketResponse: core.serialization.Schema<
    serializers.empathicVoice.ChatSocketResponse.Raw,
    Hume.empathicVoice.SubscribeEvent
> = core.serialization.undiscriminatedUnion([SubscribeEvent]);

export declare namespace ChatSocketResponse {
    export type Raw = SubscribeEvent.Raw;
}

```


## /src/serialization/resources/empathicVoice/resources/chat/client/socket/index.ts
```typescript
export { ChatSocketResponse } from "./ChatSocketResponse.js";

```


## /src/serialization/resources/empathicVoice/resources/chat/index.ts
```typescript
export * from "./client/index.js";
export * from "./types/index.js";
/**
 * @deprecated Use `serialization.empathicVoice.SubscribeEvent` instead.
 * This serializer alias will be removed in a future version.
 */
export { SubscribeEvent } from "./types/SubscribeEvent.js";

```


## /src/serialization/resources/empathicVoice/resources/chat/index.ts.diff
```diff
diff --git a/src/serialization/resources/empathicVoice/resources/chat/index.ts b/src/serialization/resources/empathicVoice/resources/chat/index.ts
index f5ca113..d9adb1a 100644
--- a/src/serialization/resources/empathicVoice/resources/chat/index.ts
+++ b/src/serialization/resources/empathicVoice/resources/chat/index.ts
@@ -1,7 +1,2 @@
 export * from "./client/index.js";
 export * from "./types/index.js";
-/**
- * @deprecated Use `serialization.empathicVoice.SubscribeEvent` instead.
- * This serializer alias will be removed in a future version.
- */
-export { SubscribeEvent } from "./types/SubscribeEvent.js";

```


## /src/serialization/resources/empathicVoice/resources/chat/types/PublishEvent.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { AssistantInput } from "../../../types/AssistantInput.js";
import { AudioInput } from "../../../types/AudioInput.js";
import { PauseAssistantMessage } from "../../../types/PauseAssistantMessage.js";
import { ResumeAssistantMessage } from "../../../types/ResumeAssistantMessage.js";
import { SessionSettings } from "../../../types/SessionSettings.js";
import { ToolErrorMessage } from "../../../types/ToolErrorMessage.js";
import { ToolResponseMessage } from "../../../types/ToolResponseMessage.js";
import { UserInput } from "../../../types/UserInput.js";

export const PublishEvent: core.serialization.Schema<
    serializers.empathicVoice.PublishEvent.Raw,
    Hume.empathicVoice.PublishEvent
> = core.serialization.undiscriminatedUnion([
    AudioInput,
    SessionSettings,
    UserInput,
    AssistantInput,
    ToolResponseMessage,
    ToolErrorMessage,
    PauseAssistantMessage,
    ResumeAssistantMessage,
]);

export declare namespace PublishEvent {
    export type Raw =
        | AudioInput.Raw
        | SessionSettings.Raw
        | UserInput.Raw
        | AssistantInput.Raw
        | ToolResponseMessage.Raw
        | ToolErrorMessage.Raw
        | PauseAssistantMessage.Raw
        | ResumeAssistantMessage.Raw;
}

```


## /src/serialization/resources/empathicVoice/resources/chat/types/SubscribeEvent.ts
```typescript
/**
 * This file was manually added to provide backward compatibility.
 *
 * @deprecated Use `serialization.empathicVoice.SubscribeEvent` instead.
 * This serializer alias will be removed in a future version.
 */

import { SubscribeEvent as NewSubscribeEvent } from "../../../types/SubscribeEvent.js";

/**
 * @deprecated Use `serialization.empathicVoice.SubscribeEvent` instead.
 * This serializer alias will be removed in a future version.
 */
export const SubscribeEvent: typeof NewSubscribeEvent = NewSubscribeEvent;

export declare namespace SubscribeEvent {
    /**
     * @deprecated Use `serialization.empathicVoice.SubscribeEvent.Raw` instead.
     * This type alias will be removed in a future version.
     */
    export type Raw = NewSubscribeEvent.Raw;
}

```


## /src/serialization/resources/empathicVoice/resources/chat/types/index.ts
```typescript
export * from "./PublishEvent.js";

```


## /src/serialization/resources/empathicVoice/resources/configs/client/index.ts
```typescript
export * from "./requests/index.js";

```


## /src/serialization/resources/empathicVoice/resources/configs/client/requests/PostedConfig.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";
import { PostedBuiltinTool } from "../../../../types/PostedBuiltinTool.js";
import { PostedConfigPromptSpec } from "../../../../types/PostedConfigPromptSpec.js";
import { PostedEllmModel } from "../../../../types/PostedEllmModel.js";
import { PostedEventMessageSpecs } from "../../../../types/PostedEventMessageSpecs.js";
import { PostedLanguageModel } from "../../../../types/PostedLanguageModel.js";
import { PostedNudgeSpec } from "../../../../types/PostedNudgeSpec.js";
import { PostedTimeoutSpecs } from "../../../../types/PostedTimeoutSpecs.js";
import { PostedUserDefinedToolSpec } from "../../../../types/PostedUserDefinedToolSpec.js";
import { PostedWebhookSpec } from "../../../../types/PostedWebhookSpec.js";
import { VoiceRef } from "../../../../types/VoiceRef.js";

export const PostedConfig: core.serialization.Schema<
    serializers.empathicVoice.PostedConfig.Raw,
    Hume.empathicVoice.PostedConfig
> = core.serialization.object({
    builtinTools: core.serialization.property(
        "builtin_tools",
        core.serialization.list(PostedBuiltinTool.optional()).optional(),
    ),
    ellmModel: core.serialization.property("ellm_model", PostedEllmModel.optional()),
    eventMessages: core.serialization.property("event_messages", PostedEventMessageSpecs.optional()),
    eviVersion: core.serialization.property("evi_version", core.serialization.string()),
    languageModel: core.serialization.property("language_model", PostedLanguageModel.optional()),
    name: core.serialization.string(),
    nudges: PostedNudgeSpec.optional(),
    prompt: PostedConfigPromptSpec.optional(),
    timeouts: PostedTimeoutSpecs.optional(),
    tools: core.serialization.list(PostedUserDefinedToolSpec.optional()).optional(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
    voice: VoiceRef.optional(),
    webhooks: core.serialization.list(PostedWebhookSpec.optional()).optional(),
});

export declare namespace PostedConfig {
    export interface Raw {
        builtin_tools?: (PostedBuiltinTool.Raw | null | undefined)[] | null;
        ellm_model?: PostedEllmModel.Raw | null;
        event_messages?: PostedEventMessageSpecs.Raw | null;
        evi_version: string;
        language_model?: PostedLanguageModel.Raw | null;
        name: string;
        nudges?: PostedNudgeSpec.Raw | null;
        prompt?: PostedConfigPromptSpec.Raw | null;
        timeouts?: PostedTimeoutSpecs.Raw | null;
        tools?: (PostedUserDefinedToolSpec.Raw | null | undefined)[] | null;
        version_description?: string | null;
        voice?: VoiceRef.Raw | null;
        webhooks?: (PostedWebhookSpec.Raw | null | undefined)[] | null;
    }
}

```


## /src/serialization/resources/empathicVoice/resources/configs/client/requests/PostedConfigName.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedConfigName: core.serialization.Schema<
    serializers.empathicVoice.PostedConfigName.Raw,
    Hume.empathicVoice.PostedConfigName
> = core.serialization.object({
    name: core.serialization.string(),
});

export declare namespace PostedConfigName {
    export interface Raw {
        name: string;
    }
}

```


## /src/serialization/resources/empathicVoice/resources/configs/client/requests/PostedConfigVersion.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";
import { PostedBuiltinTool } from "../../../../types/PostedBuiltinTool.js";
import { PostedConfigPromptSpec } from "../../../../types/PostedConfigPromptSpec.js";
import { PostedEllmModel } from "../../../../types/PostedEllmModel.js";
import { PostedEventMessageSpecs } from "../../../../types/PostedEventMessageSpecs.js";
import { PostedLanguageModel } from "../../../../types/PostedLanguageModel.js";
import { PostedNudgeSpec } from "../../../../types/PostedNudgeSpec.js";
import { PostedTimeoutSpecs } from "../../../../types/PostedTimeoutSpecs.js";
import { PostedUserDefinedToolSpec } from "../../../../types/PostedUserDefinedToolSpec.js";
import { PostedWebhookSpec } from "../../../../types/PostedWebhookSpec.js";
import { VoiceRef } from "../../../../types/VoiceRef.js";

export const PostedConfigVersion: core.serialization.Schema<
    serializers.empathicVoice.PostedConfigVersion.Raw,
    Hume.empathicVoice.PostedConfigVersion
> = core.serialization.object({
    builtinTools: core.serialization.property(
        "builtin_tools",
        core.serialization.list(PostedBuiltinTool.optional()).optional(),
    ),
    ellmModel: core.serialization.property("ellm_model", PostedEllmModel.optional()),
    eventMessages: core.serialization.property("event_messages", PostedEventMessageSpecs.optional()),
    eviVersion: core.serialization.property("evi_version", core.serialization.string()),
    languageModel: core.serialization.property("language_model", PostedLanguageModel.optional()),
    nudges: PostedNudgeSpec.optional(),
    prompt: PostedConfigPromptSpec.optional(),
    timeouts: PostedTimeoutSpecs.optional(),
    tools: core.serialization.list(PostedUserDefinedToolSpec.optional()).optional(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
    voice: VoiceRef.optional(),
    webhooks: core.serialization.list(PostedWebhookSpec.optional()).optional(),
});

export declare namespace PostedConfigVersion {
    export interface Raw {
        builtin_tools?: (PostedBuiltinTool.Raw | null | undefined)[] | null;
        ellm_model?: PostedEllmModel.Raw | null;
        event_messages?: PostedEventMessageSpecs.Raw | null;
        evi_version: string;
        language_model?: PostedLanguageModel.Raw | null;
        nudges?: PostedNudgeSpec.Raw | null;
        prompt?: PostedConfigPromptSpec.Raw | null;
        timeouts?: PostedTimeoutSpecs.Raw | null;
        tools?: (PostedUserDefinedToolSpec.Raw | null | undefined)[] | null;
        version_description?: string | null;
        voice?: VoiceRef.Raw | null;
        webhooks?: (PostedWebhookSpec.Raw | null | undefined)[] | null;
    }
}

```


## /src/serialization/resources/empathicVoice/resources/configs/client/requests/PostedConfigVersionDescription.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedConfigVersionDescription: core.serialization.Schema<
    serializers.empathicVoice.PostedConfigVersionDescription.Raw,
    Hume.empathicVoice.PostedConfigVersionDescription
> = core.serialization.object({
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedConfigVersionDescription {
    export interface Raw {
        version_description?: string | null;
    }
}

```


## /src/serialization/resources/empathicVoice/resources/configs/client/requests/index.ts
```typescript
export { PostedConfig } from "./PostedConfig.js";
export { PostedConfigName } from "./PostedConfigName.js";
export { PostedConfigVersion } from "./PostedConfigVersion.js";
export { PostedConfigVersionDescription } from "./PostedConfigVersionDescription.js";

```


## /src/serialization/resources/empathicVoice/resources/configs/index.ts
```typescript
export * from "./client/index.js";

```


## /src/serialization/resources/empathicVoice/resources/controlPlane/client/index.ts
```typescript
export * from "./socket/index.js";

```


## /src/serialization/resources/empathicVoice/resources/controlPlane/client/socket/ControlPlaneSocketResponse.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";
import { SubscribeEvent } from "../../../../types/SubscribeEvent.js";

export const ControlPlaneSocketResponse: core.serialization.Schema<
    serializers.empathicVoice.ControlPlaneSocketResponse.Raw,
    Hume.empathicVoice.SubscribeEvent
> = core.serialization.undiscriminatedUnion([SubscribeEvent]);

export declare namespace ControlPlaneSocketResponse {
    export type Raw = SubscribeEvent.Raw;
}

```


## /src/serialization/resources/empathicVoice/resources/controlPlane/client/socket/index.ts
```typescript
export { ControlPlaneSocketResponse } from "./ControlPlaneSocketResponse.js";

```


## /src/serialization/resources/empathicVoice/resources/controlPlane/index.ts
```typescript
export * from "./client/index.js";

```


## /src/serialization/resources/empathicVoice/resources/index.ts
```typescript
export * from "./chat/client/socket/index.js";
export * as chat from "./chat/index.js";
export * from "./chat/types/index.js";
export * from "./configs/client/requests/index.js";
export * as configs from "./configs/index.js";
export * from "./controlPlane/client/socket/index.js";
export * as controlPlane from "./controlPlane/index.js";
export * from "./prompts/client/requests/index.js";
export * as prompts from "./prompts/index.js";
export * from "./tools/client/requests/index.js";
export * as tools from "./tools/index.js";

```


## /src/serialization/resources/empathicVoice/resources/prompts/client/createPrompt.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnPrompt } from "../../../types/ReturnPrompt.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.prompts.createPrompt.Response.Raw,
    Hume.empathicVoice.ReturnPrompt | undefined
> = ReturnPrompt.optional();

export declare namespace Response {
    export type Raw = ReturnPrompt.Raw | null | undefined;
}

```


## /src/serialization/resources/empathicVoice/resources/prompts/client/createPromptVersion.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnPrompt } from "../../../types/ReturnPrompt.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.prompts.createPromptVersion.Response.Raw,
    Hume.empathicVoice.ReturnPrompt | undefined
> = ReturnPrompt.optional();

export declare namespace Response {
    export type Raw = ReturnPrompt.Raw | null | undefined;
}

```


## /src/serialization/resources/empathicVoice/resources/prompts/client/getPromptVersion.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnPrompt } from "../../../types/ReturnPrompt.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.prompts.getPromptVersion.Response.Raw,
    Hume.empathicVoice.ReturnPrompt | undefined
> = ReturnPrompt.optional();

export declare namespace Response {
    export type Raw = ReturnPrompt.Raw | null | undefined;
}

```


## /src/serialization/resources/empathicVoice/resources/prompts/client/index.ts
```typescript
export * as createPrompt from "./createPrompt.js";
export * as createPromptVersion from "./createPromptVersion.js";
export * as getPromptVersion from "./getPromptVersion.js";
export * from "./requests/index.js";
export * as updatePromptDescription from "./updatePromptDescription.js";

```


## /src/serialization/resources/empathicVoice/resources/prompts/client/requests/PostedPrompt.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedPrompt: core.serialization.Schema<
    serializers.empathicVoice.PostedPrompt.Raw,
    Hume.empathicVoice.PostedPrompt
> = core.serialization.object({
    name: core.serialization.string(),
    text: core.serialization.string(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedPrompt {
    export interface Raw {
        name: string;
        text: string;
        version_description?: string | null;
    }
}

```


## /src/serialization/resources/empathicVoice/resources/prompts/client/requests/PostedPromptName.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedPromptName: core.serialization.Schema<
    serializers.empathicVoice.PostedPromptName.Raw,
    Hume.empathicVoice.PostedPromptName
> = core.serialization.object({
    name: core.serialization.string(),
});

export declare namespace PostedPromptName {
    export interface Raw {
        name: string;
    }
}

```


## /src/serialization/resources/empathicVoice/resources/prompts/client/requests/PostedPromptVersion.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedPromptVersion: core.serialization.Schema<
    serializers.empathicVoice.PostedPromptVersion.Raw,
    Hume.empathicVoice.PostedPromptVersion
> = core.serialization.object({
    text: core.serialization.string(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedPromptVersion {
    export interface Raw {
        text: string;
        version_description?: string | null;
    }
}

```


## /src/serialization/resources/empathicVoice/resources/prompts/client/requests/PostedPromptVersionDescription.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedPromptVersionDescription: core.serialization.Schema<
    serializers.empathicVoice.PostedPromptVersionDescription.Raw,
    Hume.empathicVoice.PostedPromptVersionDescription
> = core.serialization.object({
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedPromptVersionDescription {
    export interface Raw {
        version_description?: string | null;
    }
}

```


## /src/serialization/resources/empathicVoice/resources/prompts/client/requests/index.ts
```typescript
export { PostedPrompt } from "./PostedPrompt.js";
export { PostedPromptName } from "./PostedPromptName.js";
export { PostedPromptVersion } from "./PostedPromptVersion.js";
export { PostedPromptVersionDescription } from "./PostedPromptVersionDescription.js";

```


## /src/serialization/resources/empathicVoice/resources/prompts/client/updatePromptDescription.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnPrompt } from "../../../types/ReturnPrompt.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.prompts.updatePromptDescription.Response.Raw,
    Hume.empathicVoice.ReturnPrompt | undefined
> = ReturnPrompt.optional();

export declare namespace Response {
    export type Raw = ReturnPrompt.Raw | null | undefined;
}

```


## /src/serialization/resources/empathicVoice/resources/prompts/index.ts
```typescript
export * from "./client/index.js";

```


## /src/serialization/resources/empathicVoice/resources/tools/client/createTool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnUserDefinedTool } from "../../../types/ReturnUserDefinedTool.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.tools.createTool.Response.Raw,
    Hume.empathicVoice.ReturnUserDefinedTool | undefined
> = ReturnUserDefinedTool.optional();

export declare namespace Response {
    export type Raw = ReturnUserDefinedTool.Raw | null | undefined;
}

```


## /src/serialization/resources/empathicVoice/resources/tools/client/createToolVersion.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnUserDefinedTool } from "../../../types/ReturnUserDefinedTool.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.tools.createToolVersion.Response.Raw,
    Hume.empathicVoice.ReturnUserDefinedTool | undefined
> = ReturnUserDefinedTool.optional();

export declare namespace Response {
    export type Raw = ReturnUserDefinedTool.Raw | null | undefined;
}

```


## /src/serialization/resources/empathicVoice/resources/tools/client/getToolVersion.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnUserDefinedTool } from "../../../types/ReturnUserDefinedTool.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.tools.getToolVersion.Response.Raw,
    Hume.empathicVoice.ReturnUserDefinedTool | undefined
> = ReturnUserDefinedTool.optional();

export declare namespace Response {
    export type Raw = ReturnUserDefinedTool.Raw | null | undefined;
}

```


## /src/serialization/resources/empathicVoice/resources/tools/client/index.ts
```typescript
export * as createTool from "./createTool.js";
export * as createToolVersion from "./createToolVersion.js";
export * as getToolVersion from "./getToolVersion.js";
export * from "./requests/index.js";
export * as updateToolDescription from "./updateToolDescription.js";

```


## /src/serialization/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedTool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedUserDefinedTool: core.serialization.Schema<
    serializers.empathicVoice.PostedUserDefinedTool.Raw,
    Hume.empathicVoice.PostedUserDefinedTool
> = core.serialization.object({
    description: core.serialization.string().optional(),
    fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
    name: core.serialization.string(),
    parameters: core.serialization.string(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedUserDefinedTool {
    export interface Raw {
        description?: string | null;
        fallback_content?: string | null;
        name: string;
        parameters: string;
        version_description?: string | null;
    }
}

```


## /src/serialization/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolName.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedUserDefinedToolName: core.serialization.Schema<
    serializers.empathicVoice.PostedUserDefinedToolName.Raw,
    Hume.empathicVoice.PostedUserDefinedToolName
> = core.serialization.object({
    name: core.serialization.string(),
});

export declare namespace PostedUserDefinedToolName {
    export interface Raw {
        name: string;
    }
}

```


## /src/serialization/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolVersion.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedUserDefinedToolVersion: core.serialization.Schema<
    serializers.empathicVoice.PostedUserDefinedToolVersion.Raw,
    Hume.empathicVoice.PostedUserDefinedToolVersion
> = core.serialization.object({
    description: core.serialization.string().optional(),
    fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
    parameters: core.serialization.string(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedUserDefinedToolVersion {
    export interface Raw {
        description?: string | null;
        fallback_content?: string | null;
        parameters: string;
        version_description?: string | null;
    }
}

```


## /src/serialization/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolVersionDescription.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedUserDefinedToolVersionDescription: core.serialization.Schema<
    serializers.empathicVoice.PostedUserDefinedToolVersionDescription.Raw,
    Hume.empathicVoice.PostedUserDefinedToolVersionDescription
> = core.serialization.object({
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedUserDefinedToolVersionDescription {
    export interface Raw {
        version_description?: string | null;
    }
}

```


## /src/serialization/resources/empathicVoice/resources/tools/client/requests/index.ts
```typescript
export { PostedUserDefinedTool } from "./PostedUserDefinedTool.js";
export { PostedUserDefinedToolName } from "./PostedUserDefinedToolName.js";
export { PostedUserDefinedToolVersion } from "./PostedUserDefinedToolVersion.js";
export { PostedUserDefinedToolVersionDescription } from "./PostedUserDefinedToolVersionDescription.js";

```


## /src/serialization/resources/empathicVoice/resources/tools/client/updateToolDescription.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnUserDefinedTool } from "../../../types/ReturnUserDefinedTool.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.tools.updateToolDescription.Response.Raw,
    Hume.empathicVoice.ReturnUserDefinedTool | undefined
> = ReturnUserDefinedTool.optional();

export declare namespace Response {
    export type Raw = ReturnUserDefinedTool.Raw | null | undefined;
}

```


## /src/serialization/resources/empathicVoice/resources/tools/index.ts
```typescript
export * from "./client/index.js";

```


## /src/serialization/resources/empathicVoice/types/AssistantEnd.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const AssistantEnd: core.serialization.ObjectSchema<
    serializers.empathicVoice.AssistantEnd.Raw,
    Hume.empathicVoice.AssistantEnd
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    type: core.serialization.stringLiteral("assistant_end"),
});

export declare namespace AssistantEnd {
    export interface Raw {
        custom_session_id?: string | null;
        type: "assistant_end";
    }
}

```


## /src/serialization/resources/empathicVoice/types/AssistantInput.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const AssistantInput: core.serialization.ObjectSchema<
    serializers.empathicVoice.AssistantInput.Raw,
    Hume.empathicVoice.AssistantInput
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    text: core.serialization.string(),
    type: core.serialization.stringLiteral("assistant_input"),
});

export declare namespace AssistantInput {
    export interface Raw {
        custom_session_id?: string | null;
        text: string;
        type: "assistant_input";
    }
}

```


## /src/serialization/resources/empathicVoice/types/AssistantMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ChatMessage } from "./ChatMessage.js";
import { Inference } from "./Inference.js";

export const AssistantMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.AssistantMessage.Raw,
    Hume.empathicVoice.AssistantMessage
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    fromText: core.serialization.property("from_text", core.serialization.boolean()),
    id: core.serialization.string().optional(),
    isQuickResponse: core.serialization.property("is_quick_response", core.serialization.boolean()),
    language: core.serialization.string().optional(),
    message: ChatMessage,
    models: Inference,
    type: core.serialization.stringLiteral("assistant_message"),
});

export declare namespace AssistantMessage {
    export interface Raw {
        custom_session_id?: string | null;
        from_text: boolean;
        id?: string | null;
        is_quick_response: boolean;
        language?: string | null;
        message: ChatMessage.Raw;
        models: Inference.Raw;
        type: "assistant_message";
    }
}

```


## /src/serialization/resources/empathicVoice/types/AssistantProsody.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { Inference } from "./Inference.js";

export const AssistantProsody: core.serialization.ObjectSchema<
    serializers.empathicVoice.AssistantProsody.Raw,
    Hume.empathicVoice.AssistantProsody
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    id: core.serialization.string().optional(),
    models: Inference,
    type: core.serialization.stringLiteral("assistant_prosody"),
});

export declare namespace AssistantProsody {
    export interface Raw {
        custom_session_id?: string | null;
        id?: string | null;
        models: Inference.Raw;
        type: "assistant_prosody";
    }
}

```


## /src/serialization/resources/empathicVoice/types/AudioConfiguration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { Encoding } from "./Encoding.js";

export const AudioConfiguration: core.serialization.ObjectSchema<
    serializers.empathicVoice.AudioConfiguration.Raw,
    Hume.empathicVoice.AudioConfiguration
> = core.serialization.object({
    channels: core.serialization.number(),
    codec: core.serialization.string().optional(),
    encoding: Encoding,
    sampleRate: core.serialization.property("sample_rate", core.serialization.number()),
});

export declare namespace AudioConfiguration {
    export interface Raw {
        channels: number;
        codec?: string | null;
        encoding: Encoding.Raw;
        sample_rate: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/AudioInput.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const AudioInput: core.serialization.ObjectSchema<
    serializers.empathicVoice.AudioInput.Raw,
    Hume.empathicVoice.AudioInput
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    data: core.serialization.string(),
    type: core.serialization.stringLiteral("audio_input"),
});

export declare namespace AudioInput {
    export interface Raw {
        custom_session_id?: string | null;
        data: string;
        type: "audio_input";
    }
}

```


## /src/serialization/resources/empathicVoice/types/AudioOutput.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const AudioOutput: core.serialization.ObjectSchema<
    serializers.empathicVoice.AudioOutput.Raw,
    Hume.empathicVoice.AudioOutput
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    data: core.serialization.string(),
    id: core.serialization.string(),
    index: core.serialization.number(),
    type: core.serialization.stringLiteral("audio_output"),
});

export declare namespace AudioOutput {
    export interface Raw {
        custom_session_id?: string | null;
        data: string;
        id: string;
        index: number;
        type: "audio_output";
    }
}

```


## /src/serialization/resources/empathicVoice/types/BuiltInTool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const BuiltInTool: core.serialization.Schema<
    serializers.empathicVoice.BuiltInTool.Raw,
    Hume.empathicVoice.BuiltInTool
> = core.serialization.enum_(["web_search", "hang_up"]);

export declare namespace BuiltInTool {
    export type Raw = "web_search" | "hang_up";
}

```


## /src/serialization/resources/empathicVoice/types/BuiltinToolConfig.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { BuiltInTool } from "./BuiltInTool.js";

export const BuiltinToolConfig: core.serialization.ObjectSchema<
    serializers.empathicVoice.BuiltinToolConfig.Raw,
    Hume.empathicVoice.BuiltinToolConfig
> = core.serialization.object({
    fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
    name: BuiltInTool,
});

export declare namespace BuiltinToolConfig {
    export interface Raw {
        fallback_content?: string | null;
        name: BuiltInTool.Raw;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ChatMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ChatMessageToolResult } from "./ChatMessageToolResult.js";
import { Role } from "./Role.js";
import { ToolCallMessage } from "./ToolCallMessage.js";

export const ChatMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.ChatMessage.Raw,
    Hume.empathicVoice.ChatMessage
> = core.serialization.object({
    content: core.serialization.string().optional(),
    role: Role,
    toolCall: core.serialization.property("tool_call", ToolCallMessage.optional()),
    toolResult: core.serialization.property("tool_result", ChatMessageToolResult.optional()),
});

export declare namespace ChatMessage {
    export interface Raw {
        content?: string | null;
        role: Role.Raw;
        tool_call?: ToolCallMessage.Raw | null;
        tool_result?: ChatMessageToolResult.Raw | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ChatMessageToolResult.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ToolErrorMessage } from "./ToolErrorMessage.js";
import { ToolResponseMessage } from "./ToolResponseMessage.js";

export const ChatMessageToolResult: core.serialization.Schema<
    serializers.empathicVoice.ChatMessageToolResult.Raw,
    Hume.empathicVoice.ChatMessageToolResult
> = core.serialization.undiscriminatedUnion([ToolResponseMessage, ToolErrorMessage]);

export declare namespace ChatMessageToolResult {
    export type Raw = ToolResponseMessage.Raw | ToolErrorMessage.Raw;
}

```


## /src/serialization/resources/empathicVoice/types/ChatMetadata.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ChatMetadata: core.serialization.ObjectSchema<
    serializers.empathicVoice.ChatMetadata.Raw,
    Hume.empathicVoice.ChatMetadata
> = core.serialization.object({
    chatGroupId: core.serialization.property("chat_group_id", core.serialization.string()),
    chatId: core.serialization.property("chat_id", core.serialization.string()),
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    requestId: core.serialization.property("request_id", core.serialization.string().optional()),
    type: core.serialization.stringLiteral("chat_metadata"),
});

export declare namespace ChatMetadata {
    export interface Raw {
        chat_group_id: string;
        chat_id: string;
        custom_session_id?: string | null;
        request_id?: string | null;
        type: "chat_metadata";
    }
}

```


## /src/serialization/resources/empathicVoice/types/ConnectSessionSettings.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ConnectSessionSettingsAudio } from "./ConnectSessionSettingsAudio.js";
import { ConnectSessionSettingsContext } from "./ConnectSessionSettingsContext.js";
import { ConnectSessionSettingsVariablesValue } from "./ConnectSessionSettingsVariablesValue.js";

export const ConnectSessionSettings: core.serialization.ObjectSchema<
    serializers.empathicVoice.ConnectSessionSettings.Raw,
    Hume.empathicVoice.ConnectSessionSettings
> = core.serialization.object({
    audio: ConnectSessionSettingsAudio.optional(),
    context: ConnectSessionSettingsContext.optional(),
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    eventLimit: core.serialization.property("event_limit", core.serialization.number().optional()),
    languageModelApiKey: core.serialization.property("language_model_api_key", core.serialization.string().optional()),
    systemPrompt: core.serialization.property("system_prompt", core.serialization.string().optional()),
    voiceId: core.serialization.property("voice_id", core.serialization.string().optional()),
    variables: core.serialization.record(core.serialization.string(), ConnectSessionSettingsVariablesValue).optional(),
});

export declare namespace ConnectSessionSettings {
    export interface Raw {
        audio?: ConnectSessionSettingsAudio.Raw | null;
        context?: ConnectSessionSettingsContext.Raw | null;
        custom_session_id?: string | null;
        event_limit?: number | null;
        language_model_api_key?: string | null;
        system_prompt?: string | null;
        voice_id?: string | null;
        variables?: Record<string, ConnectSessionSettingsVariablesValue.Raw> | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ConnectSessionSettingsAudio.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { Encoding } from "./Encoding.js";

export const ConnectSessionSettingsAudio: core.serialization.ObjectSchema<
    serializers.empathicVoice.ConnectSessionSettingsAudio.Raw,
    Hume.empathicVoice.ConnectSessionSettingsAudio
> = core.serialization.object({
    channels: core.serialization.number().optional(),
    encoding: Encoding.optional(),
    sampleRate: core.serialization.property("sample_rate", core.serialization.number().optional()),
});

export declare namespace ConnectSessionSettingsAudio {
    export interface Raw {
        channels?: number | null;
        encoding?: Encoding.Raw | null;
        sample_rate?: number | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ConnectSessionSettingsContext.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ContextType } from "./ContextType.js";

export const ConnectSessionSettingsContext: core.serialization.ObjectSchema<
    serializers.empathicVoice.ConnectSessionSettingsContext.Raw,
    Hume.empathicVoice.ConnectSessionSettingsContext
> = core.serialization.object({
    text: core.serialization.string().optional(),
    type: ContextType.optional(),
});

export declare namespace ConnectSessionSettingsContext {
    export interface Raw {
        text?: string | null;
        type?: ContextType.Raw | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ConnectSessionSettingsVariablesValue.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ConnectSessionSettingsVariablesValue: core.serialization.Schema<
    serializers.empathicVoice.ConnectSessionSettingsVariablesValue.Raw,
    Hume.empathicVoice.ConnectSessionSettingsVariablesValue
> = core.serialization.undiscriminatedUnion([
    core.serialization.string(),
    core.serialization.number(),
    core.serialization.boolean(),
]);

export declare namespace ConnectSessionSettingsVariablesValue {
    export type Raw = string | number | boolean;
}

```


## /src/serialization/resources/empathicVoice/types/Context.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ContextType } from "./ContextType.js";

export const Context: core.serialization.ObjectSchema<
    serializers.empathicVoice.Context.Raw,
    Hume.empathicVoice.Context
> = core.serialization.object({
    text: core.serialization.string(),
    type: ContextType.optional(),
});

export declare namespace Context {
    export interface Raw {
        text: string;
        type?: ContextType.Raw | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ContextType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ContextType: core.serialization.Schema<
    serializers.empathicVoice.ContextType.Raw,
    Hume.empathicVoice.ContextType
> = core.serialization.enum_(["persistent", "temporary"]);

export declare namespace ContextType {
    export type Raw = "persistent" | "temporary";
}

```


## /src/serialization/resources/empathicVoice/types/ControlPlanePublishEvent.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AssistantInput } from "./AssistantInput.js";
import { PauseAssistantMessage } from "./PauseAssistantMessage.js";
import { ResumeAssistantMessage } from "./ResumeAssistantMessage.js";
import { SessionSettings } from "./SessionSettings.js";
import { ToolErrorMessage } from "./ToolErrorMessage.js";
import { ToolResponseMessage } from "./ToolResponseMessage.js";
import { UserInput } from "./UserInput.js";

export const ControlPlanePublishEvent: core.serialization.Schema<
    serializers.empathicVoice.ControlPlanePublishEvent.Raw,
    Hume.empathicVoice.ControlPlanePublishEvent
> = core.serialization.undiscriminatedUnion([
    SessionSettings,
    UserInput,
    AssistantInput,
    ToolResponseMessage,
    ToolErrorMessage,
    PauseAssistantMessage,
    ResumeAssistantMessage,
]);

export declare namespace ControlPlanePublishEvent {
    export type Raw =
        | SessionSettings.Raw
        | UserInput.Raw
        | AssistantInput.Raw
        | ToolResponseMessage.Raw
        | ToolErrorMessage.Raw
        | PauseAssistantMessage.Raw
        | ResumeAssistantMessage.Raw;
}

```


## /src/serialization/resources/empathicVoice/types/EmotionScores.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const EmotionScores: core.serialization.ObjectSchema<
    serializers.empathicVoice.EmotionScores.Raw,
    Hume.empathicVoice.EmotionScores
> = core.serialization.object({
    admiration: core.serialization.property("Admiration", core.serialization.number()),
    adoration: core.serialization.property("Adoration", core.serialization.number()),
    aestheticAppreciation: core.serialization.property("Aesthetic Appreciation", core.serialization.number()),
    amusement: core.serialization.property("Amusement", core.serialization.number()),
    anger: core.serialization.property("Anger", core.serialization.number()),
    anxiety: core.serialization.property("Anxiety", core.serialization.number()),
    awe: core.serialization.property("Awe", core.serialization.number()),
    awkwardness: core.serialization.property("Awkwardness", core.serialization.number()),
    boredom: core.serialization.property("Boredom", core.serialization.number()),
    calmness: core.serialization.property("Calmness", core.serialization.number()),
    concentration: core.serialization.property("Concentration", core.serialization.number()),
    confusion: core.serialization.property("Confusion", core.serialization.number()),
    contemplation: core.serialization.property("Contemplation", core.serialization.number()),
    contempt: core.serialization.property("Contempt", core.serialization.number()),
    contentment: core.serialization.property("Contentment", core.serialization.number()),
    craving: core.serialization.property("Craving", core.serialization.number()),
    desire: core.serialization.property("Desire", core.serialization.number()),
    determination: core.serialization.property("Determination", core.serialization.number()),
    disappointment: core.serialization.property("Disappointment", core.serialization.number()),
    disgust: core.serialization.property("Disgust", core.serialization.number()),
    distress: core.serialization.property("Distress", core.serialization.number()),
    doubt: core.serialization.property("Doubt", core.serialization.number()),
    ecstasy: core.serialization.property("Ecstasy", core.serialization.number()),
    embarrassment: core.serialization.property("Embarrassment", core.serialization.number()),
    empathicPain: core.serialization.property("Empathic Pain", core.serialization.number()),
    entrancement: core.serialization.property("Entrancement", core.serialization.number()),
    envy: core.serialization.property("Envy", core.serialization.number()),
    excitement: core.serialization.property("Excitement", core.serialization.number()),
    fear: core.serialization.property("Fear", core.serialization.number()),
    guilt: core.serialization.property("Guilt", core.serialization.number()),
    horror: core.serialization.property("Horror", core.serialization.number()),
    interest: core.serialization.property("Interest", core.serialization.number()),
    joy: core.serialization.property("Joy", core.serialization.number()),
    love: core.serialization.property("Love", core.serialization.number()),
    nostalgia: core.serialization.property("Nostalgia", core.serialization.number()),
    pain: core.serialization.property("Pain", core.serialization.number()),
    pride: core.serialization.property("Pride", core.serialization.number()),
    realization: core.serialization.property("Realization", core.serialization.number()),
    relief: core.serialization.property("Relief", core.serialization.number()),
    romance: core.serialization.property("Romance", core.serialization.number()),
    sadness: core.serialization.property("Sadness", core.serialization.number()),
    satisfaction: core.serialization.property("Satisfaction", core.serialization.number()),
    shame: core.serialization.property("Shame", core.serialization.number()),
    surpriseNegative: core.serialization.property("Surprise (negative)", core.serialization.number()),
    surprisePositive: core.serialization.property("Surprise (positive)", core.serialization.number()),
    sympathy: core.serialization.property("Sympathy", core.serialization.number()),
    tiredness: core.serialization.property("Tiredness", core.serialization.number()),
    triumph: core.serialization.property("Triumph", core.serialization.number()),
});

export declare namespace EmotionScores {
    export interface Raw {
        Admiration: number;
        Adoration: number;
        "Aesthetic Appreciation": number;
        Amusement: number;
        Anger: number;
        Anxiety: number;
        Awe: number;
        Awkwardness: number;
        Boredom: number;
        Calmness: number;
        Concentration: number;
        Confusion: number;
        Contemplation: number;
        Contempt: number;
        Contentment: number;
        Craving: number;
        Desire: number;
        Determination: number;
        Disappointment: number;
        Disgust: number;
        Distress: number;
        Doubt: number;
        Ecstasy: number;
        Embarrassment: number;
        "Empathic Pain": number;
        Entrancement: number;
        Envy: number;
        Excitement: number;
        Fear: number;
        Guilt: number;
        Horror: number;
        Interest: number;
        Joy: number;
        Love: number;
        Nostalgia: number;
        Pain: number;
        Pride: number;
        Realization: number;
        Relief: number;
        Romance: number;
        Sadness: number;
        Satisfaction: number;
        Shame: number;
        "Surprise (negative)": number;
        "Surprise (positive)": number;
        Sympathy: number;
        Tiredness: number;
        Triumph: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/Encoding.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const Encoding: core.serialization.Schema<serializers.empathicVoice.Encoding.Raw, Hume.empathicVoice.Encoding> =
    core.serialization.stringLiteral("linear16");

export declare namespace Encoding {
    export type Raw = "linear16";
}

```


## /src/serialization/resources/empathicVoice/types/ErrorLevel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ErrorLevel: core.serialization.Schema<
    serializers.empathicVoice.ErrorLevel.Raw,
    Hume.empathicVoice.ErrorLevel
> = core.serialization.stringLiteral("warn");

export declare namespace ErrorLevel {
    export type Raw = "warn";
}

```


## /src/serialization/resources/empathicVoice/types/ErrorResponse.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ErrorResponse: core.serialization.ObjectSchema<
    serializers.empathicVoice.ErrorResponse.Raw,
    Hume.empathicVoice.ErrorResponse
> = core.serialization.object({
    code: core.serialization.string().optional(),
    error: core.serialization.string().optional(),
    message: core.serialization.string().optional(),
});

export declare namespace ErrorResponse {
    export interface Raw {
        code?: string | null;
        error?: string | null;
        message?: string | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/HttpValidationError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ValidationError } from "./ValidationError.js";

export const HttpValidationError: core.serialization.ObjectSchema<
    serializers.empathicVoice.HttpValidationError.Raw,
    Hume.empathicVoice.HttpValidationError
> = core.serialization.object({
    detail: core.serialization.list(ValidationError).optional(),
});

export declare namespace HttpValidationError {
    export interface Raw {
        detail?: ValidationError.Raw[] | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/Inference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ProsodyInference } from "./ProsodyInference.js";

export const Inference: core.serialization.ObjectSchema<
    serializers.empathicVoice.Inference.Raw,
    Hume.empathicVoice.Inference
> = core.serialization.object({
    prosody: ProsodyInference.optional(),
});

export declare namespace Inference {
    export interface Raw {
        prosody?: ProsodyInference.Raw | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/JsonMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AssistantEnd } from "./AssistantEnd.js";
import { AssistantMessage } from "./AssistantMessage.js";
import { AssistantProsody } from "./AssistantProsody.js";
import { ChatMetadata } from "./ChatMetadata.js";
import { SessionSettings } from "./SessionSettings.js";
import { ToolCallMessage } from "./ToolCallMessage.js";
import { ToolErrorMessage } from "./ToolErrorMessage.js";
import { ToolResponseMessage } from "./ToolResponseMessage.js";
import { UserInterruption } from "./UserInterruption.js";
import { UserMessage } from "./UserMessage.js";
import { WebSocketError } from "./WebSocketError.js";

export const JsonMessage: core.serialization.Schema<
    serializers.empathicVoice.JsonMessage.Raw,
    Hume.empathicVoice.JsonMessage
> = core.serialization.undiscriminatedUnion([
    AssistantEnd,
    AssistantMessage,
    AssistantProsody,
    ChatMetadata,
    WebSocketError,
    UserInterruption,
    UserMessage,
    ToolCallMessage,
    ToolResponseMessage,
    ToolErrorMessage,
    SessionSettings,
]);

export declare namespace JsonMessage {
    export type Raw =
        | AssistantEnd.Raw
        | AssistantMessage.Raw
        | AssistantProsody.Raw
        | ChatMetadata.Raw
        | WebSocketError.Raw
        | UserInterruption.Raw
        | UserMessage.Raw
        | ToolCallMessage.Raw
        | ToolResponseMessage.Raw
        | ToolErrorMessage.Raw
        | SessionSettings.Raw;
}

```


## /src/serialization/resources/empathicVoice/types/LanguageModelType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const LanguageModelType: core.serialization.Schema<
    serializers.empathicVoice.LanguageModelType.Raw,
    Hume.empathicVoice.LanguageModelType
> = core.serialization.enum_([
    "claude-3-7-sonnet-latest",
    "claude-3-5-sonnet-latest",
    "claude-3-5-haiku-latest",
    "claude-3-5-sonnet-20240620",
    "claude-3-opus-20240229",
    "claude-3-sonnet-20240229",
    "claude-3-haiku-20240307",
    "claude-sonnet-4-20250514",
    "claude-sonnet-4-5-20250929",
    "claude-haiku-4-5-20251001",
    "us.anthropic.claude-3-5-haiku-20241022-v1:0",
    "us.anthropic.claude-3-5-sonnet-20240620-v1:0",
    "us.anthropic.claude-3-haiku-20240307-v1:0",
    "gpt-oss-120b",
    "qwen-3-235b-a22b",
    "qwen-3-235b-a22b-instruct-2507",
    "qwen-3-235b-a22b-thinking-2507",
    "gemini-1.5-pro",
    "gemini-1.5-flash",
    "gemini-1.5-pro-002",
    "gemini-1.5-flash-002",
    "gemini-2.0-flash",
    "gemini-2.5-flash",
    "gemini-2.5-flash-preview-04-17",
    "gpt-4-turbo",
    "gpt-4-turbo-preview",
    "gpt-3.5-turbo-0125",
    "gpt-3.5-turbo",
    "gpt-4o",
    "gpt-4o-mini",
    "gpt-4.1",
    "gpt-5",
    "gpt-5-mini",
    "gpt-5-nano",
    "gpt-4o-priority",
    "gpt-4o-mini-priority",
    "gpt-4.1-priority",
    "gpt-5-priority",
    "gpt-5-mini-priority",
    "gpt-5-nano-priority",
    "gemma-7b-it",
    "llama3-8b-8192",
    "llama3-70b-8192",
    "llama-3.1-70b-versatile",
    "llama-3.3-70b-versatile",
    "llama-3.1-8b-instant",
    "moonshotai/kimi-k2-instruct",
    "accounts/fireworks/models/mixtral-8x7b-instruct",
    "accounts/fireworks/models/llama-v3p1-405b-instruct",
    "accounts/fireworks/models/llama-v3p1-70b-instruct",
    "accounts/fireworks/models/llama-v3p1-8b-instruct",
    "sonar",
    "sonar-pro",
    "sambanova",
    "DeepSeek-R1-Distill-Llama-70B",
    "Llama-4-Maverick-17B-128E-Instruct",
    "Qwen3-32B",
    "grok-4-fast-non-reasoning-latest",
    "ellm",
    "custom-language-model",
    "hume-evi-3-web-search",
]);

export declare namespace LanguageModelType {
    export type Raw =
        | "claude-3-7-sonnet-latest"
        | "claude-3-5-sonnet-latest"
        | "claude-3-5-haiku-latest"
        | "claude-3-5-sonnet-20240620"
        | "claude-3-opus-20240229"
        | "claude-3-sonnet-20240229"
        | "claude-3-haiku-20240307"
        | "claude-sonnet-4-20250514"
        | "claude-sonnet-4-5-20250929"
        | "claude-haiku-4-5-20251001"
        | "us.anthropic.claude-3-5-haiku-20241022-v1:0"
        | "us.anthropic.claude-3-5-sonnet-20240620-v1:0"
        | "us.anthropic.claude-3-haiku-20240307-v1:0"
        | "gpt-oss-120b"
        | "qwen-3-235b-a22b"
        | "qwen-3-235b-a22b-instruct-2507"
        | "qwen-3-235b-a22b-thinking-2507"
        | "gemini-1.5-pro"
        | "gemini-1.5-flash"
        | "gemini-1.5-pro-002"
        | "gemini-1.5-flash-002"
        | "gemini-2.0-flash"
        | "gemini-2.5-flash"
        | "gemini-2.5-flash-preview-04-17"
        | "gpt-4-turbo"
        | "gpt-4-turbo-preview"
        | "gpt-3.5-turbo-0125"
        | "gpt-3.5-turbo"
        | "gpt-4o"
        | "gpt-4o-mini"
        | "gpt-4.1"
        | "gpt-5"
        | "gpt-5-mini"
        | "gpt-5-nano"
        | "gpt-4o-priority"
        | "gpt-4o-mini-priority"
        | "gpt-4.1-priority"
        | "gpt-5-priority"
        | "gpt-5-mini-priority"
        | "gpt-5-nano-priority"
        | "gemma-7b-it"
        | "llama3-8b-8192"
        | "llama3-70b-8192"
        | "llama-3.1-70b-versatile"
        | "llama-3.3-70b-versatile"
        | "llama-3.1-8b-instant"
        | "moonshotai/kimi-k2-instruct"
        | "accounts/fireworks/models/mixtral-8x7b-instruct"
        | "accounts/fireworks/models/llama-v3p1-405b-instruct"
        | "accounts/fireworks/models/llama-v3p1-70b-instruct"
        | "accounts/fireworks/models/llama-v3p1-8b-instruct"
        | "sonar"
        | "sonar-pro"
        | "sambanova"
        | "DeepSeek-R1-Distill-Llama-70B"
        | "Llama-4-Maverick-17B-128E-Instruct"
        | "Qwen3-32B"
        | "grok-4-fast-non-reasoning-latest"
        | "ellm"
        | "custom-language-model"
        | "hume-evi-3-web-search";
}

```


## /src/serialization/resources/empathicVoice/types/MillisecondInterval.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const MillisecondInterval: core.serialization.ObjectSchema<
    serializers.empathicVoice.MillisecondInterval.Raw,
    Hume.empathicVoice.MillisecondInterval
> = core.serialization.object({
    begin: core.serialization.number(),
    end: core.serialization.number(),
});

export declare namespace MillisecondInterval {
    export interface Raw {
        begin: number;
        end: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ModelProviderEnum.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ModelProviderEnum: core.serialization.Schema<
    serializers.empathicVoice.ModelProviderEnum.Raw,
    Hume.empathicVoice.ModelProviderEnum
> = core.serialization.enum_([
    "GROQ",
    "OPEN_AI",
    "FIREWORKS",
    "ANTHROPIC",
    "CUSTOM_LANGUAGE_MODEL",
    "GOOGLE",
    "HUME_AI",
    "AMAZON_BEDROCK",
    "PERPLEXITY",
    "SAMBANOVA",
    "CEREBRAS",
]);

export declare namespace ModelProviderEnum {
    export type Raw =
        | "GROQ"
        | "OPEN_AI"
        | "FIREWORKS"
        | "ANTHROPIC"
        | "CUSTOM_LANGUAGE_MODEL"
        | "GOOGLE"
        | "HUME_AI"
        | "AMAZON_BEDROCK"
        | "PERPLEXITY"
        | "SAMBANOVA"
        | "CEREBRAS";
}

```


## /src/serialization/resources/empathicVoice/types/PauseAssistantMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PauseAssistantMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.PauseAssistantMessage.Raw,
    Hume.empathicVoice.PauseAssistantMessage
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    type: core.serialization.stringLiteral("pause_assistant_message"),
});

export declare namespace PauseAssistantMessage {
    export interface Raw {
        custom_session_id?: string | null;
        type: "pause_assistant_message";
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedBuiltinTool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedBuiltinToolName } from "./PostedBuiltinToolName.js";

export const PostedBuiltinTool: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedBuiltinTool.Raw,
    Hume.empathicVoice.PostedBuiltinTool
> = core.serialization.object({
    fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
    name: PostedBuiltinToolName,
});

export declare namespace PostedBuiltinTool {
    export interface Raw {
        fallback_content?: string | null;
        name: PostedBuiltinToolName.Raw;
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedBuiltinToolName.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedBuiltinToolName: core.serialization.Schema<
    serializers.empathicVoice.PostedBuiltinToolName.Raw,
    Hume.empathicVoice.PostedBuiltinToolName
> = core.serialization.enum_(["web_search", "hang_up"]);

export declare namespace PostedBuiltinToolName {
    export type Raw = "web_search" | "hang_up";
}

```


## /src/serialization/resources/empathicVoice/types/PostedConfigPromptSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedConfigPromptSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedConfigPromptSpec.Raw,
    Hume.empathicVoice.PostedConfigPromptSpec
> = core.serialization.object({
    id: core.serialization.string().optional(),
    text: core.serialization.string().optional(),
    version: core.serialization.number().optional(),
});

export declare namespace PostedConfigPromptSpec {
    export interface Raw {
        id?: string | null;
        text?: string | null;
        version?: number | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedEllmModel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedEllmModel: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedEllmModel.Raw,
    Hume.empathicVoice.PostedEllmModel
> = core.serialization.object({
    allowShortResponses: core.serialization.property("allow_short_responses", core.serialization.boolean().optional()),
});

export declare namespace PostedEllmModel {
    export interface Raw {
        allow_short_responses?: boolean | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedEventMessageSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedEventMessageSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedEventMessageSpec.Raw,
    Hume.empathicVoice.PostedEventMessageSpec
> = core.serialization.object({
    enabled: core.serialization.boolean(),
    text: core.serialization.string().optional(),
});

export declare namespace PostedEventMessageSpec {
    export interface Raw {
        enabled: boolean;
        text?: string | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedEventMessageSpecs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedEventMessageSpec } from "./PostedEventMessageSpec.js";

export const PostedEventMessageSpecs: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedEventMessageSpecs.Raw,
    Hume.empathicVoice.PostedEventMessageSpecs
> = core.serialization.object({
    onInactivityTimeout: core.serialization.property("on_inactivity_timeout", PostedEventMessageSpec.optional()),
    onMaxDurationTimeout: core.serialization.property("on_max_duration_timeout", PostedEventMessageSpec.optional()),
    onNewChat: core.serialization.property("on_new_chat", PostedEventMessageSpec.optional()),
});

export declare namespace PostedEventMessageSpecs {
    export interface Raw {
        on_inactivity_timeout?: PostedEventMessageSpec.Raw | null;
        on_max_duration_timeout?: PostedEventMessageSpec.Raw | null;
        on_new_chat?: PostedEventMessageSpec.Raw | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedLanguageModel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { LanguageModelType } from "./LanguageModelType.js";
import { ModelProviderEnum } from "./ModelProviderEnum.js";

export const PostedLanguageModel: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedLanguageModel.Raw,
    Hume.empathicVoice.PostedLanguageModel
> = core.serialization.object({
    modelProvider: core.serialization.property("model_provider", ModelProviderEnum.optional()),
    modelResource: core.serialization.property("model_resource", LanguageModelType.optional()),
    temperature: core.serialization.number().optional(),
});

export declare namespace PostedLanguageModel {
    export interface Raw {
        model_provider?: ModelProviderEnum.Raw | null;
        model_resource?: LanguageModelType.Raw | null;
        temperature?: number | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedNudgeSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedNudgeSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedNudgeSpec.Raw,
    Hume.empathicVoice.PostedNudgeSpec
> = core.serialization.object({
    enabled: core.serialization.boolean().optional(),
    intervalSecs: core.serialization.property("interval_secs", core.serialization.number().optional()),
});

export declare namespace PostedNudgeSpec {
    export interface Raw {
        enabled?: boolean | null;
        interval_secs?: number | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedTimeoutSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedTimeoutSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedTimeoutSpec.Raw,
    Hume.empathicVoice.PostedTimeoutSpec
> = core.serialization.object({
    durationSecs: core.serialization.property("duration_secs", core.serialization.number().optional()),
    enabled: core.serialization.boolean(),
});

export declare namespace PostedTimeoutSpec {
    export interface Raw {
        duration_secs?: number | null;
        enabled: boolean;
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedTimeoutSpecs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedTimeoutSpecsInactivity } from "./PostedTimeoutSpecsInactivity.js";
import { PostedTimeoutSpecsMaxDuration } from "./PostedTimeoutSpecsMaxDuration.js";

export const PostedTimeoutSpecs: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedTimeoutSpecs.Raw,
    Hume.empathicVoice.PostedTimeoutSpecs
> = core.serialization.object({
    inactivity: PostedTimeoutSpecsInactivity.optional(),
    maxDuration: core.serialization.property("max_duration", PostedTimeoutSpecsMaxDuration.optional()),
});

export declare namespace PostedTimeoutSpecs {
    export interface Raw {
        inactivity?: PostedTimeoutSpecsInactivity.Raw | null;
        max_duration?: PostedTimeoutSpecsMaxDuration.Raw | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedTimeoutSpecsInactivity.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedTimeoutSpecsInactivity: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedTimeoutSpecsInactivity.Raw,
    Hume.empathicVoice.PostedTimeoutSpecsInactivity
> = core.serialization.object({
    durationSecs: core.serialization.property("duration_secs", core.serialization.number().optional()),
    enabled: core.serialization.boolean(),
});

export declare namespace PostedTimeoutSpecsInactivity {
    export interface Raw {
        duration_secs?: number | null;
        enabled: boolean;
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedTimeoutSpecsMaxDuration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedTimeoutSpecsMaxDuration: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedTimeoutSpecsMaxDuration.Raw,
    Hume.empathicVoice.PostedTimeoutSpecsMaxDuration
> = core.serialization.object({
    durationSecs: core.serialization.property("duration_secs", core.serialization.number().optional()),
    enabled: core.serialization.boolean(),
});

export declare namespace PostedTimeoutSpecsMaxDuration {
    export interface Raw {
        duration_secs?: number | null;
        enabled: boolean;
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedUserDefinedToolSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedUserDefinedToolSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedUserDefinedToolSpec.Raw,
    Hume.empathicVoice.PostedUserDefinedToolSpec
> = core.serialization.object({
    id: core.serialization.string(),
    version: core.serialization.number().optional(),
});

export declare namespace PostedUserDefinedToolSpec {
    export interface Raw {
        id: string;
        version?: number | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/PostedWebhookEventType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedWebhookEventType: core.serialization.Schema<
    serializers.empathicVoice.PostedWebhookEventType.Raw,
    Hume.empathicVoice.PostedWebhookEventType
> = core.serialization.enum_(["chat_started", "chat_ended", "tool_call"]);

export declare namespace PostedWebhookEventType {
    export type Raw = "chat_started" | "chat_ended" | "tool_call";
}

```


## /src/serialization/resources/empathicVoice/types/PostedWebhookSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedWebhookEventType } from "./PostedWebhookEventType.js";

export const PostedWebhookSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedWebhookSpec.Raw,
    Hume.empathicVoice.PostedWebhookSpec
> = core.serialization.object({
    events: core.serialization.list(PostedWebhookEventType),
    url: core.serialization.string(),
});

export declare namespace PostedWebhookSpec {
    export interface Raw {
        events: PostedWebhookEventType.Raw[];
        url: string;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ProsodyInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { EmotionScores } from "./EmotionScores.js";

export const ProsodyInference: core.serialization.ObjectSchema<
    serializers.empathicVoice.ProsodyInference.Raw,
    Hume.empathicVoice.ProsodyInference
> = core.serialization.object({
    scores: EmotionScores,
});

export declare namespace ProsodyInference {
    export interface Raw {
        scores: EmotionScores.Raw;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ResumeAssistantMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ResumeAssistantMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.ResumeAssistantMessage.Raw,
    Hume.empathicVoice.ResumeAssistantMessage
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    type: core.serialization.stringLiteral("resume_assistant_message"),
});

export declare namespace ResumeAssistantMessage {
    export interface Raw {
        custom_session_id?: string | null;
        type: "resume_assistant_message";
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnBuiltinTool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnBuiltinToolToolType } from "./ReturnBuiltinToolToolType.js";

export const ReturnBuiltinTool: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnBuiltinTool.Raw,
    Hume.empathicVoice.ReturnBuiltinTool
> = core.serialization.object({
    fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
    name: core.serialization.string(),
    toolType: core.serialization.property("tool_type", ReturnBuiltinToolToolType),
});

export declare namespace ReturnBuiltinTool {
    export interface Raw {
        fallback_content?: string | null;
        name: string;
        tool_type: ReturnBuiltinToolToolType.Raw;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnBuiltinToolToolType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnBuiltinToolToolType: core.serialization.Schema<
    serializers.empathicVoice.ReturnBuiltinToolToolType.Raw,
    Hume.empathicVoice.ReturnBuiltinToolToolType
> = core.serialization.enum_(["BUILTIN", "FUNCTION"]);

export declare namespace ReturnBuiltinToolToolType {
    export type Raw = "BUILTIN" | "FUNCTION";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChat.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatStatus } from "./ReturnChatStatus.js";
import { ReturnConfigSpec } from "./ReturnConfigSpec.js";

export const ReturnChat: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChat.Raw,
    Hume.empathicVoice.ReturnChat
> = core.serialization.object({
    chatGroupId: core.serialization.property("chat_group_id", core.serialization.string()),
    config: ReturnConfigSpec.optional(),
    endTimestamp: core.serialization.property("end_timestamp", core.serialization.number().optional()),
    eventCount: core.serialization.property("event_count", core.serialization.number().optional()),
    id: core.serialization.string(),
    metadata: core.serialization.string().optional(),
    startTimestamp: core.serialization.property("start_timestamp", core.serialization.number()),
    status: ReturnChatStatus,
});

export declare namespace ReturnChat {
    export interface Raw {
        chat_group_id: string;
        config?: ReturnConfigSpec.Raw | null;
        end_timestamp?: number | null;
        event_count?: number | null;
        id: string;
        metadata?: string | null;
        start_timestamp: number;
        status: ReturnChatStatus.Raw;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatAudioReconstruction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatAudioReconstructionStatus } from "./ReturnChatAudioReconstructionStatus.js";

export const ReturnChatAudioReconstruction: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatAudioReconstruction.Raw,
    Hume.empathicVoice.ReturnChatAudioReconstruction
> = core.serialization.object({
    filename: core.serialization.string().optional(),
    id: core.serialization.string(),
    modifiedAt: core.serialization.property("modified_at", core.serialization.number().optional()),
    signedAudioUrl: core.serialization.property("signed_audio_url", core.serialization.string().optional()),
    signedUrlExpirationTimestampMillis: core.serialization.property(
        "signed_url_expiration_timestamp_millis",
        core.serialization.number().optional(),
    ),
    status: ReturnChatAudioReconstructionStatus,
    userId: core.serialization.property("user_id", core.serialization.string()),
});

export declare namespace ReturnChatAudioReconstruction {
    export interface Raw {
        filename?: string | null;
        id: string;
        modified_at?: number | null;
        signed_audio_url?: string | null;
        signed_url_expiration_timestamp_millis?: number | null;
        status: ReturnChatAudioReconstructionStatus.Raw;
        user_id: string;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatAudioReconstructionStatus.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatAudioReconstructionStatus: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatAudioReconstructionStatus.Raw,
    Hume.empathicVoice.ReturnChatAudioReconstructionStatus
> = core.serialization.enum_(["QUEUED", "IN_PROGRESS", "COMPLETE", "ERROR", "CANCELLED"]);

export declare namespace ReturnChatAudioReconstructionStatus {
    export type Raw = "QUEUED" | "IN_PROGRESS" | "COMPLETE" | "ERROR" | "CANCELLED";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatEvent.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatEventRole } from "./ReturnChatEventRole.js";
import { ReturnChatEventType } from "./ReturnChatEventType.js";

export const ReturnChatEvent: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatEvent.Raw,
    Hume.empathicVoice.ReturnChatEvent
> = core.serialization.object({
    chatId: core.serialization.property("chat_id", core.serialization.string()),
    emotionFeatures: core.serialization.property("emotion_features", core.serialization.string().optional()),
    id: core.serialization.string(),
    messageText: core.serialization.property("message_text", core.serialization.string().optional()),
    metadata: core.serialization.string().optional(),
    relatedEventId: core.serialization.property("related_event_id", core.serialization.string().optional()),
    role: ReturnChatEventRole,
    timestamp: core.serialization.number(),
    type: ReturnChatEventType,
});

export declare namespace ReturnChatEvent {
    export interface Raw {
        chat_id: string;
        emotion_features?: string | null;
        id: string;
        message_text?: string | null;
        metadata?: string | null;
        related_event_id?: string | null;
        role: ReturnChatEventRole.Raw;
        timestamp: number;
        type: ReturnChatEventType.Raw;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatEventRole.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatEventRole: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatEventRole.Raw,
    Hume.empathicVoice.ReturnChatEventRole
> = core.serialization.enum_(["USER", "AGENT", "SYSTEM", "TOOL"]);

export declare namespace ReturnChatEventRole {
    export type Raw = "USER" | "AGENT" | "SYSTEM" | "TOOL";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatEventType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatEventType: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatEventType.Raw,
    Hume.empathicVoice.ReturnChatEventType
> = core.serialization.enum_([
    "FUNCTION_CALL",
    "FUNCTION_CALL_RESPONSE",
    "CHAT_END_MESSAGE",
    "AGENT_MESSAGE",
    "SYSTEM_PROMPT",
    "USER_RECORDING_START_MESSAGE",
    "RESUME_ONSET",
    "USER_INTERRUPTION",
    "CHAT_START_MESSAGE",
    "PAUSE_ONSET",
    "USER_MESSAGE",
]);

export declare namespace ReturnChatEventType {
    export type Raw =
        | "FUNCTION_CALL"
        | "FUNCTION_CALL_RESPONSE"
        | "CHAT_END_MESSAGE"
        | "AGENT_MESSAGE"
        | "SYSTEM_PROMPT"
        | "USER_RECORDING_START_MESSAGE"
        | "RESUME_ONSET"
        | "USER_INTERRUPTION"
        | "CHAT_START_MESSAGE"
        | "PAUSE_ONSET"
        | "USER_MESSAGE";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatGroup.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnConfigSpec } from "./ReturnConfigSpec.js";

export const ReturnChatGroup: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatGroup.Raw,
    Hume.empathicVoice.ReturnChatGroup
> = core.serialization.object({
    active: core.serialization.boolean().optional(),
    firstStartTimestamp: core.serialization.property("first_start_timestamp", core.serialization.number()),
    id: core.serialization.string(),
    mostRecentChatId: core.serialization.property("most_recent_chat_id", core.serialization.string().optional()),
    mostRecentConfig: core.serialization.property("most_recent_config", ReturnConfigSpec.optional()),
    mostRecentStartTimestamp: core.serialization.property("most_recent_start_timestamp", core.serialization.number()),
    numChats: core.serialization.property("num_chats", core.serialization.number()),
});

export declare namespace ReturnChatGroup {
    export interface Raw {
        active?: boolean | null;
        first_start_timestamp: number;
        id: string;
        most_recent_chat_id?: string | null;
        most_recent_config?: ReturnConfigSpec.Raw | null;
        most_recent_start_timestamp: number;
        num_chats: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedAudioReconstructions.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatAudioReconstruction } from "./ReturnChatAudioReconstruction.js";
import { ReturnChatGroupPagedAudioReconstructionsPaginationDirection } from "./ReturnChatGroupPagedAudioReconstructionsPaginationDirection.js";

export const ReturnChatGroupPagedAudioReconstructions: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatGroupPagedAudioReconstructions.Raw,
    Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructions
> = core.serialization.object({
    audioReconstructionsPage: core.serialization.property(
        "audio_reconstructions_page",
        core.serialization.list(ReturnChatAudioReconstruction),
    ),
    id: core.serialization.string(),
    numChats: core.serialization.property("num_chats", core.serialization.number()),
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    paginationDirection: core.serialization.property(
        "pagination_direction",
        ReturnChatGroupPagedAudioReconstructionsPaginationDirection,
    ),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
    userId: core.serialization.property("user_id", core.serialization.string()),
});

export declare namespace ReturnChatGroupPagedAudioReconstructions {
    export interface Raw {
        audio_reconstructions_page: ReturnChatAudioReconstruction.Raw[];
        id: string;
        num_chats: number;
        page_number: number;
        page_size: number;
        pagination_direction: ReturnChatGroupPagedAudioReconstructionsPaginationDirection.Raw;
        total_pages: number;
        user_id: string;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedAudioReconstructionsPaginationDirection.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatGroupPagedAudioReconstructionsPaginationDirection: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatGroupPagedAudioReconstructionsPaginationDirection.Raw,
    Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructionsPaginationDirection
> = core.serialization.enum_(["ASC", "DESC"]);

export declare namespace ReturnChatGroupPagedAudioReconstructionsPaginationDirection {
    export type Raw = "ASC" | "DESC";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedChats.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChat } from "./ReturnChat.js";
import { ReturnChatGroupPagedChatsPaginationDirection } from "./ReturnChatGroupPagedChatsPaginationDirection.js";

export const ReturnChatGroupPagedChats: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatGroupPagedChats.Raw,
    Hume.empathicVoice.ReturnChatGroupPagedChats
> = core.serialization.object({
    active: core.serialization.boolean().optional(),
    chatsPage: core.serialization.property("chats_page", core.serialization.list(ReturnChat)),
    firstStartTimestamp: core.serialization.property("first_start_timestamp", core.serialization.number()),
    id: core.serialization.string(),
    mostRecentStartTimestamp: core.serialization.property("most_recent_start_timestamp", core.serialization.number()),
    numChats: core.serialization.property("num_chats", core.serialization.number()),
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    paginationDirection: core.serialization.property(
        "pagination_direction",
        ReturnChatGroupPagedChatsPaginationDirection,
    ),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnChatGroupPagedChats {
    export interface Raw {
        active?: boolean | null;
        chats_page: ReturnChat.Raw[];
        first_start_timestamp: number;
        id: string;
        most_recent_start_timestamp: number;
        num_chats: number;
        page_number: number;
        page_size: number;
        pagination_direction: ReturnChatGroupPagedChatsPaginationDirection.Raw;
        total_pages: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedChatsPaginationDirection.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatGroupPagedChatsPaginationDirection: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatGroupPagedChatsPaginationDirection.Raw,
    Hume.empathicVoice.ReturnChatGroupPagedChatsPaginationDirection
> = core.serialization.enum_(["ASC", "DESC"]);

export declare namespace ReturnChatGroupPagedChatsPaginationDirection {
    export type Raw = "ASC" | "DESC";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedEvents.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatEvent } from "./ReturnChatEvent.js";
import { ReturnChatGroupPagedEventsPaginationDirection } from "./ReturnChatGroupPagedEventsPaginationDirection.js";

export const ReturnChatGroupPagedEvents: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatGroupPagedEvents.Raw,
    Hume.empathicVoice.ReturnChatGroupPagedEvents
> = core.serialization.object({
    eventsPage: core.serialization.property("events_page", core.serialization.list(ReturnChatEvent)),
    id: core.serialization.string(),
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    paginationDirection: core.serialization.property(
        "pagination_direction",
        ReturnChatGroupPagedEventsPaginationDirection,
    ),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnChatGroupPagedEvents {
    export interface Raw {
        events_page: ReturnChatEvent.Raw[];
        id: string;
        page_number: number;
        page_size: number;
        pagination_direction: ReturnChatGroupPagedEventsPaginationDirection.Raw;
        total_pages: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedEventsPaginationDirection.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatGroupPagedEventsPaginationDirection: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatGroupPagedEventsPaginationDirection.Raw,
    Hume.empathicVoice.ReturnChatGroupPagedEventsPaginationDirection
> = core.serialization.enum_(["ASC", "DESC"]);

export declare namespace ReturnChatGroupPagedEventsPaginationDirection {
    export type Raw = "ASC" | "DESC";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatPagedEvents.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatEvent } from "./ReturnChatEvent.js";
import { ReturnChatPagedEventsPaginationDirection } from "./ReturnChatPagedEventsPaginationDirection.js";
import { ReturnChatPagedEventsStatus } from "./ReturnChatPagedEventsStatus.js";
import { ReturnConfigSpec } from "./ReturnConfigSpec.js";

export const ReturnChatPagedEvents: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatPagedEvents.Raw,
    Hume.empathicVoice.ReturnChatPagedEvents
> = core.serialization.object({
    chatGroupId: core.serialization.property("chat_group_id", core.serialization.string()),
    config: ReturnConfigSpec.optional(),
    endTimestamp: core.serialization.property("end_timestamp", core.serialization.number().optional()),
    eventsPage: core.serialization.property("events_page", core.serialization.list(ReturnChatEvent)),
    id: core.serialization.string(),
    metadata: core.serialization.string().optional(),
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    paginationDirection: core.serialization.property("pagination_direction", ReturnChatPagedEventsPaginationDirection),
    startTimestamp: core.serialization.property("start_timestamp", core.serialization.number()),
    status: ReturnChatPagedEventsStatus,
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnChatPagedEvents {
    export interface Raw {
        chat_group_id: string;
        config?: ReturnConfigSpec.Raw | null;
        end_timestamp?: number | null;
        events_page: ReturnChatEvent.Raw[];
        id: string;
        metadata?: string | null;
        page_number: number;
        page_size: number;
        pagination_direction: ReturnChatPagedEventsPaginationDirection.Raw;
        start_timestamp: number;
        status: ReturnChatPagedEventsStatus.Raw;
        total_pages: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatPagedEventsPaginationDirection.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatPagedEventsPaginationDirection: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatPagedEventsPaginationDirection.Raw,
    Hume.empathicVoice.ReturnChatPagedEventsPaginationDirection
> = core.serialization.enum_(["ASC", "DESC"]);

export declare namespace ReturnChatPagedEventsPaginationDirection {
    export type Raw = "ASC" | "DESC";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatPagedEventsStatus.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatPagedEventsStatus: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatPagedEventsStatus.Raw,
    Hume.empathicVoice.ReturnChatPagedEventsStatus
> = core.serialization.enum_([
    "ACTIVE",
    "USER_ENDED",
    "USER_TIMEOUT",
    "MAX_DURATION_TIMEOUT",
    "INACTIVITY_TIMEOUT",
    "ERROR",
]);

export declare namespace ReturnChatPagedEventsStatus {
    export type Raw =
        | "ACTIVE"
        | "USER_ENDED"
        | "USER_TIMEOUT"
        | "MAX_DURATION_TIMEOUT"
        | "INACTIVITY_TIMEOUT"
        | "ERROR";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnChatStatus.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatStatus: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatStatus.Raw,
    Hume.empathicVoice.ReturnChatStatus
> = core.serialization.enum_([
    "ACTIVE",
    "USER_ENDED",
    "USER_TIMEOUT",
    "MAX_DURATION_TIMEOUT",
    "INACTIVITY_TIMEOUT",
    "ERROR",
]);

export declare namespace ReturnChatStatus {
    export type Raw =
        | "ACTIVE"
        | "USER_ENDED"
        | "USER_TIMEOUT"
        | "MAX_DURATION_TIMEOUT"
        | "INACTIVITY_TIMEOUT"
        | "ERROR";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnConfig.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnBuiltinTool } from "./ReturnBuiltinTool.js";
import { ReturnEllmModel } from "./ReturnEllmModel.js";
import { ReturnEventMessageSpecs } from "./ReturnEventMessageSpecs.js";
import { ReturnLanguageModel } from "./ReturnLanguageModel.js";
import { ReturnNudgeSpec } from "./ReturnNudgeSpec.js";
import { ReturnPrompt } from "./ReturnPrompt.js";
import { ReturnTimeoutSpecs } from "./ReturnTimeoutSpecs.js";
import { ReturnUserDefinedTool } from "./ReturnUserDefinedTool.js";
import { ReturnVoice } from "./ReturnVoice.js";
import { ReturnWebhookSpec } from "./ReturnWebhookSpec.js";

export const ReturnConfig: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnConfig.Raw,
    Hume.empathicVoice.ReturnConfig
> = core.serialization.object({
    builtinTools: core.serialization.property(
        "builtin_tools",
        core.serialization.list(ReturnBuiltinTool.optional()).optional(),
    ),
    createdOn: core.serialization.property("created_on", core.serialization.number().optional()),
    ellmModel: core.serialization.property("ellm_model", ReturnEllmModel.optional()),
    eventMessages: core.serialization.property("event_messages", ReturnEventMessageSpecs.optional()),
    eviVersion: core.serialization.property("evi_version", core.serialization.string().optional()),
    id: core.serialization.string().optional(),
    languageModel: core.serialization.property("language_model", ReturnLanguageModel.optional()),
    modifiedOn: core.serialization.property("modified_on", core.serialization.number().optional()),
    name: core.serialization.string().optional(),
    nudges: ReturnNudgeSpec.optional(),
    prompt: ReturnPrompt.optional(),
    timeouts: ReturnTimeoutSpecs.optional(),
    tools: core.serialization.list(ReturnUserDefinedTool.optional()).optional(),
    version: core.serialization.number().optional(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
    voice: ReturnVoice.optional(),
    webhooks: core.serialization.list(ReturnWebhookSpec.optional()).optional(),
});

export declare namespace ReturnConfig {
    export interface Raw {
        builtin_tools?: (ReturnBuiltinTool.Raw | null | undefined)[] | null;
        created_on?: number | null;
        ellm_model?: ReturnEllmModel.Raw | null;
        event_messages?: ReturnEventMessageSpecs.Raw | null;
        evi_version?: string | null;
        id?: string | null;
        language_model?: ReturnLanguageModel.Raw | null;
        modified_on?: number | null;
        name?: string | null;
        nudges?: ReturnNudgeSpec.Raw | null;
        prompt?: ReturnPrompt.Raw | null;
        timeouts?: ReturnTimeoutSpecs.Raw | null;
        tools?: (ReturnUserDefinedTool.Raw | null | undefined)[] | null;
        version?: number | null;
        version_description?: string | null;
        voice?: ReturnVoice.Raw | null;
        webhooks?: (ReturnWebhookSpec.Raw | null | undefined)[] | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnConfigSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnConfigSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnConfigSpec.Raw,
    Hume.empathicVoice.ReturnConfigSpec
> = core.serialization.object({
    id: core.serialization.string(),
    version: core.serialization.number().optional(),
});

export declare namespace ReturnConfigSpec {
    export interface Raw {
        id: string;
        version?: number | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnEllmModel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnEllmModel: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnEllmModel.Raw,
    Hume.empathicVoice.ReturnEllmModel
> = core.serialization.object({
    allowShortResponses: core.serialization.property("allow_short_responses", core.serialization.boolean()),
});

export declare namespace ReturnEllmModel {
    export interface Raw {
        allow_short_responses: boolean;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnEventMessageSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnEventMessageSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnEventMessageSpec.Raw,
    Hume.empathicVoice.ReturnEventMessageSpec
> = core.serialization.object({
    enabled: core.serialization.boolean(),
    text: core.serialization.string().optional(),
});

export declare namespace ReturnEventMessageSpec {
    export interface Raw {
        enabled: boolean;
        text?: string | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnEventMessageSpecs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnEventMessageSpec } from "./ReturnEventMessageSpec.js";

export const ReturnEventMessageSpecs: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnEventMessageSpecs.Raw,
    Hume.empathicVoice.ReturnEventMessageSpecs
> = core.serialization.object({
    onInactivityTimeout: core.serialization.property("on_inactivity_timeout", ReturnEventMessageSpec.optional()),
    onMaxDurationTimeout: core.serialization.property("on_max_duration_timeout", ReturnEventMessageSpec.optional()),
    onNewChat: core.serialization.property("on_new_chat", ReturnEventMessageSpec.optional()),
});

export declare namespace ReturnEventMessageSpecs {
    export interface Raw {
        on_inactivity_timeout?: ReturnEventMessageSpec.Raw | null;
        on_max_duration_timeout?: ReturnEventMessageSpec.Raw | null;
        on_new_chat?: ReturnEventMessageSpec.Raw | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnLanguageModel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { LanguageModelType } from "./LanguageModelType.js";
import { ModelProviderEnum } from "./ModelProviderEnum.js";

export const ReturnLanguageModel: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnLanguageModel.Raw,
    Hume.empathicVoice.ReturnLanguageModel
> = core.serialization.object({
    modelProvider: core.serialization.property("model_provider", ModelProviderEnum.optional()),
    modelResource: core.serialization.property("model_resource", LanguageModelType.optional()),
    temperature: core.serialization.number().optional(),
});

export declare namespace ReturnLanguageModel {
    export interface Raw {
        model_provider?: ModelProviderEnum.Raw | null;
        model_resource?: LanguageModelType.Raw | null;
        temperature?: number | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnNudgeSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnNudgeSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnNudgeSpec.Raw,
    Hume.empathicVoice.ReturnNudgeSpec
> = core.serialization.object({
    enabled: core.serialization.boolean(),
    intervalSecs: core.serialization.property("interval_secs", core.serialization.number().optional()),
});

export declare namespace ReturnNudgeSpec {
    export interface Raw {
        enabled: boolean;
        interval_secs?: number | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnPagedChatGroups.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatGroup } from "./ReturnChatGroup.js";
import { ReturnPagedChatGroupsPaginationDirection } from "./ReturnPagedChatGroupsPaginationDirection.js";

export const ReturnPagedChatGroups: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnPagedChatGroups.Raw,
    Hume.empathicVoice.ReturnPagedChatGroups
> = core.serialization.object({
    chatGroupsPage: core.serialization.property("chat_groups_page", core.serialization.list(ReturnChatGroup)),
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    paginationDirection: core.serialization.property("pagination_direction", ReturnPagedChatGroupsPaginationDirection),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnPagedChatGroups {
    export interface Raw {
        chat_groups_page: ReturnChatGroup.Raw[];
        page_number: number;
        page_size: number;
        pagination_direction: ReturnPagedChatGroupsPaginationDirection.Raw;
        total_pages: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnPagedChatGroupsPaginationDirection.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnPagedChatGroupsPaginationDirection: core.serialization.Schema<
    serializers.empathicVoice.ReturnPagedChatGroupsPaginationDirection.Raw,
    Hume.empathicVoice.ReturnPagedChatGroupsPaginationDirection
> = core.serialization.enum_(["ASC", "DESC"]);

export declare namespace ReturnPagedChatGroupsPaginationDirection {
    export type Raw = "ASC" | "DESC";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnPagedChats.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChat } from "./ReturnChat.js";
import { ReturnPagedChatsPaginationDirection } from "./ReturnPagedChatsPaginationDirection.js";

export const ReturnPagedChats: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnPagedChats.Raw,
    Hume.empathicVoice.ReturnPagedChats
> = core.serialization.object({
    chatsPage: core.serialization.property("chats_page", core.serialization.list(ReturnChat)),
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    paginationDirection: core.serialization.property("pagination_direction", ReturnPagedChatsPaginationDirection),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnPagedChats {
    export interface Raw {
        chats_page: ReturnChat.Raw[];
        page_number: number;
        page_size: number;
        pagination_direction: ReturnPagedChatsPaginationDirection.Raw;
        total_pages: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnPagedChatsPaginationDirection.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnPagedChatsPaginationDirection: core.serialization.Schema<
    serializers.empathicVoice.ReturnPagedChatsPaginationDirection.Raw,
    Hume.empathicVoice.ReturnPagedChatsPaginationDirection
> = core.serialization.enum_(["ASC", "DESC"]);

export declare namespace ReturnPagedChatsPaginationDirection {
    export type Raw = "ASC" | "DESC";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnPagedConfigs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnConfig } from "./ReturnConfig.js";

export const ReturnPagedConfigs: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnPagedConfigs.Raw,
    Hume.empathicVoice.ReturnPagedConfigs
> = core.serialization.object({
    configsPage: core.serialization.property("configs_page", core.serialization.list(ReturnConfig).optional()),
    pageNumber: core.serialization.property("page_number", core.serialization.number().optional()),
    pageSize: core.serialization.property("page_size", core.serialization.number().optional()),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnPagedConfigs {
    export interface Raw {
        configs_page?: ReturnConfig.Raw[] | null;
        page_number?: number | null;
        page_size?: number | null;
        total_pages: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnPagedPrompts.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnPrompt } from "./ReturnPrompt.js";

export const ReturnPagedPrompts: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnPagedPrompts.Raw,
    Hume.empathicVoice.ReturnPagedPrompts
> = core.serialization.object({
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    promptsPage: core.serialization.property("prompts_page", core.serialization.list(ReturnPrompt.optional())),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnPagedPrompts {
    export interface Raw {
        page_number: number;
        page_size: number;
        prompts_page: (ReturnPrompt.Raw | null | undefined)[];
        total_pages: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnPagedUserDefinedTools.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnUserDefinedTool } from "./ReturnUserDefinedTool.js";

export const ReturnPagedUserDefinedTools: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnPagedUserDefinedTools.Raw,
    Hume.empathicVoice.ReturnPagedUserDefinedTools
> = core.serialization.object({
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    toolsPage: core.serialization.property("tools_page", core.serialization.list(ReturnUserDefinedTool.optional())),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnPagedUserDefinedTools {
    export interface Raw {
        page_number: number;
        page_size: number;
        tools_page: (ReturnUserDefinedTool.Raw | null | undefined)[];
        total_pages: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnPrompt.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnPrompt: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnPrompt.Raw,
    Hume.empathicVoice.ReturnPrompt
> = core.serialization.object({
    createdOn: core.serialization.property("created_on", core.serialization.number()),
    id: core.serialization.string(),
    modifiedOn: core.serialization.property("modified_on", core.serialization.number()),
    name: core.serialization.string(),
    text: core.serialization.string(),
    version: core.serialization.number(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
    versionType: core.serialization.property("version_type", core.serialization.string()),
});

export declare namespace ReturnPrompt {
    export interface Raw {
        created_on: number;
        id: string;
        modified_on: number;
        name: string;
        text: string;
        version: number;
        version_description?: string | null;
        version_type: string;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnPromptVersionType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnPromptVersionType: core.serialization.Schema<
    serializers.empathicVoice.ReturnPromptVersionType.Raw,
    Hume.empathicVoice.ReturnPromptVersionType
> = core.serialization.enum_(["FIXED", "LATEST"]);

export declare namespace ReturnPromptVersionType {
    export type Raw = "FIXED" | "LATEST";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnTimeoutSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnTimeoutSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnTimeoutSpec.Raw,
    Hume.empathicVoice.ReturnTimeoutSpec
> = core.serialization.object({
    durationSecs: core.serialization.property("duration_secs", core.serialization.number().optional()),
    enabled: core.serialization.boolean(),
});

export declare namespace ReturnTimeoutSpec {
    export interface Raw {
        duration_secs?: number | null;
        enabled: boolean;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnTimeoutSpecs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnTimeoutSpec } from "./ReturnTimeoutSpec.js";

export const ReturnTimeoutSpecs: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnTimeoutSpecs.Raw,
    Hume.empathicVoice.ReturnTimeoutSpecs
> = core.serialization.object({
    inactivity: ReturnTimeoutSpec,
    maxDuration: core.serialization.property("max_duration", ReturnTimeoutSpec),
});

export declare namespace ReturnTimeoutSpecs {
    export interface Raw {
        inactivity: ReturnTimeoutSpec.Raw;
        max_duration: ReturnTimeoutSpec.Raw;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnUserDefinedTool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnUserDefinedToolToolType } from "./ReturnUserDefinedToolToolType.js";
import { ReturnUserDefinedToolVersionType } from "./ReturnUserDefinedToolVersionType.js";

export const ReturnUserDefinedTool: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnUserDefinedTool.Raw,
    Hume.empathicVoice.ReturnUserDefinedTool
> = core.serialization.object({
    createdOn: core.serialization.property("created_on", core.serialization.number()),
    description: core.serialization.string().optional(),
    fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
    id: core.serialization.string(),
    modifiedOn: core.serialization.property("modified_on", core.serialization.number()),
    name: core.serialization.string(),
    parameters: core.serialization.string(),
    toolType: core.serialization.property("tool_type", ReturnUserDefinedToolToolType),
    version: core.serialization.number(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
    versionType: core.serialization.property("version_type", ReturnUserDefinedToolVersionType),
});

export declare namespace ReturnUserDefinedTool {
    export interface Raw {
        created_on: number;
        description?: string | null;
        fallback_content?: string | null;
        id: string;
        modified_on: number;
        name: string;
        parameters: string;
        tool_type: ReturnUserDefinedToolToolType.Raw;
        version: number;
        version_description?: string | null;
        version_type: ReturnUserDefinedToolVersionType.Raw;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnUserDefinedToolToolType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnUserDefinedToolToolType: core.serialization.Schema<
    serializers.empathicVoice.ReturnUserDefinedToolToolType.Raw,
    Hume.empathicVoice.ReturnUserDefinedToolToolType
> = core.serialization.enum_(["BUILTIN", "FUNCTION"]);

export declare namespace ReturnUserDefinedToolToolType {
    export type Raw = "BUILTIN" | "FUNCTION";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnUserDefinedToolVersionType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnUserDefinedToolVersionType: core.serialization.Schema<
    serializers.empathicVoice.ReturnUserDefinedToolVersionType.Raw,
    Hume.empathicVoice.ReturnUserDefinedToolVersionType
> = core.serialization.enum_(["FIXED", "LATEST"]);

export declare namespace ReturnUserDefinedToolVersionType {
    export type Raw = "FIXED" | "LATEST";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnVoice.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceProvider } from "./VoiceProvider.js";

export const ReturnVoice: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnVoice.Raw,
    Hume.empathicVoice.ReturnVoice
> = core.serialization.object({
    compatibleOctaveModels: core.serialization.property(
        "compatible_octave_models",
        core.serialization.list(core.serialization.string()).optional(),
    ),
    id: core.serialization.string(),
    name: core.serialization.string(),
    provider: VoiceProvider,
});

export declare namespace ReturnVoice {
    export interface Raw {
        compatible_octave_models?: string[] | null;
        id: string;
        name: string;
        provider: VoiceProvider.Raw;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ReturnWebhookEventType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnWebhookEventType: core.serialization.Schema<
    serializers.empathicVoice.ReturnWebhookEventType.Raw,
    Hume.empathicVoice.ReturnWebhookEventType
> = core.serialization.enum_(["chat_started", "chat_ended", "tool_call"]);

export declare namespace ReturnWebhookEventType {
    export type Raw = "chat_started" | "chat_ended" | "tool_call";
}

```


## /src/serialization/resources/empathicVoice/types/ReturnWebhookSpec.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnWebhookEventType } from "./ReturnWebhookEventType.js";

export const ReturnWebhookSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnWebhookSpec.Raw,
    Hume.empathicVoice.ReturnWebhookSpec
> = core.serialization.object({
    events: core.serialization.list(ReturnWebhookEventType),
    url: core.serialization.string(),
});

export declare namespace ReturnWebhookSpec {
    export interface Raw {
        events: ReturnWebhookEventType.Raw[];
        url: string;
    }
}

```


## /src/serialization/resources/empathicVoice/types/Role.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const Role: core.serialization.Schema<serializers.empathicVoice.Role.Raw, Hume.empathicVoice.Role> =
    core.serialization.enum_(["assistant", "system", "user", "all", "tool", "context"]);

export declare namespace Role {
    export type Raw = "assistant" | "system" | "user" | "all" | "tool" | "context";
}

```


## /src/serialization/resources/empathicVoice/types/SessionSettings.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AudioConfiguration } from "./AudioConfiguration.js";
import { BuiltinToolConfig } from "./BuiltinToolConfig.js";
import { Context } from "./Context.js";
import { SessionSettingsVariablesValue } from "./SessionSettingsVariablesValue.js";
import { Tool } from "./Tool.js";

export const SessionSettings: core.serialization.ObjectSchema<
    serializers.empathicVoice.SessionSettings.Raw,
    Hume.empathicVoice.SessionSettings
> = core.serialization.object({
    audio: AudioConfiguration.optional(),
    builtinTools: core.serialization.property("builtin_tools", core.serialization.list(BuiltinToolConfig).optional()),
    context: Context.optional(),
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    languageModelApiKey: core.serialization.property("language_model_api_key", core.serialization.string().optional()),
    metadata: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    systemPrompt: core.serialization.property("system_prompt", core.serialization.string().optional()),
    tools: core.serialization.list(Tool).optional(),
    type: core.serialization.stringLiteral("session_settings"),
    variables: core.serialization.record(core.serialization.string(), SessionSettingsVariablesValue).optional(),
    voiceId: core.serialization.property("voice_id", core.serialization.string().optional()),
});

export declare namespace SessionSettings {
    export interface Raw {
        audio?: AudioConfiguration.Raw | null;
        builtin_tools?: BuiltinToolConfig.Raw[] | null;
        context?: Context.Raw | null;
        custom_session_id?: string | null;
        language_model_api_key?: string | null;
        metadata?: Record<string, unknown> | null;
        system_prompt?: string | null;
        tools?: Tool.Raw[] | null;
        type: "session_settings";
        variables?: Record<string, SessionSettingsVariablesValue.Raw> | null;
        voice_id?: string | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/SessionSettingsVariablesValue.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const SessionSettingsVariablesValue: core.serialization.Schema<
    serializers.empathicVoice.SessionSettingsVariablesValue.Raw,
    Hume.empathicVoice.SessionSettingsVariablesValue
> = core.serialization.undiscriminatedUnion([
    core.serialization.string(),
    core.serialization.number(),
    core.serialization.boolean(),
]);

export declare namespace SessionSettingsVariablesValue {
    export type Raw = string | number | boolean;
}

```


## /src/serialization/resources/empathicVoice/types/SubscribeEvent.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AssistantEnd } from "./AssistantEnd.js";
import { AssistantMessage } from "./AssistantMessage.js";
import { AssistantProsody } from "./AssistantProsody.js";
import { AudioOutput } from "./AudioOutput.js";
import { ChatMetadata } from "./ChatMetadata.js";
import { SessionSettings } from "./SessionSettings.js";
import { ToolCallMessage } from "./ToolCallMessage.js";
import { ToolErrorMessage } from "./ToolErrorMessage.js";
import { ToolResponseMessage } from "./ToolResponseMessage.js";
import { UserInterruption } from "./UserInterruption.js";
import { UserMessage } from "./UserMessage.js";
import { WebSocketError } from "./WebSocketError.js";

export const SubscribeEvent: core.serialization.Schema<
    serializers.empathicVoice.SubscribeEvent.Raw,
    Hume.empathicVoice.SubscribeEvent
> = core.serialization.undiscriminatedUnion([
    AssistantEnd,
    AssistantMessage,
    AssistantProsody,
    AudioOutput,
    ChatMetadata,
    WebSocketError,
    UserInterruption,
    UserMessage,
    ToolCallMessage,
    ToolResponseMessage,
    ToolErrorMessage,
    SessionSettings,
]);

export declare namespace SubscribeEvent {
    export type Raw =
        | AssistantEnd.Raw
        | AssistantMessage.Raw
        | AssistantProsody.Raw
        | AudioOutput.Raw
        | ChatMetadata.Raw
        | WebSocketError.Raw
        | UserInterruption.Raw
        | UserMessage.Raw
        | ToolCallMessage.Raw
        | ToolResponseMessage.Raw
        | ToolErrorMessage.Raw
        | SessionSettings.Raw;
}

```


## /src/serialization/resources/empathicVoice/types/Tool.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ToolType } from "./ToolType.js";

export const Tool: core.serialization.ObjectSchema<serializers.empathicVoice.Tool.Raw, Hume.empathicVoice.Tool> =
    core.serialization.object({
        description: core.serialization.string().optional(),
        fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
        name: core.serialization.string(),
        parameters: core.serialization.string(),
        type: ToolType,
    });

export declare namespace Tool {
    export interface Raw {
        description?: string | null;
        fallback_content?: string | null;
        name: string;
        parameters: string;
        type: ToolType.Raw;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ToolCallMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ToolType } from "./ToolType.js";

export const ToolCallMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.ToolCallMessage.Raw,
    Hume.empathicVoice.ToolCallMessage
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    name: core.serialization.string(),
    parameters: core.serialization.string(),
    responseRequired: core.serialization.property("response_required", core.serialization.boolean()),
    toolCallId: core.serialization.property("tool_call_id", core.serialization.string()),
    toolType: core.serialization.property("tool_type", ToolType),
    type: core.serialization.stringLiteral("tool_call"),
});

export declare namespace ToolCallMessage {
    export interface Raw {
        custom_session_id?: string | null;
        name: string;
        parameters: string;
        response_required: boolean;
        tool_call_id: string;
        tool_type: ToolType.Raw;
        type: "tool_call";
    }
}

```


## /src/serialization/resources/empathicVoice/types/ToolErrorMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ErrorLevel } from "./ErrorLevel.js";
import { ToolType } from "./ToolType.js";

export const ToolErrorMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.ToolErrorMessage.Raw,
    Hume.empathicVoice.ToolErrorMessage
> = core.serialization.object({
    code: core.serialization.string().optional(),
    content: core.serialization.string().optional(),
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    error: core.serialization.string(),
    level: ErrorLevel.optional(),
    toolCallId: core.serialization.property("tool_call_id", core.serialization.string()),
    toolType: core.serialization.property("tool_type", ToolType.optional()),
    type: core.serialization.stringLiteral("tool_error"),
});

export declare namespace ToolErrorMessage {
    export interface Raw {
        code?: string | null;
        content?: string | null;
        custom_session_id?: string | null;
        error: string;
        level?: ErrorLevel.Raw | null;
        tool_call_id: string;
        tool_type?: ToolType.Raw | null;
        type: "tool_error";
    }
}

```


## /src/serialization/resources/empathicVoice/types/ToolResponseMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ToolType } from "./ToolType.js";

export const ToolResponseMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.ToolResponseMessage.Raw,
    Hume.empathicVoice.ToolResponseMessage
> = core.serialization.object({
    content: core.serialization.string(),
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    toolCallId: core.serialization.property("tool_call_id", core.serialization.string()),
    toolName: core.serialization.property("tool_name", core.serialization.string().optional()),
    toolType: core.serialization.property("tool_type", ToolType.optional()),
    type: core.serialization.stringLiteral("tool_response"),
});

export declare namespace ToolResponseMessage {
    export interface Raw {
        content: string;
        custom_session_id?: string | null;
        tool_call_id: string;
        tool_name?: string | null;
        tool_type?: ToolType.Raw | null;
        type: "tool_response";
    }
}

```


## /src/serialization/resources/empathicVoice/types/ToolType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ToolType: core.serialization.Schema<serializers.empathicVoice.ToolType.Raw, Hume.empathicVoice.ToolType> =
    core.serialization.enum_(["builtin", "function"]);

export declare namespace ToolType {
    export type Raw = "builtin" | "function";
}

```


## /src/serialization/resources/empathicVoice/types/UserInput.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const UserInput: core.serialization.ObjectSchema<
    serializers.empathicVoice.UserInput.Raw,
    Hume.empathicVoice.UserInput
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    text: core.serialization.string(),
    type: core.serialization.stringLiteral("user_input"),
});

export declare namespace UserInput {
    export interface Raw {
        custom_session_id?: string | null;
        text: string;
        type: "user_input";
    }
}

```


## /src/serialization/resources/empathicVoice/types/UserInterruption.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const UserInterruption: core.serialization.ObjectSchema<
    serializers.empathicVoice.UserInterruption.Raw,
    Hume.empathicVoice.UserInterruption
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    time: core.serialization.number(),
    type: core.serialization.stringLiteral("user_interruption"),
});

export declare namespace UserInterruption {
    export interface Raw {
        custom_session_id?: string | null;
        time: number;
        type: "user_interruption";
    }
}

```


## /src/serialization/resources/empathicVoice/types/UserMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ChatMessage } from "./ChatMessage.js";
import { Inference } from "./Inference.js";
import { MillisecondInterval } from "./MillisecondInterval.js";

export const UserMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.UserMessage.Raw,
    Hume.empathicVoice.UserMessage
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    fromText: core.serialization.property("from_text", core.serialization.boolean()),
    interim: core.serialization.boolean(),
    language: core.serialization.string().optional(),
    message: ChatMessage,
    models: Inference,
    time: MillisecondInterval,
    type: core.serialization.stringLiteral("user_message"),
});

export declare namespace UserMessage {
    export interface Raw {
        custom_session_id?: string | null;
        from_text: boolean;
        interim: boolean;
        language?: string | null;
        message: ChatMessage.Raw;
        models: Inference.Raw;
        time: MillisecondInterval.Raw;
        type: "user_message";
    }
}

```


## /src/serialization/resources/empathicVoice/types/ValidationError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ValidationErrorLocItem } from "./ValidationErrorLocItem.js";

export const ValidationError: core.serialization.ObjectSchema<
    serializers.empathicVoice.ValidationError.Raw,
    Hume.empathicVoice.ValidationError
> = core.serialization.object({
    loc: core.serialization.list(ValidationErrorLocItem),
    msg: core.serialization.string(),
    type: core.serialization.string(),
});

export declare namespace ValidationError {
    export interface Raw {
        loc: ValidationErrorLocItem.Raw[];
        msg: string;
        type: string;
    }
}

```


## /src/serialization/resources/empathicVoice/types/ValidationErrorLocItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ValidationErrorLocItem: core.serialization.Schema<
    serializers.empathicVoice.ValidationErrorLocItem.Raw,
    Hume.empathicVoice.ValidationErrorLocItem
> = core.serialization.undiscriminatedUnion([core.serialization.string(), core.serialization.number()]);

export declare namespace ValidationErrorLocItem {
    export type Raw = string | number;
}

```


## /src/serialization/resources/empathicVoice/types/VoiceId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceProvider } from "./VoiceProvider.js";

export const VoiceId: core.serialization.ObjectSchema<
    serializers.empathicVoice.VoiceId.Raw,
    Hume.empathicVoice.VoiceId
> = core.serialization.object({
    id: core.serialization.string(),
    provider: VoiceProvider.optional(),
});

export declare namespace VoiceId {
    export interface Raw {
        id: string;
        provider?: VoiceProvider.Raw | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/VoiceName.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceProvider } from "./VoiceProvider.js";

export const VoiceName: core.serialization.ObjectSchema<
    serializers.empathicVoice.VoiceName.Raw,
    Hume.empathicVoice.VoiceName
> = core.serialization.object({
    name: core.serialization.string(),
    provider: VoiceProvider.optional(),
});

export declare namespace VoiceName {
    export interface Raw {
        name: string;
        provider?: VoiceProvider.Raw | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/VoiceProvider.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const VoiceProvider: core.serialization.Schema<
    serializers.empathicVoice.VoiceProvider.Raw,
    Hume.empathicVoice.VoiceProvider
> = core.serialization.enum_(["HUME_AI", "CUSTOM_VOICE"]);

export declare namespace VoiceProvider {
    export type Raw = "HUME_AI" | "CUSTOM_VOICE";
}

```


## /src/serialization/resources/empathicVoice/types/VoiceRef.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceId } from "./VoiceId.js";
import { VoiceName } from "./VoiceName.js";

export const VoiceRef: core.serialization.Schema<serializers.empathicVoice.VoiceRef.Raw, Hume.empathicVoice.VoiceRef> =
    core.serialization.undiscriminatedUnion([VoiceId, VoiceName]);

export declare namespace VoiceRef {
    export type Raw = VoiceId.Raw | VoiceName.Raw;
}

```


## /src/serialization/resources/empathicVoice/types/WebSocketError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const WebSocketError: core.serialization.ObjectSchema<
    serializers.empathicVoice.WebSocketError.Raw,
    Hume.empathicVoice.WebSocketError
> = core.serialization.object({
    code: core.serialization.string(),
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    message: core.serialization.string(),
    requestId: core.serialization.property("request_id", core.serialization.string().optional()),
    slug: core.serialization.string(),
    type: core.serialization.stringLiteral("error"),
});

export declare namespace WebSocketError {
    export interface Raw {
        code: string;
        custom_session_id?: string | null;
        message: string;
        request_id?: string | null;
        slug: string;
        type: "error";
    }
}

```


## /src/serialization/resources/empathicVoice/types/WebhookEvent.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { WebhookEventChatEnded } from "./WebhookEventChatEnded.js";
import { WebhookEventChatStarted } from "./WebhookEventChatStarted.js";
import { WebhookEventToolCall } from "./WebhookEventToolCall.js";

export const WebhookEvent: core.serialization.Schema<
    serializers.empathicVoice.WebhookEvent.Raw,
    Hume.empathicVoice.WebhookEvent
> = core.serialization.undiscriminatedUnion([WebhookEventChatStarted, WebhookEventChatEnded, WebhookEventToolCall]);

export declare namespace WebhookEvent {
    export type Raw = WebhookEventChatStarted.Raw | WebhookEventChatEnded.Raw | WebhookEventToolCall.Raw;
}

```


## /src/serialization/resources/empathicVoice/types/WebhookEventBase.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const WebhookEventBase: core.serialization.ObjectSchema<
    serializers.empathicVoice.WebhookEventBase.Raw,
    Hume.empathicVoice.WebhookEventBase
> = core.serialization.object({
    chatGroupId: core.serialization.property("chat_group_id", core.serialization.string()),
    chatId: core.serialization.property("chat_id", core.serialization.string()),
    configId: core.serialization.property("config_id", core.serialization.string().optional()),
});

export declare namespace WebhookEventBase {
    export interface Raw {
        chat_group_id: string;
        chat_id: string;
        config_id?: string | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/WebhookEventChatEnded.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { WebhookEventBase } from "./WebhookEventBase.js";
import { WebhookEventChatStatus } from "./WebhookEventChatStatus.js";

export const WebhookEventChatEnded: core.serialization.ObjectSchema<
    serializers.empathicVoice.WebhookEventChatEnded.Raw,
    Hume.empathicVoice.WebhookEventChatEnded
> = core.serialization
    .object({
        callerNumber: core.serialization.property("caller_number", core.serialization.string().optional()),
        customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
        durationSeconds: core.serialization.property("duration_seconds", core.serialization.number()),
        endReason: core.serialization.property("end_reason", WebhookEventChatStatus),
        endTime: core.serialization.property("end_time", core.serialization.number()),
        eventName: core.serialization.property("event_name", core.serialization.stringLiteral("chat_ended").optional()),
    })
    .extend(WebhookEventBase);

export declare namespace WebhookEventChatEnded {
    export interface Raw extends WebhookEventBase.Raw {
        caller_number?: string | null;
        custom_session_id?: string | null;
        duration_seconds: number;
        end_reason: WebhookEventChatStatus.Raw;
        end_time: number;
        event_name?: "chat_ended" | null;
    }
}

```


## /src/serialization/resources/empathicVoice/types/WebhookEventChatStartType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const WebhookEventChatStartType: core.serialization.Schema<
    serializers.empathicVoice.WebhookEventChatStartType.Raw,
    Hume.empathicVoice.WebhookEventChatStartType
> = core.serialization.enum_(["new_chat_group", "resumed_chat_group"]);

export declare namespace WebhookEventChatStartType {
    export type Raw = "new_chat_group" | "resumed_chat_group";
}

```


## /src/serialization/resources/empathicVoice/types/WebhookEventChatStarted.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { WebhookEventBase } from "./WebhookEventBase.js";
import { WebhookEventChatStartType } from "./WebhookEventChatStartType.js";

export const WebhookEventChatStarted: core.serialization.ObjectSchema<
    serializers.empathicVoice.WebhookEventChatStarted.Raw,
    Hume.empathicVoice.WebhookEventChatStarted
> = core.serialization
    .object({
        callerNumber: core.serialization.property("caller_number", core.serialization.string().optional()),
        chatStartType: core.serialization.property("chat_start_type", WebhookEventChatStartType),
        customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
        eventName: core.serialization.property(
            "event_name",
            core.serialization.stringLiteral("chat_started").optional(),
        ),
        startTime: core.serialization.property("start_time", core.serialization.number()),
    })
    .extend(WebhookEventBase);

export declare namespace WebhookEventChatStarted {
    export interface Raw extends WebhookEventBase.Raw {
        caller_number?: string | null;
        chat_start_type: WebhookEventChatStartType.Raw;
        custom_session_id?: string | null;
        event_name?: "chat_started" | null;
        start_time: number;
    }
}

```


## /src/serialization/resources/empathicVoice/types/WebhookEventChatStatus.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const WebhookEventChatStatus: core.serialization.Schema<
    serializers.empathicVoice.WebhookEventChatStatus.Raw,
    Hume.empathicVoice.WebhookEventChatStatus
> = core.serialization.enum_([
    "ACTIVE",
    "USER_ENDED",
    "USER_TIMEOUT",
    "INACTIVITY_TIMEOUT",
    "MAX_DURATION_TIMEOUT",
    "SILENCE_TIMEOUT",
    "ERROR",
]);

export declare namespace WebhookEventChatStatus {
    export type Raw =
        | "ACTIVE"
        | "USER_ENDED"
        | "USER_TIMEOUT"
        | "INACTIVITY_TIMEOUT"
        | "MAX_DURATION_TIMEOUT"
        | "SILENCE_TIMEOUT"
        | "ERROR";
}

```


## /src/serialization/resources/empathicVoice/types/WebhookEventToolCall.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ToolCallMessage } from "./ToolCallMessage.js";
import { WebhookEventBase } from "./WebhookEventBase.js";

export const WebhookEventToolCall: core.serialization.ObjectSchema<
    serializers.empathicVoice.WebhookEventToolCall.Raw,
    Hume.empathicVoice.WebhookEventToolCall
> = core.serialization
    .object({
        callerNumber: core.serialization.property("caller_number", core.serialization.string().optional()),
        customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
        eventName: core.serialization.property("event_name", core.serialization.stringLiteral("tool_call").optional()),
        timestamp: core.serialization.number(),
        toolCallMessage: core.serialization.property("tool_call_message", ToolCallMessage),
    })
    .extend(WebhookEventBase);

export declare namespace WebhookEventToolCall {
    export interface Raw extends WebhookEventBase.Raw {
        caller_number?: string | null;
        custom_session_id?: string | null;
        event_name?: "tool_call" | null;
        timestamp: number;
        tool_call_message: ToolCallMessage.Raw;
    }
}

```


## /src/serialization/resources/empathicVoice/types/index.ts
```typescript
export * from "./AssistantEnd.js";
export * from "./AssistantInput.js";
export * from "./AssistantMessage.js";
export * from "./AssistantProsody.js";
export * from "./AudioConfiguration.js";
export * from "./AudioInput.js";
export * from "./AudioOutput.js";
export * from "./BuiltInTool.js";
export * from "./BuiltinToolConfig.js";
export * from "./ChatMessage.js";
export * from "./ChatMessageToolResult.js";
export * from "./ChatMetadata.js";
export * from "./ConnectSessionSettings.js";
export * from "./ConnectSessionSettingsAudio.js";
export * from "./ConnectSessionSettingsContext.js";
export * from "./ConnectSessionSettingsVariablesValue.js";
export * from "./Context.js";
export * from "./ContextType.js";
export * from "./ControlPlanePublishEvent.js";
export * from "./EmotionScores.js";
export * from "./Encoding.js";
export * from "./ErrorLevel.js";
export * from "./ErrorResponse.js";
export * from "./HttpValidationError.js";
export * from "./Inference.js";
export * from "./JsonMessage.js";
export * from "./LanguageModelType.js";
export * from "./MillisecondInterval.js";
export * from "./ModelProviderEnum.js";
export * from "./PauseAssistantMessage.js";
export * from "./PostedBuiltinTool.js";
export * from "./PostedBuiltinToolName.js";
export * from "./PostedConfigPromptSpec.js";
export * from "./PostedEllmModel.js";
export * from "./PostedEventMessageSpec.js";
export * from "./PostedEventMessageSpecs.js";
export * from "./PostedLanguageModel.js";
export * from "./PostedNudgeSpec.js";
export * from "./PostedTimeoutSpec.js";
export * from "./PostedTimeoutSpecs.js";
export * from "./PostedTimeoutSpecsInactivity.js";
export * from "./PostedTimeoutSpecsMaxDuration.js";
export * from "./PostedUserDefinedToolSpec.js";
export * from "./PostedWebhookEventType.js";
export * from "./PostedWebhookSpec.js";
export * from "./ProsodyInference.js";
export * from "./ResumeAssistantMessage.js";
export * from "./ReturnBuiltinTool.js";
export * from "./ReturnBuiltinToolToolType.js";
export * from "./ReturnChat.js";
export * from "./ReturnChatAudioReconstruction.js";
export * from "./ReturnChatAudioReconstructionStatus.js";
export * from "./ReturnChatEvent.js";
export * from "./ReturnChatEventRole.js";
export * from "./ReturnChatEventType.js";
export * from "./ReturnChatGroup.js";
export * from "./ReturnChatGroupPagedAudioReconstructions.js";
export * from "./ReturnChatGroupPagedAudioReconstructionsPaginationDirection.js";
export * from "./ReturnChatGroupPagedChats.js";
export * from "./ReturnChatGroupPagedChatsPaginationDirection.js";
export * from "./ReturnChatGroupPagedEvents.js";
export * from "./ReturnChatGroupPagedEventsPaginationDirection.js";
export * from "./ReturnChatPagedEvents.js";
export * from "./ReturnChatPagedEventsPaginationDirection.js";
export * from "./ReturnChatPagedEventsStatus.js";
export * from "./ReturnChatStatus.js";
export * from "./ReturnConfig.js";
export * from "./ReturnConfigSpec.js";
export * from "./ReturnEllmModel.js";
export * from "./ReturnEventMessageSpec.js";
export * from "./ReturnEventMessageSpecs.js";
export * from "./ReturnLanguageModel.js";
export * from "./ReturnNudgeSpec.js";
export * from "./ReturnPagedChatGroups.js";
export * from "./ReturnPagedChatGroupsPaginationDirection.js";
export * from "./ReturnPagedChats.js";
export * from "./ReturnPagedChatsPaginationDirection.js";
export * from "./ReturnPagedConfigs.js";
export * from "./ReturnPagedPrompts.js";
export * from "./ReturnPagedUserDefinedTools.js";
export * from "./ReturnPrompt.js";
export * from "./ReturnPromptVersionType.js";
export * from "./ReturnTimeoutSpec.js";
export * from "./ReturnTimeoutSpecs.js";
export * from "./ReturnUserDefinedTool.js";
export * from "./ReturnUserDefinedToolToolType.js";
export * from "./ReturnUserDefinedToolVersionType.js";
export * from "./ReturnVoice.js";
export * from "./ReturnWebhookEventType.js";
export * from "./ReturnWebhookSpec.js";
export * from "./Role.js";
export * from "./SessionSettings.js";
export * from "./SessionSettingsVariablesValue.js";
export * from "./SubscribeEvent.js";
export * from "./Tool.js";
export * from "./ToolCallMessage.js";
export * from "./ToolErrorMessage.js";
export * from "./ToolResponseMessage.js";
export * from "./ToolType.js";
export * from "./UserInput.js";
export * from "./UserInterruption.js";
export * from "./UserMessage.js";
export * from "./ValidationError.js";
export * from "./ValidationErrorLocItem.js";
export * from "./VoiceId.js";
export * from "./VoiceName.js";
export * from "./VoiceProvider.js";
export * from "./VoiceRef.js";
export * from "./WebhookEvent.js";
export * from "./WebhookEventBase.js";
export * from "./WebhookEventChatEnded.js";
export * from "./WebhookEventChatStarted.js";
export * from "./WebhookEventChatStartType.js";
export * from "./WebhookEventChatStatus.js";
export * from "./WebhookEventToolCall.js";
export * from "./WebSocketError.js";

```


## /src/serialization/resources/expressionMeasurement/index.ts
```typescript
export * from "./resources/index.js";

```


## /src/serialization/resources/expressionMeasurement/resources/batch/client/getJobPredictions.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { UnionPredictResult } from "../types/UnionPredictResult.js";

export const Response: core.serialization.Schema<
    serializers.expressionMeasurement.batch.getJobPredictions.Response.Raw,
    Hume.expressionMeasurement.batch.UnionPredictResult[]
> = core.serialization.list(UnionPredictResult);

export declare namespace Response {
    export type Raw = UnionPredictResult.Raw[];
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/client/index.ts
```typescript
export * as getJobPredictions from "./getJobPredictions.js";
export * as listJobs from "./listJobs.js";

```


## /src/serialization/resources/expressionMeasurement/resources/batch/client/listJobs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { UnionJob } from "../types/UnionJob.js";

export const Response: core.serialization.Schema<
    serializers.expressionMeasurement.batch.listJobs.Response.Raw,
    Hume.expressionMeasurement.batch.UnionJob[]
> = core.serialization.list(UnionJob);

export declare namespace Response {
    export type Raw = UnionJob.Raw[];
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/index.ts
```typescript
export * from "./client/index.js";
export * from "./types/index.js";

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Alternative.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Alternative: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Alternative.Raw,
    Hume.expressionMeasurement.batch.Alternative
> = core.serialization.stringLiteral("language_only");

export declare namespace Alternative {
    export type Raw = "language_only";
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Bcp47Tag.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Bcp47Tag: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Bcp47Tag.Raw,
    Hume.expressionMeasurement.batch.Bcp47Tag
> = core.serialization.enum_([
    "zh",
    "da",
    "nl",
    "en",
    "en-AU",
    "en-IN",
    "en-NZ",
    "en-GB",
    "fr",
    "fr-CA",
    "de",
    "hi",
    "hi-Latn",
    "id",
    "it",
    "ja",
    "ko",
    "no",
    "pl",
    "pt",
    "pt-BR",
    "pt-PT",
    "ru",
    "es",
    "es-419",
    "sv",
    "ta",
    "tr",
    "uk",
]);

export declare namespace Bcp47Tag {
    export type Raw =
        | "zh"
        | "da"
        | "nl"
        | "en"
        | "en-AU"
        | "en-IN"
        | "en-NZ"
        | "en-GB"
        | "fr"
        | "fr-CA"
        | "de"
        | "hi"
        | "hi-Latn"
        | "id"
        | "it"
        | "ja"
        | "ko"
        | "no"
        | "pl"
        | "pt"
        | "pt-BR"
        | "pt-PT"
        | "ru"
        | "es"
        | "es-419"
        | "sv"
        | "ta"
        | "tr"
        | "uk";
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/BoundingBox.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const BoundingBox: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.BoundingBox.Raw,
    Hume.expressionMeasurement.batch.BoundingBox
> = core.serialization.object({
    x: core.serialization.number(),
    y: core.serialization.number(),
    w: core.serialization.number(),
    h: core.serialization.number(),
});

export declare namespace BoundingBox {
    export interface Raw {
        x: number;
        y: number;
        w: number;
        h: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/BurstPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { DescriptionsScore } from "./DescriptionsScore.js";
import { EmotionScore } from "./EmotionScore.js";
import { TimeInterval } from "./TimeInterval.js";

export const BurstPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.BurstPrediction.Raw,
    Hume.expressionMeasurement.batch.BurstPrediction
> = core.serialization.object({
    time: TimeInterval,
    emotions: core.serialization.list(EmotionScore),
    descriptions: core.serialization.list(DescriptionsScore),
});

export declare namespace BurstPrediction {
    export interface Raw {
        time: TimeInterval.Raw;
        emotions: EmotionScore.Raw[];
        descriptions: DescriptionsScore.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Classification.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Classification: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Classification.Raw,
    Hume.expressionMeasurement.batch.Classification
> = core.serialization.record(core.serialization.string(), core.serialization.unknown());

export declare namespace Classification {
    export type Raw = Record<string, unknown>;
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedEmbeddingGeneration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const CompletedEmbeddingGeneration: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CompletedEmbeddingGeneration.Raw,
    Hume.expressionMeasurement.batch.CompletedEmbeddingGeneration
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
    startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
    endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
});

export declare namespace CompletedEmbeddingGeneration {
    export interface Raw {
        created_timestamp_ms: number;
        started_timestamp_ms: number;
        ended_timestamp_ms: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const CompletedInference: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CompletedInference.Raw,
    Hume.expressionMeasurement.batch.CompletedInference
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
    startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
    endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
    numPredictions: core.serialization.property("num_predictions", core.serialization.number()),
    numErrors: core.serialization.property("num_errors", core.serialization.number()),
});

export declare namespace CompletedInference {
    export interface Raw {
        created_timestamp_ms: number;
        started_timestamp_ms: number;
        ended_timestamp_ms: number;
        num_predictions: number;
        num_errors: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedState.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CompletedInference } from "./CompletedInference.js";

export const CompletedState: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CompletedState.Raw,
    Hume.expressionMeasurement.batch.CompletedState
> = core.serialization.object({}).extend(CompletedInference);

export declare namespace CompletedState {
    export interface Raw extends CompletedInference.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedTlInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const CompletedTlInference: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CompletedTlInference.Raw,
    Hume.expressionMeasurement.batch.CompletedTlInference
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
    startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
    endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
    numPredictions: core.serialization.property("num_predictions", core.serialization.number()),
    numErrors: core.serialization.property("num_errors", core.serialization.number()),
});

export declare namespace CompletedTlInference {
    export interface Raw {
        created_timestamp_ms: number;
        started_timestamp_ms: number;
        ended_timestamp_ms: number;
        num_predictions: number;
        num_errors: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedTraining.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { TrainingCustomModel } from "./TrainingCustomModel.js";

export const CompletedTraining: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CompletedTraining.Raw,
    Hume.expressionMeasurement.batch.CompletedTraining
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
    startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
    endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
    customModel: core.serialization.property("custom_model", TrainingCustomModel),
    alternatives: core.serialization.record(core.serialization.string(), TrainingCustomModel).optional(),
});

export declare namespace CompletedTraining {
    export interface Raw {
        created_timestamp_ms: number;
        started_timestamp_ms: number;
        ended_timestamp_ms: number;
        custom_model: TrainingCustomModel.Raw;
        alternatives?: Record<string, TrainingCustomModel.Raw> | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CustomModelId } from "./CustomModelId.js";
import { CustomModelVersionId } from "./CustomModelVersionId.js";

export const CustomModel: core.serialization.Schema<
    serializers.expressionMeasurement.batch.CustomModel.Raw,
    Hume.expressionMeasurement.batch.CustomModel
> = core.serialization.undiscriminatedUnion([CustomModelId, CustomModelVersionId]);

export declare namespace CustomModel {
    export type Raw = CustomModelId.Raw | CustomModelVersionId.Raw;
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const CustomModelId: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CustomModelId.Raw,
    Hume.expressionMeasurement.batch.CustomModelId
> = core.serialization.object({
    id: core.serialization.string(),
});

export declare namespace CustomModelId {
    export interface Raw {
        id: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const CustomModelPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CustomModelPrediction.Raw,
    Hume.expressionMeasurement.batch.CustomModelPrediction
> = core.serialization.object({
    output: core.serialization.record(core.serialization.string(), core.serialization.number()),
    error: core.serialization.string(),
    taskType: core.serialization.property("task_type", core.serialization.string()),
});

export declare namespace CustomModelPrediction {
    export interface Raw {
        output: Record<string, number>;
        error: string;
        task_type: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Tag } from "./Tag.js";

export const CustomModelRequest: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CustomModelRequest.Raw,
    Hume.expressionMeasurement.batch.CustomModelRequest
> = core.serialization.object({
    name: core.serialization.string(),
    description: core.serialization.string().optional(),
    tags: core.serialization.list(Tag).optional(),
});

export declare namespace CustomModelRequest {
    export interface Raw {
        name: string;
        description?: string | null;
        tags?: Tag.Raw[] | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelVersionId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const CustomModelVersionId: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CustomModelVersionId.Raw,
    Hume.expressionMeasurement.batch.CustomModelVersionId
> = core.serialization.object({
    versionId: core.serialization.property("version_id", core.serialization.string()),
});

export declare namespace CustomModelVersionId {
    export interface Raw {
        version_id: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelsInferenceJob.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { JobTlInference } from "./JobTlInference.js";

export const CustomModelsInferenceJob: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CustomModelsInferenceJob.Raw,
    Hume.expressionMeasurement.batch.CustomModelsInferenceJob
> = core.serialization
    .object({
        type: core.serialization.string(),
    })
    .extend(JobTlInference);

export declare namespace CustomModelsInferenceJob {
    export interface Raw extends JobTlInference.Raw {
        type: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelsTrainingJob.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { JobTraining } from "./JobTraining.js";

export const CustomModelsTrainingJob: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CustomModelsTrainingJob.Raw,
    Hume.expressionMeasurement.batch.CustomModelsTrainingJob
> = core.serialization
    .object({
        type: core.serialization.string(),
    })
    .extend(JobTraining);

export declare namespace CustomModelsTrainingJob {
    export interface Raw extends JobTraining.Raw {
        type: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Dataset.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { DatasetId } from "./DatasetId.js";
import { DatasetVersionId } from "./DatasetVersionId.js";

export const Dataset: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Dataset.Raw,
    Hume.expressionMeasurement.batch.Dataset
> = core.serialization.undiscriminatedUnion([DatasetId, DatasetVersionId]);

export declare namespace Dataset {
    export type Raw = DatasetId.Raw | DatasetVersionId.Raw;
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/DatasetId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const DatasetId: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.DatasetId.Raw,
    Hume.expressionMeasurement.batch.DatasetId
> = core.serialization.object({
    id: core.serialization.string(),
});

export declare namespace DatasetId {
    export interface Raw {
        id: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/DatasetVersionId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const DatasetVersionId: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.DatasetVersionId.Raw,
    Hume.expressionMeasurement.batch.DatasetVersionId
> = core.serialization.object({
    versionId: core.serialization.property("version_id", core.serialization.string()),
});

export declare namespace DatasetVersionId {
    export interface Raw {
        version_id: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/DescriptionsScore.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const DescriptionsScore: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.DescriptionsScore.Raw,
    Hume.expressionMeasurement.batch.DescriptionsScore
> = core.serialization.object({
    name: core.serialization.string(),
    score: core.serialization.number(),
});

export declare namespace DescriptionsScore {
    export interface Raw {
        name: string;
        score: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Direction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Direction: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Direction.Raw,
    Hume.expressionMeasurement.batch.Direction
> = core.serialization.enum_(["asc", "desc"]);

export declare namespace Direction {
    export type Raw = "asc" | "desc";
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/EmbeddingGenerationBaseRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { RegistryFileDetail } from "./RegistryFileDetail.js";

export const EmbeddingGenerationBaseRequest: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.EmbeddingGenerationBaseRequest.Raw,
    Hume.expressionMeasurement.batch.EmbeddingGenerationBaseRequest
> = core.serialization.object({
    registryFileDetails: core.serialization.property(
        "registry_file_details",
        core.serialization.list(RegistryFileDetail).optional(),
    ),
});

export declare namespace EmbeddingGenerationBaseRequest {
    export interface Raw {
        registry_file_details?: RegistryFileDetail.Raw[] | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/EmbeddingGenerationJob.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { JobEmbeddingGeneration } from "./JobEmbeddingGeneration.js";

export const EmbeddingGenerationJob: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.EmbeddingGenerationJob.Raw,
    Hume.expressionMeasurement.batch.EmbeddingGenerationJob
> = core.serialization
    .object({
        type: core.serialization.string(),
    })
    .extend(JobEmbeddingGeneration);

export declare namespace EmbeddingGenerationJob {
    export interface Raw extends JobEmbeddingGeneration.Raw {
        type: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/EmotionScore.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const EmotionScore: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.EmotionScore.Raw,
    Hume.expressionMeasurement.batch.EmotionScore
> = core.serialization.object({
    name: core.serialization.string(),
    score: core.serialization.number(),
});

export declare namespace EmotionScore {
    export interface Raw {
        name: string;
        score: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Error_.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Error_: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Error_.Raw,
    Hume.expressionMeasurement.batch.Error_
> = core.serialization.object({
    message: core.serialization.string(),
    file: core.serialization.string(),
});

export declare namespace Error_ {
    export interface Raw {
        message: string;
        file: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/EvaluationArgs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ValidationArgs } from "./ValidationArgs.js";

export const EvaluationArgs: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.EvaluationArgs.Raw,
    Hume.expressionMeasurement.batch.EvaluationArgs
> = core.serialization.object({
    validation: ValidationArgs.optional(),
});

export declare namespace EvaluationArgs {
    export interface Raw {
        validation?: ValidationArgs.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Face.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Unconfigurable } from "./Unconfigurable.js";

export const Face: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Face.Raw,
    Hume.expressionMeasurement.batch.Face
> = core.serialization.object({
    fpsPred: core.serialization.property("fps_pred", core.serialization.number().optional()),
    probThreshold: core.serialization.property("prob_threshold", core.serialization.number().optional()),
    identifyFaces: core.serialization.property("identify_faces", core.serialization.boolean().optional()),
    minFaceSize: core.serialization.property("min_face_size", core.serialization.number().optional()),
    facs: Unconfigurable.optional(),
    descriptions: Unconfigurable.optional(),
    saveFaces: core.serialization.property("save_faces", core.serialization.boolean().optional()),
});

export declare namespace Face {
    export interface Raw {
        fps_pred?: number | null;
        prob_threshold?: number | null;
        identify_faces?: boolean | null;
        min_face_size?: number | null;
        facs?: Unconfigurable.Raw | null;
        descriptions?: Unconfigurable.Raw | null;
        save_faces?: boolean | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/FacePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { BoundingBox } from "./BoundingBox.js";
import { DescriptionsScore } from "./DescriptionsScore.js";
import { EmotionScore } from "./EmotionScore.js";
import { FacsScore } from "./FacsScore.js";

export const FacePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.FacePrediction.Raw,
    Hume.expressionMeasurement.batch.FacePrediction
> = core.serialization.object({
    frame: core.serialization.number(),
    time: core.serialization.number(),
    prob: core.serialization.number(),
    box: BoundingBox,
    emotions: core.serialization.list(EmotionScore),
    facs: core.serialization.list(FacsScore).optional(),
    descriptions: core.serialization.list(DescriptionsScore).optional(),
});

export declare namespace FacePrediction {
    export interface Raw {
        frame: number;
        time: number;
        prob: number;
        box: BoundingBox.Raw;
        emotions: EmotionScore.Raw[];
        facs?: FacsScore.Raw[] | null;
        descriptions?: DescriptionsScore.Raw[] | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/FacemeshPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { EmotionScore } from "./EmotionScore.js";

export const FacemeshPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.FacemeshPrediction.Raw,
    Hume.expressionMeasurement.batch.FacemeshPrediction
> = core.serialization.object({
    emotions: core.serialization.list(EmotionScore),
});

export declare namespace FacemeshPrediction {
    export interface Raw {
        emotions: EmotionScore.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/FacsScore.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const FacsScore: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.FacsScore.Raw,
    Hume.expressionMeasurement.batch.FacsScore
> = core.serialization.object({
    name: core.serialization.string(),
    score: core.serialization.number(),
});

export declare namespace FacsScore {
    export interface Raw {
        name: string;
        score: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Failed.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Failed: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Failed.Raw,
    Hume.expressionMeasurement.batch.Failed
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
    startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
    endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
    message: core.serialization.string(),
});

export declare namespace Failed {
    export interface Raw {
        created_timestamp_ms: number;
        started_timestamp_ms: number;
        ended_timestamp_ms: number;
        message: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/FailedState.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Failed } from "./Failed.js";

export const FailedState: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.FailedState.Raw,
    Hume.expressionMeasurement.batch.FailedState
> = core.serialization.object({}).extend(Failed);

export declare namespace FailedState {
    export interface Raw extends Failed.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/File_.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const File_: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.File_.Raw,
    Hume.expressionMeasurement.batch.File_
> = core.serialization.object({
    filename: core.serialization.string().optional(),
    contentType: core.serialization.property("content_type", core.serialization.string().optional()),
    md5Sum: core.serialization.property("md5sum", core.serialization.string()),
});

export declare namespace File_ {
    export interface Raw {
        filename?: string | null;
        content_type?: string | null;
        md5sum: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Granularity.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Granularity: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Granularity.Raw,
    Hume.expressionMeasurement.batch.Granularity
> = core.serialization.enum_(["word", "sentence", "utterance", "conversational_turn"]);

export declare namespace Granularity {
    export type Raw = "word" | "sentence" | "utterance" | "conversational_turn";
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsBurstPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { BurstPrediction } from "./BurstPrediction.js";

export const GroupedPredictionsBurstPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.GroupedPredictionsBurstPrediction.Raw,
    Hume.expressionMeasurement.batch.GroupedPredictionsBurstPrediction
> = core.serialization.object({
    id: core.serialization.string(),
    predictions: core.serialization.list(BurstPrediction),
});

export declare namespace GroupedPredictionsBurstPrediction {
    export interface Raw {
        id: string;
        predictions: BurstPrediction.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsFacePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { FacePrediction } from "./FacePrediction.js";

export const GroupedPredictionsFacePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.GroupedPredictionsFacePrediction.Raw,
    Hume.expressionMeasurement.batch.GroupedPredictionsFacePrediction
> = core.serialization.object({
    id: core.serialization.string(),
    predictions: core.serialization.list(FacePrediction),
});

export declare namespace GroupedPredictionsFacePrediction {
    export interface Raw {
        id: string;
        predictions: FacePrediction.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsFacemeshPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { FacemeshPrediction } from "./FacemeshPrediction.js";

export const GroupedPredictionsFacemeshPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.GroupedPredictionsFacemeshPrediction.Raw,
    Hume.expressionMeasurement.batch.GroupedPredictionsFacemeshPrediction
> = core.serialization.object({
    id: core.serialization.string(),
    predictions: core.serialization.list(FacemeshPrediction),
});

export declare namespace GroupedPredictionsFacemeshPrediction {
    export interface Raw {
        id: string;
        predictions: FacemeshPrediction.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsLanguagePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { LanguagePrediction } from "./LanguagePrediction.js";

export const GroupedPredictionsLanguagePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.GroupedPredictionsLanguagePrediction.Raw,
    Hume.expressionMeasurement.batch.GroupedPredictionsLanguagePrediction
> = core.serialization.object({
    id: core.serialization.string(),
    predictions: core.serialization.list(LanguagePrediction),
});

export declare namespace GroupedPredictionsLanguagePrediction {
    export interface Raw {
        id: string;
        predictions: LanguagePrediction.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsNerPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { NerPrediction } from "./NerPrediction.js";

export const GroupedPredictionsNerPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.GroupedPredictionsNerPrediction.Raw,
    Hume.expressionMeasurement.batch.GroupedPredictionsNerPrediction
> = core.serialization.object({
    id: core.serialization.string(),
    predictions: core.serialization.list(NerPrediction),
});

export declare namespace GroupedPredictionsNerPrediction {
    export interface Raw {
        id: string;
        predictions: NerPrediction.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsProsodyPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ProsodyPrediction } from "./ProsodyPrediction.js";

export const GroupedPredictionsProsodyPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.GroupedPredictionsProsodyPrediction.Raw,
    Hume.expressionMeasurement.batch.GroupedPredictionsProsodyPrediction
> = core.serialization.object({
    id: core.serialization.string(),
    predictions: core.serialization.list(ProsodyPrediction),
});

export declare namespace GroupedPredictionsProsodyPrediction {
    export interface Raw {
        id: string;
        predictions: ProsodyPrediction.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/InProgress.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const InProgress: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InProgress.Raw,
    Hume.expressionMeasurement.batch.InProgress
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
    startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
});

export declare namespace InProgress {
    export interface Raw {
        created_timestamp_ms: number;
        started_timestamp_ms: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/InProgressState.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InProgress } from "./InProgress.js";

export const InProgressState: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InProgressState.Raw,
    Hume.expressionMeasurement.batch.InProgressState
> = core.serialization.object({}).extend(InProgress);

export declare namespace InProgressState {
    export interface Raw extends InProgress.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceBaseRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Models } from "./Models.js";
import { Transcription } from "./Transcription.js";

export const InferenceBaseRequest: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InferenceBaseRequest.Raw,
    Hume.expressionMeasurement.batch.InferenceBaseRequest
> = core.serialization.object({
    models: Models.optional(),
    transcription: Transcription.optional(),
    urls: core.serialization.list(core.serialization.string()).optional(),
    text: core.serialization.list(core.serialization.string()).optional(),
    callbackUrl: core.serialization.property("callback_url", core.serialization.string().optional()),
    notify: core.serialization.boolean().optional(),
});

export declare namespace InferenceBaseRequest {
    export interface Raw {
        models?: Models.Raw | null;
        transcription?: Transcription.Raw | null;
        urls?: string[] | null;
        text?: string[] | null;
        callback_url?: string | null;
        notify?: boolean | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceJob.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { JobInference } from "./JobInference.js";

export const InferenceJob: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InferenceJob.Raw,
    Hume.expressionMeasurement.batch.InferenceJob
> = core.serialization
    .object({
        type: core.serialization.string(),
    })
    .extend(JobInference);

export declare namespace InferenceJob {
    export interface Raw extends JobInference.Raw {
        type: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/InferencePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ModelsPredictions } from "./ModelsPredictions.js";

export const InferencePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InferencePrediction.Raw,
    Hume.expressionMeasurement.batch.InferencePrediction
> = core.serialization.object({
    file: core.serialization.string(),
    models: ModelsPredictions,
});

export declare namespace InferencePrediction {
    export interface Raw {
        file: string;
        models: ModelsPredictions.Raw;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { File_ } from "./File_.js";
import { Models } from "./Models.js";
import { Transcription } from "./Transcription.js";

export const InferenceRequest: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InferenceRequest.Raw,
    Hume.expressionMeasurement.batch.InferenceRequest
> = core.serialization.object({
    models: Models.optional(),
    transcription: Transcription.optional(),
    urls: core.serialization.list(core.serialization.string()).optional(),
    text: core.serialization.list(core.serialization.string()).optional(),
    callbackUrl: core.serialization.property("callback_url", core.serialization.string().optional()),
    notify: core.serialization.boolean().optional(),
    files: core.serialization.list(File_),
});

export declare namespace InferenceRequest {
    export interface Raw {
        models?: Models.Raw | null;
        transcription?: Transcription.Raw | null;
        urls?: string[] | null;
        text?: string[] | null;
        callback_url?: string | null;
        notify?: boolean | null;
        files: File_.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceResults.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Error_ } from "./Error_.js";
import { InferencePrediction } from "./InferencePrediction.js";

export const InferenceResults: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InferenceResults.Raw,
    Hume.expressionMeasurement.batch.InferenceResults
> = core.serialization.object({
    predictions: core.serialization.list(InferencePrediction),
    errors: core.serialization.list(Error_),
});

export declare namespace InferenceResults {
    export interface Raw {
        predictions: InferencePrediction.Raw[];
        errors: Error_.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceSourcePredictResult.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InferenceResults } from "./InferenceResults.js";
import { Source } from "./Source.js";

export const InferenceSourcePredictResult: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InferenceSourcePredictResult.Raw,
    Hume.expressionMeasurement.batch.InferenceSourcePredictResult
> = core.serialization.object({
    source: Source,
    results: InferenceResults.optional(),
    error: core.serialization.string().optional(),
});

export declare namespace InferenceSourcePredictResult {
    export interface Raw {
        source: Source.Raw;
        results?: InferenceResults.Raw | null;
        error?: string | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/JobEmbeddingGeneration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { EmbeddingGenerationBaseRequest } from "./EmbeddingGenerationBaseRequest.js";
import { StateEmbeddingGeneration } from "./StateEmbeddingGeneration.js";

export const JobEmbeddingGeneration: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.JobEmbeddingGeneration.Raw,
    Hume.expressionMeasurement.batch.JobEmbeddingGeneration
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string()),
    userId: core.serialization.property("user_id", core.serialization.string()),
    request: EmbeddingGenerationBaseRequest,
    state: StateEmbeddingGeneration,
});

export declare namespace JobEmbeddingGeneration {
    export interface Raw {
        job_id: string;
        user_id: string;
        request: EmbeddingGenerationBaseRequest.Raw;
        state: StateEmbeddingGeneration.Raw;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/JobId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const JobId: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.JobId.Raw,
    Hume.expressionMeasurement.batch.JobId
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string()),
});

export declare namespace JobId {
    export interface Raw {
        job_id: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/JobInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InferenceRequest } from "./InferenceRequest.js";
import { StateInference } from "./StateInference.js";

export const JobInference: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.JobInference.Raw,
    Hume.expressionMeasurement.batch.JobInference
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string()),
    request: InferenceRequest,
    state: StateInference,
});

export declare namespace JobInference {
    export interface Raw {
        job_id: string;
        request: InferenceRequest.Raw;
        state: StateInference.Raw;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/JobTlInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { StateTlInference } from "./StateTlInference.js";
import { TlInferenceBaseRequest } from "./TlInferenceBaseRequest.js";

export const JobTlInference: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.JobTlInference.Raw,
    Hume.expressionMeasurement.batch.JobTlInference
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string()),
    userId: core.serialization.property("user_id", core.serialization.string()),
    request: TlInferenceBaseRequest,
    state: StateTlInference,
});

export declare namespace JobTlInference {
    export interface Raw {
        job_id: string;
        user_id: string;
        request: TlInferenceBaseRequest.Raw;
        state: StateTlInference.Raw;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/JobTraining.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { StateTraining } from "./StateTraining.js";
import { TrainingBaseRequest } from "./TrainingBaseRequest.js";

export const JobTraining: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.JobTraining.Raw,
    Hume.expressionMeasurement.batch.JobTraining
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string()),
    userId: core.serialization.property("user_id", core.serialization.string()),
    request: TrainingBaseRequest,
    state: StateTraining,
});

export declare namespace JobTraining {
    export interface Raw {
        job_id: string;
        user_id: string;
        request: TrainingBaseRequest.Raw;
        state: StateTraining.Raw;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Language.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Granularity } from "./Granularity.js";
import { Unconfigurable } from "./Unconfigurable.js";

export const Language: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Language.Raw,
    Hume.expressionMeasurement.batch.Language
> = core.serialization.object({
    granularity: Granularity.optional(),
    sentiment: Unconfigurable.optional(),
    toxicity: Unconfigurable.optional(),
    identifySpeakers: core.serialization.property("identify_speakers", core.serialization.boolean().optional()),
});

export declare namespace Language {
    export interface Raw {
        granularity?: Granularity.Raw | null;
        sentiment?: Unconfigurable.Raw | null;
        toxicity?: Unconfigurable.Raw | null;
        identify_speakers?: boolean | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/LanguagePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { EmotionScore } from "./EmotionScore.js";
import { PositionInterval } from "./PositionInterval.js";
import { SentimentScore } from "./SentimentScore.js";
import { TimeInterval } from "./TimeInterval.js";
import { ToxicityScore } from "./ToxicityScore.js";

export const LanguagePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.LanguagePrediction.Raw,
    Hume.expressionMeasurement.batch.LanguagePrediction
> = core.serialization.object({
    text: core.serialization.string(),
    position: PositionInterval,
    time: TimeInterval.optional(),
    confidence: core.serialization.number().optional(),
    speakerConfidence: core.serialization.property("speaker_confidence", core.serialization.number().optional()),
    emotions: core.serialization.list(EmotionScore),
    sentiment: core.serialization.list(SentimentScore).optional(),
    toxicity: core.serialization.list(ToxicityScore).optional(),
});

export declare namespace LanguagePrediction {
    export interface Raw {
        text: string;
        position: PositionInterval.Raw;
        time?: TimeInterval.Raw | null;
        confidence?: number | null;
        speaker_confidence?: number | null;
        emotions: EmotionScore.Raw[];
        sentiment?: SentimentScore.Raw[] | null;
        toxicity?: ToxicityScore.Raw[] | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Models.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Face } from "./Face.js";
import { Language } from "./Language.js";
import { Ner } from "./Ner.js";
import { Prosody } from "./Prosody.js";
import { Unconfigurable } from "./Unconfigurable.js";

export const Models: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Models.Raw,
    Hume.expressionMeasurement.batch.Models
> = core.serialization.object({
    face: Face.optional(),
    burst: Unconfigurable.optional(),
    prosody: Prosody.optional(),
    language: Language.optional(),
    ner: Ner.optional(),
    facemesh: Unconfigurable.optional(),
});

export declare namespace Models {
    export interface Raw {
        face?: Face.Raw | null;
        burst?: Unconfigurable.Raw | null;
        prosody?: Prosody.Raw | null;
        language?: Language.Raw | null;
        ner?: Ner.Raw | null;
        facemesh?: Unconfigurable.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/ModelsPredictions.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { PredictionsOptionalNullBurstPrediction } from "./PredictionsOptionalNullBurstPrediction.js";
import { PredictionsOptionalNullFacemeshPrediction } from "./PredictionsOptionalNullFacemeshPrediction.js";
import { PredictionsOptionalNullFacePrediction } from "./PredictionsOptionalNullFacePrediction.js";
import { PredictionsOptionalTranscriptionMetadataLanguagePrediction } from "./PredictionsOptionalTranscriptionMetadataLanguagePrediction.js";
import { PredictionsOptionalTranscriptionMetadataNerPrediction } from "./PredictionsOptionalTranscriptionMetadataNerPrediction.js";
import { PredictionsOptionalTranscriptionMetadataProsodyPrediction } from "./PredictionsOptionalTranscriptionMetadataProsodyPrediction.js";

export const ModelsPredictions: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.ModelsPredictions.Raw,
    Hume.expressionMeasurement.batch.ModelsPredictions
> = core.serialization.object({
    face: PredictionsOptionalNullFacePrediction.optional(),
    burst: PredictionsOptionalNullBurstPrediction.optional(),
    prosody: PredictionsOptionalTranscriptionMetadataProsodyPrediction.optional(),
    language: PredictionsOptionalTranscriptionMetadataLanguagePrediction.optional(),
    ner: PredictionsOptionalTranscriptionMetadataNerPrediction.optional(),
    facemesh: PredictionsOptionalNullFacemeshPrediction.optional(),
});

export declare namespace ModelsPredictions {
    export interface Raw {
        face?: PredictionsOptionalNullFacePrediction.Raw | null;
        burst?: PredictionsOptionalNullBurstPrediction.Raw | null;
        prosody?: PredictionsOptionalTranscriptionMetadataProsodyPrediction.Raw | null;
        language?: PredictionsOptionalTranscriptionMetadataLanguagePrediction.Raw | null;
        ner?: PredictionsOptionalTranscriptionMetadataNerPrediction.Raw | null;
        facemesh?: PredictionsOptionalNullFacemeshPrediction.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Ner.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Ner: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Ner.Raw,
    Hume.expressionMeasurement.batch.Ner
> = core.serialization.object({
    identifySpeakers: core.serialization.property("identify_speakers", core.serialization.boolean().optional()),
});

export declare namespace Ner {
    export interface Raw {
        identify_speakers?: boolean | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/NerPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { EmotionScore } from "./EmotionScore.js";
import { PositionInterval } from "./PositionInterval.js";
import { TimeInterval } from "./TimeInterval.js";

export const NerPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.NerPrediction.Raw,
    Hume.expressionMeasurement.batch.NerPrediction
> = core.serialization.object({
    entity: core.serialization.string(),
    position: PositionInterval,
    entityConfidence: core.serialization.property("entity_confidence", core.serialization.number()),
    support: core.serialization.number(),
    uri: core.serialization.string(),
    linkWord: core.serialization.property("link_word", core.serialization.string()),
    time: TimeInterval.optional(),
    confidence: core.serialization.number().optional(),
    speakerConfidence: core.serialization.property("speaker_confidence", core.serialization.number().optional()),
    emotions: core.serialization.list(EmotionScore),
});

export declare namespace NerPrediction {
    export interface Raw {
        entity: string;
        position: PositionInterval.Raw;
        entity_confidence: number;
        support: number;
        uri: string;
        link_word: string;
        time?: TimeInterval.Raw | null;
        confidence?: number | null;
        speaker_confidence?: number | null;
        emotions: EmotionScore.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Null.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Null: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Null.Raw,
    Hume.expressionMeasurement.batch.Null
> = core.serialization.record(core.serialization.string(), core.serialization.unknown());

export declare namespace Null {
    export type Raw = Record<string, unknown>;
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/PositionInterval.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const PositionInterval: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PositionInterval.Raw,
    Hume.expressionMeasurement.batch.PositionInterval
> = core.serialization.object({
    begin: core.serialization.number(),
    end: core.serialization.number(),
});

export declare namespace PositionInterval {
    export interface Raw {
        begin: number;
        end: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullBurstPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { GroupedPredictionsBurstPrediction } from "./GroupedPredictionsBurstPrediction.js";
import { Null } from "./Null.js";

export const PredictionsOptionalNullBurstPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PredictionsOptionalNullBurstPrediction.Raw,
    Hume.expressionMeasurement.batch.PredictionsOptionalNullBurstPrediction
> = core.serialization.object({
    metadata: Null.optional(),
    groupedPredictions: core.serialization.property(
        "grouped_predictions",
        core.serialization.list(GroupedPredictionsBurstPrediction),
    ),
});

export declare namespace PredictionsOptionalNullBurstPrediction {
    export interface Raw {
        metadata?: Null.Raw | null;
        grouped_predictions: GroupedPredictionsBurstPrediction.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullFacePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { GroupedPredictionsFacePrediction } from "./GroupedPredictionsFacePrediction.js";
import { Null } from "./Null.js";

export const PredictionsOptionalNullFacePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PredictionsOptionalNullFacePrediction.Raw,
    Hume.expressionMeasurement.batch.PredictionsOptionalNullFacePrediction
> = core.serialization.object({
    metadata: Null.optional(),
    groupedPredictions: core.serialization.property(
        "grouped_predictions",
        core.serialization.list(GroupedPredictionsFacePrediction),
    ),
});

export declare namespace PredictionsOptionalNullFacePrediction {
    export interface Raw {
        metadata?: Null.Raw | null;
        grouped_predictions: GroupedPredictionsFacePrediction.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullFacemeshPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { GroupedPredictionsFacemeshPrediction } from "./GroupedPredictionsFacemeshPrediction.js";
import { Null } from "./Null.js";

export const PredictionsOptionalNullFacemeshPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PredictionsOptionalNullFacemeshPrediction.Raw,
    Hume.expressionMeasurement.batch.PredictionsOptionalNullFacemeshPrediction
> = core.serialization.object({
    metadata: Null.optional(),
    groupedPredictions: core.serialization.property(
        "grouped_predictions",
        core.serialization.list(GroupedPredictionsFacemeshPrediction),
    ),
});

export declare namespace PredictionsOptionalNullFacemeshPrediction {
    export interface Raw {
        metadata?: Null.Raw | null;
        grouped_predictions: GroupedPredictionsFacemeshPrediction.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataLanguagePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { GroupedPredictionsLanguagePrediction } from "./GroupedPredictionsLanguagePrediction.js";
import { TranscriptionMetadata } from "./TranscriptionMetadata.js";

export const PredictionsOptionalTranscriptionMetadataLanguagePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataLanguagePrediction.Raw,
    Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataLanguagePrediction
> = core.serialization.object({
    metadata: TranscriptionMetadata.optional(),
    groupedPredictions: core.serialization.property(
        "grouped_predictions",
        core.serialization.list(GroupedPredictionsLanguagePrediction),
    ),
});

export declare namespace PredictionsOptionalTranscriptionMetadataLanguagePrediction {
    export interface Raw {
        metadata?: TranscriptionMetadata.Raw | null;
        grouped_predictions: GroupedPredictionsLanguagePrediction.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataNerPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { GroupedPredictionsNerPrediction } from "./GroupedPredictionsNerPrediction.js";
import { TranscriptionMetadata } from "./TranscriptionMetadata.js";

export const PredictionsOptionalTranscriptionMetadataNerPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataNerPrediction.Raw,
    Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataNerPrediction
> = core.serialization.object({
    metadata: TranscriptionMetadata.optional(),
    groupedPredictions: core.serialization.property(
        "grouped_predictions",
        core.serialization.list(GroupedPredictionsNerPrediction),
    ),
});

export declare namespace PredictionsOptionalTranscriptionMetadataNerPrediction {
    export interface Raw {
        metadata?: TranscriptionMetadata.Raw | null;
        grouped_predictions: GroupedPredictionsNerPrediction.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataProsodyPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { GroupedPredictionsProsodyPrediction } from "./GroupedPredictionsProsodyPrediction.js";
import { TranscriptionMetadata } from "./TranscriptionMetadata.js";

export const PredictionsOptionalTranscriptionMetadataProsodyPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataProsodyPrediction.Raw,
    Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataProsodyPrediction
> = core.serialization.object({
    metadata: TranscriptionMetadata.optional(),
    groupedPredictions: core.serialization.property(
        "grouped_predictions",
        core.serialization.list(GroupedPredictionsProsodyPrediction),
    ),
});

export declare namespace PredictionsOptionalTranscriptionMetadataProsodyPrediction {
    export interface Raw {
        metadata?: TranscriptionMetadata.Raw | null;
        grouped_predictions: GroupedPredictionsProsodyPrediction.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Prosody.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Granularity } from "./Granularity.js";
import { Window } from "./Window.js";

export const Prosody: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Prosody.Raw,
    Hume.expressionMeasurement.batch.Prosody
> = core.serialization.object({
    granularity: Granularity.optional(),
    window: Window.optional(),
    identifySpeakers: core.serialization.property("identify_speakers", core.serialization.boolean().optional()),
});

export declare namespace Prosody {
    export interface Raw {
        granularity?: Granularity.Raw | null;
        window?: Window.Raw | null;
        identify_speakers?: boolean | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/ProsodyPrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { EmotionScore } from "./EmotionScore.js";
import { TimeInterval } from "./TimeInterval.js";

export const ProsodyPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.ProsodyPrediction.Raw,
    Hume.expressionMeasurement.batch.ProsodyPrediction
> = core.serialization.object({
    text: core.serialization.string().optional(),
    time: TimeInterval,
    confidence: core.serialization.number().optional(),
    speakerConfidence: core.serialization.property("speaker_confidence", core.serialization.number().optional()),
    emotions: core.serialization.list(EmotionScore),
});

export declare namespace ProsodyPrediction {
    export interface Raw {
        text?: string | null;
        time: TimeInterval.Raw;
        confidence?: number | null;
        speaker_confidence?: number | null;
        emotions: EmotionScore.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Queued.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Queued: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Queued.Raw,
    Hume.expressionMeasurement.batch.Queued
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
});

export declare namespace Queued {
    export interface Raw {
        created_timestamp_ms: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/QueuedState.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Queued } from "./Queued.js";

export const QueuedState: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.QueuedState.Raw,
    Hume.expressionMeasurement.batch.QueuedState
> = core.serialization.object({}).extend(Queued);

export declare namespace QueuedState {
    export interface Raw extends Queued.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/RegistryFileDetail.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const RegistryFileDetail: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.RegistryFileDetail.Raw,
    Hume.expressionMeasurement.batch.RegistryFileDetail
> = core.serialization.object({
    fileId: core.serialization.property("file_id", core.serialization.string()),
    fileUrl: core.serialization.property("file_url", core.serialization.string()),
});

export declare namespace RegistryFileDetail {
    export interface Raw {
        file_id: string;
        file_url: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Regression.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Regression: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Regression.Raw,
    Hume.expressionMeasurement.batch.Regression
> = core.serialization.record(core.serialization.string(), core.serialization.unknown());

export declare namespace Regression {
    export type Raw = Record<string, unknown>;
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/SentimentScore.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const SentimentScore: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.SentimentScore.Raw,
    Hume.expressionMeasurement.batch.SentimentScore
> = core.serialization.object({
    name: core.serialization.string(),
    score: core.serialization.number(),
});

export declare namespace SentimentScore {
    export interface Raw {
        name: string;
        score: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/SortBy.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const SortBy: core.serialization.Schema<
    serializers.expressionMeasurement.batch.SortBy.Raw,
    Hume.expressionMeasurement.batch.SortBy
> = core.serialization.enum_(["created", "started", "ended"]);

export declare namespace SortBy {
    export type Raw = "created" | "started" | "ended";
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Source.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { SourceFile } from "./SourceFile.js";
import { SourceTextSource } from "./SourceTextSource.js";
import { SourceUrl } from "./SourceUrl.js";

export const Source: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Source.Raw,
    Hume.expressionMeasurement.batch.Source
> = core.serialization
    .union("type", {
        url: SourceUrl,
        file: SourceFile,
        text: SourceTextSource,
    })
    .transform<Hume.expressionMeasurement.batch.Source>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace Source {
    export type Raw = Source.Url | Source.File | Source.Text;

    export interface Url extends SourceUrl.Raw {
        type: "url";
    }

    export interface File extends SourceFile.Raw {
        type: "file";
    }

    export interface Text extends SourceTextSource.Raw {
        type: "text";
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/SourceFile.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { File_ } from "./File_.js";

export const SourceFile: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.SourceFile.Raw,
    Hume.expressionMeasurement.batch.SourceFile
> = core.serialization.object({}).extend(File_);

export declare namespace SourceFile {
    export interface Raw extends File_.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/SourceTextSource.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const SourceTextSource: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.SourceTextSource.Raw,
    Hume.expressionMeasurement.batch.SourceTextSource
> = core.serialization.object({});

export declare namespace SourceTextSource {
    export type Raw = {};
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/SourceUrl.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Url } from "./Url.js";

export const SourceUrl: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.SourceUrl.Raw,
    Hume.expressionMeasurement.batch.SourceUrl
> = core.serialization.object({}).extend(Url);

export declare namespace SourceUrl {
    export interface Raw extends Url.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGeneration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { StateEmbeddingGenerationCompletedEmbeddingGeneration } from "./StateEmbeddingGenerationCompletedEmbeddingGeneration.js";
import { StateEmbeddingGenerationFailed } from "./StateEmbeddingGenerationFailed.js";
import { StateEmbeddingGenerationInProgress } from "./StateEmbeddingGenerationInProgress.js";
import { StateEmbeddingGenerationQueued } from "./StateEmbeddingGenerationQueued.js";

export const StateEmbeddingGeneration: core.serialization.Schema<
    serializers.expressionMeasurement.batch.StateEmbeddingGeneration.Raw,
    Hume.expressionMeasurement.batch.StateEmbeddingGeneration
> = core.serialization
    .union("status", {
        QUEUED: StateEmbeddingGenerationQueued,
        IN_PROGRESS: StateEmbeddingGenerationInProgress,
        COMPLETED: StateEmbeddingGenerationCompletedEmbeddingGeneration,
        FAILED: StateEmbeddingGenerationFailed,
    })
    .transform<Hume.expressionMeasurement.batch.StateEmbeddingGeneration>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace StateEmbeddingGeneration {
    export type Raw =
        | StateEmbeddingGeneration.Queued
        | StateEmbeddingGeneration.InProgress
        | StateEmbeddingGeneration.Completed
        | StateEmbeddingGeneration.Failed;

    export interface Queued extends StateEmbeddingGenerationQueued.Raw {
        status: "QUEUED";
    }

    export interface InProgress extends StateEmbeddingGenerationInProgress.Raw {
        status: "IN_PROGRESS";
    }

    export interface Completed extends StateEmbeddingGenerationCompletedEmbeddingGeneration.Raw {
        status: "COMPLETED";
    }

    export interface Failed extends StateEmbeddingGenerationFailed.Raw {
        status: "FAILED";
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationCompletedEmbeddingGeneration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CompletedEmbeddingGeneration } from "./CompletedEmbeddingGeneration.js";

export const StateEmbeddingGenerationCompletedEmbeddingGeneration: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateEmbeddingGenerationCompletedEmbeddingGeneration.Raw,
    Hume.expressionMeasurement.batch.StateEmbeddingGenerationCompletedEmbeddingGeneration
> = core.serialization.object({}).extend(CompletedEmbeddingGeneration);

export declare namespace StateEmbeddingGenerationCompletedEmbeddingGeneration {
    export interface Raw extends CompletedEmbeddingGeneration.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationFailed.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Failed } from "./Failed.js";

export const StateEmbeddingGenerationFailed: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateEmbeddingGenerationFailed.Raw,
    Hume.expressionMeasurement.batch.StateEmbeddingGenerationFailed
> = core.serialization.object({}).extend(Failed);

export declare namespace StateEmbeddingGenerationFailed {
    export interface Raw extends Failed.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationInProgress.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InProgress } from "./InProgress.js";

export const StateEmbeddingGenerationInProgress: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateEmbeddingGenerationInProgress.Raw,
    Hume.expressionMeasurement.batch.StateEmbeddingGenerationInProgress
> = core.serialization.object({}).extend(InProgress);

export declare namespace StateEmbeddingGenerationInProgress {
    export interface Raw extends InProgress.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationQueued.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Queued } from "./Queued.js";

export const StateEmbeddingGenerationQueued: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateEmbeddingGenerationQueued.Raw,
    Hume.expressionMeasurement.batch.StateEmbeddingGenerationQueued
> = core.serialization.object({}).extend(Queued);

export declare namespace StateEmbeddingGenerationQueued {
    export interface Raw extends Queued.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CompletedState } from "./CompletedState.js";
import { FailedState } from "./FailedState.js";
import { InProgressState } from "./InProgressState.js";
import { QueuedState } from "./QueuedState.js";

export const StateInference: core.serialization.Schema<
    serializers.expressionMeasurement.batch.StateInference.Raw,
    Hume.expressionMeasurement.batch.StateInference
> = core.serialization
    .union("status", {
        QUEUED: QueuedState,
        IN_PROGRESS: InProgressState,
        COMPLETED: CompletedState,
        FAILED: FailedState,
    })
    .transform<Hume.expressionMeasurement.batch.StateInference>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace StateInference {
    export type Raw =
        | StateInference.Queued
        | StateInference.InProgress
        | StateInference.Completed
        | StateInference.Failed;

    export interface Queued extends QueuedState.Raw {
        status: "QUEUED";
    }

    export interface InProgress extends InProgressState.Raw {
        status: "IN_PROGRESS";
    }

    export interface Completed extends CompletedState.Raw {
        status: "COMPLETED";
    }

    export interface Failed extends FailedState.Raw {
        status: "FAILED";
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { StateTlInferenceCompletedTlInference } from "./StateTlInferenceCompletedTlInference.js";
import { StateTlInferenceFailed } from "./StateTlInferenceFailed.js";
import { StateTlInferenceInProgress } from "./StateTlInferenceInProgress.js";
import { StateTlInferenceQueued } from "./StateTlInferenceQueued.js";

export const StateTlInference: core.serialization.Schema<
    serializers.expressionMeasurement.batch.StateTlInference.Raw,
    Hume.expressionMeasurement.batch.StateTlInference
> = core.serialization
    .union("status", {
        QUEUED: StateTlInferenceQueued,
        IN_PROGRESS: StateTlInferenceInProgress,
        COMPLETED: StateTlInferenceCompletedTlInference,
        FAILED: StateTlInferenceFailed,
    })
    .transform<Hume.expressionMeasurement.batch.StateTlInference>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace StateTlInference {
    export type Raw =
        | StateTlInference.Queued
        | StateTlInference.InProgress
        | StateTlInference.Completed
        | StateTlInference.Failed;

    export interface Queued extends StateTlInferenceQueued.Raw {
        status: "QUEUED";
    }

    export interface InProgress extends StateTlInferenceInProgress.Raw {
        status: "IN_PROGRESS";
    }

    export interface Completed extends StateTlInferenceCompletedTlInference.Raw {
        status: "COMPLETED";
    }

    export interface Failed extends StateTlInferenceFailed.Raw {
        status: "FAILED";
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInferenceCompletedTlInference.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CompletedTlInference } from "./CompletedTlInference.js";

export const StateTlInferenceCompletedTlInference: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTlInferenceCompletedTlInference.Raw,
    Hume.expressionMeasurement.batch.StateTlInferenceCompletedTlInference
> = core.serialization.object({}).extend(CompletedTlInference);

export declare namespace StateTlInferenceCompletedTlInference {
    export interface Raw extends CompletedTlInference.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInferenceFailed.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Failed } from "./Failed.js";

export const StateTlInferenceFailed: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTlInferenceFailed.Raw,
    Hume.expressionMeasurement.batch.StateTlInferenceFailed
> = core.serialization.object({}).extend(Failed);

export declare namespace StateTlInferenceFailed {
    export interface Raw extends Failed.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInferenceInProgress.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InProgress } from "./InProgress.js";

export const StateTlInferenceInProgress: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTlInferenceInProgress.Raw,
    Hume.expressionMeasurement.batch.StateTlInferenceInProgress
> = core.serialization.object({}).extend(InProgress);

export declare namespace StateTlInferenceInProgress {
    export interface Raw extends InProgress.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInferenceQueued.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Queued } from "./Queued.js";

export const StateTlInferenceQueued: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTlInferenceQueued.Raw,
    Hume.expressionMeasurement.batch.StateTlInferenceQueued
> = core.serialization.object({}).extend(Queued);

export declare namespace StateTlInferenceQueued {
    export interface Raw extends Queued.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateTraining.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { StateTrainingCompletedTraining } from "./StateTrainingCompletedTraining.js";
import { StateTrainingFailed } from "./StateTrainingFailed.js";
import { StateTrainingInProgress } from "./StateTrainingInProgress.js";
import { StateTrainingQueued } from "./StateTrainingQueued.js";

export const StateTraining: core.serialization.Schema<
    serializers.expressionMeasurement.batch.StateTraining.Raw,
    Hume.expressionMeasurement.batch.StateTraining
> = core.serialization
    .union("status", {
        QUEUED: StateTrainingQueued,
        IN_PROGRESS: StateTrainingInProgress,
        COMPLETED: StateTrainingCompletedTraining,
        FAILED: StateTrainingFailed,
    })
    .transform<Hume.expressionMeasurement.batch.StateTraining>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace StateTraining {
    export type Raw = StateTraining.Queued | StateTraining.InProgress | StateTraining.Completed | StateTraining.Failed;

    export interface Queued extends StateTrainingQueued.Raw {
        status: "QUEUED";
    }

    export interface InProgress extends StateTrainingInProgress.Raw {
        status: "IN_PROGRESS";
    }

    export interface Completed extends StateTrainingCompletedTraining.Raw {
        status: "COMPLETED";
    }

    export interface Failed extends StateTrainingFailed.Raw {
        status: "FAILED";
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateTrainingCompletedTraining.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CompletedTraining } from "./CompletedTraining.js";

export const StateTrainingCompletedTraining: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTrainingCompletedTraining.Raw,
    Hume.expressionMeasurement.batch.StateTrainingCompletedTraining
> = core.serialization.object({}).extend(CompletedTraining);

export declare namespace StateTrainingCompletedTraining {
    export interface Raw extends CompletedTraining.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateTrainingFailed.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Failed } from "./Failed.js";

export const StateTrainingFailed: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTrainingFailed.Raw,
    Hume.expressionMeasurement.batch.StateTrainingFailed
> = core.serialization.object({}).extend(Failed);

export declare namespace StateTrainingFailed {
    export interface Raw extends Failed.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateTrainingInProgress.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InProgress } from "./InProgress.js";

export const StateTrainingInProgress: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTrainingInProgress.Raw,
    Hume.expressionMeasurement.batch.StateTrainingInProgress
> = core.serialization.object({}).extend(InProgress);

export declare namespace StateTrainingInProgress {
    export interface Raw extends InProgress.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/StateTrainingQueued.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Queued } from "./Queued.js";

export const StateTrainingQueued: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTrainingQueued.Raw,
    Hume.expressionMeasurement.batch.StateTrainingQueued
> = core.serialization.object({}).extend(Queued);

export declare namespace StateTrainingQueued {
    export interface Raw extends Queued.Raw {}
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Status.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Status: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Status.Raw,
    Hume.expressionMeasurement.batch.Status
> = core.serialization.enum_(["QUEUED", "IN_PROGRESS", "COMPLETED", "FAILED"]);

export declare namespace Status {
    export type Raw = "QUEUED" | "IN_PROGRESS" | "COMPLETED" | "FAILED";
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Tag.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Tag: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Tag.Raw,
    Hume.expressionMeasurement.batch.Tag
> = core.serialization.object({
    key: core.serialization.string(),
    value: core.serialization.string(),
});

export declare namespace Tag {
    export interface Raw {
        key: string;
        value: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Target.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Target: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Target.Raw,
    Hume.expressionMeasurement.batch.Target
> = core.serialization.undiscriminatedUnion([
    core.serialization.number(),
    core.serialization.number(),
    core.serialization.string(),
]);

export declare namespace Target {
    export type Raw = number | number | string;
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Task.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { TaskClassification } from "./TaskClassification.js";
import { TaskRegression } from "./TaskRegression.js";

export const Task: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Task.Raw,
    Hume.expressionMeasurement.batch.Task
> = core.serialization
    .union("type", {
        classification: TaskClassification,
        regression: TaskRegression,
    })
    .transform<Hume.expressionMeasurement.batch.Task>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace Task {
    export type Raw = Task.Classification | Task.Regression;

    export interface Classification extends TaskClassification.Raw {
        type: "classification";
    }

    export interface Regression extends TaskRegression.Raw {
        type: "regression";
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/TaskClassification.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TaskClassification: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TaskClassification.Raw,
    Hume.expressionMeasurement.batch.TaskClassification
> = core.serialization.object({});

export declare namespace TaskClassification {
    export type Raw = {};
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/TaskRegression.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TaskRegression: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TaskRegression.Raw,
    Hume.expressionMeasurement.batch.TaskRegression
> = core.serialization.object({});

export declare namespace TaskRegression {
    export type Raw = {};
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/TextSource.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TextSource: core.serialization.Schema<
    serializers.expressionMeasurement.batch.TextSource.Raw,
    Hume.expressionMeasurement.batch.TextSource
> = core.serialization.record(core.serialization.string(), core.serialization.unknown());

export declare namespace TextSource {
    export type Raw = Record<string, unknown>;
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/TimeInterval.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TimeInterval: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TimeInterval.Raw,
    Hume.expressionMeasurement.batch.TimeInterval
> = core.serialization.object({
    begin: core.serialization.number(),
    end: core.serialization.number(),
});

export declare namespace TimeInterval {
    export interface Raw {
        begin: number;
        end: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/TlInferenceBaseRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CustomModel } from "./CustomModel.js";

export const TlInferenceBaseRequest: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TlInferenceBaseRequest.Raw,
    Hume.expressionMeasurement.batch.TlInferenceBaseRequest
> = core.serialization.object({
    customModel: core.serialization.property("custom_model", CustomModel),
    urls: core.serialization.list(core.serialization.string()).optional(),
    callbackUrl: core.serialization.property("callback_url", core.serialization.string().optional()),
    notify: core.serialization.boolean().optional(),
});

export declare namespace TlInferenceBaseRequest {
    export interface Raw {
        custom_model: CustomModel.Raw;
        urls?: string[] | null;
        callback_url?: string | null;
        notify?: boolean | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/TlInferencePrediction.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CustomModelPrediction } from "./CustomModelPrediction.js";

export const TlInferencePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TlInferencePrediction.Raw,
    Hume.expressionMeasurement.batch.TlInferencePrediction
> = core.serialization.object({
    file: core.serialization.string(),
    fileType: core.serialization.property("file_type", core.serialization.string()),
    customModels: core.serialization.property(
        "custom_models",
        core.serialization.record(core.serialization.string(), CustomModelPrediction),
    ),
});

export declare namespace TlInferencePrediction {
    export interface Raw {
        file: string;
        file_type: string;
        custom_models: Record<string, CustomModelPrediction.Raw>;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/TlInferenceResults.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Error_ } from "./Error_.js";
import { TlInferencePrediction } from "./TlInferencePrediction.js";

export const TlInferenceResults: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TlInferenceResults.Raw,
    Hume.expressionMeasurement.batch.TlInferenceResults
> = core.serialization.object({
    predictions: core.serialization.list(TlInferencePrediction),
    errors: core.serialization.list(Error_),
});

export declare namespace TlInferenceResults {
    export interface Raw {
        predictions: TlInferencePrediction.Raw[];
        errors: Error_.Raw[];
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/TlInferenceSourcePredictResult.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Source } from "./Source.js";
import { TlInferenceResults } from "./TlInferenceResults.js";

export const TlInferenceSourcePredictResult: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TlInferenceSourcePredictResult.Raw,
    Hume.expressionMeasurement.batch.TlInferenceSourcePredictResult
> = core.serialization.object({
    source: Source,
    results: TlInferenceResults.optional(),
    error: core.serialization.string().optional(),
});

export declare namespace TlInferenceSourcePredictResult {
    export interface Raw {
        source: Source.Raw;
        results?: TlInferenceResults.Raw | null;
        error?: string | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/ToxicityScore.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const ToxicityScore: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.ToxicityScore.Raw,
    Hume.expressionMeasurement.batch.ToxicityScore
> = core.serialization.object({
    name: core.serialization.string(),
    score: core.serialization.number(),
});

export declare namespace ToxicityScore {
    export interface Raw {
        name: string;
        score: number;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/TrainingBaseRequest.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Alternative } from "./Alternative.js";
import { CustomModelRequest } from "./CustomModelRequest.js";
import { Dataset } from "./Dataset.js";
import { EvaluationArgs } from "./EvaluationArgs.js";
import { Task } from "./Task.js";

export const TrainingBaseRequest: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TrainingBaseRequest.Raw,
    Hume.expressionMeasurement.batch.TrainingBaseRequest
> = core.serialization.object({
    customModel: core.serialization.property("custom_model", CustomModelRequest),
    dataset: Dataset,
    targetFeature: core.serialization.property("target_feature", core.serialization.string().optional()),
    task: Task.optional(),
    evaluation: EvaluationArgs.optional(),
    alternatives: core.serialization.list(Alternative).optional(),
    callbackUrl: core.serialization.property("callback_url", core.serialization.string().optional()),
    notify: core.serialization.boolean().optional(),
});

export declare namespace TrainingBaseRequest {
    export interface Raw {
        custom_model: CustomModelRequest.Raw;
        dataset: Dataset.Raw;
        target_feature?: string | null;
        task?: Task.Raw | null;
        evaluation?: EvaluationArgs.Raw | null;
        alternatives?: Alternative.Raw[] | null;
        callback_url?: string | null;
        notify?: boolean | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/TrainingCustomModel.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TrainingCustomModel: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TrainingCustomModel.Raw,
    Hume.expressionMeasurement.batch.TrainingCustomModel
> = core.serialization.object({
    id: core.serialization.string(),
    versionId: core.serialization.property("version_id", core.serialization.string().optional()),
});

export declare namespace TrainingCustomModel {
    export interface Raw {
        id: string;
        version_id?: string | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Transcription.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Bcp47Tag } from "./Bcp47Tag.js";

export const Transcription: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Transcription.Raw,
    Hume.expressionMeasurement.batch.Transcription
> = core.serialization.object({
    language: Bcp47Tag.optional(),
    identifySpeakers: core.serialization.property("identify_speakers", core.serialization.boolean().optional()),
    confidenceThreshold: core.serialization.property("confidence_threshold", core.serialization.number().optional()),
});

export declare namespace Transcription {
    export interface Raw {
        language?: Bcp47Tag.Raw | null;
        identify_speakers?: boolean | null;
        confidence_threshold?: number | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/TranscriptionMetadata.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Bcp47Tag } from "./Bcp47Tag.js";

export const TranscriptionMetadata: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TranscriptionMetadata.Raw,
    Hume.expressionMeasurement.batch.TranscriptionMetadata
> = core.serialization.object({
    confidence: core.serialization.number(),
    detectedLanguage: core.serialization.property("detected_language", Bcp47Tag.optional()),
});

export declare namespace TranscriptionMetadata {
    export interface Raw {
        confidence: number;
        detected_language?: Bcp47Tag.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Type.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Type: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Type.Raw,
    Hume.expressionMeasurement.batch.Type
> = core.serialization.enum_(["EMBEDDING_GENERATION", "INFERENCE", "TL_INFERENCE", "TRAINING"]);

export declare namespace Type {
    export type Raw = "EMBEDDING_GENERATION" | "INFERENCE" | "TL_INFERENCE" | "TRAINING";
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Unconfigurable.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Unconfigurable: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Unconfigurable.Raw,
    Hume.expressionMeasurement.batch.Unconfigurable
> = core.serialization.record(core.serialization.string(), core.serialization.unknown());

export declare namespace Unconfigurable {
    export type Raw = Record<string, unknown>;
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/UnionJob.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InferenceJob } from "./InferenceJob.js";

export const UnionJob: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.UnionJob.Raw,
    Hume.expressionMeasurement.batch.UnionJob
> = InferenceJob;

export declare namespace UnionJob {
    export type Raw = InferenceJob.Raw;
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/UnionPredictResult.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InferenceSourcePredictResult } from "./InferenceSourcePredictResult.js";

export const UnionPredictResult: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.UnionPredictResult.Raw,
    Hume.expressionMeasurement.batch.UnionPredictResult
> = InferenceSourcePredictResult;

export declare namespace UnionPredictResult {
    export type Raw = InferenceSourcePredictResult.Raw;
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Url.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Url: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Url.Raw,
    Hume.expressionMeasurement.batch.Url
> = core.serialization.object({
    url: core.serialization.string(),
});

export declare namespace Url {
    export interface Raw {
        url: string;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/ValidationArgs.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Target } from "./Target.js";

export const ValidationArgs: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.ValidationArgs.Raw,
    Hume.expressionMeasurement.batch.ValidationArgs
> = core.serialization.object({
    positiveLabel: core.serialization.property("positive_label", Target.optional()),
});

export declare namespace ValidationArgs {
    export interface Raw {
        positive_label?: Target.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/When.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const When: core.serialization.Schema<
    serializers.expressionMeasurement.batch.When.Raw,
    Hume.expressionMeasurement.batch.When
> = core.serialization.enum_(["created_before", "created_after"]);

export declare namespace When {
    export type Raw = "created_before" | "created_after";
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/Window.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Window: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Window.Raw,
    Hume.expressionMeasurement.batch.Window
> = core.serialization.object({
    length: core.serialization.number().optional(),
    step: core.serialization.number().optional(),
});

export declare namespace Window {
    export interface Raw {
        length?: number | null;
        step?: number | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/batch/types/index.ts
```typescript
export * from "./Alternative.js";
export * from "./Bcp47Tag.js";
export * from "./BoundingBox.js";
export * from "./BurstPrediction.js";
export * from "./Classification.js";
export * from "./CompletedEmbeddingGeneration.js";
export * from "./CompletedInference.js";
export * from "./CompletedState.js";
export * from "./CompletedTlInference.js";
export * from "./CompletedTraining.js";
export * from "./CustomModel.js";
export * from "./CustomModelId.js";
export * from "./CustomModelPrediction.js";
export * from "./CustomModelRequest.js";
export * from "./CustomModelsInferenceJob.js";
export * from "./CustomModelsTrainingJob.js";
export * from "./CustomModelVersionId.js";
export * from "./Dataset.js";
export * from "./DatasetId.js";
export * from "./DatasetVersionId.js";
export * from "./DescriptionsScore.js";
export * from "./Direction.js";
export * from "./EmbeddingGenerationBaseRequest.js";
export * from "./EmbeddingGenerationJob.js";
export * from "./EmotionScore.js";
export * from "./Error_.js";
export * from "./EvaluationArgs.js";
export * from "./Face.js";
export * from "./FacemeshPrediction.js";
export * from "./FacePrediction.js";
export * from "./FacsScore.js";
export * from "./Failed.js";
export * from "./FailedState.js";
export * from "./File_.js";
export * from "./Granularity.js";
export * from "./GroupedPredictionsBurstPrediction.js";
export * from "./GroupedPredictionsFacemeshPrediction.js";
export * from "./GroupedPredictionsFacePrediction.js";
export * from "./GroupedPredictionsLanguagePrediction.js";
export * from "./GroupedPredictionsNerPrediction.js";
export * from "./GroupedPredictionsProsodyPrediction.js";
export * from "./InferenceBaseRequest.js";
export * from "./InferenceJob.js";
export * from "./InferencePrediction.js";
export * from "./InferenceRequest.js";
export * from "./InferenceResults.js";
export * from "./InferenceSourcePredictResult.js";
export * from "./InProgress.js";
export * from "./InProgressState.js";
export * from "./JobEmbeddingGeneration.js";
export * from "./JobId.js";
export * from "./JobInference.js";
export * from "./JobTlInference.js";
export * from "./JobTraining.js";
export * from "./Language.js";
export * from "./LanguagePrediction.js";
export * from "./Models.js";
export * from "./ModelsPredictions.js";
export * from "./Ner.js";
export * from "./NerPrediction.js";
export * from "./Null.js";
export * from "./PositionInterval.js";
export * from "./PredictionsOptionalNullBurstPrediction.js";
export * from "./PredictionsOptionalNullFacemeshPrediction.js";
export * from "./PredictionsOptionalNullFacePrediction.js";
export * from "./PredictionsOptionalTranscriptionMetadataLanguagePrediction.js";
export * from "./PredictionsOptionalTranscriptionMetadataNerPrediction.js";
export * from "./PredictionsOptionalTranscriptionMetadataProsodyPrediction.js";
export * from "./Prosody.js";
export * from "./ProsodyPrediction.js";
export * from "./Queued.js";
export * from "./QueuedState.js";
export * from "./RegistryFileDetail.js";
export * from "./Regression.js";
export * from "./SentimentScore.js";
export * from "./SortBy.js";
export * from "./Source.js";
export * from "./SourceFile.js";
export * from "./SourceTextSource.js";
export * from "./SourceUrl.js";
export * from "./StateEmbeddingGeneration.js";
export * from "./StateEmbeddingGenerationCompletedEmbeddingGeneration.js";
export * from "./StateEmbeddingGenerationFailed.js";
export * from "./StateEmbeddingGenerationInProgress.js";
export * from "./StateEmbeddingGenerationQueued.js";
export * from "./StateInference.js";
export * from "./StateTlInference.js";
export * from "./StateTlInferenceCompletedTlInference.js";
export * from "./StateTlInferenceFailed.js";
export * from "./StateTlInferenceInProgress.js";
export * from "./StateTlInferenceQueued.js";
export * from "./StateTraining.js";
export * from "./StateTrainingCompletedTraining.js";
export * from "./StateTrainingFailed.js";
export * from "./StateTrainingInProgress.js";
export * from "./StateTrainingQueued.js";
export * from "./Status.js";
export * from "./Tag.js";
export * from "./Target.js";
export * from "./Task.js";
export * from "./TaskClassification.js";
export * from "./TaskRegression.js";
export * from "./TextSource.js";
export * from "./TimeInterval.js";
export * from "./TlInferenceBaseRequest.js";
export * from "./TlInferencePrediction.js";
export * from "./TlInferenceResults.js";
export * from "./TlInferenceSourcePredictResult.js";
export * from "./ToxicityScore.js";
export * from "./TrainingBaseRequest.js";
export * from "./TrainingCustomModel.js";
export * from "./Transcription.js";
export * from "./TranscriptionMetadata.js";
export * from "./Type.js";
export * from "./Unconfigurable.js";
export * from "./UnionJob.js";
export * from "./UnionPredictResult.js";
export * from "./Url.js";
export * from "./ValidationArgs.js";
export * from "./When.js";
export * from "./Window.js";

```


## /src/serialization/resources/expressionMeasurement/resources/index.ts
```typescript
export * as batch from "./batch/index.js";
export * as stream from "./stream/index.js";

```


## /src/serialization/resources/expressionMeasurement/resources/stream/index.ts
```typescript
export * from "./resources/index.js";
export * from "./types/index.js";

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/index.ts
```typescript
export * from "./stream/client/socket/index.js";
export * as stream from "./stream/index.js";
export * from "./stream/types/index.js";

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/client/index.ts
```typescript
export * from "./socket/index.js";

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/client/socket/StreamSocketResponse.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../../api/index.js";
import * as core from "../../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../../index.js";
import { SubscribeEvent } from "../../types/SubscribeEvent.js";

export const StreamSocketResponse: core.serialization.Schema<
    serializers.expressionMeasurement.stream.StreamSocketResponse.Raw,
    Hume.expressionMeasurement.stream.SubscribeEvent
> = core.serialization.undiscriminatedUnion([SubscribeEvent]);

export declare namespace StreamSocketResponse {
    export type Raw = SubscribeEvent.Raw;
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/client/socket/index.ts
```typescript
export { StreamSocketResponse } from "./StreamSocketResponse.js";

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/index.ts
```typescript
export * from "./client/index.js";
export * from "./types/index.js";

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/Config.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamFace } from "./StreamFace.js";
import { StreamLanguage } from "./StreamLanguage.js";

export const Config: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.Config.Raw,
    Hume.expressionMeasurement.stream.Config
> = core.serialization.object({
    burst: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    face: StreamFace.optional(),
    facemesh: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    language: StreamLanguage.optional(),
    prosody: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
});

export declare namespace Config {
    export interface Raw {
        burst?: Record<string, unknown> | null;
        face?: StreamFace.Raw | null;
        facemesh?: Record<string, unknown> | null;
        language?: StreamLanguage.Raw | null;
        prosody?: Record<string, unknown> | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/JobDetails.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";

export const JobDetails: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.JobDetails.Raw,
    Hume.expressionMeasurement.stream.JobDetails
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string().optional()),
});

export declare namespace JobDetails {
    export interface Raw {
        job_id?: string | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamErrorMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { JobDetails } from "./JobDetails.js";

export const StreamErrorMessage: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamErrorMessage.Raw,
    Hume.expressionMeasurement.stream.StreamErrorMessage
> = core.serialization.object({
    error: core.serialization.string().optional(),
    code: core.serialization.string().optional(),
    payloadId: core.serialization.property("payload_id", core.serialization.string().optional()),
    jobDetails: core.serialization.property("job_details", JobDetails.optional()),
});

export declare namespace StreamErrorMessage {
    export interface Raw {
        error?: string | null;
        code?: string | null;
        payload_id?: string | null;
        job_details?: JobDetails.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamFace.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";

export const StreamFace: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamFace.Raw,
    Hume.expressionMeasurement.stream.StreamFace
> = core.serialization.object({
    facs: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    descriptions: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    identifyFaces: core.serialization.property("identify_faces", core.serialization.boolean().optional()),
    fpsPred: core.serialization.property("fps_pred", core.serialization.number().optional()),
    probThreshold: core.serialization.property("prob_threshold", core.serialization.number().optional()),
    minFaceSize: core.serialization.property("min_face_size", core.serialization.number().optional()),
});

export declare namespace StreamFace {
    export interface Raw {
        facs?: Record<string, unknown> | null;
        descriptions?: Record<string, unknown> | null;
        identify_faces?: boolean | null;
        fps_pred?: number | null;
        prob_threshold?: number | null;
        min_face_size?: number | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamLanguage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";

export const StreamLanguage: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamLanguage.Raw,
    Hume.expressionMeasurement.stream.StreamLanguage
> = core.serialization.object({
    sentiment: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    toxicity: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    granularity: core.serialization.string().optional(),
});

export declare namespace StreamLanguage {
    export interface Raw {
        sentiment?: Record<string, unknown> | null;
        toxicity?: Record<string, unknown> | null;
        granularity?: string | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictions.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamModelPredictionsBurst } from "./StreamModelPredictionsBurst.js";
import { StreamModelPredictionsFace } from "./StreamModelPredictionsFace.js";
import { StreamModelPredictionsFacemesh } from "./StreamModelPredictionsFacemesh.js";
import { StreamModelPredictionsJobDetails } from "./StreamModelPredictionsJobDetails.js";
import { StreamModelPredictionsLanguage } from "./StreamModelPredictionsLanguage.js";
import { StreamModelPredictionsProsody } from "./StreamModelPredictionsProsody.js";

export const StreamModelPredictions: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictions.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictions
> = core.serialization.object({
    payloadId: core.serialization.property("payload_id", core.serialization.string().optional()),
    jobDetails: core.serialization.property("job_details", StreamModelPredictionsJobDetails.optional()),
    burst: StreamModelPredictionsBurst.optional(),
    face: StreamModelPredictionsFace.optional(),
    facemesh: StreamModelPredictionsFacemesh.optional(),
    language: StreamModelPredictionsLanguage.optional(),
    prosody: StreamModelPredictionsProsody.optional(),
});

export declare namespace StreamModelPredictions {
    export interface Raw {
        payload_id?: string | null;
        job_details?: StreamModelPredictionsJobDetails.Raw | null;
        burst?: StreamModelPredictionsBurst.Raw | null;
        face?: StreamModelPredictionsFace.Raw | null;
        facemesh?: StreamModelPredictionsFacemesh.Raw | null;
        language?: StreamModelPredictionsLanguage.Raw | null;
        prosody?: StreamModelPredictionsProsody.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsBurst.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamModelPredictionsBurstPredictionsItem } from "./StreamModelPredictionsBurstPredictionsItem.js";

export const StreamModelPredictionsBurst: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsBurst.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsBurst
> = core.serialization.object({
    predictions: core.serialization.list(StreamModelPredictionsBurstPredictionsItem).optional(),
});

export declare namespace StreamModelPredictionsBurst {
    export interface Raw {
        predictions?: StreamModelPredictionsBurstPredictionsItem.Raw[] | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsBurstPredictionsItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
import { TimeRange } from "../../../types/TimeRange.js";

export const StreamModelPredictionsBurstPredictionsItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsBurstPredictionsItem.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsBurstPredictionsItem
> = core.serialization.object({
    time: TimeRange.optional(),
    emotions: EmotionEmbedding.optional(),
});

export declare namespace StreamModelPredictionsBurstPredictionsItem {
    export interface Raw {
        time?: TimeRange.Raw | null;
        emotions?: EmotionEmbedding.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFace.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamModelPredictionsFacePredictionsItem } from "./StreamModelPredictionsFacePredictionsItem.js";

export const StreamModelPredictionsFace: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsFace.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsFace
> = core.serialization.object({
    predictions: core.serialization.list(StreamModelPredictionsFacePredictionsItem).optional(),
});

export declare namespace StreamModelPredictionsFace {
    export interface Raw {
        predictions?: StreamModelPredictionsFacePredictionsItem.Raw[] | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacePredictionsItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
import { StreamBoundingBox } from "../../../types/StreamBoundingBox.js";

export const StreamModelPredictionsFacePredictionsItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsFacePredictionsItem.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsFacePredictionsItem
> = core.serialization.object({
    frame: core.serialization.number().optional(),
    time: core.serialization.number().optional(),
    bbox: StreamBoundingBox.optional(),
    prob: core.serialization.number().optional(),
    faceId: core.serialization.property("face_id", core.serialization.string().optional()),
    emotions: EmotionEmbedding.optional(),
    facs: EmotionEmbedding.optional(),
    descriptions: EmotionEmbedding.optional(),
});

export declare namespace StreamModelPredictionsFacePredictionsItem {
    export interface Raw {
        frame?: number | null;
        time?: number | null;
        bbox?: StreamBoundingBox.Raw | null;
        prob?: number | null;
        face_id?: string | null;
        emotions?: EmotionEmbedding.Raw | null;
        facs?: EmotionEmbedding.Raw | null;
        descriptions?: EmotionEmbedding.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacemesh.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamModelPredictionsFacemeshPredictionsItem } from "./StreamModelPredictionsFacemeshPredictionsItem.js";

export const StreamModelPredictionsFacemesh: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsFacemesh.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsFacemesh
> = core.serialization.object({
    predictions: core.serialization.list(StreamModelPredictionsFacemeshPredictionsItem).optional(),
});

export declare namespace StreamModelPredictionsFacemesh {
    export interface Raw {
        predictions?: StreamModelPredictionsFacemeshPredictionsItem.Raw[] | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacemeshPredictionsItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";

export const StreamModelPredictionsFacemeshPredictionsItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsFacemeshPredictionsItem.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsFacemeshPredictionsItem
> = core.serialization.object({
    emotions: EmotionEmbedding.optional(),
});

export declare namespace StreamModelPredictionsFacemeshPredictionsItem {
    export interface Raw {
        emotions?: EmotionEmbedding.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsJobDetails.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";

export const StreamModelPredictionsJobDetails: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsJobDetails.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsJobDetails
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string().optional()),
});

export declare namespace StreamModelPredictionsJobDetails {
    export interface Raw {
        job_id?: string | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsLanguage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamModelPredictionsLanguagePredictionsItem } from "./StreamModelPredictionsLanguagePredictionsItem.js";

export const StreamModelPredictionsLanguage: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsLanguage.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsLanguage
> = core.serialization.object({
    predictions: core.serialization.list(StreamModelPredictionsLanguagePredictionsItem).optional(),
});

export declare namespace StreamModelPredictionsLanguage {
    export interface Raw {
        predictions?: StreamModelPredictionsLanguagePredictionsItem.Raw[] | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsLanguagePredictionsItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
import { Sentiment } from "../../../types/Sentiment.js";
import { TextPosition } from "../../../types/TextPosition.js";
import { Toxicity } from "../../../types/Toxicity.js";

export const StreamModelPredictionsLanguagePredictionsItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsLanguagePredictionsItem.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsLanguagePredictionsItem
> = core.serialization.object({
    text: core.serialization.string().optional(),
    position: TextPosition.optional(),
    emotions: EmotionEmbedding.optional(),
    sentiment: Sentiment.optional(),
    toxicity: Toxicity.optional(),
});

export declare namespace StreamModelPredictionsLanguagePredictionsItem {
    export interface Raw {
        text?: string | null;
        position?: TextPosition.Raw | null;
        emotions?: EmotionEmbedding.Raw | null;
        sentiment?: Sentiment.Raw | null;
        toxicity?: Toxicity.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsProsody.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamModelPredictionsProsodyPredictionsItem } from "./StreamModelPredictionsProsodyPredictionsItem.js";

export const StreamModelPredictionsProsody: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsProsody.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsProsody
> = core.serialization.object({
    predictions: core.serialization.list(StreamModelPredictionsProsodyPredictionsItem).optional(),
});

export declare namespace StreamModelPredictionsProsody {
    export interface Raw {
        predictions?: StreamModelPredictionsProsodyPredictionsItem.Raw[] | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsProsodyPredictionsItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
import { TimeRange } from "../../../types/TimeRange.js";

export const StreamModelPredictionsProsodyPredictionsItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsProsodyPredictionsItem.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsProsodyPredictionsItem
> = core.serialization.object({
    time: TimeRange.optional(),
    emotions: EmotionEmbedding.optional(),
});

export declare namespace StreamModelPredictionsProsodyPredictionsItem {
    export interface Raw {
        time?: TimeRange.Raw | null;
        emotions?: EmotionEmbedding.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelsEndpointPayload.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { Config } from "./Config.js";

export const StreamModelsEndpointPayload: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelsEndpointPayload.Raw,
    Hume.expressionMeasurement.stream.StreamModelsEndpointPayload
> = core.serialization.object({
    data: core.serialization.string().optional(),
    models: Config.optional(),
    streamWindowMs: core.serialization.property("stream_window_ms", core.serialization.number().optional()),
    resetStream: core.serialization.property("reset_stream", core.serialization.boolean().optional()),
    rawText: core.serialization.property("raw_text", core.serialization.boolean().optional()),
    jobDetails: core.serialization.property("job_details", core.serialization.boolean().optional()),
    payloadId: core.serialization.property("payload_id", core.serialization.string().optional()),
});

export declare namespace StreamModelsEndpointPayload {
    export interface Raw {
        data?: string | null;
        models?: Config.Raw | null;
        stream_window_ms?: number | null;
        reset_stream?: boolean | null;
        raw_text?: boolean | null;
        job_details?: boolean | null;
        payload_id?: string | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamWarningMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamWarningMessageJobDetails } from "./StreamWarningMessageJobDetails.js";

export const StreamWarningMessage: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamWarningMessage.Raw,
    Hume.expressionMeasurement.stream.StreamWarningMessage
> = core.serialization.object({
    warning: core.serialization.string().optional(),
    code: core.serialization.string().optional(),
    payloadId: core.serialization.property("payload_id", core.serialization.string().optional()),
    jobDetails: core.serialization.property("job_details", StreamWarningMessageJobDetails.optional()),
});

export declare namespace StreamWarningMessage {
    export interface Raw {
        warning?: string | null;
        code?: string | null;
        payload_id?: string | null;
        job_details?: StreamWarningMessageJobDetails.Raw | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamWarningMessageJobDetails.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";

export const StreamWarningMessageJobDetails: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamWarningMessageJobDetails.Raw,
    Hume.expressionMeasurement.stream.StreamWarningMessageJobDetails
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string().optional()),
});

export declare namespace StreamWarningMessageJobDetails {
    export interface Raw {
        job_id?: string | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/SubscribeEvent.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamErrorMessage } from "./StreamErrorMessage.js";
import { StreamModelPredictions } from "./StreamModelPredictions.js";
import { StreamWarningMessage } from "./StreamWarningMessage.js";

export const SubscribeEvent: core.serialization.Schema<
    serializers.expressionMeasurement.stream.SubscribeEvent.Raw,
    Hume.expressionMeasurement.stream.SubscribeEvent
> = core.serialization.undiscriminatedUnion([StreamModelPredictions, StreamErrorMessage, StreamWarningMessage]);

export declare namespace SubscribeEvent {
    export type Raw = StreamModelPredictions.Raw | StreamErrorMessage.Raw | StreamWarningMessage.Raw;
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/index.ts
```typescript
export * from "./Config.js";
export * from "./JobDetails.js";
export * from "./StreamErrorMessage.js";
export * from "./StreamFace.js";
export * from "./StreamLanguage.js";
export * from "./StreamModelPredictions.js";
export * from "./StreamModelPredictionsBurst.js";
export * from "./StreamModelPredictionsBurstPredictionsItem.js";
export * from "./StreamModelPredictionsFace.js";
export * from "./StreamModelPredictionsFacemesh.js";
export * from "./StreamModelPredictionsFacemeshPredictionsItem.js";
export * from "./StreamModelPredictionsFacePredictionsItem.js";
export * from "./StreamModelPredictionsJobDetails.js";
export * from "./StreamModelPredictionsLanguage.js";
export * from "./StreamModelPredictionsLanguagePredictionsItem.js";
export * from "./StreamModelPredictionsProsody.js";
export * from "./StreamModelPredictionsProsodyPredictionsItem.js";
export * from "./StreamModelsEndpointPayload.js";
export * from "./StreamWarningMessage.js";
export * from "./StreamWarningMessageJobDetails.js";
export * from "./SubscribeEvent.js";

```


## /src/serialization/resources/expressionMeasurement/resources/stream/types/EmotionEmbedding.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { EmotionEmbeddingItem } from "./EmotionEmbeddingItem.js";

export const EmotionEmbedding: core.serialization.Schema<
    serializers.expressionMeasurement.stream.EmotionEmbedding.Raw,
    Hume.expressionMeasurement.stream.EmotionEmbedding
> = core.serialization.list(EmotionEmbeddingItem);

export declare namespace EmotionEmbedding {
    export type Raw = EmotionEmbeddingItem.Raw[];
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/types/EmotionEmbeddingItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const EmotionEmbeddingItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.EmotionEmbeddingItem.Raw,
    Hume.expressionMeasurement.stream.EmotionEmbeddingItem
> = core.serialization.object({
    name: core.serialization.string().optional(),
    score: core.serialization.number().optional(),
});

export declare namespace EmotionEmbeddingItem {
    export interface Raw {
        name?: string | null;
        score?: number | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/types/Sentiment.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { SentimentItem } from "./SentimentItem.js";

export const Sentiment: core.serialization.Schema<
    serializers.expressionMeasurement.stream.Sentiment.Raw,
    Hume.expressionMeasurement.stream.Sentiment
> = core.serialization.list(SentimentItem);

export declare namespace Sentiment {
    export type Raw = SentimentItem.Raw[];
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/types/SentimentItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const SentimentItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.SentimentItem.Raw,
    Hume.expressionMeasurement.stream.SentimentItem
> = core.serialization.object({
    name: core.serialization.string().optional(),
    score: core.serialization.number().optional(),
});

export declare namespace SentimentItem {
    export interface Raw {
        name?: string | null;
        score?: number | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/types/StreamBoundingBox.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const StreamBoundingBox: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamBoundingBox.Raw,
    Hume.expressionMeasurement.stream.StreamBoundingBox
> = core.serialization.object({
    x: core.serialization.number().optional(),
    y: core.serialization.number().optional(),
    w: core.serialization.number().optional(),
    h: core.serialization.number().optional(),
});

export declare namespace StreamBoundingBox {
    export interface Raw {
        x?: number | null;
        y?: number | null;
        w?: number | null;
        h?: number | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/types/TextPosition.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TextPosition: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.TextPosition.Raw,
    Hume.expressionMeasurement.stream.TextPosition
> = core.serialization.object({
    begin: core.serialization.number().optional(),
    end: core.serialization.number().optional(),
});

export declare namespace TextPosition {
    export interface Raw {
        begin?: number | null;
        end?: number | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/types/TimeRange.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TimeRange: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.TimeRange.Raw,
    Hume.expressionMeasurement.stream.TimeRange
> = core.serialization.object({
    begin: core.serialization.number().optional(),
    end: core.serialization.number().optional(),
});

export declare namespace TimeRange {
    export interface Raw {
        begin?: number | null;
        end?: number | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/types/Toxicity.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ToxicityItem } from "./ToxicityItem.js";

export const Toxicity: core.serialization.Schema<
    serializers.expressionMeasurement.stream.Toxicity.Raw,
    Hume.expressionMeasurement.stream.Toxicity
> = core.serialization.list(ToxicityItem);

export declare namespace Toxicity {
    export type Raw = ToxicityItem.Raw[];
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/types/ToxicityItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const ToxicityItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.ToxicityItem.Raw,
    Hume.expressionMeasurement.stream.ToxicityItem
> = core.serialization.object({
    name: core.serialization.string().optional(),
    score: core.serialization.number().optional(),
});

export declare namespace ToxicityItem {
    export interface Raw {
        name?: string | null;
        score?: number | null;
    }
}

```


## /src/serialization/resources/expressionMeasurement/resources/stream/types/index.ts
```typescript
export * from "./EmotionEmbedding.js";
export * from "./EmotionEmbeddingItem.js";
export * from "./Sentiment.js";
export * from "./SentimentItem.js";
export * from "./StreamBoundingBox.js";
export * from "./TextPosition.js";
export * from "./TimeRange.js";
export * from "./Toxicity.js";
export * from "./ToxicityItem.js";

```


## /src/serialization/resources/index.ts
```typescript
export * as empathicVoice from "./empathicVoice/index.js";
export * as expressionMeasurement from "./expressionMeasurement/index.js";
export * as tts from "./tts/index.js";

```


## /src/serialization/resources/tts/index.ts
```typescript
export * from "./resources/index.js";
export * from "./types/index.js";

```


## /src/serialization/resources/tts/resources/index.ts
```typescript
export * from "./streamInput/client/socket/index.js";
export * as streamInput from "./streamInput/index.js";
export * from "./voices/client/requests/index.js";
export * as voices from "./voices/index.js";

```


## /src/serialization/resources/tts/resources/streamInput/client/index.ts
```typescript
export * from "./socket/index.js";

```


## /src/serialization/resources/tts/resources/streamInput/client/socket/StreamInputSocketResponse.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";
import { TtsOutput } from "../../../../types/TtsOutput.js";

export const StreamInputSocketResponse: core.serialization.Schema<
    serializers.tts.StreamInputSocketResponse.Raw,
    Hume.tts.TtsOutput
> = core.serialization.undiscriminatedUnion([TtsOutput]);

export declare namespace StreamInputSocketResponse {
    export type Raw = TtsOutput.Raw;
}

```


## /src/serialization/resources/tts/resources/streamInput/client/socket/index.ts
```typescript
export { StreamInputSocketResponse } from "./StreamInputSocketResponse.js";

```


## /src/serialization/resources/tts/resources/streamInput/index.ts
```typescript
export * from "./client/index.js";

```


## /src/serialization/resources/tts/resources/voices/client/index.ts
```typescript
export * from "./requests/index.js";

```


## /src/serialization/resources/tts/resources/voices/client/requests/PostedVoice.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedVoice: core.serialization.Schema<serializers.tts.PostedVoice.Raw, Hume.tts.PostedVoice> =
    core.serialization.object({
        generationId: core.serialization.property("generation_id", core.serialization.string()),
        name: core.serialization.string(),
    });

export declare namespace PostedVoice {
    export interface Raw {
        generation_id: string;
        name: string;
    }
}

```


## /src/serialization/resources/tts/resources/voices/client/requests/index.ts
```typescript
export { PostedVoice } from "./PostedVoice.js";

```


## /src/serialization/resources/tts/resources/voices/index.ts
```typescript
export * from "./client/index.js";

```


## /src/serialization/resources/tts/types/AudioEncoding.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AudioFormatType } from "./AudioFormatType.js";

export const AudioEncoding: core.serialization.ObjectSchema<serializers.tts.AudioEncoding.Raw, Hume.tts.AudioEncoding> =
    core.serialization.object({
        format: AudioFormatType,
        sampleRate: core.serialization.property("sample_rate", core.serialization.number()),
    });

export declare namespace AudioEncoding {
    export interface Raw {
        format: AudioFormatType.Raw;
        sample_rate: number;
    }
}

```


## /src/serialization/resources/tts/types/AudioFormatType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const AudioFormatType: core.serialization.Schema<serializers.tts.AudioFormatType.Raw, Hume.tts.AudioFormatType> =
    core.serialization.enum_(["mp3", "pcm", "wav"]);

export declare namespace AudioFormatType {
    export type Raw = "mp3" | "pcm" | "wav";
}

```


## /src/serialization/resources/tts/types/ErrorResponse.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ErrorResponse: core.serialization.ObjectSchema<serializers.tts.ErrorResponse.Raw, Hume.tts.ErrorResponse> =
    core.serialization.object({
        code: core.serialization.string().optional(),
        error: core.serialization.string().optional(),
        message: core.serialization.string().optional(),
    });

export declare namespace ErrorResponse {
    export interface Raw {
        code?: string | null;
        error?: string | null;
        message?: string | null;
    }
}

```


## /src/serialization/resources/tts/types/Format.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { FormatMp3 } from "./FormatMp3.js";
import { FormatPcm } from "./FormatPcm.js";
import { FormatWav } from "./FormatWav.js";

export const Format: core.serialization.Schema<serializers.tts.Format.Raw, Hume.tts.Format> =
    core.serialization.undiscriminatedUnion([FormatMp3, FormatPcm, FormatWav]);

export declare namespace Format {
    export type Raw = FormatMp3.Raw | FormatPcm.Raw | FormatWav.Raw;
}

```


## /src/serialization/resources/tts/types/FormatMp3.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const FormatMp3: core.serialization.ObjectSchema<serializers.tts.FormatMp3.Raw, Hume.tts.FormatMp3> =
    core.serialization.object({
        type: core.serialization.stringLiteral("mp3"),
    });

export declare namespace FormatMp3 {
    export interface Raw {
        type: "mp3";
    }
}

```


## /src/serialization/resources/tts/types/FormatPcm.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const FormatPcm: core.serialization.ObjectSchema<serializers.tts.FormatPcm.Raw, Hume.tts.FormatPcm> =
    core.serialization.object({
        type: core.serialization.stringLiteral("pcm"),
    });

export declare namespace FormatPcm {
    export interface Raw {
        type: "pcm";
    }
}

```


## /src/serialization/resources/tts/types/FormatWav.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const FormatWav: core.serialization.ObjectSchema<serializers.tts.FormatWav.Raw, Hume.tts.FormatWav> =
    core.serialization.object({
        type: core.serialization.stringLiteral("wav"),
    });

export declare namespace FormatWav {
    export interface Raw {
        type: "wav";
    }
}

```


## /src/serialization/resources/tts/types/HttpValidationError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ValidationError } from "./ValidationError.js";

export const HttpValidationError: core.serialization.ObjectSchema<
    serializers.tts.HttpValidationError.Raw,
    Hume.tts.HttpValidationError
> = core.serialization.object({
    detail: core.serialization.list(ValidationError).optional(),
});

export declare namespace HttpValidationError {
    export interface Raw {
        detail?: ValidationError.Raw[] | null;
    }
}

```


## /src/serialization/resources/tts/types/MillisecondInterval.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const MillisecondInterval: core.serialization.ObjectSchema<
    serializers.tts.MillisecondInterval.Raw,
    Hume.tts.MillisecondInterval
> = core.serialization.object({
    begin: core.serialization.number(),
    end: core.serialization.number(),
});

export declare namespace MillisecondInterval {
    export interface Raw {
        begin: number;
        end: number;
    }
}

```


## /src/serialization/resources/tts/types/OctaveVersion.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const OctaveVersion: core.serialization.Schema<serializers.tts.OctaveVersion.Raw, Hume.tts.OctaveVersion> =
    core.serialization.enum_(["1", "2"]);

export declare namespace OctaveVersion {
    export type Raw = "1" | "2";
}

```


## /src/serialization/resources/tts/types/PostedContext.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedContextWithGenerationId } from "./PostedContextWithGenerationId.js";
import { PostedContextWithUtterances } from "./PostedContextWithUtterances.js";

export const PostedContext: core.serialization.Schema<serializers.tts.PostedContext.Raw, Hume.tts.PostedContext> =
    core.serialization.undiscriminatedUnion([PostedContextWithGenerationId, PostedContextWithUtterances]);

export declare namespace PostedContext {
    export type Raw = PostedContextWithGenerationId.Raw | PostedContextWithUtterances.Raw;
}

```


## /src/serialization/resources/tts/types/PostedContextWithGenerationId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedContextWithGenerationId: core.serialization.ObjectSchema<
    serializers.tts.PostedContextWithGenerationId.Raw,
    Hume.tts.PostedContextWithGenerationId
> = core.serialization.object({
    generationId: core.serialization.property("generation_id", core.serialization.string()),
});

export declare namespace PostedContextWithGenerationId {
    export interface Raw {
        generation_id: string;
    }
}

```


## /src/serialization/resources/tts/types/PostedContextWithUtterances.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedUtterance } from "./PostedUtterance.js";

export const PostedContextWithUtterances: core.serialization.ObjectSchema<
    serializers.tts.PostedContextWithUtterances.Raw,
    Hume.tts.PostedContextWithUtterances
> = core.serialization.object({
    utterances: core.serialization.list(PostedUtterance),
});

export declare namespace PostedContextWithUtterances {
    export interface Raw {
        utterances: PostedUtterance.Raw[];
    }
}

```


## /src/serialization/resources/tts/types/PostedTts.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { Format } from "./Format.js";
import { OctaveVersion } from "./OctaveVersion.js";
import { PostedContext } from "./PostedContext.js";
import { PostedUtterance } from "./PostedUtterance.js";
import { TimestampType } from "./TimestampType.js";

export const PostedTts: core.serialization.ObjectSchema<serializers.tts.PostedTts.Raw, Hume.tts.PostedTts> =
    core.serialization.object({
        context: PostedContext.optional(),
        format: Format.optional(),
        includeTimestampTypes: core.serialization.property(
            "include_timestamp_types",
            core.serialization.list(TimestampType).optional(),
        ),
        numGenerations: core.serialization.property("num_generations", core.serialization.number().optional()),
        splitUtterances: core.serialization.property("split_utterances", core.serialization.boolean().optional()),
        stripHeaders: core.serialization.property("strip_headers", core.serialization.boolean().optional()),
        utterances: core.serialization.list(PostedUtterance),
        version: OctaveVersion.optional(),
        instantMode: core.serialization.property("instant_mode", core.serialization.boolean().optional()),
    });

export declare namespace PostedTts {
    export interface Raw {
        context?: PostedContext.Raw | null;
        format?: Format.Raw | null;
        include_timestamp_types?: TimestampType.Raw[] | null;
        num_generations?: number | null;
        split_utterances?: boolean | null;
        strip_headers?: boolean | null;
        utterances: PostedUtterance.Raw[];
        version?: OctaveVersion.Raw | null;
        instant_mode?: boolean | null;
    }
}

```


## /src/serialization/resources/tts/types/PostedUtterance.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedUtteranceVoice } from "./PostedUtteranceVoice.js";

export const PostedUtterance: core.serialization.ObjectSchema<
    serializers.tts.PostedUtterance.Raw,
    Hume.tts.PostedUtterance
> = core.serialization.object({
    description: core.serialization.string().optional(),
    speed: core.serialization.number().optional(),
    text: core.serialization.string(),
    trailingSilence: core.serialization.property("trailing_silence", core.serialization.number().optional()),
    voice: PostedUtteranceVoice.optional(),
});

export declare namespace PostedUtterance {
    export interface Raw {
        description?: string | null;
        speed?: number | null;
        text: string;
        trailing_silence?: number | null;
        voice?: PostedUtteranceVoice.Raw | null;
    }
}

```


## /src/serialization/resources/tts/types/PostedUtteranceVoice.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedUtteranceVoiceWithId } from "./PostedUtteranceVoiceWithId.js";
import { PostedUtteranceVoiceWithName } from "./PostedUtteranceVoiceWithName.js";

export const PostedUtteranceVoice: core.serialization.Schema<
    serializers.tts.PostedUtteranceVoice.Raw,
    Hume.tts.PostedUtteranceVoice
> = core.serialization.undiscriminatedUnion([PostedUtteranceVoiceWithId, PostedUtteranceVoiceWithName]);

export declare namespace PostedUtteranceVoice {
    export type Raw = PostedUtteranceVoiceWithId.Raw | PostedUtteranceVoiceWithName.Raw;
}

```


## /src/serialization/resources/tts/types/PostedUtteranceVoiceWithId.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceProvider } from "./VoiceProvider.js";

export const PostedUtteranceVoiceWithId: core.serialization.ObjectSchema<
    serializers.tts.PostedUtteranceVoiceWithId.Raw,
    Hume.tts.PostedUtteranceVoiceWithId
> = core.serialization.object({
    id: core.serialization.string(),
    provider: VoiceProvider.optional(),
});

export declare namespace PostedUtteranceVoiceWithId {
    export interface Raw {
        id: string;
        provider?: VoiceProvider.Raw | null;
    }
}

```


## /src/serialization/resources/tts/types/PostedUtteranceVoiceWithName.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceProvider } from "./VoiceProvider.js";

export const PostedUtteranceVoiceWithName: core.serialization.ObjectSchema<
    serializers.tts.PostedUtteranceVoiceWithName.Raw,
    Hume.tts.PostedUtteranceVoiceWithName
> = core.serialization.object({
    name: core.serialization.string(),
    provider: VoiceProvider.optional(),
});

export declare namespace PostedUtteranceVoiceWithName {
    export interface Raw {
        name: string;
        provider?: VoiceProvider.Raw | null;
    }
}

```


## /src/serialization/resources/tts/types/PublishTts.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedUtteranceVoice } from "./PostedUtteranceVoice.js";

export const PublishTts: core.serialization.ObjectSchema<serializers.tts.PublishTts.Raw, Hume.tts.PublishTts> =
    core.serialization.object({
        close: core.serialization.boolean().optional(),
        description: core.serialization.string().optional(),
        flush: core.serialization.boolean().optional(),
        speed: core.serialization.number().optional(),
        text: core.serialization.string().optional(),
        trailingSilence: core.serialization.property("trailing_silence", core.serialization.number().optional()),
        voice: PostedUtteranceVoice.optional(),
    });

export declare namespace PublishTts {
    export interface Raw {
        close?: boolean | null;
        description?: string | null;
        flush?: boolean | null;
        speed?: number | null;
        text?: string | null;
        trailing_silence?: number | null;
        voice?: PostedUtteranceVoice.Raw | null;
    }
}

```


## /src/serialization/resources/tts/types/ReturnGeneration.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AudioEncoding } from "./AudioEncoding.js";
import { Snippet } from "./Snippet.js";

export const ReturnGeneration: core.serialization.ObjectSchema<
    serializers.tts.ReturnGeneration.Raw,
    Hume.tts.ReturnGeneration
> = core.serialization.object({
    audio: core.serialization.string(),
    duration: core.serialization.number(),
    encoding: AudioEncoding,
    fileSize: core.serialization.property("file_size", core.serialization.number()),
    generationId: core.serialization.property("generation_id", core.serialization.string()),
    snippets: core.serialization.list(core.serialization.list(Snippet)),
});

export declare namespace ReturnGeneration {
    export interface Raw {
        audio: string;
        duration: number;
        encoding: AudioEncoding.Raw;
        file_size: number;
        generation_id: string;
        snippets: Snippet.Raw[][];
    }
}

```


## /src/serialization/resources/tts/types/ReturnPagedVoices.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnVoice } from "./ReturnVoice.js";

export const ReturnPagedVoices: core.serialization.ObjectSchema<
    serializers.tts.ReturnPagedVoices.Raw,
    Hume.tts.ReturnPagedVoices
> = core.serialization.object({
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
    voicesPage: core.serialization.property("voices_page", core.serialization.list(ReturnVoice)),
});

export declare namespace ReturnPagedVoices {
    export interface Raw {
        page_number: number;
        page_size: number;
        total_pages: number;
        voices_page: ReturnVoice.Raw[];
    }
}

```


## /src/serialization/resources/tts/types/ReturnTts.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnGeneration } from "./ReturnGeneration.js";

export const ReturnTts: core.serialization.ObjectSchema<serializers.tts.ReturnTts.Raw, Hume.tts.ReturnTts> =
    core.serialization.object({
        generations: core.serialization.list(ReturnGeneration),
        requestId: core.serialization.property("request_id", core.serialization.string().optional()),
    });

export declare namespace ReturnTts {
    export interface Raw {
        generations: ReturnGeneration.Raw[];
        request_id?: string | null;
    }
}

```


## /src/serialization/resources/tts/types/ReturnVoice.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceProvider } from "./VoiceProvider.js";

export const ReturnVoice: core.serialization.ObjectSchema<serializers.tts.ReturnVoice.Raw, Hume.tts.ReturnVoice> =
    core.serialization.object({
        compatibleOctaveModels: core.serialization.property(
            "compatible_octave_models",
            core.serialization.list(core.serialization.string()).optional(),
        ),
        id: core.serialization.string(),
        name: core.serialization.string(),
        provider: VoiceProvider,
    });

export declare namespace ReturnVoice {
    export interface Raw {
        compatible_octave_models?: string[] | null;
        id: string;
        name: string;
        provider: VoiceProvider.Raw;
    }
}

```


## /src/serialization/resources/tts/types/Snippet.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { Timestamp } from "./Timestamp.js";

export const Snippet: core.serialization.ObjectSchema<serializers.tts.Snippet.Raw, Hume.tts.Snippet> =
    core.serialization.object({
        audio: core.serialization.string(),
        generationId: core.serialization.property("generation_id", core.serialization.string()),
        id: core.serialization.string(),
        text: core.serialization.string(),
        timestamps: core.serialization.list(Timestamp),
        transcribedText: core.serialization.property("transcribed_text", core.serialization.string().optional()),
        utteranceIndex: core.serialization.property("utterance_index", core.serialization.number().optional()),
    });

export declare namespace Snippet {
    export interface Raw {
        audio: string;
        generation_id: string;
        id: string;
        text: string;
        timestamps: Timestamp.Raw[];
        transcribed_text?: string | null;
        utterance_index?: number | null;
    }
}

```


## /src/serialization/resources/tts/types/SnippetAudioChunk.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AudioFormatType } from "./AudioFormatType.js";
import { Snippet } from "./Snippet.js";

export const SnippetAudioChunk: core.serialization.ObjectSchema<
    serializers.tts.SnippetAudioChunk.Raw,
    Hume.tts.SnippetAudioChunk
> = core.serialization.object({
    audio: core.serialization.string(),
    audioFormat: core.serialization.property("audio_format", AudioFormatType),
    chunkIndex: core.serialization.property("chunk_index", core.serialization.number()),
    generationId: core.serialization.property("generation_id", core.serialization.string()),
    isLastChunk: core.serialization.property("is_last_chunk", core.serialization.boolean()),
    requestId: core.serialization.property("request_id", core.serialization.string()),
    snippet: Snippet.optional(),
    snippetId: core.serialization.property("snippet_id", core.serialization.string()),
    text: core.serialization.string(),
    transcribedText: core.serialization.property("transcribed_text", core.serialization.string().optional()),
    type: core.serialization.stringLiteral("audio"),
    utteranceIndex: core.serialization.property("utterance_index", core.serialization.number().optional()),
});

export declare namespace SnippetAudioChunk {
    export interface Raw {
        audio: string;
        audio_format: AudioFormatType.Raw;
        chunk_index: number;
        generation_id: string;
        is_last_chunk: boolean;
        request_id: string;
        snippet?: Snippet.Raw | null;
        snippet_id: string;
        text: string;
        transcribed_text?: string | null;
        type: "audio";
        utterance_index?: number | null;
    }
}

```


## /src/serialization/resources/tts/types/Timestamp.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { MillisecondInterval } from "./MillisecondInterval.js";
import { TimestampType } from "./TimestampType.js";

export const Timestamp: core.serialization.ObjectSchema<serializers.tts.Timestamp.Raw, Hume.tts.Timestamp> =
    core.serialization.object({
        text: core.serialization.string(),
        time: MillisecondInterval,
        type: TimestampType,
    });

export declare namespace Timestamp {
    export interface Raw {
        text: string;
        time: MillisecondInterval.Raw;
        type: TimestampType.Raw;
    }
}

```


## /src/serialization/resources/tts/types/TimestampMessage.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { Timestamp } from "./Timestamp.js";

export const TimestampMessage: core.serialization.ObjectSchema<
    serializers.tts.TimestampMessage.Raw,
    Hume.tts.TimestampMessage
> = core.serialization.object({
    generationId: core.serialization.property("generation_id", core.serialization.string()),
    requestId: core.serialization.property("request_id", core.serialization.string()),
    snippetId: core.serialization.property("snippet_id", core.serialization.string()),
    timestamp: Timestamp,
    type: core.serialization.stringLiteral("timestamp"),
});

export declare namespace TimestampMessage {
    export interface Raw {
        generation_id: string;
        request_id: string;
        snippet_id: string;
        timestamp: Timestamp.Raw;
        type: "timestamp";
    }
}

```


## /src/serialization/resources/tts/types/TimestampType.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const TimestampType: core.serialization.Schema<serializers.tts.TimestampType.Raw, Hume.tts.TimestampType> =
    core.serialization.enum_(["word", "phoneme"]);

export declare namespace TimestampType {
    export type Raw = "word" | "phoneme";
}

```


## /src/serialization/resources/tts/types/TtsOutput.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { SnippetAudioChunk } from "./SnippetAudioChunk.js";
import { TimestampMessage } from "./TimestampMessage.js";

export const TtsOutput: core.serialization.Schema<serializers.tts.TtsOutput.Raw, Hume.tts.TtsOutput> =
    core.serialization.undiscriminatedUnion([SnippetAudioChunk, TimestampMessage]);

export declare namespace TtsOutput {
    export type Raw = SnippetAudioChunk.Raw | TimestampMessage.Raw;
}

```


## /src/serialization/resources/tts/types/ValidationError.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ValidationErrorLocItem } from "./ValidationErrorLocItem.js";

export const ValidationError: core.serialization.ObjectSchema<
    serializers.tts.ValidationError.Raw,
    Hume.tts.ValidationError
> = core.serialization.object({
    loc: core.serialization.list(ValidationErrorLocItem),
    msg: core.serialization.string(),
    type: core.serialization.string(),
});

export declare namespace ValidationError {
    export interface Raw {
        loc: ValidationErrorLocItem.Raw[];
        msg: string;
        type: string;
    }
}

```


## /src/serialization/resources/tts/types/ValidationErrorLocItem.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ValidationErrorLocItem: core.serialization.Schema<
    serializers.tts.ValidationErrorLocItem.Raw,
    Hume.tts.ValidationErrorLocItem
> = core.serialization.undiscriminatedUnion([core.serialization.string(), core.serialization.number()]);

export declare namespace ValidationErrorLocItem {
    export type Raw = string | number;
}

```


## /src/serialization/resources/tts/types/VoiceProvider.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const VoiceProvider: core.serialization.Schema<serializers.tts.VoiceProvider.Raw, Hume.tts.VoiceProvider> =
    core.serialization.enum_(["HUME_AI", "CUSTOM_VOICE"]);

export declare namespace VoiceProvider {
    export type Raw = "HUME_AI" | "CUSTOM_VOICE";
}

```


## /src/serialization/resources/tts/types/index.ts
```typescript
export * from "./AudioEncoding.js";
export * from "./AudioFormatType.js";
export * from "./ErrorResponse.js";
export * from "./Format.js";
export * from "./FormatMp3.js";
export * from "./FormatPcm.js";
export * from "./FormatWav.js";
export * from "./HttpValidationError.js";
export * from "./MillisecondInterval.js";
export * from "./OctaveVersion.js";
export * from "./PostedContext.js";
export * from "./PostedContextWithGenerationId.js";
export * from "./PostedContextWithUtterances.js";
export * from "./PostedTts.js";
export * from "./PostedUtterance.js";
export * from "./PostedUtteranceVoice.js";
export * from "./PostedUtteranceVoiceWithId.js";
export * from "./PostedUtteranceVoiceWithName.js";
export * from "./PublishTts.js";
export * from "./ReturnGeneration.js";
export * from "./ReturnPagedVoices.js";
export * from "./ReturnTts.js";
export * from "./ReturnVoice.js";
export * from "./Snippet.js";
export * from "./SnippetAudioChunk.js";
export * from "./Timestamp.js";
export * from "./TimestampMessage.js";
export * from "./TimestampType.js";
export * from "./TtsOutput.js";
export * from "./ValidationError.js";
export * from "./ValidationErrorLocItem.js";
export * from "./VoiceProvider.js";

```


## /src/version.ts
```typescript
export const SDK_VERSION = "0.15.11";

```


## /src/wrapper/EVIWebAudioPlayer.ts
```typescript
import { convertBase64ToBlob } from "./convertBase64ToBlob.js";
import type { AudioOutput } from "api/resources/empathicVoice";
import { convertLinearFrequenciesToBark } from "./convertFrequencyScale.js";
import { generateEmptyFft } from "./generateEmptyFft.js";

/**
 * Options for configuring an {@link EVIWebAudioPlayer}.
 *
 * @default `{}` for sensible defaults.
 */
export interface EVIWebAudioPlayerOptions {
    /**
     * Initial master gain, via a `GainNode`, from `0` (_silent_) to `1` (_full volume_).
     * Values outside this range are clamped.
     *
     * @default 1
     */
    volume?: number;
    /**
     * Disable AudioWorklet Mode and use Regular Buffer Mode instead.
     * Regular Buffer Mode falls back to AudioBufferSourceNode in the main thread if worklets aren't available.
     * @default false (AudioWorklet Mode enabled)
     */
    disableAudioWorklet?: boolean;
    /**
     * Real-time FFT (frequency-domain) settings **only** for visualization.
     *
     * - **Disable**: omit or `{ enabled: false }` – no `AnalyserNode` is created.
     * - **Defaults**: `{ enabled: true }` → 2048-point FFT at 16 ms (~60 Hz), mapped to 24 Bark bands.
     * - **Custom**: supply {@link EVIWebAudioPlayerFFTOptions} to override `size`, `interval`, or `transform`.
     */
    fft?: EVIWebAudioPlayerFFTOptions;
}

/**
 * FFT (frequency-domain) options for visualization.
 *
 * Pass `{ enabled: true }` for defaults, or omit/disable entirely for zero overhead.
 */
export type EVIWebAudioPlayerFFTOptions = FftEnabled | FftDisabled;

type FftDisabled = {
    /**
     * Turn visualization data OFF—skip analyser creation entirely (zero extra CPU).
     */
    enabled: false;
};

type FftEnabled = {
    /**
     * Turn visualization data ON—create an `AnalyserNode`, poll it, and emit `'fft'` events.
     */
    enabled: true;
    /**
     * FFT size (power-of-two, 32 – 32768).
     * Defaults to 2048 → 1024 bins (~ 23 Hz at 48 kHz).
     * @default 2048
     */
    size?: number;
    /**
     * Polling interval, in **milliseconds**.
     * Default 16 ms (~ 60 Hz) to sync with `requestAnimationFrame()`.
     * @default 16
     */
    interval?: number;
    /**
     * Custom post-processing for raw magnitude data. Omit for built-in 24-band Bark mapping.
     *
     * @param bins PCM byte magnitudes (0 – 255) from `AnalyserNode`.
     * @param sampleRate `AudioContext` sample rate in Hz.
     * @returns Payload emitted with each `'fft'` event.
     */
    transform?: (bins: Uint8Array, sampleRate: number) => number[];
};

type ResolvedFftOptions = {
    readonly size: number;
    readonly interval: number;
    readonly transform: (bins: Uint8Array, sampleRate: number) => number[];
};

type PlayerEventMap = {
    play: CustomEvent<{ id: string }>;
    stop: CustomEvent<{ id: string }>;
    fft: CustomEvent<{ fft: number[] }>;
    error: CustomEvent<{ message: string }>;
};

/**
 * A sequential, glitch-free Web-Audio player for **EVI** audio output.
 *
 * - **Decoding & playback**: base-64 PCM chunks feed an `AudioWorkletNode` and play in order, without gaps.
 * - **One-time init**: await {@link init} in a user-gesture to build audio graph and unlock the browser’s
 *  `AudioContext`; later calls are no-ops.
 * - **Optional FFT**: `{ fft: { enabled: true } }` adds an `AnalyserNode` and emits `'fft'` events; omit to skip.
 * - **Controls**: {@link setVolume}, {@link mute}, {@link unmute}, {@link stop}, {@link dispose}.
 * - **Events**: listen for `'play'`, `'stop'`, `'fft'`, `'error'`.
 */
export class EVIWebAudioPlayer extends EventTarget {
    /** Default URL of the `audio-worklet.js` processor module, fetched from Hume AI’s CDN. */
    static #DEFAULT_WORKLET_URL = "https://storage.googleapis.com/evi-react-sdk-assets/audio-worklet-20250506.js";
    /** Default FFT size (power-of-two). */
    static #DEFAULT_FFT_SIZE = 2048;
    /** Default analyser poll interval (16 ms). */
    static #DEFAULT_FFT_INTERVAL = 16;

    /** `true` while any clip is currently audible. */
    get playing(): boolean {
        return this.#playing;
    }
    /** `true` if gain is set to 0 via {@link mute}. */
    get muted(): boolean {
        return this.#muted;
    }
    /** Current output gain (0‑1). */
    get volume(): number {
        return this.#volume;
    }
    /** Most recent FFT frame (empty when analyser disabled). */
    get fft(): number[] {
        return this.#fft;
    }

    #ctx: AudioContext | null = null;
    #workletNode: AudioWorkletNode | null = null;
    #analyserNode: AnalyserNode | null = null;
    #gainNode: GainNode | null = null;

    #initialized = false;
    #playing = false;
    #muted = false;
    #volume: number;
    #disableAudioWorklet: boolean;

    #fft: number[] = generateEmptyFft();
    #fftTimer: number | null = null;
    #fftOptions: ResolvedFftOptions | null = null;

    #clipQueue: Array<{ id: string; buffer: AudioBuffer; index: number }> = [];
    #currentlyPlayingAudioBuffer: AudioBufferSourceNode | null = null;
    #isProcessing = false;
    // chunkBufferQueues and #lastQueuedChunk are used to make sure that
    // we don't play chunks out of order. #chunkBufferQueues is NOT the
    // audio playback queue.
    #lastQueuedChunk: { id: string; index: number } | null = null;
    #chunkBufferQueues: Record<string, Array<AudioBuffer | undefined>> = {};

    constructor(private readonly opts: EVIWebAudioPlayerOptions = {}) {
        super();
        this.#volume = opts.volume ?? 1.0;
        this.#disableAudioWorklet = opts.disableAudioWorklet ?? false;

        // Resolve FFT options if enabled
        if (opts.fft?.enabled) {
            const { size, interval, transform } = opts.fft;
            this.#fftOptions = {
                size: size ?? EVIWebAudioPlayer.#DEFAULT_FFT_SIZE,
                interval: interval ?? EVIWebAudioPlayer.#DEFAULT_FFT_INTERVAL,
                transform: transform ?? ((bins, sampleRate) => convertLinearFrequenciesToBark(bins, sampleRate)),
            };
        }
    }

    /**
     * * Subscribes to a player event and returns `this` for chaining.
     *
     * @param type One of `'play'`, `'stop'`, `'fft'`, or `'error'`.
     * @param fn Handler invoked with the event’s typed `detail` payload.
     * @param opts Optional `AddEventListenerOptions` (e.g. `{ once: true }`).
     *
     * @example
     *  ```ts
     *  const player = new EVIWebAudioPlayer();
     *  player
     *    .on('play', e => console.log('play',  e.detail.id))
     *    .on('stop', e => console.log('stop',  e.detail.id))
     *    .on('fft', e => console.log('stop',  e.detail.fft))
     *    .on('error', e => console.error('error', e.detail.message));
     *  ```
     */
    on<K extends keyof PlayerEventMap>(
        type: K,
        fn: (e: PlayerEventMap[K]) => void,
        opts?: AddEventListenerOptions,
    ): this {
        super.addEventListener(type, fn as EventListener, opts);
        return this;
    }

    /**
     * Set up and start the player’s Web-Audio pipeline.
     *
     * - Creates a **suspended** `AudioContext`, loads the worklet processor, wires `AudioWorkletNode → (AnalyserNode?) → GainNode → destination`, then calls `resume()`.
     * - Must be awaited inside a user-gesture (click/tap/key); later calls are no-ops.
     * - If `fft.enabled` is `false` (or `fft` is omitted), no `AnalyserNode` or polling timer is created.
     *
     * **Safari quirk:** Safari locks an `AudioContext` to the device’s current sample rate at creation.
     * If you open a Bluetooth headset mic afterward, the OS may switch to the 16 kHz HFP profile and down-sample playback, which sounds “telephone-y.”
     * To avoid this, call `getUserMedia()` (or otherwise open audio input) **before** `init()`.
     *
     * @throws {Error} If the browser lacks `AudioWorklet` support, or if `AudioContext.resume()` is rejected (autoplay policy, device error).
     */
    async init(): Promise<void> {
        if (this.#initialized) return;

        // Create the AudioContext
        this.#ctx = new AudioContext();

        // Fail fast if AudioWorklet isn’t supported
        if (!this.#ctx.audioWorklet) {
            console.warn("AudioWorklet is not supported in this browser. Falling back to Regular Buffer Mode.");
            this.#disableAudioWorklet = true;
        }

        try {
            // Build GainNode
            this.#gainNode = this.#ctx.createGain();
            this.#gainNode.gain.value = this.#volume;

            // Build AnalyserNode (optional)
            if (this.#fftOptions) {
                this.#analyserNode = this.#ctx.createAnalyser();
                this.#analyserNode.fftSize = this.#fftOptions.size;
            } else {
                // Always create AnalyserNode, even if FFT is disabled, to avoid null checks in Buffer Mode
                this.#analyserNode = this.#ctx.createAnalyser();
                this.#analyserNode.fftSize = EVIWebAudioPlayer.#DEFAULT_FFT_SIZE;
            }

            if (!this.#disableAudioWorklet) {
                // Loads the AudioWorklet processor module.
                await this.#ctx.audioWorklet.addModule(EVIWebAudioPlayer.#DEFAULT_WORKLET_URL);

                // Build AudioWorkletNode
                this.#workletNode = new AudioWorkletNode(this.#ctx, "audio-processor");

                // When the worklet posts { type: "ended" }, mark playback stopped and emit a `'stop'` event.
                this.#workletNode.port.onmessage = (e: MessageEvent) => {
                    if ((e.data as { type?: string }).type === "ended") {
                        this.#playing = false;
                        this.dispatchEvent(new CustomEvent("stop", { detail: { id: "stream" } }));
                    }
                };

                // Audio graph nodes
                const workletNode = this.#workletNode; // AudioWorkletNode (PCM processor)
                const analyserNode = this.#analyserNode; // Optional AnalyserNode (FFT)
                const gainNode = this.#gainNode; // GainNode (volume control)
                const destination = this.#ctx.destination; // AudioDestinationNode (speakers)

                // Analyser node is filtered out of audio graph if null (FFT disabled)
                const audioGraph = [workletNode, analyserNode, gainNode, destination].filter(Boolean) as AudioNode[];

                // Wire nodes: AudioWorkletNode → (AnalyserNode?) → GainNode → AudioDestinationNode
                audioGraph.reduce((prev, next) => (prev.connect(next), next));
            } else {
                // Regular Buffer Mode
                const analyserNode = this.#analyserNode;
                const gainNode = this.#gainNode;
                const destination = this.#ctx.destination;

                // Wire nodes: (AnalyserNode?) → GainNode → AudioDestinationNode
                const audioGraph = [analyserNode, gainNode, destination].filter(Boolean) as AudioNode[];
                audioGraph.reduce((prev, next) => (prev.connect(next), next));
            }

            // If an analyser is configured, begin polling it at the resolved interval and dispatching `'fft'` events for each frame.
            this.#startAnalyserPollingIfEnabled();

            // Resume the AudioContext now that the audio graph is fully wired.
            // Browsers allow `resume()` only inside a user-gesture callback.
            // Any rejection (autoplay policy, hardware issue, etc.) is caught by the outer catch-block below, which emits an 'error' event and re-throws.
            await this.#ctx.resume();

            this.#initialized = true;
        } catch (err) {
            const suffix = err instanceof Error ? `: ${err.message}` : String(err);
            this.#emitError(`Failed to initialize audio player${suffix}`);
            throw err;
        }
    }

    /**
     * Queue one {@link AudioOutput} message for playback.
     *
     * Decodes the base-64 PCM data, sends it to the `AudioWorkletNode` for glitch-free, in-order playback, and emits `'play'` for the first chunk of a new stream.
     *
     * @param message The `AudioOutput` message received from EVI’s WebSocket.
     *
     * @see {@link https://dev.hume.ai/reference/empathic-voice-interface-evi/chat/chat#receive.Audio-Output.type API Reference}
     */
    async enqueue(message: AudioOutput): Promise<void> {
        if (!this.#initialized || !this.#ctx) {
            this.#emitError("Audio player is not initialized");
            return;
        }

        if (!this.#disableAudioWorklet) {
            try {
                const { data, id } = message;

                const blob = convertBase64ToBlob(data);
                const buffer = await blob.arrayBuffer();

                const audio = await this.#ctx.decodeAudioData(buffer);
                const pcmData = audio.getChannelData(0);

                this.#workletNode!.port.postMessage({ type: "audio", data: pcmData });

                this.#playing = true;
                this.dispatchEvent(new CustomEvent("play", { detail: { id } }));
            } catch (err) {
                const msg = err instanceof Error ? err.message : "Unknown error";
                this.#emitError(`Failed to queue clip: ${msg}`);
            }
        } else {
            // Regular Buffer Mode
            try {
                const audioBuffer = await this.#convertToAudioBuffer(message);
                if (!audioBuffer) {
                    this.#emitError("Failed to convert data to audio buffer");
                    return;
                }

                const playableBuffers = this.#getNextAudioBuffers(message, audioBuffer);
                if (playableBuffers.length === 0) {
                    return;
                }

                for (const nextAudioBufferToPlay of playableBuffers) {
                    this.#clipQueue.push({
                        id: nextAudioBufferToPlay.id,
                        buffer: nextAudioBufferToPlay.buffer,
                        index: nextAudioBufferToPlay.index,
                    });
                    if (this.#clipQueue.length === 1) {
                        this.#playNextClip();
                    }
                }
            } catch (e) {
                const eMessage = e instanceof Error ? e.message : "Unknown error";
                this.#emitError(`Failed to add clip to queue: ${eMessage}`);
            }
        }
    }

    /**
     * Flush the worklet queue and output silence.
     */
    stop(): void {
        if (!this.#disableAudioWorklet) {
            // Clear buffered audio from the worklet queue
            this.#workletNode?.port.postMessage({ type: "fadeAndClear" });
        } else {
            // Regular Buffer mode
            if (this.#currentlyPlayingAudioBuffer) {
                this.#currentlyPlayingAudioBuffer.stop();
                this.#currentlyPlayingAudioBuffer.disconnect();
                this.#currentlyPlayingAudioBuffer = null;
            }
            this.#clipQueue = [];
            this.#isProcessing = false;
        }

        // Restart analyser polling so fft events continue after stopping or clearing the queue
        this.#startAnalyserPollingIfEnabled();

        this.#playing = false;
        this.dispatchEvent(new CustomEvent("stop", { detail: { id: "manual" } }));
    }

    /**
     * Set the master gain ({@link volume}) to a value between `0` (_silent_) and `1` (_full volume_).
     *
     * - Clamps out-of-range values.
     * - If called before {@link init}, stores volume for when `AudioContext` is created.
     * - If currently {@link muted}, updates stored volume but keeps output silent until {@link unmute}.
     *
     * @param volume Desired gain; clamped to [0, 1].
     */
    setVolume(volume: number): void {
        const clampedVolume = Math.max(0, Math.min(volume, 1));
        this.#volume = clampedVolume;

        if (this.#gainNode && this.#ctx && !this.#muted) {
            this.#gainNode.gain.setValueAtTime(clampedVolume, this.#ctx.currentTime);
        }
    }

    /**
     * Mute output instantly by setting the gain to 0. Retains the last volume internally for later restore.
     */
    mute(): void {
        if (!this.#gainNode || !this.#ctx) return;
        this.#gainNode.gain.setValueAtTime(0, this.#ctx.currentTime);
        this.#muted = true;
    }

    /**
     * Restore output gain to the last set volume (via setVolume).
     */
    unmute(): void {
        if (!this.#gainNode || !this.#ctx) return;
        this.#gainNode.gain.setValueAtTime(this.#volume, this.#ctx.currentTime);
        this.#muted = false;
    }

    /**
     * Tear down all Web-Audio resources (worklet, analyser, gain, context) and reset state so {@link init} can be called again.
     */
    dispose(): void {
        if (this.#fftTimer != null) {
            clearInterval(this.#fftTimer);
            this.#fftTimer = null;
        }

        if (!this.#disableAudioWorklet) {
            this.#workletNode?.port.postMessage({ type: "fadeAndClear" });
            this.#workletNode?.port.postMessage({ type: "end" });
            this.#workletNode?.port.close();
            this.#workletNode?.disconnect();
        } else {
            // Regular Buffer mode
            if (this.#currentlyPlayingAudioBuffer) {
                this.#currentlyPlayingAudioBuffer.stop();
                this.#currentlyPlayingAudioBuffer.disconnect();
                this.#currentlyPlayingAudioBuffer = null;
            }
            this.#clipQueue = [];
            this.#isProcessing = false;
        }

        this.#analyserNode?.disconnect();

        this.#gainNode?.disconnect();
        this.#ctx?.close().catch(() => void 0);

        this.#initialized = false;
        this.#playing = false;
        this.#fft = generateEmptyFft();
    }

    /**
     * Polls the AnalyserNode at the configured interval, applies the FFT transform, and emits `'fft'` events.
     * No-ops if no analyser is present.
     */
    #startAnalyserPollingIfEnabled() {
        if (!this.#fftOptions || !this.#analyserNode) return;
        if (this.#fftTimer) clearInterval(this.#fftTimer);

        const { interval, transform } = this.#fftOptions;

        this.#fftTimer = window.setInterval(() => {
            const bins = new Uint8Array(this.#analyserNode!.frequencyBinCount);
            this.#analyserNode!.getByteFrequencyData(bins);
            this.#fft = transform(bins, this.#ctx!.sampleRate);
            this.dispatchEvent(new CustomEvent("fft", { detail: { fft: this.#fft } }));
        }, interval);
    }

    /**
     * Emit an `error` event with the supplied message.
     */
    #emitError(message: string) {
        this.dispatchEvent(new CustomEvent("error", { detail: { message } }));
    }

    /**
     * Converts a base64 encoded audio data message to an AudioBuffer.
     */
    async #convertToAudioBuffer(message: AudioOutput): Promise<AudioBuffer | undefined> {
        if (!this.#initialized || !this.#ctx) {
            this.#emitError("Audio player has not been initialized");
            return;
        }
        const blob = convertBase64ToBlob(message.data);
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await this.#ctx.decodeAudioData(arrayBuffer);
        return audioBuffer;
    }

    /**
     * Manages incoming audio chunks to ensure they are processed in the correct order.
     */
    #getNextAudioBuffers(
        message: AudioOutput,
        audioBuffer: AudioBuffer,
    ): Array<{ id: string; index: number; buffer: AudioBuffer }> {
        // Prevent prototype pollution by restricting dangerous property names.
        if (message.id === "__proto__" || message.id === "constructor" || message.id === "prototype") {
            this.#emitError(`Attempted to use a dangerous property name as message ID: ${message.id}`);
            return [];
        }
        //1. Add the current buffer to the queue
        if (!this.#chunkBufferQueues[message.id]) {
            this.#chunkBufferQueues[message.id] = [];
        }

        // Ensure message.index is a safe, non-negative integer to prevent prototype pollution.
        if (!Number.isInteger(message.index) || message.index < 0) {
            this.#emitError(`Attempted to use an invalid index: ${message.index}`);
            return [];
        }

        const queueForCurrMessage = this.#chunkBufferQueues[message.id] || [];
        queueForCurrMessage[message.index] = audioBuffer;

        // 2. Now collect buffers that are ready to be played
        const lastId = this.#lastQueuedChunk?.id;
        const buffers: Array<{ id: string; index: number; buffer: AudioBuffer }> = [];

        // If the current message ID is different from the last one that was added
        // to the queue, that means that we're playing a new message now, so the first chunk
        // we play needs to be at index 0.
        if (message.id !== lastId) {
            if (queueForCurrMessage[0]) {
                this.#lastQueuedChunk = { id: message.id, index: 0 };
                buffers.push({
                    id: message.id,
                    index: 0,
                    buffer: queueForCurrMessage[0],
                });
                queueForCurrMessage[0] = undefined;
            } else {
                return [];
            }
        }

        // Drain the queue - basically if any chunks were received out of order previously,
        // and they're now ready to be played because the earlier chunks
        // have been received, we can add them to the buffers array.
        let nextIdx = (this.#lastQueuedChunk?.index || 0) + 1;
        let nextBuf = queueForCurrMessage[nextIdx];
        while (nextBuf) {
            buffers.push({ index: nextIdx, buffer: nextBuf, id: message.id });
            queueForCurrMessage[nextIdx] = undefined;
            this.#lastQueuedChunk = { id: message.id, index: nextIdx };
            nextIdx += 1;
            nextBuf = queueForCurrMessage[nextIdx];
        }

        return buffers;
    }

    /**
     * Only for Regular Buffer mode.
     * This function is called when the current audio clip ends.
     * It will play the next clip in the queue if there is one.
     */
    #playNextClip() {
        if (this.#clipQueue.length === 0 || this.#isProcessing) {
            return;
        }

        if (this.#analyserNode === null || this.#ctx === null) {
            this.#emitError("Audio player is not initialized");
            return;
        }

        const nextClip = this.#clipQueue.shift();

        if (!nextClip) {
            return;
        }

        this.#isProcessing = true;
        this.#playing = true;

        const bufferSource = this.#ctx.createBufferSource();

        bufferSource.buffer = nextClip.buffer;

        if (this.#analyserNode) {
            bufferSource.connect(this.#analyserNode);
        }

        if (this.#gainNode) {
            this.#analyserNode?.connect(this.#gainNode);
            this.#gainNode.connect(this.#ctx.destination);
        } else {
            this.#analyserNode?.connect(this.#ctx.destination);
        }

        this.#currentlyPlayingAudioBuffer = bufferSource;

        this.#startAnalyserPollingIfEnabled();

        bufferSource.start(0);
        if (nextClip.index === 0) {
            this.dispatchEvent(new CustomEvent("play", { detail: { id: nextClip.id } }));
        }

        bufferSource.onended = () => {
            if (this.#fftTimer) {
                clearInterval(this.#fftTimer);
                this.#fftTimer = null;
            }
            this.#fft = generateEmptyFft();
            bufferSource.disconnect();
            this.#isProcessing = false;
            this.#playing = false;
            this.dispatchEvent(new CustomEvent("stop", { detail: { id: nextClip.id } }));
            this.#currentlyPlayingAudioBuffer = null;
            this.#playNextClip();
        };
    }
}

```


## /src/wrapper/HumeClient.ts
```typescript
import { HumeClient as FernClient } from "../Client.js";
import * as core from "../core/index.js";
import { ExpressionMeasurement } from "./expressionMeasurement/ExpressionMeasurementClient.js";
import * as environments from "../environments.js";
import { SDK_VERSION } from "../version.js";

export declare namespace HumeClient {
    type Options = Omit<FernClient.Options, "environment"> & { accessToken?: string } & (
            | { accessToken: NonNullable<core.Supplier<string>> }
            | { apiKey: NonNullable<FernClient.Options["apiKey"]> }
        ) & {
            environment?: core.Supplier<environments.HumeEnvironment | environments.HumeEnvironmentUrls | string>;
        };
}

export class HumeClient extends FernClient {
    constructor(_options: HumeClient.Options) {
        let options: FernClient.Options;
        let oldEnvironment: HumeClient.Options["environment"];
        ({ environment: oldEnvironment, ...options } = _options || {});

        // Check if both accessToken and Authorization header are provided (case-insensitive)
        if (_options.accessToken && _options.headers) {
            const hasAuthHeader = Object.keys(_options.headers).some((key) => key.toLowerCase() === "authorization");
            if (hasAuthHeader) {
                throw new Error("Cannot provide both 'accessToken' and 'headers.Authorization'. Please use only one.");
            }
        }

        if (_options.accessToken) {
            options.headers = {
                ...options.headers,
                Authorization: core.Supplier.map(_options.accessToken, (token) => `Bearer ${token}`),
            };
        }

        // Add telemetry headers
        options.headers = {
            ...options.headers,
            "X-Hume-Client-Name": "typescript_sdk",
            "X-Hume-Client-Version": SDK_VERSION,
        };

        // Allow setting a single url http://... or https://... for environment'
        if (oldEnvironment) {
            const environment: FernClient.Options["environment"] = _options.environment
                ? core.Supplier.map(
                      _options.environment,
                      (e): environments.HumeEnvironment | environments.HumeEnvironmentUrls => {
                          if (typeof e === "string") {
                              if (e.startsWith("http://")) {
                                  return {
                                      base: e,
                                      evi: e.replace("http://", "ws://") + "/v0/evi",
                                      tts: e.replace("http://", "ws://") + "/v0/tts",
                                      stream: e.replace("http://", "ws://") + "/v0/stream",
                                  };
                              }
                              if (e.startsWith("https://")) {
                                  return {
                                      base: e,
                                      evi: e.replace("https://", "wss://") + "/v0/evi",
                                      tts: e.replace("https://", "wss://") + "/v0/tts",
                                      stream: e.replace("https://", "wss://") + "/v0/stream",
                                  };
                              }
                              return {
                                  base: "https://" + e,
                                  evi: "wss://" + e + "/v0/evi",
                                  tts: "wss://" + e + "/v0/tts",
                                  stream: "wss://" + e + "/v0/stream",
                              };
                          } else {
                              return e;
                          }
                      },
                  )
                : undefined;
            options.environment = environment;
        }

        super(options);
    }

    // We need to override this from FernClient to use the extended
    // `ExpressionMeasurement` from `wrapper` and not `api/resources/`
    protected _expressionMeasurement: ExpressionMeasurement | undefined;

    public get expressionMeasurement(): ExpressionMeasurement {
        return (this._expressionMeasurement ??= new ExpressionMeasurement(this._options));
    }
}

```


## /src/wrapper/SilenceFiller.ts
```typescript
/**
 * A minimal Writable-like interface that SilenceFiller can pipe to.
 * This matches the subset of Node.js Writable that we need.
 */
export interface PipeDestination {
    write(chunk: Uint8Array): boolean;
    end?(): void;
    on?(event: "drain", listener: () => void): this;
    once?(event: "drain", listener: () => void): this;
    removeListener?(event: "drain", listener: () => void): this;
}

type EventListener = (...args: unknown[]) => void;

/**
 * SilenceFiller is a pipeable stream that intersperses incoming audio data
 * with bytes of silence. This is important in some cases to keep an audio
 * stream "alive". Audio players, such as ffmpeg, can interpret inactivity as
 * meaning the stream is ended, or disconnected.
 *
 * This implementation does not depend on Node.js built-ins and can work in
 * any JavaScript environment, while still being pipeable to Node.js streams.
 *
 * @example
 * ```typescript
 * import { SilenceFiller } from 'hume';
 *
 * const BYTES_PER_SAMPLE = 2; // 16-bit samples
 * const SAMPLE_RATE = 48000;
 * const BUFFER_SIZE = Math.floor(SAMPLE_RATE * 0.1 * BYTES_PER_SAMPLE); // 100ms buffer
 * const silenceFiller = new SilenceFiller(BUFFER_SIZE, SAMPLE_RATE, BYTES_PER_SAMPLE, 10);
 *
 * // Pipe silence filler output to audio player stdin
 * silenceFiller.pipe(audioPlayer.stdin);
 *
 * // Handle pipe errors
 * silenceFiller.on('error', (err) => {
 *   console.error("SilenceFiller error:", err);
 * });
 *
 * // Write audio data as it arrives
 * silenceFiller.writeAudio(audioBuffer);
 *
 * // End the stream when done
 * await silenceFiller.endStream();
 * ```
 */
export class SilenceFiller {
    private unclockedSilenceFiller: UnclockedSilenceFiller;
    private isStarted: boolean = false;
    private pushIntervalId: ReturnType<typeof setInterval> | null = null;
    private bytesPerSample: number;
    private pushIntervalMs: number;
    private destination: PipeDestination | null = null;
    private eventListeners: Map<string, Set<EventListener>> = new Map();
    private ended: boolean = false;

    /**
     * Creates a new SilenceFiller instance.
     *
     * @param pushIntervalMs - The interval in milliseconds for pushing audio data (default: 5ms).
     * @param sampleRate - The sample rate of the audio (e.g., 48000).
     * @param bytesPerSample - The number of bytes per audio sample (e.g., 2 for 16-bit).
     * @param bufferSize - How much to 'prebuffer'. If you set this too low there
     * is a chance that playback will stutter, but if you set it too high
     * playback will take longer to start.
     */
    constructor(
        pushIntervalMs: number = 5,
        sampleRate: number = 48000,
        bytesPerSample: number = 2,
        bufferSize: number = 9600,
    ) {
        this.unclockedSilenceFiller = new UnclockedSilenceFiller(bufferSize, sampleRate, bytesPerSample);
        this.bytesPerSample = bytesPerSample;
        this.pushIntervalMs = pushIntervalMs;
    }

    /**
     * Pipes the output of this SilenceFiller to a writable destination.
     *
     * @param destination - The destination to pipe to (e.g., a Node.js Writable stream).
     * @returns The destination, for chaining.
     */
    pipe<T extends PipeDestination>(destination: T): T {
        this.destination = destination;
        return destination;
    }

    /**
     * Registers an event listener.
     *
     * @param event - The event name ('error', 'end').
     * @param listener - The listener function.
     * @returns This instance, for chaining.
     */
    on(event: string, listener: EventListener): this {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, new Set());
        }
        this.eventListeners.get(event)!.add(listener);
        return this;
    }

    /**
     * Registers a one-time event listener.
     *
     * @param event - The event name ('error', 'end').
     * @param listener - The listener function.
     * @returns This instance, for chaining.
     */
    once(event: string, listener: EventListener): this {
        const onceWrapper: EventListener = (...args: unknown[]) => {
            this.off(event, onceWrapper);
            listener(...args);
        };
        return this.on(event, onceWrapper);
    }

    /**
     * Removes an event listener.
     *
     * @param event - The event name.
     * @param listener - The listener function to remove.
     * @returns This instance, for chaining.
     */
    off(event: string, listener: EventListener): this {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            listeners.delete(listener);
        }
        return this;
    }

    /**
     * Emits an event to all registered listeners.
     *
     * @param event - The event name.
     * @param args - Arguments to pass to listeners.
     */
    private emit(event: string, ...args: unknown[]): void {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            for (const listener of listeners) {
                try {
                    listener(...args);
                } catch {
                    // Ignore errors in listeners
                }
            }
        }
    }

    /**
     * Writes audio data to the silence filler.
     *
     * @param audioBuffer - The audio buffer to write (Uint8Array or Buffer).
     */
    writeAudio(audioBuffer: Uint8Array): void {
        const now = Date.now();
        try {
            this.unclockedSilenceFiller.writeAudio(audioBuffer, now);
            if (!this.isStarted && this.unclockedSilenceFiller.donePrebuffering) {
                this.isStarted = true;
                this.startPushInterval();
            }
        } catch (error) {
            console.error(`[SilenceFiller] Error writing audio:`, error);
            this.emit("error", error);
        }
    }

    private startPushInterval(): void {
        this.pushIntervalId = setInterval(() => {
            this.pushData();
        }, this.pushIntervalMs);
    }

    private pushData(): void {
        if (!this.isStarted || !this.destination) return;

        try {
            const now = Date.now();
            const audioChunk = this.unclockedSilenceFiller.readAudio(now);

            if (audioChunk && audioChunk.length > 0) {
                // Ensure chunk size is aligned to bytesPerSample
                const alignedChunkSize = Math.floor(audioChunk.length / this.bytesPerSample) * this.bytesPerSample;

                if (alignedChunkSize > 0) {
                    const chunk = audioChunk.subarray(0, alignedChunkSize);
                    this.destination.write(chunk);
                }
            }
        } catch (error) {
            console.error(`[SilenceFiller] Error pushing data:`, error);
            this.emit("error", error);
        }
    }

    /**
     * Ends the stream and drains all remaining audio data.
     *
     * @returns A promise that resolves when the stream has ended.
     */
    endStream(): Promise<void> {
        return new Promise((resolve) => {
            if (this.ended) {
                resolve();
                return;
            }
            this.ended = true;

            // Stop pushing data
            if (this.pushIntervalId) {
                clearInterval(this.pushIntervalId);
                this.pushIntervalId = null;
            }

            // Drain all remaining audio from SilenceFiller
            const now = Date.now();

            // Keep reading until no more audio is available
            while (this.destination) {
                const remainingChunk = this.unclockedSilenceFiller.readAudio(now);

                if (!remainingChunk || remainingChunk.length === 0) {
                    break;
                }

                const alignedChunkSize = Math.floor(remainingChunk.length / this.bytesPerSample) * this.bytesPerSample;
                if (alignedChunkSize > 0) {
                    const chunk = remainingChunk.subarray(0, alignedChunkSize);
                    this.destination.write(chunk);
                }
            }

            this.emit("end");
            resolve();
        });
    }
}

/**
 * Does the actual calculation of how interspersing audio with silence
 * is "pure" in the sense that it does not rely on the system clock.
 * It's up to the caller to provide timestamps.
 *
 * @internal
 */
export class UnclockedSilenceFiller {
    private audioQueue: Uint8Array[] = [];
    private totalBufferedBytes: number = 0;
    private startTimestamp: number | null = null;
    private totalBytesSent: number = 0;
    public donePrebuffering: boolean = false;
    private bufferSize: number;
    private sampleRate: number;
    private bytesPerSample: number;

    constructor(bufferSize: number, sampleRate: number, bytesPerSample: number) {
        this.bufferSize = bufferSize;
        this.sampleRate = sampleRate;
        this.bytesPerSample = bytesPerSample;
    }

    writeAudio(audioBuffer: Uint8Array, timestamp: number): void {
        this.audioQueue.push(audioBuffer);
        this.totalBufferedBytes += audioBuffer.length;

        if (this.startTimestamp === null) {
            this.startTimestamp = timestamp;
        }

        if (!this.donePrebuffering && this.totalBufferedBytes >= this.bufferSize) {
            this.donePrebuffering = true;
        }
    }

    readAudio(timestamp: number): Uint8Array | null {
        if (this.startTimestamp === null || !this.donePrebuffering) {
            return null;
        }

        const elapsedMs = timestamp - this.startTimestamp;

        const targetBytesSent = Math.floor(((this.sampleRate * elapsedMs) / 1000) * this.bytesPerSample);

        const bytesNeeded = targetBytesSent - this.totalBytesSent;

        if (bytesNeeded <= 0) {
            return null;
        }

        // Ensure bytesNeeded is a multiple of bytesPerSample
        const alignedBytesNeeded = Math.floor(bytesNeeded / this.bytesPerSample) * this.bytesPerSample;

        if (alignedBytesNeeded <= 0) {
            return null;
        }

        let chunk = new Uint8Array(0);

        // Drain from queue until we have enough bytes
        while (chunk.length < alignedBytesNeeded && this.audioQueue.length > 0) {
            const nextBuffer = this.audioQueue.shift()!;
            chunk = concatUint8Arrays(chunk, nextBuffer);
            this.totalBufferedBytes -= nextBuffer.length;
        }

        // If we have more than needed, put the excess back
        if (chunk.length > alignedBytesNeeded) {
            const excess = chunk.subarray(alignedBytesNeeded);
            this.audioQueue.unshift(excess);
            this.totalBufferedBytes += excess.length;
            chunk = chunk.subarray(0, alignedBytesNeeded);
        }

        // Fill remaining with silence if needed
        if (chunk.length < alignedBytesNeeded) {
            const silenceNeeded = new Uint8Array(alignedBytesNeeded - chunk.length); // Uint8Array is zero-filled by default
            chunk = concatUint8Arrays(chunk, silenceNeeded);
        }

        // Update total bytes sent
        this.totalBytesSent += chunk.length;

        return chunk;
    }
}

/**
 * Concatenates two Uint8Arrays into a new Uint8Array.
 */
function concatUint8Arrays(a: Uint8Array, b: Uint8Array): Uint8Array {
    const result = new Uint8Array(a.length + b.length);
    result.set(a, 0);
    result.set(b, a.length);
    return result;
}

```


## /src/wrapper/base64Decode.ts
```typescript
export function base64Decode(str: string): string | Buffer {
    if (typeof Buffer === "function") {
        // Node.js environment
        return Buffer.from(str, "base64");
    } else if (typeof atob === "function") {
        // Browser environment
        return atob(str);
    } else {
        throw new Error("Base64 encoding not supported in this environment.");
    }
}

```


## /src/wrapper/base64Encode.ts
```typescript
export function base64Encode(str: string): string {
    if (typeof Buffer === "function") {
        // Node.js environment
        return Buffer.from(str).toString("base64");
    } else if (typeof btoa === "function") {
        // Browser environment
        return btoa(str);
    } else {
        throw new Error("Base64 encoding not supported in this environment.");
    }
}

```


## /src/wrapper/checkForAudioTracks.ts
```typescript
/**
 * @name checkForAudioTracks
 * @description
 * Check if a MediaStream has audio tracks.
 * @param stream
 * The MediaStream to check
 */
export const checkForAudioTracks = (stream: MediaStream): void => {
    const tracks = stream.getAudioTracks();

    if (tracks.length === 0) {
        throw new Error("No audio tracks");
    }
    if (tracks.length > 1) {
        throw new Error("Multiple audio tracks");
    }
    const track = tracks[0];
    if (!track) {
        throw new Error("No audio track");
    }
};

```


## /src/wrapper/collate.ts
```typescript
/**
 * Takes an async iterator that yields interleaved items from different groups
 * and produces an iterator that yields items in group order.
 *
 * Example:
 *   Input:  A1, B1, A2, A3 (final), C1, C2, C3 (final), B2 (final)
 *   Output: A1, A2, A3, B1, B2, C1, C2, C3
 *
 * This is useful when using synthesizeJsonStreaming with num_generations > 1
 *
 * @example
 * ```typescript
 *
 * import { collate } from 'hume';
 *
 * const stream = hume.synthesizeJsonStreaming({
 *   ...
 * })
 *
 * const contiguous = collate(
 *   stream
 *   (chunk) => chunk.generationId,
 *   (chunk) => chunk.isLastChunk
 * );
 *
 * for await (const item of contiguous) {
 *   audioPlayer.write(item.audio)
 * }
 * ```
 *
 * @param source - Async iterable that yields interleaved items.
 * @param groupBy - Function to determine a "key" that determines the group identity for each item.
 * @param isFinal - Function to determine if an item is the final item in its group.
 * @returns An async iterable that yields items in group order.
 */
export async function* collate<TItem, TKey>(
    source: AsyncIterable<TItem>,
    groupBy: (x: TItem) => TKey,
    isFinal: (x: TItem) => boolean,
): AsyncIterable<TItem> {
    const buffers = new Map<TKey, TItem[]>();
    const order: TKey[] = [];
    let current: TKey | undefined;

    const ensure = (k: TKey) => {
        if (!buffers.has(k)) {
            buffers.set(k, []);
            order.push(k);
        }
    };

    const flushGroup = function* (k: TKey) {
        const buf = buffers.get(k);
        if (!buf) return;
        for (const item of buf) yield item;
        buffers.delete(k);
    };

    const nextGroup = (): TKey | undefined => {
        // pop the next group in first-seen order that still has a buffer
        while (order.length && !buffers.has(order[0])) order.shift();
        return order.shift();
    };

    for await (const item of source) {
        const k = groupBy(item);

        if (current === undefined) current = k;
        ensure(k);
        buffers.get(k)!.push(item);

        // if we just saw the final item for the current group, flush it and advance
        if (k === current && isFinal(item)) {
            yield* flushGroup(current);
            current = nextGroup();
        }
    }

    // stream ended; flush remaining groups in first-seen order
    if (current !== undefined) {
        if (buffers.has(current)) yield* flushGroup(current);
        while (true) {
            const k = nextGroup();
            if (k === undefined) break;
            yield* flushGroup(k);
        }
    }
}

```


## /src/wrapper/convertBase64ToBlob.ts
```typescript
/**
 * Converts a base64-encoded string into a `Blob` object with the specified content type.
 *
 * @param {string} base64 - The base64-encoded string representing binary data.
 * @param {string} contentType - The MIME type to assign to the resulting `Blob`.
 * @returns {Blob} A `Blob` object containing the binary data from the base64 string.
 */
export function convertBase64ToBlob(base64: string, contentType?: string): Blob {
    // Decode base64 string to a binary string
    const binaryString = window.atob(base64);

    // Create a Uint8Array with the same length as the binary string
    const byteArray = new Uint8Array(binaryString.length);

    // Fill the Uint8Array by converting each character's Unicode value to a byte
    for (let i = 0; i < binaryString.length; i++) {
        byteArray[i] = binaryString.charCodeAt(i);
    }

    // Create and return a Blob with the specified content type
    return new Blob([byteArray], { type: contentType });
}

```


## /src/wrapper/convertBlobToBase64.ts
```typescript
/**
 * Converts a `Blob` object into a base64-encoded string.
 * The resulting string contains the binary data from the `Blob`.
 *
 * @param {Blob} blob - The `Blob` object to convert to base64.
 * @returns {Promise<string>} A promise that resolves to a base64-encoded string representing the `Blob` data.
 */
export function convertBlobToBase64(blob: Blob): Promise<string> {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();

        // Handle the load event which is triggered when readAsDataURL completes
        reader.onloadend = () => {
            // Ensure reader.result is not null and is a string
            if (typeof reader.result === "string") {
                // Extract the Base64 encoded string, skipping the data URL prefix (e.g., "data:image/png;base64,")
                const base64Data = reader.result.split(",")[1];
                if (base64Data) {
                    resolve(base64Data);
                } else {
                    reject(new Error("Failed to split the result into Base64 data."));
                }
            } else {
                reject(new Error("FileReader result is null or not a string."));
            }
        };

        // Handle errors during the read process
        reader.onerror = () => {
            reject(new Error(`Error reading blob: ${reader.error?.message}`));
        };

        // Initiate reading the blob as a data URL
        reader.readAsDataURL(blob);
    });
}

```


## /src/wrapper/convertFrequencyScale.ts
```typescript
// This function converts linear-scaled frequency decibels from an AnalyserNode's frequncy data to Bark scale [https://en.wikipedia.org/wiki/Bark_scale]
// This implementation uses a simple approach of mapping indices in the linear-scaled array to the closest
// Bark scale center frequency and is not intended to be an accurate representation, but rather "close-enough" for visualization purposes
const barkCenterFrequencies = [
    50, 150, 250, 350, 450, 570, 700, 840, 1000, 1170, 1370, 1600, 1850, 2150, 2500, 2900, 3400, 4000, 4800, 5800, 7000,
    8500, 10500, 13500,
]; // Center frequency value in Hz

// Min/max values from https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
const minValue = 0;
const maxValue = 255;

export function convertLinearFrequenciesToBark(linearData: Uint8Array, sampleRate: number): number[] {
    const maxFrequency = sampleRate / 2;
    const frequencyResolution = maxFrequency / linearData.length;

    const barkFrequencies = barkCenterFrequencies.map((barkFreq) => {
        const linearDataIndex = Math.round(barkFreq / frequencyResolution);
        if (linearDataIndex >= 0 && linearDataIndex < linearData.length) {
            return (((linearData[linearDataIndex] ?? 0) - minValue) / (maxValue - minValue)) * 2;
        } else {
            return 0;
        }
    });

    return barkFrequencies;
}

```


## /src/wrapper/ensureSingleValidAudioTrack.ts
```typescript
/**
 * Ensures that the given media stream contains exactly one valid audio track.
 * Throws an error if no audio tracks are found, if there is more than one audio track,
 * or if the sole audio track is falsy.
 *
 * @param {MediaStream} stream - The media stream object containing audio tracks to validate.
 * @throws {Error} "No audio tracks" if the stream contains zero audio tracks.
 * @throws {Error} "Multiple audio tracks" if the stream contains more than one audio track.
 * @throws {Error} "No audio track" if the sole audio track is falsy.
 */
export const ensureSingleValidAudioTrack = (stream: MediaStream): void => {
    const tracks = stream.getAudioTracks();

    if (tracks.length === 0) {
        throw new Error("No audio tracks available");
    } else if (tracks.length > 1) {
        throw new Error("Multiple audio tracks found");
    } else if (!tracks[0]) {
        throw new Error("The audio track is invalid");
    }
};

```


## /src/wrapper/expressionMeasurement/ExpressionMeasurementClient.ts
```typescript
import { ExpressionMeasurementClient as FernClient } from "../../api/resources/expressionMeasurement/client/Client.js";
import { BatchClient } from "./batch/BatchClient.js";
import { StreamClient } from "./streaming/StreamingClient.js";

export class ExpressionMeasurement extends FernClient {
    protected _batch: BatchClient | undefined;

    // BatchClient here is overridden from the generated version, we wrap expression measurement jobs in
    // a helper that makes it easier to await the result of a job.
    public get batch(): BatchClient {
        return (this._batch ??= new BatchClient(this._options));
    }

    // Streamclient here is an addition -- not present on the base FernClient.
    protected _stream: StreamClient | undefined;

    public get stream(): StreamClient {
        return (this._stream ??= new StreamClient(this._options));
    }
}

```


## /src/wrapper/expressionMeasurement/batch/BatchClient.ts
```typescript
import { BatchClient as FernClient } from "../../../api/resources/expressionMeasurement/resources/batch/client/Client.js";
import * as Hume from "../../../api/index.js";
import { Job } from "./Job.js";
import * as core from "../../../core/index.js";

export class BatchClient extends FernClient {
    // This just wraps the return value of the base class's `startInferenceJob` and `startInferenceJobFromLocalFile` methods
    // and returns a `Job` instance (has helper functions to await the job's result) instead of a raw job ID.
    public startInferenceJob(
        request: Hume.expressionMeasurement.batch.InferenceBaseRequest = {},
        requestOptions?: FernClient.RequestOptions,
    ): core.HttpResponsePromise<Job> {
        return core.HttpResponsePromise.fromPromise(
            super
                .startInferenceJob(request, requestOptions)
                .withRawResponse()
                .then((result) => {
                    return { data: new Job(result.data.jobId, this), rawResponse: result.rawResponse };
                }),
        );
    }

    public startInferenceJobFromLocalFile(
        request: Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest,
        requestOptions?: FernClient.RequestOptions,
    ): core.HttpResponsePromise<Job> {
        return core.HttpResponsePromise.fromPromise(
            super
                .startInferenceJobFromLocalFile(request, requestOptions)
                .withRawResponse()
                .then((result) => {
                    return { data: new Job(result.data.jobId, this), rawResponse: result.rawResponse };
                }),
        );
    }
}

```


## /src/wrapper/expressionMeasurement/batch/Job.ts
```typescript
import * as Hume from "../../../api/index.js";
import * as errors from "../../../errors/index.js";
import { BatchClient } from "./BatchClient.js";

export class Job implements Hume.expressionMeasurement.batch.JobId {
    constructor(
        public readonly jobId: string,
        private readonly client: BatchClient,
    ) {}

    public async awaitCompletion(timeoutInSeconds = 300): Promise<void> {
        return new Promise((resolve, reject) => {
            const poller = new JobCompletionPoller(this.jobId, this.client);
            poller.start(resolve);
            setTimeout(() => {
                poller.stop();
                reject(new errors.HumeTimeoutError("Timeout exceeded when polling for job completion"));
            }, timeoutInSeconds * 1_000);
        });
    }
}

class JobCompletionPoller {
    private isPolling = true;
    constructor(
        private readonly jobId: string,
        private readonly client: BatchClient,
    ) {}

    public start(onTerminal: () => void) {
        this.isPolling = true;
        this.poll(onTerminal);
    }

    public stop() {
        this.isPolling = false;
    }

    private async poll(onTerminal: () => void): Promise<void> {
        try {
            const jobDetails = await this.client.getJobDetails(this.jobId);
            if (jobDetails.state.status === "COMPLETED" || jobDetails.state.status === "FAILED") {
                onTerminal();
                this.stop();
            }
        } catch {
            // swallow errors while polling
        }

        if (this.isPolling) {
            setTimeout(() => this.poll(onTerminal), 1_000);
        }
    }
}

```


## /src/wrapper/expressionMeasurement/streaming/StreamSocket.ts
```typescript
import WebSocket from "ws";
import { v4 as uuid } from "uuid";
import { parse } from "./StreamingClient.js";
import { base64Encode } from "../../base64Encode.js";
import * as Hume from "../../../api/index.js";
import * as errors from "../../../errors/index.js";
import * as serializers from "../../../serialization/index.js";
import * as fs from "fs";

export declare namespace StreamSocket {
    interface Args {
        websocket: WebSocket;
        config: Hume.expressionMeasurement.stream.Config;
        streamWindowMs?: number;
    }
}

export class StreamSocket {
    readonly websocket: WebSocket;
    private readonly streamWindowMs?: number;
    private config: Hume.expressionMeasurement.stream.Config;

    constructor({ websocket, config, streamWindowMs }: StreamSocket.Args) {
        this.websocket = websocket;
        this.config = config;
        this.streamWindowMs = streamWindowMs;
    }

    /**
     * Send file on the `StreamSocket`
     *
     * @param file A fs.ReadStream | File | Blob
     * @param config This method is intended for use with a `LanguageConfig`.
     * When the socket is configured for other modalities this method will fail.
     */
    public async sendFile({
        file,
        config,
    }: {
        file: fs.ReadStream | Blob;
        config?: Hume.expressionMeasurement.stream.Config;
    }): Promise<Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage> {
        if (config != null) {
            this.config = config;
        }
        let contents = "";
        if (file instanceof fs.ReadStream) {
            const chunks: Buffer[] = [];
            for await (const chunk of file) {
                chunks.push(Buffer.from(chunk));
            }
            contents = Buffer.concat(chunks).toString("base64");
        } else if (file instanceof Blob) {
            const toBase64 = (file: Blob): Promise<string> =>
                new Promise((res) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => res(reader.result as string);
                });
            contents = await toBase64(file);
        } else {
            throw new errors.HumeError({
                message: `file must be one of ReadStream or Blob.`,
            });
        }
        const request: Hume.expressionMeasurement.stream.StreamModelsEndpointPayload = {
            payloadId: uuid(),
            data: contents,
            models: this.config,
            rawText: false,
        };
        if (this.streamWindowMs != null) {
            request.streamWindowMs = this.streamWindowMs;
        }
        const response = await this.send(request);
        if (response == null) {
            throw new errors.HumeError({
                message: `Received no response after sending file: ${file}`,
            });
        }
        return response;
    }

    /**
     * Send text on the `StreamSocket`
     *
     * @param text Text to send to the language model.
     * @param config This method is intended for use with a `LanguageConfig`.
     * When the socket is configured for other modalities this method will fail.
     */
    public async sendText({
        text,
        config,
    }: {
        text: string;
        config?: Hume.expressionMeasurement.stream.Config;
    }): Promise<Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage> {
        if (config != null) {
            this.config = config;
        }
        const request: Hume.expressionMeasurement.stream.StreamModelsEndpointPayload = {
            payloadId: uuid(),
            data: text,
            rawText: true,
            models: this.config,
        };
        if (this.streamWindowMs != null) {
            request.streamWindowMs = this.streamWindowMs;
        }
        const response = await this.send(request);
        if (response == null) {
            throw new errors.HumeError({
                message: `Received no response after sending text: ${text}`,
            });
        }
        return response;
    }

    /**
     * Send facemesh landmarks on the `StreamSocket`
     *
     * @param landmarks List of landmark points for multiple faces.
     * The shape of this 3-dimensional list should be (n, 478, 3) where n is the number
     * of faces to be processed, 478 is the number of MediaPipe landmarks per face and 3
     * represents the (x, y, z) coordinates of each landmark.
     * @param config List of model configurations.
     * If set these configurations will overwrite existing configurations
     */
    public async sendFacemesh({
        landmarks,
        config,
    }: {
        landmarks: number[][][];
        config?: Hume.expressionMeasurement.stream.Config;
    }): Promise<Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage> {
        const response = this.sendText({
            text: base64Encode(JSON.stringify(landmarks)),
            config,
        });
        return response;
    }

    /**
     *
     * Reset the streaming sliding window.
     *
     * Call this method when some media has been fully processed and you want to continue using the same
     * streaming connection without leaking context across media samples.
     */
    public async reset(): Promise<void> {
        await this.send({
            resetStream: true,
        });
    }

    /**
     *
     * Get details associated with the current streaming connection.
     *
     */
    public async getJobDetails(): Promise<void> {
        await this.send({
            jobDetails: true,
        });
    }

    /**
     * Closes the underlying socket.
     */
    public close(): void {
        this.websocket.close();
    }

    private async send(
        payload: Hume.expressionMeasurement.stream.StreamModelsEndpointPayload,
    ): Promise<Hume.expressionMeasurement.stream.Config | void> {
        await this.tillSocketOpen();
        const jsonPayload = serializers.expressionMeasurement.stream.StreamModelsEndpointPayload.jsonOrThrow(payload, {
            unrecognizedObjectKeys: "strip",
        });
        this.websocket.send(JSON.stringify(jsonPayload));
        const response = await new Promise<
            Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage | undefined
        >((resolve) => {
            this.websocket.addEventListener("message", (event) => {
                const response = parse(event.data);
                resolve(response);
            });
        });
        if (response != null && isError(response)) {
            throw new errors.HumeError({
                message: `CODE ${response.code}: ${response.error}`,
            });
        }
        return response;
    }

    private async tillSocketOpen(): Promise<WebSocket> {
        if (this.websocket.readyState === WebSocket.OPEN) {
            return this.websocket;
        }
        return new Promise((resolve, reject) => {
            this.websocket.addEventListener("open", () => {
                resolve(this.websocket);
            });

            this.websocket.addEventListener("error", (event) => {
                reject(event);
            });
        });
    }
}

function isError(
    response: Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage,
): response is Hume.expressionMeasurement.stream.StreamErrorMessage {
    return (response as Hume.expressionMeasurement.stream.StreamErrorMessage).error != null;
}

```


## /src/wrapper/expressionMeasurement/streaming/StreamingClient.ts
```typescript
import * as Hume from "../../../api/index.js";
import * as serializers from "../../../serialization/index.js";
import * as core from "../../../core/index.js";
import { StreamSocket } from "./StreamSocket.js";
import WebSocket from "ws";

export declare namespace StreamClient {
    interface Options {
        apiKey?: core.Supplier<string | undefined>;
    }

    interface ConnectArgs {
        /* Job config */
        config: Hume.expressionMeasurement.stream.Config;
        /* Length of the sliding window in milliseconds to use when 
            aggregating media across streaming payloads within one WebSocket connection. */
        streamWindowMs?: number;

        onOpen?: (event: WebSocket.Event) => void;
        onMessage?: (message: Hume.expressionMeasurement.stream.Config) => void;
        onError?: (error: Hume.expressionMeasurement.stream.StreamErrorMessage) => void;
        onClose?: (event: WebSocket.Event) => void;
    }
}

export class StreamClient {
    constructor(protected readonly _options: StreamClient.Options) {}

    public connect(args: StreamClient.ConnectArgs): StreamSocket {
        const websocket = new WebSocket(`wss://api.hume.ai/v0/stream/models`, {
            headers: {
                "X-Hume-Api-Key": typeof this._options.apiKey === "string" ? this._options.apiKey : "",
            },
            timeout: 10,
        });

        websocket.addEventListener("open", (event) => {
            args.onOpen?.(event);
        });

        websocket.addEventListener("error", (e) => {
            args.onError?.({
                code: e.type,
                error: e.message,
            });
        });

        websocket.addEventListener("message", async ({ data }) => {
            parse(data, {
                onMessage: args.onMessage,
                onError: args.onError,
            });
        });

        websocket.addEventListener("close", (event) => {
            args.onClose?.(event);
        });

        return new StreamSocket({
            websocket,
            streamWindowMs: args.streamWindowMs,
            config: args.config,
        });
    }
}

export function parse(
    data: WebSocket.Data,
    args: {
        onMessage?: (message: Hume.expressionMeasurement.stream.Config) => void;
        onError?: (error: Hume.expressionMeasurement.stream.StreamErrorMessage) => void;
    } = {},
): Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage | undefined {
    const message = JSON.parse(data as string);

    const parsedResponse = serializers.expressionMeasurement.stream.Config.parse(message, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true,
        breadcrumbsPrefix: ["response"],
    });
    if (parsedResponse.ok) {
        args.onMessage?.(parsedResponse.value);
        return parsedResponse.value;
    }

    const parsedError = serializers.expressionMeasurement.stream.StreamErrorMessage.parse(message, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true,
        breadcrumbsPrefix: ["response"],
    });
    if (parsedError.ok) {
        args.onError?.(parsedError.value);
        return parsedError.value;
    }
}

```


## /src/wrapper/fetchAccessToken.ts
```typescript
import { base64Encode } from "./base64Encode.js";
import { z } from "zod";

/**
 * Fetches a new access token from the Hume API using the provided API key and Secret key.
 *
 * @param args - The arguments for the request.
 * @example
 * ```typescript
 * async function getToken() {
 *   const accessToken = await fetchAccessToken({
 *     apiKey: 'test',
 *     secretKey: 'test',
 *   });
 *
 *   console.log(accessToken); // Outputs the access token
 * }
 * ```
 */
export const fetchAccessToken = async ({
    apiKey,
    secretKey,
    host = "api.hume.ai",
}: {
    apiKey: string;
    secretKey: string;
    host?: string;
}): Promise<string> => {
    const authString = `${apiKey}:${secretKey}`;
    const encoded = base64Encode(authString);

    const res = await fetch(`https://${host}/oauth2-cc/token`, {
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            Authorization: `Basic ${encoded}`,
        },
        body: new URLSearchParams({
            grant_type: "client_credentials",
        }).toString(),
    });
    if (!res.ok) {
        throw new Error(`Failed to fetch access token: (${res.status} ${res.statusText})\n ${await res.text()}`);
    }
    return z
        .object({
            access_token: z.string(),
        })
        .transform((data) => {
            return data.access_token;
        })
        .parse(await res.json());
};

```


## /src/wrapper/generateEmptyFft.ts
```typescript
export function generateEmptyFft(): number[] {
    return Array.from({ length: 24 }).map(() => 0);
}

```


## /src/wrapper/getAudioStream.ts
```typescript
export type AudioStreamOptions = {
    echoCancellation?: boolean;
    noiseSuppression?: boolean;
    autoGainControl?: boolean;
};

/**
 * Requests an audio stream from the user's device using the `getUserMedia` API.
 * The stream will have echo cancellation, noise suppression, and auto gain control enabled.
 *
 * @returns {Promise<MediaStream>} A promise that resolves to a `MediaStream` containing audio data only.
 * @throws {DOMException} If the user denies access or no audio input devices are found.
 */
export const getAudioStream = async (audioStreamOptions: AudioStreamOptions = {}): Promise<MediaStream> => {
    const { echoCancellation = true, noiseSuppression = true, autoGainControl = true } = audioStreamOptions;
    return navigator.mediaDevices.getUserMedia({
        audio: {
            echoCancellation,
            noiseSuppression,
            autoGainControl,
        },
        video: false,
    });
};

```


## /src/wrapper/getBrowserSupportedMimeType.ts
```typescript
/**
 * Enum representing the supported MIME types for audio recording.
 */
export enum MimeType {
    WEBM = "audio/webm",
    MP4 = "audio/mp4",
    WAV = "audio/wav",
}

/**
 * Represents a successful result where a compatible MIME type was found.
 * @property {true} success - Indicates a successful result.
 * @property {MimeType} mimeType - The MIME type supported by the browser.
 */
type MimeTypeSuccessResult = { success: true; mimeType: MimeType };

/**
 * Represents a failure result when no compatible MIME type is supported or an error occurs.
 * @property {false} success - Indicates a failure result.
 * @property {Error} error - The error explaining why a compatible MIME type was not found.
 */
type MimeTypeFailureResult = { success: false; error: Error };

/**
 * Union type representing the possible outcomes of checking for a supported MIME type.
 * Could either be a successful or failure result.
 */
type MimeTypeResult = MimeTypeSuccessResult | MimeTypeFailureResult;

/**
 * Checks whether the `MediaRecorder` API is supported in the current environment.
 *
 * @returns {boolean} Returns `true` if the `MediaRecorder` API is supported, otherwise `false`.
 */
function isMediaRecorderSupported(): boolean {
    return typeof MediaRecorder !== "undefined";
}

/**
 * Finds and returns the first MIME type from the given array that is supported by the `MediaRecorder`.
 *
 * @param {MimeType[]} mimeTypes - An array of MIME types to check for compatibility.
 * @returns {MimeType | null} The first supported MIME type or `null` if none are supported.
 */
function getSupportedMimeType(mimeTypes: MimeType[]): MimeType | null {
    return mimeTypes.find((type) => MediaRecorder.isTypeSupported(type)) || null;
}

/**
 * Determines if the current browser supports any of the predefined audio MIME types
 * (WEBM, MP4, or WAV) via the `MediaRecorder` API.
 *
 * @returns {MimeTypeResult} An object containing the success status and either a supported MIME type or an error.
 * @throws {Error} If the `MediaRecorder` API is not supported by the browser or no compatible types are found.
 */
export function getBrowserSupportedMimeType(): MimeTypeResult {
    // Check if the MediaRecorder API is supported in the current environment.
    if (!isMediaRecorderSupported()) {
        return {
            success: false,
            error: new Error("MediaRecorder is not supported"),
        };
    }

    const COMPATIBLE_MIME_TYPES = [MimeType.WEBM, MimeType.MP4, MimeType.WAV];

    // Find the first compatible MIME type that the browser's MediaRecorder supports.
    const supportedMimeType = getSupportedMimeType(COMPATIBLE_MIME_TYPES);

    // If no compatible MIME type is found, return a failure result with an appropriate error message.
    if (!supportedMimeType) {
        return {
            success: false,
            error: new Error("Browser does not support any compatible mime types"),
        };
    }

    // If a compatible MIME type is found, return a success result with the supported MIME type.
    return {
        success: true,
        mimeType: supportedMimeType,
    };
}

```


## /src/wrapper/index.ts
```typescript
export { base64Decode } from "./base64Decode.js";
export { base64Encode } from "./base64Encode.js";
export { convertBase64ToBlob } from "./convertBase64ToBlob.js";
export { convertBlobToBase64 } from "./convertBlobToBase64.js";
export { ensureSingleValidAudioTrack } from "./ensureSingleValidAudioTrack.js";
export { checkForAudioTracks } from "./checkForAudioTracks.js";
export { fetchAccessToken } from "./fetchAccessToken.js";
export { getAudioStream } from "./getAudioStream.js";
export { MimeType, getBrowserSupportedMimeType } from "./getBrowserSupportedMimeType.js";
export { HumeClient } from "./HumeClient.js";
export { ExpressionMeasurement } from "./expressionMeasurement/ExpressionMeasurementClient.js";
export { EVIWebAudioPlayer } from "./EVIWebAudioPlayer.js";
export type { EVIWebAudioPlayerFFTOptions, EVIWebAudioPlayerOptions } from "./EVIWebAudioPlayer.js";
export { collate } from "./collate.js";
export { SilenceFiller } from "./SilenceFiller.js";
export type { PipeDestination } from "./SilenceFiller.js";

/**
 * @deprecated SilenceFiller no longer requires dynamic import. Use `import { SilenceFiller } from 'hume'` directly.
 */
export const createSilenceFiller = async (): Promise<typeof import("./SilenceFiller.js").SilenceFiller> => {
    const { SilenceFiller } = await import("./SilenceFiller.js");
    return SilenceFiller;
};

```


## /tests/BrowserTestEnvironment.ts
```typescript
/** THIS FILE IS MANUALLY MAINAINED: see .fernignore */
import { TestEnvironment } from "jest-environment-jsdom";

class BrowserTestEnvironment extends TestEnvironment {
    async setup() {
        await super.setup();
        this.global.Request = Request;
        this.global.Response = Response;
        this.global.ReadableStream = ReadableStream;
        this.global.TextEncoder = TextEncoder;
        this.global.TextDecoder = TextDecoder;
        this.global.FormData = FormData;
        if (typeof File === "undefined") {
            this.global.File = require("buffer").File;
        } else {
            this.global.File = File;
        }
        this.global.Blob = Blob;
    }
}

export default BrowserTestEnvironment;

```


## /tests/custom.test.ts
```typescript
/**
 * This is a custom test file, if you wish to add more tests
 * to your SDK.
 * Be sure to mark this file in `.fernignore`.
 *
 * If you include example requests/responses in your fern definition,
 * you will have tests automatically generated for you.
 */
describe("test", () => {
    it("default", () => {
        expect(true).toBe(true);
    });
});

```


## /tests/mock-server/MockServer.ts
```typescript
import type { RequestHandlerOptions } from "msw";
import type { SetupServer } from "msw/node";

import { mockEndpointBuilder } from "./mockEndpointBuilder";

export interface MockServerOptions {
    baseUrl: string;
    server: SetupServer;
}

export class MockServer {
    private readonly server: SetupServer;
    public readonly baseUrl: string;

    constructor({ baseUrl, server }: MockServerOptions) {
        this.baseUrl = baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
        this.server = server;
    }

    public mockEndpoint(options?: RequestHandlerOptions): ReturnType<typeof mockEndpointBuilder> {
        const builder = mockEndpointBuilder({
            once: options?.once ?? true,
            onBuild: (handler) => {
                this.server.use(handler);
            },
        }).baseUrl(this.baseUrl);
        return builder;
    }
}

```


## /tests/mock-server/MockServerPool.ts
```typescript
import { setupServer } from "msw/node";

import { fromJson, toJson } from "../../src/core/json";
import { MockServer } from "./MockServer";
import { randomBaseUrl } from "./randomBaseUrl";

const mswServer = setupServer();
interface MockServerOptions {
    baseUrl?: string;
}

async function formatHttpRequest(request: Request, id?: string): Promise<string> {
    try {
        const clone = request.clone();
        const headers = [...clone.headers.entries()].map(([k, v]) => `${k}: ${v}`).join("\n");

        let body = "";
        try {
            const contentType = clone.headers.get("content-type");
            if (contentType?.includes("application/json")) {
                body = toJson(fromJson(await clone.text()), undefined, 2);
            } else if (clone.body) {
                body = await clone.text();
            }
        } catch (_e) {
            body = "(unable to parse body)";
        }

        const title = id ? `### Request ${id} ###\n` : "";
        const firstLine = `${title}${request.method} ${request.url.toString()} HTTP/1.1`;

        return `\n${firstLine}\n${headers}\n\n${body || "(no body)"}\n`;
    } catch (e) {
        return `Error formatting request: ${e}`;
    }
}

async function formatHttpResponse(response: Response, id?: string): Promise<string> {
    try {
        const clone = response.clone();
        const headers = [...clone.headers.entries()].map(([k, v]) => `${k}: ${v}`).join("\n");

        let body = "";
        try {
            const contentType = clone.headers.get("content-type");
            if (contentType?.includes("application/json")) {
                body = toJson(fromJson(await clone.text()), undefined, 2);
            } else if (clone.body) {
                body = await clone.text();
            }
        } catch (_e) {
            body = "(unable to parse body)";
        }

        const title = id ? `### Response for ${id} ###\n` : "";
        const firstLine = `${title}HTTP/1.1 ${response.status} ${response.statusText}`;

        return `\n${firstLine}\n${headers}\n\n${body || "(no body)"}\n`;
    } catch (e) {
        return `Error formatting response: ${e}`;
    }
}

class MockServerPool {
    private servers: MockServer[] = [];

    public createServer(options?: Partial<MockServerOptions>): MockServer {
        const baseUrl = options?.baseUrl || randomBaseUrl();
        const server = new MockServer({ baseUrl, server: mswServer });
        this.servers.push(server);
        return server;
    }

    public getServers(): MockServer[] {
        return [...this.servers];
    }

    public listen(): void {
        const onUnhandledRequest = process.env.LOG_LEVEL === "debug" ? "warn" : "bypass";
        mswServer.listen({ onUnhandledRequest });

        if (process.env.LOG_LEVEL === "debug") {
            mswServer.events.on("request:start", async ({ request, requestId }) => {
                const formattedRequest = await formatHttpRequest(request, requestId);
                console.debug(`request:start\n${formattedRequest}`);
            });

            mswServer.events.on("request:unhandled", async ({ request, requestId }) => {
                const formattedRequest = await formatHttpRequest(request, requestId);
                console.debug(`request:unhandled\n${formattedRequest}`);
            });

            mswServer.events.on("response:mocked", async ({ request, response, requestId }) => {
                const formattedResponse = await formatHttpResponse(response, requestId);
                console.debug(`response:mocked\n${formattedResponse}`);
            });
        }
    }

    public close(): void {
        this.servers = [];
        mswServer.close();
    }
}

export const mockServerPool = new MockServerPool();

```


## /tests/mock-server/mockEndpointBuilder.ts
```typescript
import { type DefaultBodyType, type HttpHandler, HttpResponse, type HttpResponseResolver, http } from "msw";

import { url } from "../../src/core";
import { toJson } from "../../src/core/json";
import { withFormUrlEncoded } from "./withFormUrlEncoded";
import { withHeaders } from "./withHeaders";
import { withJson } from "./withJson";

type HttpMethod = "all" | "get" | "post" | "put" | "delete" | "patch" | "options" | "head";

interface MethodStage {
    baseUrl(baseUrl: string): MethodStage;
    all(path: string): RequestHeadersStage;
    get(path: string): RequestHeadersStage;
    post(path: string): RequestHeadersStage;
    put(path: string): RequestHeadersStage;
    delete(path: string): RequestHeadersStage;
    patch(path: string): RequestHeadersStage;
    options(path: string): RequestHeadersStage;
    head(path: string): RequestHeadersStage;
}

interface RequestHeadersStage extends RequestBodyStage, ResponseStage {
    header(name: string, value: string): RequestHeadersStage;
    headers(headers: Record<string, string>): RequestBodyStage;
}

interface RequestBodyStage extends ResponseStage {
    jsonBody(body: unknown): ResponseStage;
    formUrlEncodedBody(body: unknown): ResponseStage;
}

interface ResponseStage {
    respondWith(): ResponseStatusStage;
}
interface ResponseStatusStage {
    statusCode(statusCode: number): ResponseHeaderStage;
}

interface ResponseHeaderStage extends ResponseBodyStage, BuildStage {
    header(name: string, value: string): ResponseHeaderStage;
    headers(headers: Record<string, string>): ResponseHeaderStage;
}

interface ResponseBodyStage {
    jsonBody(body: unknown): BuildStage;
}

interface BuildStage {
    build(): HttpHandler;
}

export interface HttpHandlerBuilderOptions {
    onBuild?: (handler: HttpHandler) => void;
    once?: boolean;
}

class RequestBuilder implements MethodStage, RequestHeadersStage, RequestBodyStage, ResponseStage {
    private method: HttpMethod = "get";
    private _baseUrl: string = "";
    private path: string = "/";
    private readonly predicates: ((resolver: HttpResponseResolver) => HttpResponseResolver)[] = [];
    private readonly handlerOptions?: HttpHandlerBuilderOptions;

    constructor(options?: HttpHandlerBuilderOptions) {
        this.handlerOptions = options;
    }

    baseUrl(baseUrl: string): MethodStage {
        this._baseUrl = baseUrl;
        return this;
    }

    all(path: string): RequestHeadersStage {
        this.method = "all";
        this.path = path;
        return this;
    }

    get(path: string): RequestHeadersStage {
        this.method = "get";
        this.path = path;
        return this;
    }

    post(path: string): RequestHeadersStage {
        this.method = "post";
        this.path = path;
        return this;
    }

    put(path: string): RequestHeadersStage {
        this.method = "put";
        this.path = path;
        return this;
    }

    delete(path: string): RequestHeadersStage {
        this.method = "delete";
        this.path = path;
        return this;
    }

    patch(path: string): RequestHeadersStage {
        this.method = "patch";
        this.path = path;
        return this;
    }

    options(path: string): RequestHeadersStage {
        this.method = "options";
        this.path = path;
        return this;
    }

    head(path: string): RequestHeadersStage {
        this.method = "head";
        this.path = path;
        return this;
    }

    header(name: string, value: string): RequestHeadersStage {
        this.predicates.push((resolver) => withHeaders({ [name]: value }, resolver));
        return this;
    }

    headers(headers: Record<string, string>): RequestBodyStage {
        this.predicates.push((resolver) => withHeaders(headers, resolver));
        return this;
    }

    jsonBody(body: unknown): ResponseStage {
        if (body === undefined) {
            throw new Error("Undefined is not valid JSON. Do not call jsonBody if you want an empty body.");
        }
        this.predicates.push((resolver) => withJson(body, resolver));
        return this;
    }

    formUrlEncodedBody(body: unknown): ResponseStage {
        if (body === undefined) {
            throw new Error(
                "Undefined is not valid for form-urlencoded. Do not call formUrlEncodedBody if you want an empty body.",
            );
        }
        this.predicates.push((resolver) => withFormUrlEncoded(body, resolver));
        return this;
    }

    respondWith(): ResponseStatusStage {
        return new ResponseBuilder(this.method, this.buildUrl(), this.predicates, this.handlerOptions);
    }

    private buildUrl(): string {
        return url.join(this._baseUrl, this.path);
    }
}

class ResponseBuilder implements ResponseStatusStage, ResponseHeaderStage, ResponseBodyStage, BuildStage {
    private readonly method: HttpMethod;
    private readonly url: string;
    private readonly requestPredicates: ((resolver: HttpResponseResolver) => HttpResponseResolver)[];
    private readonly handlerOptions?: HttpHandlerBuilderOptions;

    private responseStatusCode: number = 200;
    private responseHeaders: Record<string, string> = {};
    private responseBody: DefaultBodyType = undefined;

    constructor(
        method: HttpMethod,
        url: string,
        requestPredicates: ((resolver: HttpResponseResolver) => HttpResponseResolver)[],
        options?: HttpHandlerBuilderOptions,
    ) {
        this.method = method;
        this.url = url;
        this.requestPredicates = requestPredicates;
        this.handlerOptions = options;
    }

    public statusCode(code: number): ResponseHeaderStage {
        this.responseStatusCode = code;
        return this;
    }

    public header(name: string, value: string): ResponseHeaderStage {
        this.responseHeaders[name] = value;
        return this;
    }

    public headers(headers: Record<string, string>): ResponseHeaderStage {
        this.responseHeaders = { ...this.responseHeaders, ...headers };
        return this;
    }

    public jsonBody(body: unknown): BuildStage {
        if (body === undefined) {
            throw new Error("Undefined is not valid JSON. Do not call jsonBody if you expect an empty body.");
        }
        this.responseBody = toJson(body);
        return this;
    }

    public build(): HttpHandler {
        const responseResolver: HttpResponseResolver = () => {
            const response = new HttpResponse(this.responseBody, {
                status: this.responseStatusCode,
                headers: this.responseHeaders,
            });
            // if no Content-Type header is set, delete the default text content type that is set
            if (Object.keys(this.responseHeaders).some((key) => key.toLowerCase() === "content-type") === false) {
                response.headers.delete("Content-Type");
            }
            return response;
        };

        const finalResolver = this.requestPredicates.reduceRight((acc, predicate) => predicate(acc), responseResolver);

        const handler = http[this.method](this.url, finalResolver, this.handlerOptions);
        this.handlerOptions?.onBuild?.(handler);
        return handler;
    }
}

export function mockEndpointBuilder(options?: HttpHandlerBuilderOptions): MethodStage {
    return new RequestBuilder(options);
}

```


## /tests/mock-server/randomBaseUrl.ts
```typescript
export function randomBaseUrl(): string {
    const randomString = Math.random().toString(36).substring(2, 15);
    return `http://${randomString}.localhost`;
}

```


## /tests/mock-server/setup.ts
```typescript
import { afterAll, beforeAll } from "vitest";

import { mockServerPool } from "./MockServerPool";

beforeAll(() => {
    mockServerPool.listen();
});
afterAll(() => {
    mockServerPool.close();
});

```


## /tests/mock-server/withFormUrlEncoded.ts
```typescript
import { type HttpResponseResolver, passthrough } from "msw";

import { toJson } from "../../src/core/json";

/**
 * Creates a request matcher that validates if the request form-urlencoded body exactly matches the expected object
 * @param expectedBody - The exact body object to match against
 * @param resolver - Response resolver to execute if body matches
 */
export function withFormUrlEncoded(expectedBody: unknown, resolver: HttpResponseResolver): HttpResponseResolver {
    return async (args) => {
        const { request } = args;

        let clonedRequest: Request;
        let bodyText: string | undefined;
        let actualBody: Record<string, string>;
        try {
            clonedRequest = request.clone();
            bodyText = await clonedRequest.text();
            if (bodyText === "") {
                // Empty body is valid if expected body is also empty
                const isExpectedEmpty =
                    expectedBody != null &&
                    typeof expectedBody === "object" &&
                    Object.keys(expectedBody as Record<string, unknown>).length === 0;
                if (!isExpectedEmpty) {
                    console.error("Request body is empty, expected a form-urlencoded body.");
                    return passthrough();
                }
                actualBody = {};
            } else {
                const params = new URLSearchParams(bodyText);
                actualBody = {};
                for (const [key, value] of params.entries()) {
                    actualBody[key] = value;
                }
            }
        } catch (error) {
            console.error(`Error processing form-urlencoded request body:\n\tError: ${error}\n\tBody: ${bodyText}`);
            return passthrough();
        }

        const mismatches = findMismatches(actualBody, expectedBody);
        if (Object.keys(mismatches).length > 0) {
            console.error("Form-urlencoded body mismatch:", toJson(mismatches, undefined, 2));
            return passthrough();
        }

        return resolver(args);
    };
}

function findMismatches(actual: any, expected: any): Record<string, { actual: any; expected: any }> {
    const mismatches: Record<string, { actual: any; expected: any }> = {};

    if (typeof actual !== typeof expected) {
        return { value: { actual, expected } };
    }

    if (typeof actual !== "object" || actual === null || expected === null) {
        if (actual !== expected) {
            return { value: { actual, expected } };
        }
        return {};
    }

    const actualKeys = Object.keys(actual);
    const expectedKeys = Object.keys(expected);

    const allKeys = new Set([...actualKeys, ...expectedKeys]);

    for (const key of allKeys) {
        if (!expectedKeys.includes(key)) {
            if (actual[key] === undefined) {
                continue;
            }
            mismatches[key] = { actual: actual[key], expected: undefined };
        } else if (!actualKeys.includes(key)) {
            if (expected[key] === undefined) {
                continue;
            }
            mismatches[key] = { actual: undefined, expected: expected[key] };
        } else if (actual[key] !== expected[key]) {
            mismatches[key] = { actual: actual[key], expected: expected[key] };
        }
    }

    return mismatches;
}

```


## /tests/mock-server/withHeaders.ts
```typescript
import { type HttpResponseResolver, passthrough } from "msw";

/**
 * Creates a request matcher that validates if request headers match specified criteria
 * @param expectedHeaders - Headers to match against
 * @param resolver - Response resolver to execute if headers match
 */
export function withHeaders(
    expectedHeaders: Record<string, string | RegExp | ((value: string) => boolean)>,
    resolver: HttpResponseResolver,
): HttpResponseResolver {
    return (args) => {
        const { request } = args;
        const { headers } = request;

        const mismatches: Record<
            string,
            { actual: string | null; expected: string | RegExp | ((value: string) => boolean) }
        > = {};

        for (const [key, expectedValue] of Object.entries(expectedHeaders)) {
            const actualValue = headers.get(key);

            if (actualValue === null) {
                mismatches[key] = { actual: null, expected: expectedValue };
                continue;
            }

            if (typeof expectedValue === "function") {
                if (!expectedValue(actualValue)) {
                    mismatches[key] = { actual: actualValue, expected: expectedValue };
                }
            } else if (expectedValue instanceof RegExp) {
                if (!expectedValue.test(actualValue)) {
                    mismatches[key] = { actual: actualValue, expected: expectedValue };
                }
            } else if (expectedValue !== actualValue) {
                mismatches[key] = { actual: actualValue, expected: expectedValue };
            }
        }

        if (Object.keys(mismatches).length > 0) {
            const formattedMismatches = formatHeaderMismatches(mismatches);
            console.error("Header mismatch:", formattedMismatches);
            return passthrough();
        }

        return resolver(args);
    };
}

function formatHeaderMismatches(
    mismatches: Record<string, { actual: string | null; expected: string | RegExp | ((value: string) => boolean) }>,
): Record<string, { actual: string | null; expected: string }> {
    const formatted: Record<string, { actual: string | null; expected: string }> = {};

    for (const [key, { actual, expected }] of Object.entries(mismatches)) {
        formatted[key] = {
            actual,
            expected:
                expected instanceof RegExp
                    ? expected.toString()
                    : typeof expected === "function"
                      ? "[Function]"
                      : expected,
        };
    }

    return formatted;
}

```


## /tests/mock-server/withJson.ts
```typescript
import { type HttpResponseResolver, passthrough } from "msw";

import { fromJson, toJson } from "../../src/core/json";

/**
 * Creates a request matcher that validates if the request JSON body exactly matches the expected object
 * @param expectedBody - The exact body object to match against
 * @param resolver - Response resolver to execute if body matches
 */
export function withJson(expectedBody: unknown, resolver: HttpResponseResolver): HttpResponseResolver {
    return async (args) => {
        const { request } = args;

        let clonedRequest: Request;
        let bodyText: string | undefined;
        let actualBody: unknown;
        try {
            clonedRequest = request.clone();
            bodyText = await clonedRequest.text();
            if (bodyText === "") {
                console.error("Request body is empty, expected a JSON object.");
                return passthrough();
            }
            actualBody = fromJson(bodyText);
        } catch (error) {
            console.error(`Error processing request body:\n\tError: ${error}\n\tBody: ${bodyText}`);
            return passthrough();
        }

        const mismatches = findMismatches(actualBody, expectedBody);
        if (Object.keys(mismatches).filter((key) => !key.startsWith("pagination.")).length > 0) {
            console.error("JSON body mismatch:", toJson(mismatches, undefined, 2));
            return passthrough();
        }

        return resolver(args);
    };
}

function findMismatches(actual: any, expected: any): Record<string, { actual: any; expected: any }> {
    const mismatches: Record<string, { actual: any; expected: any }> = {};

    if (typeof actual !== typeof expected) {
        if (areEquivalent(actual, expected)) {
            return {};
        }
        return { value: { actual, expected } };
    }

    if (typeof actual !== "object" || actual === null || expected === null) {
        if (actual !== expected) {
            if (areEquivalent(actual, expected)) {
                return {};
            }
            return { value: { actual, expected } };
        }
        return {};
    }

    if (Array.isArray(actual) && Array.isArray(expected)) {
        if (actual.length !== expected.length) {
            return { length: { actual: actual.length, expected: expected.length } };
        }

        const arrayMismatches: Record<string, { actual: any; expected: any }> = {};
        for (let i = 0; i < actual.length; i++) {
            const itemMismatches = findMismatches(actual[i], expected[i]);
            if (Object.keys(itemMismatches).length > 0) {
                for (const [mismatchKey, mismatchValue] of Object.entries(itemMismatches)) {
                    arrayMismatches[`[${i}]${mismatchKey === "value" ? "" : `.${mismatchKey}`}`] = mismatchValue;
                }
            }
        }
        return arrayMismatches;
    }

    const actualKeys = Object.keys(actual);
    const expectedKeys = Object.keys(expected);

    const allKeys = new Set([...actualKeys, ...expectedKeys]);

    for (const key of allKeys) {
        if (!expectedKeys.includes(key)) {
            if (actual[key] === undefined) {
                continue; // Skip undefined values in actual
            }
            mismatches[key] = { actual: actual[key], expected: undefined };
        } else if (!actualKeys.includes(key)) {
            if (expected[key] === undefined) {
                continue; // Skip undefined values in expected
            }
            mismatches[key] = { actual: undefined, expected: expected[key] };
        } else if (
            typeof actual[key] === "object" &&
            actual[key] !== null &&
            typeof expected[key] === "object" &&
            expected[key] !== null
        ) {
            const nestedMismatches = findMismatches(actual[key], expected[key]);
            if (Object.keys(nestedMismatches).length > 0) {
                for (const [nestedKey, nestedValue] of Object.entries(nestedMismatches)) {
                    mismatches[`${key}${nestedKey === "value" ? "" : `.${nestedKey}`}`] = nestedValue;
                }
            }
        } else if (actual[key] !== expected[key]) {
            if (areEquivalent(actual[key], expected[key])) {
                continue;
            }
            mismatches[key] = { actual: actual[key], expected: expected[key] };
        }
    }

    return mismatches;
}

function areEquivalent(actual: unknown, expected: unknown): boolean {
    if (actual === expected) {
        return true;
    }
    if (isEquivalentBigInt(actual, expected)) {
        return true;
    }
    if (isEquivalentDatetime(actual, expected)) {
        return true;
    }
    return false;
}

function isEquivalentBigInt(actual: unknown, expected: unknown) {
    if (typeof actual === "number") {
        actual = BigInt(actual);
    }
    if (typeof expected === "number") {
        expected = BigInt(expected);
    }
    if (typeof actual === "bigint" && typeof expected === "bigint") {
        return actual === expected;
    }
    return false;
}

function isEquivalentDatetime(str1: unknown, str2: unknown): boolean {
    if (typeof str1 !== "string" || typeof str2 !== "string") {
        return false;
    }
    const isoDatePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d{3})?Z$/;
    if (!isoDatePattern.test(str1) || !isoDatePattern.test(str2)) {
        return false;
    }

    try {
        const date1 = new Date(str1).getTime();
        const date2 = new Date(str2).getTime();
        return date1 === date2;
    } catch {
        return false;
    }
}

```


## /tests/setup.ts
```typescript
import { expect } from "vitest";

interface CustomMatchers<R = unknown> {
    toContainHeaders(expectedHeaders: Record<string, string>): R;
}

declare module "vitest" {
    interface Assertion<T = any> extends CustomMatchers<T> {}
    interface AsymmetricMatchersContaining extends CustomMatchers {}
}

expect.extend({
    toContainHeaders(actual: unknown, expectedHeaders: Record<string, string>) {
        const isHeaders = actual instanceof Headers;
        const isPlainObject = typeof actual === "object" && actual !== null && !Array.isArray(actual);

        if (!isHeaders && !isPlainObject) {
            throw new TypeError("Received value must be an instance of Headers or a plain object!");
        }

        if (typeof expectedHeaders !== "object" || expectedHeaders === null || Array.isArray(expectedHeaders)) {
            throw new TypeError("Expected headers must be a plain object!");
        }

        const missingHeaders: string[] = [];
        const mismatchedHeaders: Array<{ key: string; expected: string; actual: string | null }> = [];

        for (const [key, value] of Object.entries(expectedHeaders)) {
            let actualValue: string | null = null;

            if (isHeaders) {
                // Headers.get() is already case-insensitive
                actualValue = (actual as Headers).get(key);
            } else {
                // For plain objects, do case-insensitive lookup
                const actualObj = actual as Record<string, string>;
                const lowerKey = key.toLowerCase();
                const foundKey = Object.keys(actualObj).find((k) => k.toLowerCase() === lowerKey);
                actualValue = foundKey ? actualObj[foundKey] : null;
            }

            if (actualValue === null || actualValue === undefined) {
                missingHeaders.push(key);
            } else if (actualValue !== value) {
                mismatchedHeaders.push({ key, expected: value, actual: actualValue });
            }
        }

        const pass = missingHeaders.length === 0 && mismatchedHeaders.length === 0;

        const actualType = isHeaders ? "Headers" : "object";

        if (pass) {
            return {
                message: () => `expected ${actualType} not to contain ${this.utils.printExpected(expectedHeaders)}`,
                pass: true,
            };
        } else {
            const messages: string[] = [];

            if (missingHeaders.length > 0) {
                messages.push(`Missing headers: ${this.utils.printExpected(missingHeaders.join(", "))}`);
            }

            if (mismatchedHeaders.length > 0) {
                const mismatches = mismatchedHeaders.map(
                    ({ key, expected, actual }) =>
                        `${key}: expected ${this.utils.printExpected(expected)} but got ${this.utils.printReceived(actual)}`,
                );
                messages.push(mismatches.join("\n"));
            }

            return {
                message: () =>
                    `expected ${actualType} to contain ${this.utils.printExpected(expectedHeaders)}\n\n${messages.join("\n")}`,
                pass: false,
            };
        }
    },
});

```


## /tests/tsconfig.json
```json
{
    "extends": "../tsconfig.base.json",
    "compilerOptions": {
        "outDir": null,
        "rootDir": "..",
        "baseUrl": "..",
        "types": ["vitest/globals"]
    },
    "include": ["../src", "../tests"],
    "exclude": []
}

```


## /tests/unit/auth/BasicAuth.test.ts
```typescript
import { BasicAuth } from "../../../src/core/auth/BasicAuth";

describe("BasicAuth", () => {
    interface ToHeaderTestCase {
        description: string;
        input: { username: string; password: string };
        expected: string;
    }

    interface FromHeaderTestCase {
        description: string;
        input: string;
        expected: { username: string; password: string };
    }

    interface ErrorTestCase {
        description: string;
        input: string;
        expectedError: string;
    }

    describe("toAuthorizationHeader", () => {
        const toHeaderTests: ToHeaderTestCase[] = [
            {
                description: "correctly converts to header",
                input: { username: "username", password: "password" },
                expected: "Basic dXNlcm5hbWU6cGFzc3dvcmQ=",
            },
        ];

        toHeaderTests.forEach(({ description, input, expected }) => {
            it(description, () => {
                expect(BasicAuth.toAuthorizationHeader(input)).toBe(expected);
            });
        });
    });

    describe("fromAuthorizationHeader", () => {
        const fromHeaderTests: FromHeaderTestCase[] = [
            {
                description: "correctly parses header",
                input: "Basic dXNlcm5hbWU6cGFzc3dvcmQ=",
                expected: { username: "username", password: "password" },
            },
            {
                description: "handles password with colons",
                input: "Basic dXNlcjpwYXNzOndvcmQ=",
                expected: { username: "user", password: "pass:word" },
            },
            {
                description: "handles empty username and password (just colon)",
                input: "Basic Og==",
                expected: { username: "", password: "" },
            },
            {
                description: "handles empty username",
                input: "Basic OnBhc3N3b3Jk",
                expected: { username: "", password: "password" },
            },
            {
                description: "handles empty password",
                input: "Basic dXNlcm5hbWU6",
                expected: { username: "username", password: "" },
            },
        ];

        fromHeaderTests.forEach(({ description, input, expected }) => {
            it(description, () => {
                expect(BasicAuth.fromAuthorizationHeader(input)).toEqual(expected);
            });
        });

        const errorTests: ErrorTestCase[] = [
            {
                description: "throws error for completely empty credentials",
                input: "Basic ",
                expectedError: "Invalid basic auth",
            },
            {
                description: "throws error for credentials without colon",
                input: "Basic dXNlcm5hbWU=",
                expectedError: "Invalid basic auth",
            },
        ];

        errorTests.forEach(({ description, input, expectedError }) => {
            it(description, () => {
                expect(() => BasicAuth.fromAuthorizationHeader(input)).toThrow(expectedError);
            });
        });
    });
});

```


## /tests/unit/auth/BearerToken.test.ts
```typescript
import { BearerToken } from "../../../src/core/auth/BearerToken";

describe("BearerToken", () => {
    describe("toAuthorizationHeader", () => {
        it("correctly converts to header", () => {
            expect(BearerToken.toAuthorizationHeader("my-token")).toBe("Bearer my-token");
        });
    });
    describe("fromAuthorizationHeader", () => {
        it("correctly parses header", () => {
            expect(BearerToken.fromAuthorizationHeader("Bearer my-token")).toBe("my-token");
        });
    });
});

```


## /tests/unit/auth/auth.test.ts
```typescript
/**
 * Tests for authentication support - both apiKey and accessToken methods.
 */

import { describe, expect, it } from "vitest";

import { HeaderAuthProvider } from "../../../src/auth/HeaderAuthProvider";
import { HumeClient } from "../../../src/wrapper/HumeClient";

describe("Authentication", () => {
    describe("HeaderAuthProvider", () => {
        it("returns X-Hume-Api-Key header when apiKey is provided", async () => {
            const provider = new HeaderAuthProvider({ apiKey: "test-api-key" });
            const result = await provider.getAuthRequest();
            expect(result.headers).toEqual({ "X-Hume-Api-Key": "test-api-key" });
        });

        it("returns Authorization header when accessToken is provided via headers", async () => {
            const provider = new HeaderAuthProvider({
                headers: { Authorization: "Bearer test-token" },
            });
            const result = await provider.getAuthRequest();
            expect(result.headers).toEqual({ Authorization: "Bearer test-token" });
        });

        it("handles case-insensitive Authorization header", async () => {
            const provider = new HeaderAuthProvider({
                headers: { authorization: "Bearer test-token" },
            });
            const result = await provider.getAuthRequest();
            expect(result.headers).toEqual({ Authorization: "Bearer test-token" });
        });

        it("prefers apiKey over Authorization header when both are provided", async () => {
            const provider = new HeaderAuthProvider({
                apiKey: "test-api-key",
                headers: { Authorization: "Bearer test-token" },
            });
            const result = await provider.getAuthRequest();
            expect(result.headers).toEqual({ "X-Hume-Api-Key": "test-api-key" });
        });

        it("throws when neither apiKey nor Authorization header is provided", async () => {
            const provider = new HeaderAuthProvider({});
            await expect(provider.getAuthRequest()).rejects.toThrow(
                "Please provide either 'apiKey' or 'accessToken' when initializing the client",
            );
        });

        it("throws when apiKey is undefined and no Authorization header", async () => {
            const provider = new HeaderAuthProvider({ apiKey: undefined });
            await expect(provider.getAuthRequest()).rejects.toThrow("Please provide either 'apiKey' or 'accessToken'");
        });

        it("supports Supplier function for apiKey", async () => {
            const provider = new HeaderAuthProvider({
                apiKey: () => "dynamic-api-key",
            });
            const result = await provider.getAuthRequest();
            expect(result.headers).toEqual({ "X-Hume-Api-Key": "dynamic-api-key" });
        });

        // Note: The local Supplier type is synchronous, so async functions are not directly supported.
        // However, the await in getAuthRequest() handles values that happen to be Promises.

        it("supports Supplier function for Authorization header", async () => {
            const provider = new HeaderAuthProvider({
                headers: { Authorization: () => "Bearer dynamic-token" },
            });
            const result = await provider.getAuthRequest();
            expect(result.headers).toEqual({ Authorization: "Bearer dynamic-token" });
        });

        describe("canCreate", () => {
            it("returns true when apiKey is provided", () => {
                expect(HeaderAuthProvider.canCreate({ apiKey: "test" })).toBe(true);
            });

            it("returns true when Authorization header is provided", () => {
                expect(
                    HeaderAuthProvider.canCreate({
                        headers: { Authorization: "Bearer token" },
                    }),
                ).toBe(true);
            });

            it("returns true when authorization header is provided (case-insensitive)", () => {
                expect(
                    HeaderAuthProvider.canCreate({
                        headers: { authorization: "Bearer token" },
                    }),
                ).toBe(true);
            });

            it("returns false when neither is provided", () => {
                expect(HeaderAuthProvider.canCreate({})).toBe(false);
            });

            it("returns false when headers exist but no Authorization", () => {
                expect(
                    HeaderAuthProvider.canCreate({
                        headers: { "X-Custom-Header": "value" },
                    }),
                ).toBe(false);
            });
        });
    });

    describe("HumeClient wrapper", () => {
        it("accepts apiKey authentication", () => {
            const client = new HumeClient({ apiKey: "test-api-key" });
            expect(client).toBeDefined();
        });

        it("accepts accessToken authentication", () => {
            const client = new HumeClient({ accessToken: "test-token" });
            expect(client).toBeDefined();
        });

        it("converts accessToken to Authorization header internally", () => {
            const client = new HumeClient({ accessToken: "test-token" });
            // Access the internal options to verify the Authorization header is set
            const options = (client as any)._options;
            expect(options.headers).toBeDefined();
            // The Authorization header is set as a Supplier, so we can't easily check the value directly
            // but we can verify the header key exists
            const hasAuthHeader = Object.keys(options.headers).some((key) => key.toLowerCase() === "authorization");
            expect(hasAuthHeader).toBe(true);
        });

        it("throws when both accessToken and Authorization header are provided", () => {
            expect(
                () =>
                    new HumeClient({
                        accessToken: "token",
                        headers: { Authorization: "Bearer another" },
                    }),
            ).toThrow("Cannot provide both 'accessToken' and 'headers.Authorization'");
        });

        it("allows custom headers alongside apiKey", () => {
            const client = new HumeClient({
                apiKey: "test-api-key",
                headers: { "X-Custom-Header": "value" },
            });
            expect(client).toBeDefined();
        });

        it("allows custom headers alongside accessToken", () => {
            const client = new HumeClient({
                accessToken: "test-token",
                headers: { "X-Custom-Header": "value" },
            });
            expect(client).toBeDefined();
        });
    });
});

```


## /tests/unit/base64.test.ts
```typescript
import { base64Decode, base64Encode } from "../../src/core/base64";

describe("base64", () => {
    describe("base64Encode", () => {
        it("should encode ASCII strings", () => {
            expect(base64Encode("hello")).toBe("aGVsbG8=");
            expect(base64Encode("")).toBe("");
        });

        it("should encode UTF-8 strings", () => {
            expect(base64Encode("café")).toBe("Y2Fmw6k=");
            expect(base64Encode("🎉")).toBe("8J+OiQ==");
        });

        it("should handle basic auth credentials", () => {
            expect(base64Encode("username:password")).toBe("dXNlcm5hbWU6cGFzc3dvcmQ=");
        });
    });

    describe("base64Decode", () => {
        it("should decode ASCII strings", () => {
            expect(base64Decode("aGVsbG8=")).toBe("hello");
            expect(base64Decode("")).toBe("");
        });

        it("should decode UTF-8 strings", () => {
            expect(base64Decode("Y2Fmw6k=")).toBe("café");
            expect(base64Decode("8J+OiQ==")).toBe("🎉");
        });

        it("should handle basic auth credentials", () => {
            expect(base64Decode("dXNlcm5hbWU6cGFzc3dvcmQ=")).toBe("username:password");
        });
    });

    describe("round-trip encoding", () => {
        const testStrings = [
            "hello world",
            "test@example.com",
            "café",
            "username:password",
            "user@domain.com:super$ecret123!",
        ];

        testStrings.forEach((testString) => {
            it(`should round-trip encode/decode: "${testString}"`, () => {
                const encoded = base64Encode(testString);
                const decoded = base64Decode(encoded);
                expect(decoded).toBe(testString);
            });
        });
    });
});

```


## /tests/unit/fetcher/Fetcher.test.ts
```typescript
import fs from "fs";
import stream from "stream";
import { join } from "path";

import { Fetcher, fetcherImpl } from "../../../src/core/fetcher/Fetcher";
import type { BinaryResponse } from "../../../src/core";

function expectHeadersToContain(headers: Headers, expected: Record<string, string>) {
    for (const [key, value] of Object.entries(expected)) {
        expect(headers.get(key)).toBe(value);
    }
}

describe("Test fetcherImpl", () => {
    it("should handle successful request", async () => {
        const mockArgs: Fetcher.Args = {
            url: "https://httpbin.org/post",
            method: "POST",
            headers: { "X-Test": "x-test-header" },
            body: { data: "test" },
            contentType: "application/json",
            requestType: "json",
            responseType: "json",
        };

        global.fetch = vi.fn().mockResolvedValue(
            new Response(JSON.stringify({ data: "test" }), {
                status: 200,
                statusText: "OK",
            }),
        );

        const result = await fetcherImpl(mockArgs);
        expect(result.ok).toBe(true);
        if (result.ok) {
            expect(result.body).toEqual({ data: "test" });
        }

        expect(global.fetch).toHaveBeenCalledWith(
            "https://httpbin.org/post",
            expect.objectContaining({
                method: "POST",
                body: JSON.stringify({ data: "test" }),
            }),
        );
        const callArgs = vi.mocked(global.fetch).mock.calls[0]![1]!;
        expectHeadersToContain(callArgs.headers as Headers, { "X-Test": "x-test-header" });
    });

    it("should send octet stream", async () => {
        const url = "https://httpbin.org/post/file";
        const mockArgs: Fetcher.Args = {
            url,
            method: "POST",
            headers: { "X-Test": "x-test-header" },
            contentType: "application/octet-stream",
            requestType: "bytes",
            responseType: "json",
            body: fs.createReadStream(join(__dirname, "test-file.txt")),
        };

        global.fetch = vi.fn().mockResolvedValue(
            new Response(JSON.stringify({ data: "test" }), {
                status: 200,
                statusText: "OK",
            }),
        );

        const result = await fetcherImpl(mockArgs);

        expect(global.fetch).toHaveBeenCalledWith(
            url,
            expect.objectContaining({
                method: "POST",
                body: expect.any(fs.ReadStream),
            }),
        );
        const callArgs = vi.mocked(global.fetch).mock.calls[0]![1]!;
        expectHeadersToContain(callArgs.headers as Headers, { "X-Test": "x-test-header" });
        expect(result.ok).toBe(true);
        if (result.ok) {
            expect(result.body).toEqual({ data: "test" });
        }
    });

    it("should receive file as stream", async () => {
        const url = "https://httpbin.org/post/file";
        const mockArgs: Fetcher.Args = {
            url,
            method: "GET",
            headers: { "X-Test": "x-test-header" },
            responseType: "binary-response",
        };

        global.fetch = vi.fn().mockResolvedValue(
            new Response(
                stream.Readable.toWeb(fs.createReadStream(join(__dirname, "test-file.txt"))) as ReadableStream,
                {
                    status: 200,
                    statusText: "OK",
                },
            ),
        );

        const result = await fetcherImpl(mockArgs);

        expect(global.fetch).toHaveBeenCalledWith(
            url,
            expect.objectContaining({
                method: "GET",
            }),
        );
        const callArgs = vi.mocked(global.fetch).mock.calls[0]![1]!;
        expectHeadersToContain(callArgs.headers as Headers, { "X-Test": "x-test-header" });
        expect(result.ok).toBe(true);
        if (result.ok) {
            const body = result.body as BinaryResponse;
            expect(body).toBeDefined();
            expect(body.bodyUsed).toBe(false);
            expect(typeof body.stream).toBe("function");
            const stream = body.stream();
            expect(stream).toBeInstanceOf(ReadableStream);
            const reader = stream.getReader();
            const { value } = await reader.read();
            const decoder = new TextDecoder();
            const streamContent = decoder.decode(value);
            expect(streamContent).toBe("This is a test file!\n");
            expect(body.bodyUsed).toBe(true);
        }
    });

    it("should receive file as blob", async () => {
        const url = "https://httpbin.org/post/file";
        const mockArgs: Fetcher.Args = {
            url,
            method: "GET",
            headers: { "X-Test": "x-test-header" },
            responseType: "binary-response",
        };

        global.fetch = vi.fn().mockResolvedValue(
            new Response(
                stream.Readable.toWeb(fs.createReadStream(join(__dirname, "test-file.txt"))) as ReadableStream,
                {
                    status: 200,
                    statusText: "OK",
                },
            ),
        );

        const result = await fetcherImpl(mockArgs);

        expect(global.fetch).toHaveBeenCalledWith(
            url,
            expect.objectContaining({
                method: "GET",
            }),
        );
        const callArgs = vi.mocked(global.fetch).mock.calls[0]![1]!;
        expectHeadersToContain(callArgs.headers as Headers, { "X-Test": "x-test-header" });
        expect(result.ok).toBe(true);
        if (result.ok) {
            const body = result.body as BinaryResponse;
            expect(body).toBeDefined();
            expect(body.bodyUsed).toBe(false);
            expect(typeof body.blob).toBe("function");
            const blob = await body.blob();
            expect(blob).toBeInstanceOf(Blob);
            const reader = blob.stream().getReader();
            const { value } = await reader.read();
            const decoder = new TextDecoder();
            const streamContent = decoder.decode(value);
            expect(streamContent).toBe("This is a test file!\n");
            expect(body.bodyUsed).toBe(true);
        }
    });

    it("should receive file as arraybuffer", async () => {
        const url = "https://httpbin.org/post/file";
        const mockArgs: Fetcher.Args = {
            url,
            method: "GET",
            headers: { "X-Test": "x-test-header" },
            responseType: "binary-response",
        };

        global.fetch = vi.fn().mockResolvedValue(
            new Response(
                stream.Readable.toWeb(fs.createReadStream(join(__dirname, "test-file.txt"))) as ReadableStream,
                {
                    status: 200,
                    statusText: "OK",
                },
            ),
        );

        const result = await fetcherImpl(mockArgs);

        expect(global.fetch).toHaveBeenCalledWith(
            url,
            expect.objectContaining({
                method: "GET",
            }),
        );
        const callArgs = vi.mocked(global.fetch).mock.calls[0]![1]!;
        expectHeadersToContain(callArgs.headers as Headers, { "X-Test": "x-test-header" });
        expect(result.ok).toBe(true);
        if (result.ok) {
            const body = result.body as BinaryResponse;
            expect(body).toBeDefined();
            expect(body.bodyUsed).toBe(false);
            expect(typeof body.arrayBuffer).toBe("function");
            const arrayBuffer = await body.arrayBuffer();
            expect(arrayBuffer).toBeInstanceOf(ArrayBuffer);
            const decoder = new TextDecoder();
            const streamContent = decoder.decode(new Uint8Array(arrayBuffer));
            expect(streamContent).toBe("This is a test file!\n");
            expect(body.bodyUsed).toBe(true);
        }
    });

    it("should receive file as bytes", async () => {
        const url = "https://httpbin.org/post/file";
        const mockArgs: Fetcher.Args = {
            url,
            method: "GET",
            headers: { "X-Test": "x-test-header" },
            responseType: "binary-response",
        };

        global.fetch = vi.fn().mockResolvedValue(
            new Response(
                stream.Readable.toWeb(fs.createReadStream(join(__dirname, "test-file.txt"))) as ReadableStream,
                {
                    status: 200,
                    statusText: "OK",
                },
            ),
        );

        const result = await fetcherImpl(mockArgs);

        expect(global.fetch).toHaveBeenCalledWith(
            url,
            expect.objectContaining({
                method: "GET",
            }),
        );
        const callArgs = vi.mocked(global.fetch).mock.calls[0]![1]!;
        expectHeadersToContain(callArgs.headers as Headers, { "X-Test": "x-test-header" });
        expect(result.ok).toBe(true);
        if (result.ok) {
            const body = result.body as BinaryResponse;
            expect(body).toBeDefined();
            expect(body.bodyUsed).toBe(false);
            if (!body.bytes) {
                return;
            }
            expect(typeof body.bytes).toBe("function");
            const bytes = await body.bytes();
            expect(bytes).toBeInstanceOf(Uint8Array);
            const decoder = new TextDecoder();
            const streamContent = decoder.decode(bytes);
            expect(streamContent).toBe("This is a test file!\n");
            expect(body.bodyUsed).toBe(true);
        }
    });
});

```


## /tests/unit/fetcher/HttpResponsePromise.test.ts
```typescript
import { beforeEach, describe, expect, it, vi } from "vitest";

import { HttpResponsePromise } from "../../../src/core/fetcher/HttpResponsePromise";
import type { RawResponse, WithRawResponse } from "../../../src/core/fetcher/RawResponse";

describe("HttpResponsePromise", () => {
    const mockRawResponse: RawResponse = {
        headers: new Headers(),
        redirected: false,
        status: 200,
        statusText: "OK",
        type: "basic" as ResponseType,
        url: "https://example.com",
    };
    const mockData = { id: "123", name: "test" };
    const mockWithRawResponse: WithRawResponse<typeof mockData> = {
        data: mockData,
        rawResponse: mockRawResponse,
    };

    describe("fromFunction", () => {
        it("should create an HttpResponsePromise from a function", async () => {
            const mockFn = vi
                .fn<(arg1: string, arg2: string) => Promise<WithRawResponse<typeof mockData>>>()
                .mockResolvedValue(mockWithRawResponse);

            const responsePromise = HttpResponsePromise.fromFunction(mockFn, "arg1", "arg2");

            const result = await responsePromise;
            expect(result).toEqual(mockData);
            expect(mockFn).toHaveBeenCalledWith("arg1", "arg2");

            const resultWithRawResponse = await responsePromise.withRawResponse();
            expect(resultWithRawResponse).toEqual({
                data: mockData,
                rawResponse: mockRawResponse,
            });
        });
    });

    describe("fromPromise", () => {
        it("should create an HttpResponsePromise from a promise", async () => {
            const promise = Promise.resolve(mockWithRawResponse);

            const responsePromise = HttpResponsePromise.fromPromise(promise);

            const result = await responsePromise;
            expect(result).toEqual(mockData);

            const resultWithRawResponse = await responsePromise.withRawResponse();
            expect(resultWithRawResponse).toEqual({
                data: mockData,
                rawResponse: mockRawResponse,
            });
        });
    });

    describe("fromExecutor", () => {
        it("should create an HttpResponsePromise from an executor function", async () => {
            const responsePromise = HttpResponsePromise.fromExecutor((resolve) => {
                resolve(mockWithRawResponse);
            });

            const result = await responsePromise;
            expect(result).toEqual(mockData);

            const resultWithRawResponse = await responsePromise.withRawResponse();
            expect(resultWithRawResponse).toEqual({
                data: mockData,
                rawResponse: mockRawResponse,
            });
        });
    });

    describe("fromResult", () => {
        it("should create an HttpResponsePromise from a result", async () => {
            const responsePromise = HttpResponsePromise.fromResult(mockWithRawResponse);

            const result = await responsePromise;
            expect(result).toEqual(mockData);

            const resultWithRawResponse = await responsePromise.withRawResponse();
            expect(resultWithRawResponse).toEqual({
                data: mockData,
                rawResponse: mockRawResponse,
            });
        });
    });

    describe("Promise methods", () => {
        let responsePromise: HttpResponsePromise<typeof mockData>;

        beforeEach(() => {
            responsePromise = HttpResponsePromise.fromResult(mockWithRawResponse);
        });

        it("should support then() method", async () => {
            const result = await responsePromise.then((data) => ({
                ...data,
                modified: true,
            }));

            expect(result).toEqual({
                ...mockData,
                modified: true,
            });
        });

        it("should support catch() method", async () => {
            const errorResponsePromise = HttpResponsePromise.fromExecutor((_, reject) => {
                reject(new Error("Test error"));
            });

            const catchSpy = vi.fn();
            await errorResponsePromise.catch(catchSpy);

            expect(catchSpy).toHaveBeenCalled();
            const error = catchSpy.mock.calls[0]?.[0];
            expect(error).toBeInstanceOf(Error);
            expect((error as Error).message).toBe("Test error");
        });

        it("should support finally() method", async () => {
            const finallySpy = vi.fn();
            await responsePromise.finally(finallySpy);

            expect(finallySpy).toHaveBeenCalled();
        });
    });

    describe("withRawResponse", () => {
        it("should return both data and raw response", async () => {
            const responsePromise = HttpResponsePromise.fromResult(mockWithRawResponse);

            const result = await responsePromise.withRawResponse();

            expect(result).toEqual({
                data: mockData,
                rawResponse: mockRawResponse,
            });
        });
    });
});

```


## /tests/unit/fetcher/RawResponse.test.ts
```typescript
import { describe, expect, it } from "vitest";

import { toRawResponse } from "../../../src/core/fetcher/RawResponse";

describe("RawResponse", () => {
    describe("toRawResponse", () => {
        it("should convert Response to RawResponse by removing body, bodyUsed, and ok properties", () => {
            const mockHeaders = new Headers({ "content-type": "application/json" });
            const mockResponse = {
                body: "test body",
                bodyUsed: false,
                ok: true,
                headers: mockHeaders,
                redirected: false,
                status: 200,
                statusText: "OK",
                type: "basic" as ResponseType,
                url: "https://example.com",
            };

            const result = toRawResponse(mockResponse as unknown as Response);

            expect("body" in result).toBe(false);
            expect("bodyUsed" in result).toBe(false);
            expect("ok" in result).toBe(false);
            expect(result.headers).toBe(mockHeaders);
            expect(result.redirected).toBe(false);
            expect(result.status).toBe(200);
            expect(result.statusText).toBe("OK");
            expect(result.type).toBe("basic");
            expect(result.url).toBe("https://example.com");
        });
    });
});

```


## /tests/unit/fetcher/createRequestUrl.test.ts
```typescript
import { createRequestUrl } from "../../../src/core/fetcher/createRequestUrl";

describe("Test createRequestUrl", () => {
    const BASE_URL = "https://api.example.com";

    interface TestCase {
        description: string;
        baseUrl: string;
        queryParams?: Record<string, any>;
        expected: string;
    }

    const testCases: TestCase[] = [
        {
            description: "should return the base URL when no query parameters are provided",
            baseUrl: BASE_URL,
            expected: BASE_URL,
        },
        {
            description: "should append simple query parameters",
            baseUrl: BASE_URL,
            queryParams: { key: "value", another: "param" },
            expected: "https://api.example.com?key=value&another=param",
        },
        {
            description: "should handle array query parameters",
            baseUrl: BASE_URL,
            queryParams: { items: ["a", "b", "c"] },
            expected: "https://api.example.com?items=a&items=b&items=c",
        },
        {
            description: "should handle object query parameters",
            baseUrl: BASE_URL,
            queryParams: { filter: { name: "John", age: 30 } },
            expected: "https://api.example.com?filter%5Bname%5D=John&filter%5Bage%5D=30",
        },
        {
            description: "should handle mixed types of query parameters",
            baseUrl: BASE_URL,
            queryParams: {
                simple: "value",
                array: ["x", "y"],
                object: { key: "value" },
            },
            expected: "https://api.example.com?simple=value&array=x&array=y&object%5Bkey%5D=value",
        },
        {
            description: "should handle empty query parameters object",
            baseUrl: BASE_URL,
            queryParams: {},
            expected: BASE_URL,
        },
        {
            description: "should encode special characters in query parameters",
            baseUrl: BASE_URL,
            queryParams: { special: "a&b=c d" },
            expected: "https://api.example.com?special=a%26b%3Dc%20d",
        },
        {
            description: "should handle numeric values",
            baseUrl: BASE_URL,
            queryParams: { count: 42, price: 19.99, active: 1, inactive: 0 },
            expected: "https://api.example.com?count=42&price=19.99&active=1&inactive=0",
        },
        {
            description: "should handle boolean values",
            baseUrl: BASE_URL,
            queryParams: { enabled: true, disabled: false },
            expected: "https://api.example.com?enabled=true&disabled=false",
        },
        {
            description: "should handle null and undefined values",
            baseUrl: BASE_URL,
            queryParams: {
                valid: "value",
                nullValue: null,
                undefinedValue: undefined,
                emptyString: "",
            },
            expected: "https://api.example.com?valid=value&nullValue=&emptyString=",
        },
        {
            description: "should handle deeply nested objects",
            baseUrl: BASE_URL,
            queryParams: {
                user: {
                    profile: {
                        name: "John",
                        settings: { theme: "dark" },
                    },
                },
            },
            expected:
                "https://api.example.com?user%5Bprofile%5D%5Bname%5D=John&user%5Bprofile%5D%5Bsettings%5D%5Btheme%5D=dark",
        },
        {
            description: "should handle arrays of objects",
            baseUrl: BASE_URL,
            queryParams: {
                users: [
                    { name: "John", age: 30 },
                    { name: "Jane", age: 25 },
                ],
            },
            expected:
                "https://api.example.com?users%5Bname%5D=John&users%5Bage%5D=30&users%5Bname%5D=Jane&users%5Bage%5D=25",
        },
        {
            description: "should handle mixed arrays",
            baseUrl: BASE_URL,
            queryParams: {
                mixed: ["string", 42, true, { key: "value" }],
            },
            expected: "https://api.example.com?mixed=string&mixed=42&mixed=true&mixed%5Bkey%5D=value",
        },
        {
            description: "should handle empty arrays",
            baseUrl: BASE_URL,
            queryParams: { emptyArray: [] },
            expected: BASE_URL,
        },
        {
            description: "should handle empty objects",
            baseUrl: BASE_URL,
            queryParams: { emptyObject: {} },
            expected: BASE_URL,
        },
        {
            description: "should handle special characters in keys",
            baseUrl: BASE_URL,
            queryParams: { "key with spaces": "value", "key[with]brackets": "value" },
            expected: "https://api.example.com?key%20with%20spaces=value&key%5Bwith%5Dbrackets=value",
        },
        {
            description: "should handle URL with existing query parameters",
            baseUrl: "https://api.example.com?existing=param",
            queryParams: { new: "value" },
            expected: "https://api.example.com?existing=param?new=value",
        },
        {
            description: "should handle complex nested structures",
            baseUrl: BASE_URL,
            queryParams: {
                filters: {
                    status: ["active", "pending"],
                    category: {
                        type: "electronics",
                        subcategories: ["phones", "laptops"],
                    },
                },
                sort: { field: "name", direction: "asc" },
            },
            expected:
                "https://api.example.com?filters%5Bstatus%5D=active&filters%5Bstatus%5D=pending&filters%5Bcategory%5D%5Btype%5D=electronics&filters%5Bcategory%5D%5Bsubcategories%5D=phones&filters%5Bcategory%5D%5Bsubcategories%5D=laptops&sort%5Bfield%5D=name&sort%5Bdirection%5D=asc",
        },
    ];

    testCases.forEach(({ description, baseUrl, queryParams, expected }) => {
        it(description, () => {
            expect(createRequestUrl(baseUrl, queryParams)).toBe(expected);
        });
    });
});

```


## /tests/unit/fetcher/getRequestBody.test.ts
```typescript
import { getRequestBody } from "../../../src/core/fetcher/getRequestBody";
import { RUNTIME } from "../../../src/core/runtime";

describe("Test getRequestBody", () => {
    interface TestCase {
        description: string;
        input: any;
        type: "json" | "form" | "file" | "bytes" | "other";
        expected: any;
        skipCondition?: () => boolean;
    }

    const testCases: TestCase[] = [
        {
            description: "should stringify body if not FormData in Node environment",
            input: { key: "value" },
            type: "json",
            expected: '{"key":"value"}',
            skipCondition: () => RUNTIME.type !== "node",
        },
        {
            description: "should stringify body if not FormData in browser environment",
            input: { key: "value" },
            type: "json",
            expected: '{"key":"value"}',
            skipCondition: () => RUNTIME.type !== "browser",
        },
        {
            description: "should return the Uint8Array",
            input: new Uint8Array([1, 2, 3]),
            type: "bytes",
            expected: new Uint8Array([1, 2, 3]),
        },
        {
            description: "should serialize objects for form-urlencoded content type",
            input: { username: "johndoe", email: "john@example.com" },
            type: "form",
            expected: "username=johndoe&email=john%40example.com",
        },
        {
            description: "should serialize complex nested objects and arrays for form-urlencoded content type",
            input: {
                user: {
                    profile: {
                        name: "John Doe",
                        settings: {
                            theme: "dark",
                            notifications: true,
                        },
                    },
                    tags: ["admin", "user"],
                    contacts: [
                        { type: "email", value: "john@example.com" },
                        { type: "phone", value: "+1234567890" },
                    ],
                },
                filters: {
                    status: ["active", "pending"],
                    metadata: {
                        created: "2024-01-01",
                        categories: ["electronics", "books"],
                    },
                },
                preferences: ["notifications", "updates"],
            },
            type: "form",
            expected:
                "user%5Bprofile%5D%5Bname%5D=John%20Doe&" +
                "user%5Bprofile%5D%5Bsettings%5D%5Btheme%5D=dark&" +
                "user%5Bprofile%5D%5Bsettings%5D%5Bnotifications%5D=true&" +
                "user%5Btags%5D=admin&" +
                "user%5Btags%5D=user&" +
                "user%5Bcontacts%5D%5Btype%5D=email&" +
                "user%5Bcontacts%5D%5Bvalue%5D=john%40example.com&" +
                "user%5Bcontacts%5D%5Btype%5D=phone&" +
                "user%5Bcontacts%5D%5Bvalue%5D=%2B1234567890&" +
                "filters%5Bstatus%5D=active&" +
                "filters%5Bstatus%5D=pending&" +
                "filters%5Bmetadata%5D%5Bcreated%5D=2024-01-01&" +
                "filters%5Bmetadata%5D%5Bcategories%5D=electronics&" +
                "filters%5Bmetadata%5D%5Bcategories%5D=books&" +
                "preferences=notifications&" +
                "preferences=updates",
        },
        {
            description: "should return the input for pre-serialized form-urlencoded strings",
            input: "key=value&another=param",
            type: "other",
            expected: "key=value&another=param",
        },
        {
            description: "should JSON stringify objects",
            input: { key: "value" },
            type: "json",
            expected: '{"key":"value"}',
        },
    ];

    testCases.forEach(({ description, input, type, expected, skipCondition }) => {
        it(description, async () => {
            if (skipCondition?.()) {
                return;
            }

            const result = await getRequestBody({
                body: input,
                type,
            });

            if (input instanceof Uint8Array) {
                expect(result).toBe(input);
            } else {
                expect(result).toBe(expected);
            }
        });
    });

    it("should return FormData in browser environment", async () => {
        if (RUNTIME.type === "browser") {
            const formData = new FormData();
            formData.append("key", "value");
            const result = await getRequestBody({
                body: formData,
                type: "file",
            });
            expect(result).toBe(formData);
        }
    });
});

```


## /tests/unit/fetcher/getResponseBody.test.ts
```typescript
import { getResponseBody } from "../../../src/core/fetcher/getResponseBody";

import { RUNTIME } from "../../../src/core/runtime";

describe("Test getResponseBody", () => {
    interface SimpleTestCase {
        description: string;
        responseData: string | Record<string, any>;
        responseType?: "blob" | "sse" | "streaming" | "text";
        expected: any;
        skipCondition?: () => boolean;
    }

    const simpleTestCases: SimpleTestCase[] = [
        {
            description: "should handle text response type",
            responseData: "test text",
            responseType: "text",
            expected: "test text",
        },
        {
            description: "should handle JSON response",
            responseData: { key: "value" },
            expected: { key: "value" },
        },
        {
            description: "should handle empty response",
            responseData: "",
            expected: undefined,
        },
        {
            description: "should handle non-JSON response",
            responseData: "invalid json",
            expected: {
                ok: false,
                error: {
                    reason: "non-json",
                    statusCode: 200,
                    rawBody: "invalid json",
                },
            },
        },
    ];

    simpleTestCases.forEach(({ description, responseData, responseType, expected, skipCondition }) => {
        it(description, async () => {
            if (skipCondition?.()) {
                return;
            }

            const mockResponse = new Response(
                typeof responseData === "string" ? responseData : JSON.stringify(responseData),
            );
            const result = await getResponseBody(mockResponse, responseType);
            expect(result).toEqual(expected);
        });
    });

    it("should handle blob response type", async () => {
        const mockBlob = new Blob(["test"], { type: "text/plain" });
        const mockResponse = new Response(mockBlob);
        const result = await getResponseBody(mockResponse, "blob");
        // @ts-expect-error
        expect(result.constructor.name).toBe("Blob");
    });

    it("should handle sse response type", async () => {
        if (RUNTIME.type === "node") {
            const mockStream = new ReadableStream();
            const mockResponse = new Response(mockStream);
            const result = await getResponseBody(mockResponse, "sse");
            expect(result).toBe(mockStream);
        }
    });

    it("should handle streaming response type", async () => {
        const encoder = new TextEncoder();
        const testData = "test stream data";
        const mockStream = new ReadableStream({
            start(controller) {
                controller.enqueue(encoder.encode(testData));
                controller.close();
            },
        });

        const mockResponse = new Response(mockStream);
        const result = (await getResponseBody(mockResponse, "streaming")) as ReadableStream;

        expect(result).toBeInstanceOf(ReadableStream);

        const reader = result.getReader();
        const decoder = new TextDecoder();
        const { value } = await reader.read();
        const streamContent = decoder.decode(value);
        expect(streamContent).toBe(testData);
    });
});

```


## /tests/unit/fetcher/logging.test.ts
```typescript
import { fetcherImpl } from "../../../src/core/fetcher/Fetcher";

function createMockLogger() {
    return {
        debug: vi.fn(),
        info: vi.fn(),
        warn: vi.fn(),
        error: vi.fn(),
    };
}

function mockSuccessResponse(data: unknown = { data: "test" }, status = 200, statusText = "OK") {
    global.fetch = vi.fn().mockResolvedValue(
        new Response(JSON.stringify(data), {
            status,
            statusText,
        }),
    );
}

function mockErrorResponse(data: unknown = { error: "Error" }, status = 404, statusText = "Not Found") {
    global.fetch = vi.fn().mockResolvedValue(
        new Response(JSON.stringify(data), {
            status,
            statusText,
        }),
    );
}

describe("Fetcher Logging Integration", () => {
    describe("Request Logging", () => {
        it("should log successful request at debug level", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: { test: "data" },
                contentType: "application/json",
                requestType: "json",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    method: "POST",
                    url: "https://example.com/api",
                    headers: expect.toContainHeaders({
                        "Content-Type": "application/json",
                    }),
                    hasBody: true,
                }),
            );

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "HTTP request succeeded",
                expect.objectContaining({
                    method: "POST",
                    url: "https://example.com/api",
                    statusCode: 200,
                }),
            );
        });

        it("should not log debug messages at info level for successful requests", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "info",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).not.toHaveBeenCalled();
            expect(mockLogger.info).not.toHaveBeenCalled();
        });

        it("should log request with body flag", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "POST",
                body: { data: "test" },
                contentType: "application/json",
                requestType: "json",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    hasBody: true,
                }),
            );
        });

        it("should log request without body flag", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    hasBody: false,
                }),
            );
        });

        it("should not log when silent mode is enabled", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: true,
                },
            });

            expect(mockLogger.debug).not.toHaveBeenCalled();
            expect(mockLogger.info).not.toHaveBeenCalled();
            expect(mockLogger.warn).not.toHaveBeenCalled();
            expect(mockLogger.error).not.toHaveBeenCalled();
        });

        it("should not log when no logging config is provided", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
            });

            expect(mockLogger.debug).not.toHaveBeenCalled();
        });
    });

    describe("Error Logging", () => {
        it("should log 4xx errors at error level", async () => {
            const mockLogger = createMockLogger();
            mockErrorResponse({ error: "Not found" }, 404, "Not Found");

            const result = await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "error",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(result.ok).toBe(false);
            expect(mockLogger.error).toHaveBeenCalledWith(
                "HTTP request failed with error status",
                expect.objectContaining({
                    method: "GET",
                    url: "https://example.com/api",
                    statusCode: 404,
                }),
            );
        });

        it("should log 5xx errors at error level", async () => {
            const mockLogger = createMockLogger();
            mockErrorResponse({ error: "Internal error" }, 500, "Internal Server Error");

            const result = await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "error",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(result.ok).toBe(false);
            expect(mockLogger.error).toHaveBeenCalledWith(
                "HTTP request failed with error status",
                expect.objectContaining({
                    method: "GET",
                    url: "https://example.com/api",
                    statusCode: 500,
                }),
            );
        });

        it("should log aborted request errors", async () => {
            const mockLogger = createMockLogger();

            const abortController = new AbortController();
            abortController.abort();

            global.fetch = vi.fn().mockRejectedValue(new Error("Aborted"));

            const result = await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                abortSignal: abortController.signal,
                maxRetries: 0,
                logging: {
                    level: "error",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(result.ok).toBe(false);
            expect(mockLogger.error).toHaveBeenCalledWith(
                "HTTP request was aborted",
                expect.objectContaining({
                    method: "GET",
                    url: "https://example.com/api",
                }),
            );
        });

        it("should log timeout errors", async () => {
            const mockLogger = createMockLogger();

            const timeoutError = new Error("Request timeout");
            timeoutError.name = "AbortError";

            global.fetch = vi.fn().mockRejectedValue(timeoutError);

            const result = await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "error",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(result.ok).toBe(false);
            expect(mockLogger.error).toHaveBeenCalledWith(
                "HTTP request timed out",
                expect.objectContaining({
                    method: "GET",
                    url: "https://example.com/api",
                    timeoutMs: undefined,
                }),
            );
        });

        it("should log unknown errors", async () => {
            const mockLogger = createMockLogger();

            const unknownError = new Error("Unknown error");

            global.fetch = vi.fn().mockRejectedValue(unknownError);

            const result = await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "error",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(result.ok).toBe(false);
            expect(mockLogger.error).toHaveBeenCalledWith(
                "HTTP request failed with error",
                expect.objectContaining({
                    method: "GET",
                    url: "https://example.com/api",
                    errorMessage: "Unknown error",
                }),
            );
        });
    });

    describe("Logging with Redaction", () => {
        it("should redact sensitive data in error logs", async () => {
            const mockLogger = createMockLogger();
            mockErrorResponse({ error: "Unauthorized" }, 401, "Unauthorized");

            await fetcherImpl({
                url: "https://example.com/api?api_key=secret",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "error",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.error).toHaveBeenCalledWith(
                "HTTP request failed with error status",
                expect.objectContaining({
                    url: "https://example.com/api?api_key=[REDACTED]",
                }),
            );
        });
    });

    describe("Different HTTP Methods", () => {
        it("should log GET requests", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    method: "GET",
                }),
            );
        });

        it("should log POST requests", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse({ data: "test" }, 201, "Created");

            await fetcherImpl({
                url: "https://example.com/api",
                method: "POST",
                body: { data: "test" },
                contentType: "application/json",
                requestType: "json",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    method: "POST",
                }),
            );
        });

        it("should log PUT requests", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "PUT",
                body: { data: "test" },
                contentType: "application/json",
                requestType: "json",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    method: "PUT",
                }),
            );
        });

        it("should log DELETE requests", async () => {
            const mockLogger = createMockLogger();
            global.fetch = vi.fn().mockResolvedValue(
                new Response(null, {
                    status: 200,
                    statusText: "OK",
                }),
            );

            await fetcherImpl({
                url: "https://example.com/api",
                method: "DELETE",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    method: "DELETE",
                }),
            );
        });
    });

    describe("Status Code Logging", () => {
        it("should log 2xx success status codes", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse({ data: "test" }, 201, "Created");

            await fetcherImpl({
                url: "https://example.com/api",
                method: "POST",
                body: { data: "test" },
                contentType: "application/json",
                requestType: "json",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "HTTP request succeeded",
                expect.objectContaining({
                    statusCode: 201,
                }),
            );
        });

        it("should log 3xx redirect status codes as success", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse({ data: "test" }, 301, "Moved Permanently");

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "HTTP request succeeded",
                expect.objectContaining({
                    statusCode: 301,
                }),
            );
        });
    });
});

```


## /tests/unit/fetcher/makeRequest.test.ts
```typescript
import type { Mock } from "vitest";
import { makeRequest } from "../../../src/core/fetcher/makeRequest";

describe("Test makeRequest", () => {
    const mockPostUrl = "https://httpbin.org/post";
    const mockGetUrl = "https://httpbin.org/get";
    const mockHeaders = { "Content-Type": "application/json" };
    const mockBody = JSON.stringify({ key: "value" });

    let mockFetch: Mock;

    beforeEach(() => {
        mockFetch = vi.fn();
        mockFetch.mockResolvedValue(new Response(JSON.stringify({ test: "successful" }), { status: 200 }));
    });

    it("should handle POST request correctly", async () => {
        const response = await makeRequest(mockFetch, mockPostUrl, "POST", mockHeaders, mockBody);
        const responseBody = await response.json();
        expect(responseBody).toEqual({ test: "successful" });
        expect(mockFetch).toHaveBeenCalledTimes(1);
        const [calledUrl, calledOptions] = mockFetch.mock.calls[0];
        expect(calledUrl).toBe(mockPostUrl);
        expect(calledOptions).toEqual(
            expect.objectContaining({
                method: "POST",
                headers: mockHeaders,
                body: mockBody,
                credentials: undefined,
            }),
        );
        expect(calledOptions.signal).toBeDefined();
        expect(calledOptions.signal).toBeInstanceOf(AbortSignal);
    });

    it("should handle GET request correctly", async () => {
        const response = await makeRequest(mockFetch, mockGetUrl, "GET", mockHeaders, undefined);
        const responseBody = await response.json();
        expect(responseBody).toEqual({ test: "successful" });
        expect(mockFetch).toHaveBeenCalledTimes(1);
        const [calledUrl, calledOptions] = mockFetch.mock.calls[0];
        expect(calledUrl).toBe(mockGetUrl);
        expect(calledOptions).toEqual(
            expect.objectContaining({
                method: "GET",
                headers: mockHeaders,
                body: undefined,
                credentials: undefined,
            }),
        );
        expect(calledOptions.signal).toBeDefined();
        expect(calledOptions.signal).toBeInstanceOf(AbortSignal);
    });
});

```


## /tests/unit/fetcher/redacting.test.ts
```typescript
import { fetcherImpl } from "../../../src/core/fetcher/Fetcher";

function createMockLogger() {
    return {
        debug: vi.fn(),
        info: vi.fn(),
        warn: vi.fn(),
        error: vi.fn(),
    };
}

function mockSuccessResponse(data: unknown = { data: "test" }, status = 200, statusText = "OK") {
    global.fetch = vi.fn().mockResolvedValue(
        new Response(JSON.stringify(data), {
            status,
            statusText,
        }),
    );
}

describe("Redacting Logic", () => {
    describe("Header Redaction", () => {
        it("should redact authorization header", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                headers: { Authorization: "Bearer secret-token-12345" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    headers: expect.toContainHeaders({
                        Authorization: "[REDACTED]",
                    }),
                }),
            );
        });

        it("should redact api-key header (case-insensitive)", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                headers: { "X-API-KEY": "secret-api-key" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    headers: expect.toContainHeaders({
                        "X-API-KEY": "[REDACTED]",
                    }),
                }),
            );
        });

        it("should redact cookie header", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                headers: { Cookie: "session=abc123; token=xyz789" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    headers: expect.toContainHeaders({
                        Cookie: "[REDACTED]",
                    }),
                }),
            );
        });

        it("should redact x-auth-token header", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                headers: { "x-auth-token": "auth-token-12345" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    headers: expect.toContainHeaders({
                        "x-auth-token": "[REDACTED]",
                    }),
                }),
            );
        });

        it("should redact proxy-authorization header", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                headers: { "Proxy-Authorization": "Basic credentials" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    headers: expect.toContainHeaders({
                        "Proxy-Authorization": "[REDACTED]",
                    }),
                }),
            );
        });

        it("should redact x-csrf-token header", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                headers: { "X-CSRF-Token": "csrf-token-abc" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    headers: expect.toContainHeaders({
                        "X-CSRF-Token": "[REDACTED]",
                    }),
                }),
            );
        });

        it("should redact www-authenticate header", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                headers: { "WWW-Authenticate": "Bearer realm=example" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    headers: expect.toContainHeaders({
                        "WWW-Authenticate": "[REDACTED]",
                    }),
                }),
            );
        });

        it("should redact x-session-token header", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                headers: { "X-Session-Token": "session-token-xyz" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    headers: expect.toContainHeaders({
                        "X-Session-Token": "[REDACTED]",
                    }),
                }),
            );
        });

        it("should not redact non-sensitive headers", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "User-Agent": "Test/1.0",
                    Accept: "application/json",
                },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    headers: expect.toContainHeaders({
                        "Content-Type": "application/json",
                        "User-Agent": "Test/1.0",
                        Accept: "application/json",
                    }),
                }),
            );
        });

        it("should redact multiple sensitive headers at once", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                headers: {
                    Authorization: "Bearer token",
                    "X-API-Key": "api-key",
                    Cookie: "session=123",
                    "Content-Type": "application/json",
                },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    headers: expect.toContainHeaders({
                        Authorization: "[REDACTED]",
                        "X-API-Key": "[REDACTED]",
                        Cookie: "[REDACTED]",
                        "Content-Type": "application/json",
                    }),
                }),
            );
        });
    });

    describe("Response Header Redaction", () => {
        it("should redact Set-Cookie in response headers", async () => {
            const mockLogger = createMockLogger();

            const mockHeaders = new Headers();
            mockHeaders.set("Set-Cookie", "session=abc123; HttpOnly; Secure");
            mockHeaders.set("Content-Type", "application/json");

            global.fetch = vi.fn().mockResolvedValue(
                new Response(JSON.stringify({ data: "test" }), {
                    status: 200,
                    statusText: "OK",
                    headers: mockHeaders,
                }),
            );

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "HTTP request succeeded",
                expect.objectContaining({
                    responseHeaders: expect.toContainHeaders({
                        "set-cookie": "[REDACTED]",
                        "content-type": "application/json",
                    }),
                }),
            );
        });

        it("should redact authorization in response headers", async () => {
            const mockLogger = createMockLogger();

            const mockHeaders = new Headers();
            mockHeaders.set("Authorization", "Bearer token-123");
            mockHeaders.set("Content-Type", "application/json");

            global.fetch = vi.fn().mockResolvedValue(
                new Response(JSON.stringify({ data: "test" }), {
                    status: 200,
                    statusText: "OK",
                    headers: mockHeaders,
                }),
            );

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "HTTP request succeeded",
                expect.objectContaining({
                    responseHeaders: expect.toContainHeaders({
                        authorization: "[REDACTED]",
                        "content-type": "application/json",
                    }),
                }),
            );
        });

        it("should redact response headers in error responses", async () => {
            const mockLogger = createMockLogger();

            const mockHeaders = new Headers();
            mockHeaders.set("WWW-Authenticate", "Bearer realm=example");
            mockHeaders.set("Content-Type", "application/json");

            global.fetch = vi.fn().mockResolvedValue(
                new Response(JSON.stringify({ error: "Unauthorized" }), {
                    status: 401,
                    statusText: "Unauthorized",
                    headers: mockHeaders,
                }),
            );

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "error",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.error).toHaveBeenCalledWith(
                "HTTP request failed with error status",
                expect.objectContaining({
                    responseHeaders: expect.toContainHeaders({
                        "www-authenticate": "[REDACTED]",
                        "content-type": "application/json",
                    }),
                }),
            );
        });
    });

    describe("Query Parameter Redaction", () => {
        it("should redact api_key query parameter", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                queryParameters: { api_key: "secret-key" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    queryParameters: expect.objectContaining({
                        api_key: "[REDACTED]",
                    }),
                }),
            );
        });

        it("should redact token query parameter", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                queryParameters: { token: "secret-token" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    queryParameters: expect.objectContaining({
                        token: "[REDACTED]",
                    }),
                }),
            );
        });

        it("should redact access_token query parameter", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                queryParameters: { access_token: "secret-access-token" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    queryParameters: expect.objectContaining({
                        access_token: "[REDACTED]",
                    }),
                }),
            );
        });

        it("should redact password query parameter", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                queryParameters: { password: "secret-password" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    queryParameters: expect.objectContaining({
                        password: "[REDACTED]",
                    }),
                }),
            );
        });

        it("should redact secret query parameter", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                queryParameters: { secret: "secret-value" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    queryParameters: expect.objectContaining({
                        secret: "[REDACTED]",
                    }),
                }),
            );
        });

        it("should redact session_id query parameter", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                queryParameters: { session_id: "session-123" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    queryParameters: expect.objectContaining({
                        session_id: "[REDACTED]",
                    }),
                }),
            );
        });

        it("should not redact non-sensitive query parameters", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                queryParameters: {
                    page: "1",
                    limit: "10",
                    sort: "name",
                },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    queryParameters: expect.objectContaining({
                        page: "1",
                        limit: "10",
                        sort: "name",
                    }),
                }),
            );
        });

        it("should not redact parameters containing 'auth' substring like 'author'", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                queryParameters: {
                    author: "john",
                    authenticate: "false",
                    authorization_level: "user",
                },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    queryParameters: expect.objectContaining({
                        author: "john",
                        authenticate: "false",
                        authorization_level: "user",
                    }),
                }),
            );
        });

        it("should handle undefined query parameters", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    queryParameters: undefined,
                }),
            );
        });

        it("should redact case-insensitive query parameters", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                queryParameters: { API_KEY: "secret-key", Token: "secret-token" },
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    queryParameters: expect.objectContaining({
                        API_KEY: "[REDACTED]",
                        Token: "[REDACTED]",
                    }),
                }),
            );
        });
    });

    describe("URL Redaction", () => {
        it("should redact credentials in URL", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://user:password@example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://[REDACTED]@example.com/api",
                }),
            );
        });

        it("should redact api_key in query string", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api?api_key=secret-key&page=1",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api?api_key=[REDACTED]&page=1",
                }),
            );
        });

        it("should redact token in query string", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api?token=secret-token",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api?token=[REDACTED]",
                }),
            );
        });

        it("should redact password in query string", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api?username=user&password=secret",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api?username=user&password=[REDACTED]",
                }),
            );
        });

        it("should not redact non-sensitive query strings", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api?page=1&limit=10&sort=name",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api?page=1&limit=10&sort=name",
                }),
            );
        });

        it("should not redact URL parameters containing 'auth' substring like 'author'", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api?author=john&authenticate=false&page=1",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api?author=john&authenticate=false&page=1",
                }),
            );
        });

        it("should handle URL with fragment", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api?token=secret#section",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api?token=[REDACTED]#section",
                }),
            );
        });

        it("should redact URL-encoded query parameters", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api?api%5Fkey=secret",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api?api%5Fkey=[REDACTED]",
                }),
            );
        });

        it("should handle URL without query string", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api",
                }),
            );
        });

        it("should handle empty query string", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api?",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api?",
                }),
            );
        });

        it("should redact multiple sensitive parameters in URL", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api?api_key=secret1&token=secret2&page=1",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api?api_key=[REDACTED]&token=[REDACTED]&page=1",
                }),
            );
        });

        it("should redact both credentials and query parameters", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://user:pass@example.com/api?token=secret",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://[REDACTED]@example.com/api?token=[REDACTED]",
                }),
            );
        });

        it("should use fast path for URLs without sensitive keywords", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api?page=1&limit=10&sort=name&filter=value",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api?page=1&limit=10&sort=name&filter=value",
                }),
            );
        });

        it("should handle query parameter without value", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api?flag&token=secret",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api?flag&token=[REDACTED]",
                }),
            );
        });

        it("should handle URL with multiple @ symbols in credentials", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://user@example.com:pass@host.com/api",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://[REDACTED]@host.com/api",
                }),
            );
        });

        it("should handle URL with @ in query parameter but not in credentials", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://example.com/api?email=user@example.com",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://example.com/api?email=user@example.com",
                }),
            );
        });

        it("should handle URL with both credentials and @ in path", async () => {
            const mockLogger = createMockLogger();
            mockSuccessResponse();

            await fetcherImpl({
                url: "https://user:pass@example.com/users/@username",
                method: "GET",
                responseType: "json",
                maxRetries: 0,
                logging: {
                    level: "debug",
                    logger: mockLogger,
                    silent: false,
                },
            });

            expect(mockLogger.debug).toHaveBeenCalledWith(
                "Making HTTP request",
                expect.objectContaining({
                    url: "https://[REDACTED]@example.com/users/@username",
                }),
            );
        });
    });
});

```


## /tests/unit/fetcher/requestWithRetries.test.ts
```typescript
import type { Mock, MockInstance } from "vitest";
import { requestWithRetries } from "../../../src/core/fetcher/requestWithRetries";

describe("requestWithRetries", () => {
    let mockFetch: Mock;
    let originalMathRandom: typeof Math.random;
    let setTimeoutSpy: MockInstance;

    beforeEach(() => {
        mockFetch = vi.fn();
        originalMathRandom = Math.random;

        Math.random = vi.fn(() => 0.5);

        vi.useFakeTimers({
            toFake: [
                "setTimeout",
                "clearTimeout",
                "setInterval",
                "clearInterval",
                "setImmediate",
                "clearImmediate",
                "Date",
                "performance",
                "requestAnimationFrame",
                "cancelAnimationFrame",
                "requestIdleCallback",
                "cancelIdleCallback",
            ],
        });
    });

    afterEach(() => {
        Math.random = originalMathRandom;
        vi.clearAllMocks();
        vi.clearAllTimers();
    });

    it("should retry on retryable status codes", async () => {
        setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
            process.nextTick(callback);
            return null as any;
        });

        const retryableStatuses = [408, 429, 500, 502];
        let callCount = 0;

        mockFetch.mockImplementation(async () => {
            if (callCount < retryableStatuses.length) {
                return new Response("", { status: retryableStatuses[callCount++] });
            }
            return new Response("", { status: 200 });
        });

        const responsePromise = requestWithRetries(() => mockFetch(), retryableStatuses.length);
        await vi.runAllTimersAsync();
        const response = await responsePromise;

        expect(mockFetch).toHaveBeenCalledTimes(retryableStatuses.length + 1);
        expect(response.status).toBe(200);
    });

    it("should respect maxRetries limit", async () => {
        setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
            process.nextTick(callback);
            return null as any;
        });

        const maxRetries = 2;
        mockFetch.mockResolvedValue(new Response("", { status: 500 }));

        const responsePromise = requestWithRetries(() => mockFetch(), maxRetries);
        await vi.runAllTimersAsync();
        const response = await responsePromise;

        expect(mockFetch).toHaveBeenCalledTimes(maxRetries + 1);
        expect(response.status).toBe(500);
    });

    it("should not retry on success status codes", async () => {
        setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
            process.nextTick(callback);
            return null as any;
        });

        const successStatuses = [200, 201, 202];

        for (const status of successStatuses) {
            mockFetch.mockReset();
            setTimeoutSpy.mockClear();
            mockFetch.mockResolvedValueOnce(new Response("", { status }));

            const responsePromise = requestWithRetries(() => mockFetch(), 3);
            await vi.runAllTimersAsync();
            await responsePromise;

            expect(mockFetch).toHaveBeenCalledTimes(1);
            expect(setTimeoutSpy).not.toHaveBeenCalled();
        }
    });

    interface RetryHeaderTestCase {
        description: string;
        headerName: string;
        headerValue: string | (() => string);
        expectedDelayMin: number;
        expectedDelayMax: number;
    }

    const retryHeaderTests: RetryHeaderTestCase[] = [
        {
            description: "should respect retry-after header with seconds value",
            headerName: "retry-after",
            headerValue: "5",
            expectedDelayMin: 4000,
            expectedDelayMax: 6000,
        },
        {
            description: "should respect retry-after header with HTTP date value",
            headerName: "retry-after",
            headerValue: () => new Date(Date.now() + 3000).toUTCString(),
            expectedDelayMin: 2000,
            expectedDelayMax: 4000,
        },
        {
            description: "should respect x-ratelimit-reset header",
            headerName: "x-ratelimit-reset",
            headerValue: () => Math.floor((Date.now() + 4000) / 1000).toString(),
            expectedDelayMin: 3000,
            expectedDelayMax: 6000,
        },
    ];

    retryHeaderTests.forEach(({ description, headerName, headerValue, expectedDelayMin, expectedDelayMax }) => {
        it(description, async () => {
            setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
                process.nextTick(callback);
                return null as any;
            });

            const value = typeof headerValue === "function" ? headerValue() : headerValue;
            mockFetch
                .mockResolvedValueOnce(
                    new Response("", {
                        status: 429,
                        headers: new Headers({ [headerName]: value }),
                    }),
                )
                .mockResolvedValueOnce(new Response("", { status: 200 }));

            const responsePromise = requestWithRetries(() => mockFetch(), 1);
            await vi.runAllTimersAsync();
            const response = await responsePromise;

            expect(setTimeoutSpy).toHaveBeenCalledWith(expect.any(Function), expect.any(Number));
            const actualDelay = setTimeoutSpy.mock.calls[0][1];
            expect(actualDelay).toBeGreaterThan(expectedDelayMin);
            expect(actualDelay).toBeLessThan(expectedDelayMax);
            expect(response.status).toBe(200);
        });
    });

    it("should apply correct exponential backoff with jitter", async () => {
        setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
            process.nextTick(callback);
            return null as any;
        });

        mockFetch.mockResolvedValue(new Response("", { status: 500 }));
        const maxRetries = 3;
        const expectedDelays = [1000, 2000, 4000];

        const responsePromise = requestWithRetries(() => mockFetch(), maxRetries);
        await vi.runAllTimersAsync();
        await responsePromise;

        expect(setTimeoutSpy).toHaveBeenCalledTimes(expectedDelays.length);

        expectedDelays.forEach((delay, index) => {
            expect(setTimeoutSpy).toHaveBeenNthCalledWith(index + 1, expect.any(Function), delay);
        });

        expect(mockFetch).toHaveBeenCalledTimes(maxRetries + 1);
    });

    it("should handle concurrent retries independently", async () => {
        setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
            process.nextTick(callback);
            return null as any;
        });

        mockFetch
            .mockResolvedValueOnce(new Response("", { status: 500 }))
            .mockResolvedValueOnce(new Response("", { status: 500 }))
            .mockResolvedValueOnce(new Response("", { status: 200 }))
            .mockResolvedValueOnce(new Response("", { status: 200 }));

        const promise1 = requestWithRetries(() => mockFetch(), 1);
        const promise2 = requestWithRetries(() => mockFetch(), 1);

        await vi.runAllTimersAsync();
        const [response1, response2] = await Promise.all([promise1, promise2]);

        expect(response1.status).toBe(200);
        expect(response2.status).toBe(200);
    });

    it("should cap delay at MAX_RETRY_DELAY for large header values", async () => {
        setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
            process.nextTick(callback);
            return null as any;
        });

        mockFetch
            .mockResolvedValueOnce(
                new Response("", {
                    status: 429,
                    headers: new Headers({ "retry-after": "120" }), // 120 seconds = 120000ms > MAX_RETRY_DELAY (60000ms)
                }),
            )
            .mockResolvedValueOnce(new Response("", { status: 200 }));

        const responsePromise = requestWithRetries(() => mockFetch(), 1);
        await vi.runAllTimersAsync();
        const response = await responsePromise;

        expect(setTimeoutSpy).toHaveBeenCalledWith(expect.any(Function), 60000);
        expect(response.status).toBe(200);
    });
});

```


## /tests/unit/fetcher/signals.test.ts
```typescript
import { anySignal, getTimeoutSignal } from "../../../src/core/fetcher/signals";

describe("Test getTimeoutSignal", () => {
    beforeEach(() => {
        vi.useFakeTimers();
    });

    afterEach(() => {
        vi.useRealTimers();
    });

    it("should return an object with signal and abortId", () => {
        const { signal, abortId } = getTimeoutSignal(1000);

        expect(signal).toBeDefined();
        expect(abortId).toBeDefined();
        expect(signal).toBeInstanceOf(AbortSignal);
        expect(signal.aborted).toBe(false);
    });

    it("should create a signal that aborts after the specified timeout", () => {
        const timeoutMs = 5000;
        const { signal } = getTimeoutSignal(timeoutMs);

        expect(signal.aborted).toBe(false);

        vi.advanceTimersByTime(timeoutMs - 1);
        expect(signal.aborted).toBe(false);

        vi.advanceTimersByTime(1);
        expect(signal.aborted).toBe(true);
    });
});

describe("Test anySignal", () => {
    it("should return an AbortSignal", () => {
        const signal = anySignal(new AbortController().signal);
        expect(signal).toBeInstanceOf(AbortSignal);
    });

    it("should abort when any of the input signals is aborted", () => {
        const controller1 = new AbortController();
        const controller2 = new AbortController();
        const signal = anySignal(controller1.signal, controller2.signal);

        expect(signal.aborted).toBe(false);
        controller1.abort();
        expect(signal.aborted).toBe(true);
    });

    it("should handle an array of signals", () => {
        const controller1 = new AbortController();
        const controller2 = new AbortController();
        const signal = anySignal([controller1.signal, controller2.signal]);

        expect(signal.aborted).toBe(false);
        controller2.abort();
        expect(signal.aborted).toBe(true);
    });

    it("should abort immediately if one of the input signals is already aborted", () => {
        const controller1 = new AbortController();
        const controller2 = new AbortController();
        controller1.abort();

        const signal = anySignal(controller1.signal, controller2.signal);
        expect(signal.aborted).toBe(true);
    });
});

```


## /tests/unit/fetcher/test-file.txt
```txt
This is a test file!

```


## /tests/unit/file/file.test.ts
```typescript
import fs from "fs";
import { join } from "path";
import { Readable } from "stream";
import { toBinaryUploadRequest, Uploadable } from "../../../src/core/file/index";

let File = global.File;
if (typeof File === "undefined") {
    File = require("buffer").File;
}

describe("toBinaryUploadRequest", () => {
    const TEST_FILE_PATH = join(__dirname, "test-file.txt");

    beforeEach(() => {
        vi.clearAllMocks();
    });

    describe("Buffer input", () => {
        it("should handle Buffer with all metadata", async () => {
            const buffer = Buffer.from("test data");
            const input: Uploadable.WithMetadata = {
                data: buffer,
                filename: "test.txt",
                contentType: "text/plain",
                contentLength: 42,
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(buffer);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="test.txt"',
                "Content-Type": "text/plain",
                "Content-Length": "42",
            });
        });

        it("should handle Buffer without metadata", async () => {
            const buffer = Buffer.from("test data");
            const input: Uploadable.WithMetadata = {
                data: buffer,
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(buffer);
            expect(result.headers).toEqual({
                "Content-Length": "9", // buffer.length
            });
        });

        it("should handle Buffer passed directly", async () => {
            const buffer = Buffer.from("test data");

            const result = await toBinaryUploadRequest(buffer);

            expect(result.body).toBe(buffer);
            expect(result.headers).toEqual({
                "Content-Length": "9", // buffer.length
            });
        });
    });

    describe("ArrayBuffer input", () => {
        it("should handle ArrayBuffer with metadata", async () => {
            const arrayBuffer = new ArrayBuffer(10);
            const input: Uploadable.WithMetadata = {
                data: arrayBuffer,
                filename: "data.bin",
                contentType: "application/octet-stream",
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(arrayBuffer);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="data.bin"',
                "Content-Type": "application/octet-stream",
                "Content-Length": "10", // arrayBuffer.byteLength
            });
        });

        it("should handle ArrayBuffer passed directly", async () => {
            const arrayBuffer = new ArrayBuffer(10);

            const result = await toBinaryUploadRequest(arrayBuffer);

            expect(result.body).toBe(arrayBuffer);
            expect(result.headers).toEqual({
                "Content-Length": "10", // arrayBuffer.byteLength
            });
        });
    });

    describe("Uint8Array input", () => {
        it("should handle Uint8Array with metadata", async () => {
            const uint8Array = new Uint8Array([1, 2, 3, 4, 5]);
            const input: Uploadable.WithMetadata = {
                data: uint8Array,
                filename: "bytes.bin",
                contentType: "application/octet-stream",
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(uint8Array);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="bytes.bin"',
                "Content-Type": "application/octet-stream",
                "Content-Length": "5", // uint8Array.byteLength
            });
        });

        it("should handle Uint8Array passed directly", async () => {
            const uint8Array = new Uint8Array([1, 2, 3, 4, 5]);

            const result = await toBinaryUploadRequest(uint8Array);

            expect(result.body).toBe(uint8Array);
            expect(result.headers).toEqual({
                "Content-Length": "5", // uint8Array.byteLength
            });
        });
    });

    describe("Blob input", () => {
        it("should handle Blob with metadata", async () => {
            const blob = new Blob(["test content"], { type: "text/plain" });
            const input: Uploadable.WithMetadata = {
                data: blob,
                filename: "override.txt",
                contentType: "text/html", // Override blob's type
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(blob);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="override.txt"',
                "Content-Type": "text/html", // Should use provided contentType
                "Content-Length": "12", // blob.size
            });
        });

        it("should handle Blob with intrinsic type", async () => {
            const blob = new Blob(["test content"], { type: "application/json" });
            const input: Uploadable.WithMetadata = {
                data: blob,
                filename: "data.json",
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(blob);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="data.json"',
                "Content-Type": "application/json", // Should use blob's type
                "Content-Length": "12", // blob.size
            });
        });

        it("should handle Blob passed directly", async () => {
            const blob = new Blob(["test content"], { type: "text/plain" });

            const result = await toBinaryUploadRequest(blob);

            expect(result.body).toBe(blob);
            expect(result.headers).toEqual({
                "Content-Type": "text/plain", // Should use blob's type
                "Content-Length": "12", // blob.size
            });
        });
    });

    describe("File input", () => {
        it("should handle File with metadata", async () => {
            const file = new File(["file content"], "original.txt", { type: "text/plain" });
            const input: Uploadable.WithMetadata = {
                data: file,
                filename: "renamed.txt",
                contentType: "text/html", // Override file's type
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(file);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="renamed.txt"',
                "Content-Type": "text/html", // Should use provided contentType
                "Content-Length": "12", // file.size
            });
        });

        it("should handle File with intrinsic properties", async () => {
            const file = new File(["file content"], "test.json", { type: "application/json" });
            const input: Uploadable.WithMetadata = {
                data: file,
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(file);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="test.json"', // Should use file's name
                "Content-Type": "application/json", // Should use file's type
                "Content-Length": "12", // file.size
            });
        });

        it("should handle File passed directly", async () => {
            const file = new File(["file content"], "direct.txt", { type: "text/plain" });

            const result = await toBinaryUploadRequest(file);

            expect(result.body).toBe(file);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="direct.txt"',
                "Content-Type": "text/plain",
                "Content-Length": "12", // file.size
            });
        });
    });

    describe("ReadableStream input", () => {
        it("should handle ReadableStream with metadata", async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(new TextEncoder().encode("stream data"));
                    controller.close();
                },
            });
            const input: Uploadable.WithMetadata = {
                data: stream,
                filename: "stream.txt",
                contentType: "text/plain",
                contentLength: 100,
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(stream);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="stream.txt"',
                "Content-Type": "text/plain",
                "Content-Length": "100", // Should use provided contentLength
            });
        });

        it("should handle ReadableStream without size", async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(new TextEncoder().encode("stream data"));
                    controller.close();
                },
            });
            const input: Uploadable.WithMetadata = {
                data: stream,
                filename: "stream.txt",
                contentType: "text/plain",
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(stream);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="stream.txt"',
                "Content-Type": "text/plain",
                // No Content-Length header since it cannot be determined from ReadableStream
            });
        });

        it("should handle ReadableStream passed directly", async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(new TextEncoder().encode("stream data"));
                    controller.close();
                },
            });

            const result = await toBinaryUploadRequest(stream);

            expect(result.body).toBe(stream);
            expect(result.headers).toEqual({
                // No headers since no metadata provided and cannot be determined
            });
        });
    });

    describe("Node.js Readable stream input", () => {
        it("should handle Readable stream with metadata", async () => {
            const readable = new Readable({
                read() {
                    this.push("readable data");
                    this.push(null);
                },
            });
            const input: Uploadable.WithMetadata = {
                data: readable,
                filename: "readable.txt",
                contentType: "text/plain",
                contentLength: 50,
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(readable);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="readable.txt"',
                "Content-Type": "text/plain",
                "Content-Length": "50", // Should use provided contentLength
            });
        });

        it("should handle Readable stream without size", async () => {
            const readable = new Readable({
                read() {
                    this.push("readable data");
                    this.push(null);
                },
            });
            const input: Uploadable.WithMetadata = {
                data: readable,
                filename: "readable.txt",
                contentType: "text/plain",
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(readable);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="readable.txt"',
                "Content-Type": "text/plain",
                // No Content-Length header since it cannot be determined from Readable
            });
        });

        it("should handle Readable stream passed directly", async () => {
            const readable = new Readable({
                read() {
                    this.push("readable data");
                    this.push(null);
                },
            });

            const result = await toBinaryUploadRequest(readable);

            expect(result.body).toBe(readable);
            expect(result.headers).toEqual({
                // No headers since no metadata provided and cannot be determined
            });
        });
    });

    describe("File path input (FromPath type)", () => {
        it("should handle file path with all metadata", async () => {
            const input: Uploadable.FromPath = {
                path: TEST_FILE_PATH,
                filename: "custom.txt",
                contentType: "text/html",
                contentLength: 42,
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBeInstanceOf(fs.ReadStream);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="custom.txt"',
                "Content-Type": "text/html",
                "Content-Length": "42", // Should use provided contentLength
            });
        });

        it("should handle file path with minimal metadata", async () => {
            const input: Uploadable.FromPath = {
                path: TEST_FILE_PATH,
                contentType: "text/plain",
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBeInstanceOf(fs.ReadStream);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="test-file.txt"', // Should extract from path
                "Content-Type": "text/plain",
                "Content-Length": "21", // Should determine from file system (test file is 21 bytes)
            });
        });

        it("should handle file path with no metadata", async () => {
            const input: Uploadable.FromPath = {
                path: TEST_FILE_PATH,
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBeInstanceOf(fs.ReadStream);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="test-file.txt"', // Should extract from path
                "Content-Length": "21", // Should determine from file system (test file is 21 bytes)
            });
        });

        it("should handle Windows-style paths", async () => {
            const input: Uploadable.FromPath = {
                path: "C:\\Users\\test\\file.txt",
            };

            // Mock fs methods to avoid actual file system access
            const mockStats = { size: 123 };
            const mockReadStream = {} as fs.ReadStream;

            // Mock the dynamic import of fs
            vi.doMock("fs", () => ({
                createReadStream: vi.fn().mockReturnValue(mockReadStream),
                promises: {
                    stat: vi.fn().mockResolvedValue(mockStats),
                },
            }));

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(mockReadStream);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="file.txt"', // Should extract from Windows path
                "Content-Length": "123",
            });

            // Clear the mock
            vi.doUnmock("fs");
        });

        it("should handle file path when fs is not available", async () => {
            const input: Uploadable.FromPath = {
                path: TEST_FILE_PATH,
            };

            // Mock import to simulate environment without fs
            vi.doMock("fs", () => ({
                createReadStream: undefined,
            }));

            await expect(toBinaryUploadRequest(input)).rejects.toThrow(
                "File path uploads are not supported in this environment.",
            );

            // Clear the mock
            vi.doUnmock("fs");
        });
    });

    describe("ArrayBufferView input", () => {
        it("should handle ArrayBufferView with metadata", async () => {
            const arrayBuffer = new ArrayBuffer(10);
            const arrayBufferView = new Int8Array(arrayBuffer);
            const input: Uploadable.WithMetadata = {
                data: arrayBufferView,
                filename: "view.bin",
                contentType: "application/octet-stream",
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(arrayBufferView);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="view.bin"',
                "Content-Type": "application/octet-stream",
                "Content-Length": "10", // arrayBufferView.byteLength
            });
        });

        it("should handle ArrayBufferView passed directly", async () => {
            const arrayBuffer = new ArrayBuffer(10);
            const arrayBufferView = new Int8Array(arrayBuffer);

            const result = await toBinaryUploadRequest(arrayBufferView);

            expect(result.body).toBe(arrayBufferView);
            expect(result.headers).toEqual({
                "Content-Length": "10", // arrayBufferView.byteLength
            });
        });
    });

    describe("Edge cases", () => {
        it("should handle empty headers when no metadata is available", async () => {
            const buffer = Buffer.from("");
            const input: Uploadable.WithMetadata = {
                data: buffer,
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(buffer);
            expect(result.headers).toEqual({
                "Content-Length": "0",
            });
        });

        it("should handle zero contentLength", async () => {
            const buffer = Buffer.from("test");
            const input: Uploadable.WithMetadata = {
                data: buffer,
                contentLength: 0,
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(buffer);
            expect(result.headers).toEqual({
                "Content-Length": "0", // Should use provided 0
            });
        });

        it("should handle null filename", async () => {
            const buffer = Buffer.from("test");
            const input: Uploadable.WithMetadata = {
                data: buffer,
                filename: undefined,
                contentType: "text/plain",
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(buffer);
            expect(result.headers).toEqual({
                "Content-Type": "text/plain",
                "Content-Length": "4",
                // No Content-Disposition since filename is undefined
            });
        });

        it("should handle null contentType", async () => {
            const buffer = Buffer.from("test");
            const input: Uploadable.WithMetadata = {
                data: buffer,
                filename: "test.txt",
                contentType: undefined,
            };

            const result = await toBinaryUploadRequest(input);

            expect(result.body).toBe(buffer);
            expect(result.headers).toEqual({
                "Content-Disposition": 'attachment; filename="test.txt"',
                "Content-Length": "4",
                // No Content-Type since contentType is undefined
            });
        });
    });
});

```


## /tests/unit/file/test-file.txt
```txt
This is a test file!

```


## /tests/unit/form-data-utils/encodeAsFormParameter.test.ts
```typescript
import { encodeAsFormParameter } from "../../../src/core/form-data-utils/encodeAsFormParameter";

describe("encodeAsFormParameter", () => {
    describe("Basic functionality", () => {
        it("should return empty object for null/undefined", () => {
            expect(encodeAsFormParameter(null)).toEqual({});
            expect(encodeAsFormParameter(undefined)).toEqual({});
        });

        it("should return empty object for primitive values", () => {
            expect(encodeAsFormParameter("hello")).toEqual({});
            expect(encodeAsFormParameter(42)).toEqual({});
            expect(encodeAsFormParameter(true)).toEqual({});
        });

        it("should handle simple key-value pairs", () => {
            const obj = { name: "John", age: 30 };
            expect(encodeAsFormParameter(obj)).toEqual({
                name: "John",
                age: "30",
            });
        });

        it("should handle empty objects", () => {
            expect(encodeAsFormParameter({})).toEqual({});
        });
    });

    describe("Array handling", () => {
        it("should handle arrays with indices format (default)", () => {
            const obj = { items: ["a", "b", "c"] };
            expect(encodeAsFormParameter(obj)).toEqual({
                "items[0]": "a",
                "items[1]": "b",
                "items[2]": "c",
            });
        });

        it("should handle empty arrays", () => {
            const obj = { items: [] };
            expect(encodeAsFormParameter(obj)).toEqual({});
        });

        it("should handle arrays with mixed types", () => {
            const obj = { mixed: ["string", 42, true, false] };
            expect(encodeAsFormParameter(obj)).toEqual({
                "mixed[0]": "string",
                "mixed[1]": "42",
                "mixed[2]": "true",
                "mixed[3]": "false",
            });
        });

        it("should handle arrays with objects", () => {
            const obj = { users: [{ name: "John" }, { name: "Jane" }] };
            expect(encodeAsFormParameter(obj)).toEqual({
                "users[0][name]": "John",
                "users[1][name]": "Jane",
            });
        });

        it("should handle arrays with null/undefined values", () => {
            const obj = { items: ["a", null, "c", undefined, "e"] };
            expect(encodeAsFormParameter(obj)).toEqual({
                "items[0]": "a",
                "items[1]": "",
                "items[2]": "c",
                "items[4]": "e",
            });
        });
    });

    describe("Nested objects", () => {
        it("should handle nested objects", () => {
            const obj = { user: { name: "John", age: 30 } };
            expect(encodeAsFormParameter(obj)).toEqual({
                "user[name]": "John",
                "user[age]": "30",
            });
        });

        it("should handle deeply nested objects", () => {
            const obj = { user: { profile: { name: "John", settings: { theme: "dark" } } } };
            expect(encodeAsFormParameter(obj)).toEqual({
                "user[profile][name]": "John",
                "user[profile][settings][theme]": "dark",
            });
        });

        it("should handle empty nested objects", () => {
            const obj = { user: {} };
            expect(encodeAsFormParameter(obj)).toEqual({});
        });
    });

    describe("Special characters and encoding", () => {
        it("should not encode values (encode: false is used)", () => {
            const obj = { name: "John Doe", email: "john@example.com" };
            expect(encodeAsFormParameter(obj)).toEqual({
                name: "John Doe",
                email: "john@example.com",
            });
        });

        it("should not encode special characters in keys", () => {
            const obj = { "user name": "John", "email[primary]": "john@example.com" };
            expect(encodeAsFormParameter(obj)).toEqual({
                "user name": "John",
                "email[primary]": "john@example.com",
            });
        });

        it("should handle values that contain special characters", () => {
            const obj = {
                query: "search term with spaces",
                filter: "category:electronics",
            };
            expect(encodeAsFormParameter(obj)).toEqual({
                query: "search term with spaces",
                filter: "category:electronics",
            });
        });

        it("should handle ampersand and equals characters (edge case)", () => {
            // Note: Values containing & and = may be problematic because
            // encodeAsFormParameter splits on these characters when parsing the stringified result
            const obj = {
                message: "Hello & welcome",
                equation: "x = y + z",
            };
            // This demonstrates the limitation - ampersands and equals signs in values
            // will cause the parameter to be split incorrectly
            const result = encodeAsFormParameter(obj);

            // We expect this to be parsed incorrectly due to the implementation
            expect(result.message).toBe("Hello ");
            expect(result[" welcome"]).toBeUndefined();
            expect(result.equation).toBe("x ");
            expect(result[" y + z"]).toBeUndefined();
        });
    });

    describe("Form data specific scenarios", () => {
        it("should handle file upload metadata", () => {
            const metadata = {
                file: {
                    name: "document.pdf",
                    size: 1024,
                    type: "application/pdf",
                },
                options: {
                    compress: true,
                    quality: 0.8,
                },
            };
            expect(encodeAsFormParameter(metadata)).toEqual({
                "file[name]": "document.pdf",
                "file[size]": "1024",
                "file[type]": "application/pdf",
                "options[compress]": "true",
                "options[quality]": "0.8",
            });
        });

        it("should handle form validation data", () => {
            const formData = {
                fields: ["name", "email", "phone"],
                validation: {
                    required: ["name", "email"],
                    patterns: {
                        email: "^[^@]+@[^@]+\\.[^@]+$",
                        phone: "^\\+?[1-9]\\d{1,14}$",
                    },
                },
            };
            expect(encodeAsFormParameter(formData)).toEqual({
                "fields[0]": "name",
                "fields[1]": "email",
                "fields[2]": "phone",
                "validation[required][0]": "name",
                "validation[required][1]": "email",
                "validation[patterns][email]": "^[^@]+@[^@]+\\.[^@]+$",
                "validation[patterns][phone]": "^\\+?[1-9]\\d{1,14}$",
            });
        });

        it("should handle search/filter parameters", () => {
            const searchParams = {
                filters: {
                    status: ["active", "pending"],
                    category: {
                        type: "electronics",
                        subcategories: ["phones", "laptops"],
                    },
                },
                sort: { field: "name", direction: "asc" },
                pagination: { page: 1, limit: 20 },
            };
            expect(encodeAsFormParameter(searchParams)).toEqual({
                "filters[status][0]": "active",
                "filters[status][1]": "pending",
                "filters[category][type]": "electronics",
                "filters[category][subcategories][0]": "phones",
                "filters[category][subcategories][1]": "laptops",
                "sort[field]": "name",
                "sort[direction]": "asc",
                "pagination[page]": "1",
                "pagination[limit]": "20",
            });
        });
    });

    describe("Edge cases", () => {
        it("should handle boolean values", () => {
            const obj = { enabled: true, disabled: false };
            expect(encodeAsFormParameter(obj)).toEqual({
                enabled: "true",
                disabled: "false",
            });
        });

        it("should handle empty strings", () => {
            const obj = { name: "", description: "test" };
            expect(encodeAsFormParameter(obj)).toEqual({
                name: "",
                description: "test",
            });
        });

        it("should handle zero values", () => {
            const obj = { count: 0, price: 0.0 };
            expect(encodeAsFormParameter(obj)).toEqual({
                count: "0",
                price: "0",
            });
        });

        it("should handle numeric keys", () => {
            const obj = { "0": "zero", "1": "one" };
            expect(encodeAsFormParameter(obj)).toEqual({
                "0": "zero",
                "1": "one",
            });
        });

        it("should handle objects with null/undefined values", () => {
            const obj = { name: "John", age: null, email: undefined, active: true };
            expect(encodeAsFormParameter(obj)).toEqual({
                name: "John",
                age: "",
                active: "true",
            });
        });
    });

    describe("Integration with form submission", () => {
        it("should produce form-compatible key-value pairs", () => {
            const formObject = {
                username: "john_doe",
                preferences: {
                    theme: "dark",
                    notifications: ["email", "push"],
                    settings: {
                        autoSave: true,
                        timeout: 300,
                    },
                },
            };

            const result = encodeAsFormParameter(formObject);

            // Verify all values are strings (as required for form data)
            Object.values(result).forEach((value) => {
                expect(typeof value).toBe("string");
            });

            // Verify the structure can be reconstructed
            expect(result).toEqual({
                username: "john_doe",
                "preferences[theme]": "dark",
                "preferences[notifications][0]": "email",
                "preferences[notifications][1]": "push",
                "preferences[settings][autoSave]": "true",
                "preferences[settings][timeout]": "300",
            });
        });

        it("should handle complex nested arrays for API parameters", () => {
            const apiParams = {
                query: {
                    filters: [
                        { field: "status", operator: "eq", value: "active" },
                        { field: "created", operator: "gte", value: "2023-01-01" },
                    ],
                    sort: [
                        { field: "name", direction: "asc" },
                        { field: "created", direction: "desc" },
                    ],
                },
            };

            const result = encodeAsFormParameter(apiParams);
            expect(result).toEqual({
                "query[filters][0][field]": "status",
                "query[filters][0][operator]": "eq",
                "query[filters][0][value]": "active",
                "query[filters][1][field]": "created",
                "query[filters][1][operator]": "gte",
                "query[filters][1][value]": "2023-01-01",
                "query[sort][0][field]": "name",
                "query[sort][0][direction]": "asc",
                "query[sort][1][field]": "created",
                "query[sort][1][direction]": "desc",
            });
        });
    });

    describe("Error cases and malformed input", () => {
        it("should handle circular references gracefully", () => {
            const obj: any = { name: "test" };
            obj.self = obj;

            // This will throw a RangeError due to stack overflow - this is expected behavior
            expect(() => encodeAsFormParameter(obj)).toThrow("Maximum call stack size exceeded");
        });

        it("should handle very deeply nested objects", () => {
            let deepObj: any = { value: "deep" };
            for (let i = 0; i < 100; i++) {
                deepObj = { level: deepObj };
            }

            expect(() => encodeAsFormParameter(deepObj)).not.toThrow();
            const result = encodeAsFormParameter(deepObj);
            expect(Object.keys(result).length).toBeGreaterThan(0);
        });

        it("should handle empty string splitting edge case", () => {
            // Test what happens when qs returns an empty string
            const result = encodeAsFormParameter({});
            expect(result).toEqual({});
        });
    });
});

```


## /tests/unit/form-data-utils/formDataWrapper.test.ts
```typescript
import { Blob, File } from "buffer";
import { join } from "path";
/* eslint-disable @typescript-eslint/ban-ts-comment */
import { Readable } from "stream";
import { FormDataWrapper, newFormData } from "../../../src/core/form-data-utils/FormDataWrapper";

// Helper function to serialize FormData to string for inspection
async function serializeFormData(formData: FormData): Promise<string> {
    const request = new Request("http://localhost", {
        method: "POST",
        body: formData,
    });

    const buffer = await request.arrayBuffer();
    return new TextDecoder().decode(buffer);
}

describe("FormDataWrapper", () => {
    let formData: FormDataWrapper;

    beforeEach(async () => {
        formData = new FormDataWrapper();
        await formData.setup();
    });

    it("Upload file by path", async () => {
        await formData.appendFile("file", {
            path: join(__dirname, "..", "test-file.txt"),
        });

        const serialized = await serializeFormData(formData.getRequest().body);

        expect(serialized).toContain('Content-Disposition: form-data; name="file"');
        expect(serialized).toContain('filename="test-file.txt"');
        expect(serialized).toContain("This is a test file!");
    });

    it("Upload file by path with filename", async () => {
        await formData.appendFile("file", {
            path: join(__dirname, "..", "test-file.txt"),
            filename: "custom-file.txt",
        });

        const serialized = await serializeFormData(formData.getRequest().body);

        expect(serialized).toContain('Content-Disposition: form-data; name="file"');
        expect(serialized).toContain('filename="custom-file.txt"');
        expect(serialized).toContain("This is a test file!");
    });

    describe("Stream handling", () => {
        it("serializes Node.js Readable stream with filename", async () => {
            const stream = Readable.from(["file content"]);
            await formData.appendFile("file", {
                data: stream,
                filename: "testfile.txt",
            });

            const serialized = await serializeFormData(formData.getRequest().body);

            expect(serialized).toContain('Content-Disposition: form-data; name="file"');
            expect(serialized).toContain('filename="testfile.txt"');
            expect(serialized).toContain("file content");
        });

        it("auto-detects filename from stream path property", async () => {
            const stream = Readable.from(["file content"]);
            (stream as { path?: string }).path = "/test/path/testfile.txt";

            await formData.appendFile("file", stream);

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="testfile.txt"');
        });

        it("handles Windows-style paths", async () => {
            const stream = Readable.from(["file content"]);
            (stream as { path?: string }).path = "C:\\test\\path\\testfile.txt";

            await formData.appendFile("file", stream);

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="testfile.txt"');
        });

        it("handles empty streams", async () => {
            const stream = Readable.from([]);
            await formData.appendFile("file", {
                data: stream,
                filename: "empty.txt",
            });

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="empty.txt"');
            expect(serialized).toMatch(/------formdata-undici-\w+|------WebKitFormBoundary\w+/);
        });

        it("serializes Web ReadableStream with filename", async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(new TextEncoder().encode("web stream content"));
                    controller.close();
                },
            });

            await formData.appendFile("file", {
                data: stream,
                filename: "webstream.txt",
            });

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="webstream.txt"');
            expect(serialized).toContain("web stream content");
        });

        it("handles empty Web ReadableStream", async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.close();
                },
            });

            await formData.appendFile("file", {
                data: stream,
                filename: "empty.txt",
            });

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="empty.txt"');
            expect(serialized).toMatch(/------formdata-undici-\w+|------WebKitFormBoundary\w+/);
        });
    });

    describe("Blob and File types", () => {
        it("serializes Blob with specified filename", async () => {
            const blob = new Blob(["file content"], { type: "text/plain" });
            await formData.appendFile("file", {
                data: blob,
                filename: "testfile.txt",
            });

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="testfile.txt"');
            expect(serialized).toContain("Content-Type: text/plain");
            expect(serialized).toContain("file content");
        });

        it("uses default filename for Blob without explicit filename", async () => {
            const blob = new Blob(["file content"], { type: "text/plain" });
            await formData.appendFile("file", blob);

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="blob"');
        });

        it("preserves File object filename", async () => {
            if (typeof File !== "undefined") {
                const file = new File(["file content"], "original.txt", { type: "text/plain" });
                await formData.appendFile("file", file);

                const serialized = await serializeFormData(formData.getRequest().body);
                expect(serialized).toContain('filename="original.txt"');
                expect(serialized).toContain("file content");
            }
        });

        it("allows filename override for File objects", async () => {
            if (typeof File !== "undefined") {
                const file = new File(["file content"], "original.txt", { type: "text/plain" });
                await formData.appendFile("file", {
                    data: file,
                    filename: "override.txt",
                });

                const serialized = await serializeFormData(formData.getRequest().body);
                expect(serialized).toContain('filename="override.txt"');
                expect(serialized).not.toContain('filename="original.txt"');
            }
        });
    });

    describe("Binary data types", () => {
        it("serializes ArrayBuffer with filename", async () => {
            const arrayBuffer = new ArrayBuffer(8);
            new Uint8Array(arrayBuffer).set([1, 2, 3, 4, 5, 6, 7, 8]);

            await formData.appendFile("file", {
                data: arrayBuffer,
                filename: "binary.bin",
            });

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="binary.bin"');
            expect(serialized).toMatch(/------formdata-undici-\w+|------WebKitFormBoundary\w+/);
        });

        it("serializes Uint8Array with filename", async () => {
            const uint8Array = new Uint8Array([72, 101, 108, 108, 111]); // "Hello"
            await formData.appendFile("file", {
                data: uint8Array,
                filename: "binary.bin",
            });

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="binary.bin"');
            expect(serialized).toContain("Hello");
        });

        it("serializes other typed arrays", async () => {
            const int16Array = new Int16Array([1000, 2000, 3000]);
            await formData.appendFile("file", {
                data: int16Array,
                filename: "numbers.bin",
            });

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="numbers.bin"');
        });

        it("serializes Buffer data with filename", async () => {
            if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer === "function") {
                const buffer = Buffer.from("test content");
                await formData.appendFile("file", {
                    data: buffer,
                    filename: "test.txt",
                });

                const serialized = await serializeFormData(formData.getRequest().body);
                expect(serialized).toContain('filename="test.txt"');
                expect(serialized).toContain("test content");
            }
        });
    });

    describe("Text and primitive types", () => {
        it("serializes string as regular form field", async () => {
            formData.append("text", "test string");

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('name="text"');
            expect(serialized).not.toContain("filename=");
            expect(serialized).toContain("test string");
        });

        it("serializes numbers and booleans as strings", async () => {
            formData.append("number", 12345);
            formData.append("flag", true);

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain("12345");
            expect(serialized).toContain("true");
        });
    });

    describe("Edge cases and error handling", () => {
        it("handles empty filename gracefully", async () => {
            await formData.appendFile("file", {
                data: new Blob(["content"], { type: "text/plain" }),
                filename: "",
            });

            const serialized = await serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="blob"'); // Default fallback
        });

        it("handles multiple files in single form", async () => {
            await formData.appendFile("file1", {
                data: new Blob(["content1"], { type: "text/plain" }),
                filename: "file1.txt",
            });
            await formData.appendFile("file2", {
                data: new Blob(["content2"], { type: "text/plain" }),
                filename: "file2.txt",
            });
            formData.append("text", "regular field");

            const serialized = await serializeFormData(formData.getRequest().body);

            expect(serialized).toContain('filename="file1.txt"');
            expect(serialized).toContain('filename="file2.txt"');
            expect(serialized).toContain('name="text"');
            expect(serialized).not.toContain('filename="text"');
        });
    });

    describe("Request structure", () => {
        it("returns correct request structure", async () => {
            await formData.appendFile("file", {
                data: new Blob(["content"], { type: "text/plain" }),
                filename: "test.txt",
            });

            const request = formData.getRequest();

            expect(request).toHaveProperty("body");
            expect(request).toHaveProperty("headers");
            expect(request).toHaveProperty("duplex");
            expect(request.body).toBeInstanceOf(FormData);
            expect(request.headers).toEqual({});
            expect(request.duplex).toBe("half");
        });

        it("generates proper multipart boundary structure", async () => {
            await formData.appendFile("file", {
                data: new Blob(["test content"], { type: "text/plain" }),
                filename: "test.txt",
            });
            formData.append("field", "value");

            const serialized = await serializeFormData(formData.getRequest().body);

            expect(serialized).toMatch(/------formdata-undici-\w+|------WebKitFormBoundary\w+/);
            expect(serialized).toContain("Content-Disposition: form-data;");
            expect(serialized).toMatch(/------formdata-undici-\w+--|------WebKitFormBoundary\w+--/);
        });
    });

    describe("Factory function", () => {
        it("returns FormDataWrapper instance", async () => {
            const formData = await newFormData();
            expect(formData).toBeInstanceOf(FormDataWrapper);
        });

        it("creates independent instances", async () => {
            const formData1 = await newFormData();
            const formData2 = await newFormData();

            await formData1.setup();
            await formData2.setup();

            formData1.append("test1", "value1");
            formData2.append("test2", "value2");

            const request1 = formData1.getRequest() as { body: FormData };
            const request2 = formData2.getRequest() as { body: FormData };

            const entries1 = Array.from(request1.body.entries());
            const entries2 = Array.from(request2.body.entries());

            expect(entries1).toHaveLength(1);
            expect(entries2).toHaveLength(1);
            expect(entries1[0][0]).toBe("test1");
            expect(entries2[0][0]).toBe("test2");
        });
    });
});

```


## /tests/unit/logging/logger.test.ts
```typescript
import { ConsoleLogger, createLogger, Logger, LogLevel } from "../../../src/core/logging/logger";

function createMockLogger() {
    return {
        debug: vi.fn(),
        info: vi.fn(),
        warn: vi.fn(),
        error: vi.fn(),
    };
}

describe("Logger", () => {
    describe("LogLevel", () => {
        it("should have correct log levels", () => {
            expect(LogLevel.Debug).toBe("debug");
            expect(LogLevel.Info).toBe("info");
            expect(LogLevel.Warn).toBe("warn");
            expect(LogLevel.Error).toBe("error");
        });
    });

    describe("ConsoleLogger", () => {
        let consoleLogger: ConsoleLogger;
        let consoleSpy: {
            debug: ReturnType<typeof vi.spyOn>;
            info: ReturnType<typeof vi.spyOn>;
            warn: ReturnType<typeof vi.spyOn>;
            error: ReturnType<typeof vi.spyOn>;
        };

        beforeEach(() => {
            consoleLogger = new ConsoleLogger();
            consoleSpy = {
                debug: vi.spyOn(console, "debug").mockImplementation(() => {}),
                info: vi.spyOn(console, "info").mockImplementation(() => {}),
                warn: vi.spyOn(console, "warn").mockImplementation(() => {}),
                error: vi.spyOn(console, "error").mockImplementation(() => {}),
            };
        });

        afterEach(() => {
            consoleSpy.debug.mockRestore();
            consoleSpy.info.mockRestore();
            consoleSpy.warn.mockRestore();
            consoleSpy.error.mockRestore();
        });

        it("should log debug messages", () => {
            consoleLogger.debug("debug message", { data: "test" });
            expect(consoleSpy.debug).toHaveBeenCalledWith("debug message", { data: "test" });
        });

        it("should log info messages", () => {
            consoleLogger.info("info message", { data: "test" });
            expect(consoleSpy.info).toHaveBeenCalledWith("info message", { data: "test" });
        });

        it("should log warn messages", () => {
            consoleLogger.warn("warn message", { data: "test" });
            expect(consoleSpy.warn).toHaveBeenCalledWith("warn message", { data: "test" });
        });

        it("should log error messages", () => {
            consoleLogger.error("error message", { data: "test" });
            expect(consoleSpy.error).toHaveBeenCalledWith("error message", { data: "test" });
        });

        it("should handle multiple arguments", () => {
            consoleLogger.debug("message", "arg1", "arg2", { key: "value" });
            expect(consoleSpy.debug).toHaveBeenCalledWith("message", "arg1", "arg2", { key: "value" });
        });
    });

    describe("Logger with level filtering", () => {
        let mockLogger: {
            debug: ReturnType<typeof vi.fn>;
            info: ReturnType<typeof vi.fn>;
            warn: ReturnType<typeof vi.fn>;
            error: ReturnType<typeof vi.fn>;
        };

        beforeEach(() => {
            mockLogger = createMockLogger();
        });

        describe("Debug level", () => {
            it("should log all levels when set to debug", () => {
                const logger = new Logger({
                    level: LogLevel.Debug,
                    logger: mockLogger,
                    silent: false,
                });

                logger.debug("debug");
                logger.info("info");
                logger.warn("warn");
                logger.error("error");

                expect(mockLogger.debug).toHaveBeenCalledWith("debug");
                expect(mockLogger.info).toHaveBeenCalledWith("info");
                expect(mockLogger.warn).toHaveBeenCalledWith("warn");
                expect(mockLogger.error).toHaveBeenCalledWith("error");
            });

            it("should report correct level checks", () => {
                const logger = new Logger({
                    level: LogLevel.Debug,
                    logger: mockLogger,
                    silent: false,
                });

                expect(logger.isDebug()).toBe(true);
                expect(logger.isInfo()).toBe(true);
                expect(logger.isWarn()).toBe(true);
                expect(logger.isError()).toBe(true);
            });
        });

        describe("Info level", () => {
            it("should log info, warn, and error when set to info", () => {
                const logger = new Logger({
                    level: LogLevel.Info,
                    logger: mockLogger,
                    silent: false,
                });

                logger.debug("debug");
                logger.info("info");
                logger.warn("warn");
                logger.error("error");

                expect(mockLogger.debug).not.toHaveBeenCalled();
                expect(mockLogger.info).toHaveBeenCalledWith("info");
                expect(mockLogger.warn).toHaveBeenCalledWith("warn");
                expect(mockLogger.error).toHaveBeenCalledWith("error");
            });

            it("should report correct level checks", () => {
                const logger = new Logger({
                    level: LogLevel.Info,
                    logger: mockLogger,
                    silent: false,
                });

                expect(logger.isDebug()).toBe(false);
                expect(logger.isInfo()).toBe(true);
                expect(logger.isWarn()).toBe(true);
                expect(logger.isError()).toBe(true);
            });
        });

        describe("Warn level", () => {
            it("should log warn and error when set to warn", () => {
                const logger = new Logger({
                    level: LogLevel.Warn,
                    logger: mockLogger,
                    silent: false,
                });

                logger.debug("debug");
                logger.info("info");
                logger.warn("warn");
                logger.error("error");

                expect(mockLogger.debug).not.toHaveBeenCalled();
                expect(mockLogger.info).not.toHaveBeenCalled();
                expect(mockLogger.warn).toHaveBeenCalledWith("warn");
                expect(mockLogger.error).toHaveBeenCalledWith("error");
            });

            it("should report correct level checks", () => {
                const logger = new Logger({
                    level: LogLevel.Warn,
                    logger: mockLogger,
                    silent: false,
                });

                expect(logger.isDebug()).toBe(false);
                expect(logger.isInfo()).toBe(false);
                expect(logger.isWarn()).toBe(true);
                expect(logger.isError()).toBe(true);
            });
        });

        describe("Error level", () => {
            it("should only log error when set to error", () => {
                const logger = new Logger({
                    level: LogLevel.Error,
                    logger: mockLogger,
                    silent: false,
                });

                logger.debug("debug");
                logger.info("info");
                logger.warn("warn");
                logger.error("error");

                expect(mockLogger.debug).not.toHaveBeenCalled();
                expect(mockLogger.info).not.toHaveBeenCalled();
                expect(mockLogger.warn).not.toHaveBeenCalled();
                expect(mockLogger.error).toHaveBeenCalledWith("error");
            });

            it("should report correct level checks", () => {
                const logger = new Logger({
                    level: LogLevel.Error,
                    logger: mockLogger,
                    silent: false,
                });

                expect(logger.isDebug()).toBe(false);
                expect(logger.isInfo()).toBe(false);
                expect(logger.isWarn()).toBe(false);
                expect(logger.isError()).toBe(true);
            });
        });

        describe("Silent mode", () => {
            it("should not log anything when silent is true", () => {
                const logger = new Logger({
                    level: LogLevel.Debug,
                    logger: mockLogger,
                    silent: true,
                });

                logger.debug("debug");
                logger.info("info");
                logger.warn("warn");
                logger.error("error");

                expect(mockLogger.debug).not.toHaveBeenCalled();
                expect(mockLogger.info).not.toHaveBeenCalled();
                expect(mockLogger.warn).not.toHaveBeenCalled();
                expect(mockLogger.error).not.toHaveBeenCalled();
            });

            it("should report all level checks as false when silent", () => {
                const logger = new Logger({
                    level: LogLevel.Debug,
                    logger: mockLogger,
                    silent: true,
                });

                expect(logger.isDebug()).toBe(false);
                expect(logger.isInfo()).toBe(false);
                expect(logger.isWarn()).toBe(false);
                expect(logger.isError()).toBe(false);
            });
        });

        describe("shouldLog", () => {
            it("should correctly determine if level should be logged", () => {
                const logger = new Logger({
                    level: LogLevel.Info,
                    logger: mockLogger,
                    silent: false,
                });

                expect(logger.shouldLog(LogLevel.Debug)).toBe(false);
                expect(logger.shouldLog(LogLevel.Info)).toBe(true);
                expect(logger.shouldLog(LogLevel.Warn)).toBe(true);
                expect(logger.shouldLog(LogLevel.Error)).toBe(true);
            });

            it("should return false for all levels when silent", () => {
                const logger = new Logger({
                    level: LogLevel.Debug,
                    logger: mockLogger,
                    silent: true,
                });

                expect(logger.shouldLog(LogLevel.Debug)).toBe(false);
                expect(logger.shouldLog(LogLevel.Info)).toBe(false);
                expect(logger.shouldLog(LogLevel.Warn)).toBe(false);
                expect(logger.shouldLog(LogLevel.Error)).toBe(false);
            });
        });

        describe("Multiple arguments", () => {
            it("should pass multiple arguments to logger", () => {
                const logger = new Logger({
                    level: LogLevel.Debug,
                    logger: mockLogger,
                    silent: false,
                });

                logger.debug("message", "arg1", { key: "value" }, 123);
                expect(mockLogger.debug).toHaveBeenCalledWith("message", "arg1", { key: "value" }, 123);
            });
        });
    });

    describe("createLogger", () => {
        it("should return default logger when no config provided", () => {
            const logger = createLogger();
            expect(logger).toBeInstanceOf(Logger);
        });

        it("should return same logger instance when Logger is passed", () => {
            const customLogger = new Logger({
                level: LogLevel.Debug,
                logger: new ConsoleLogger(),
                silent: false,
            });

            const result = createLogger(customLogger);
            expect(result).toBe(customLogger);
        });

        it("should create logger with custom config", () => {
            const mockLogger = createMockLogger();

            const logger = createLogger({
                level: LogLevel.Warn,
                logger: mockLogger,
                silent: false,
            });

            expect(logger).toBeInstanceOf(Logger);
            logger.warn("test");
            expect(mockLogger.warn).toHaveBeenCalledWith("test");
        });

        it("should use default values for missing config", () => {
            const logger = createLogger({});
            expect(logger).toBeInstanceOf(Logger);
        });

        it("should override default level", () => {
            const mockLogger = createMockLogger();

            const logger = createLogger({
                level: LogLevel.Debug,
                logger: mockLogger,
                silent: false,
            });

            logger.debug("test");
            expect(mockLogger.debug).toHaveBeenCalledWith("test");
        });

        it("should override default silent mode", () => {
            const mockLogger = createMockLogger();

            const logger = createLogger({
                logger: mockLogger,
                silent: false,
            });

            logger.info("test");
            expect(mockLogger.info).toHaveBeenCalledWith("test");
        });

        it("should use provided logger implementation", () => {
            const customLogger = createMockLogger();

            const logger = createLogger({
                logger: customLogger,
                level: LogLevel.Debug,
                silent: false,
            });

            logger.debug("test");
            expect(customLogger.debug).toHaveBeenCalledWith("test");
        });

        it("should default to silent: true", () => {
            const mockLogger = createMockLogger();

            const logger = createLogger({
                logger: mockLogger,
                level: LogLevel.Debug,
            });

            logger.debug("test");
            expect(mockLogger.debug).not.toHaveBeenCalled();
        });
    });

    describe("Default logger", () => {
        it("should have silent: true by default", () => {
            const logger = createLogger();
            expect(logger.shouldLog(LogLevel.Info)).toBe(false);
        });

        it("should not log when using default logger", () => {
            const logger = createLogger();

            logger.info("test");
            expect(logger.isInfo()).toBe(false);
        });
    });

    describe("Edge cases", () => {
        it("should handle empty message", () => {
            const mockLogger = createMockLogger();

            const logger = new Logger({
                level: LogLevel.Debug,
                logger: mockLogger,
                silent: false,
            });

            logger.debug("");
            expect(mockLogger.debug).toHaveBeenCalledWith("");
        });

        it("should handle no arguments", () => {
            const mockLogger = createMockLogger();

            const logger = new Logger({
                level: LogLevel.Debug,
                logger: mockLogger,
                silent: false,
            });

            logger.debug("message");
            expect(mockLogger.debug).toHaveBeenCalledWith("message");
        });

        it("should handle complex objects", () => {
            const mockLogger = createMockLogger();

            const logger = new Logger({
                level: LogLevel.Debug,
                logger: mockLogger,
                silent: false,
            });

            const complexObject = {
                nested: { key: "value" },
                array: [1, 2, 3],
                fn: () => "test",
            };

            logger.debug("message", complexObject);
            expect(mockLogger.debug).toHaveBeenCalledWith("message", complexObject);
        });

        it("should handle errors as arguments", () => {
            const mockLogger = createMockLogger();

            const logger = new Logger({
                level: LogLevel.Error,
                logger: mockLogger,
                silent: false,
            });

            const error = new Error("Test error");
            logger.error("Error occurred", error);
            expect(mockLogger.error).toHaveBeenCalledWith("Error occurred", error);
        });
    });
});

```


## /tests/unit/schemas/bigint/bigint.test.ts
```typescript
import { bigint } from "../../../../src/core/schemas/builders/bigint";
import { itJson, itParse, itSchema } from "../utils/itSchema";
import { itValidateJson, itValidateParse } from "../utils/itValidate";

describe("bigint", () => {
    itSchema("converts between raw bigint and parsed bigint", bigint(), {
        raw: BigInt("9007199254740992"),
        parsed: BigInt("9007199254740992"),
    });

    itParse("converts between raw number and parsed bigint", bigint(), {
        raw: 10,
        parsed: BigInt("10"),
    });

    itParse("converts between raw number and parsed bigint", bigint(), {
        raw: BigInt("10"),
        parsed: BigInt("10"),
    });

    itJson("converts raw bigint to parsed bigint", bigint(), {
        parsed: BigInt("10"),
        raw: BigInt("10"),
    });

    itValidateParse("string", bigint(), "42", [
        {
            message: 'Expected bigint | number. Received "42".',
            path: [],
        },
    ]);

    itValidateJson("number", bigint(), 42, [
        {
            message: "Expected bigint. Received 42.",
            path: [],
        },
    ]);

    itValidateJson("string", bigint(), "42", [
        {
            message: 'Expected bigint. Received "42".',
            path: [],
        },
    ]);
});

```


## /tests/unit/schemas/date/date.test.ts
```typescript
import { date } from "../../../../src/core/schemas/builders/date";
import { itSchema } from "../utils/itSchema";
import { itValidateJson, itValidateParse } from "../utils/itValidate";

describe("date", () => {
    itSchema("converts between raw ISO string and parsed Date", date(), {
        raw: "2022-09-29T05:41:21.939Z",
        parsed: new Date("2022-09-29T05:41:21.939Z"),
    });

    itValidateParse("non-string", date(), 42, [
        {
            message: "Expected string. Received 42.",
            path: [],
        },
    ]);

    itValidateParse("non-ISO", date(), "hello world", [
        {
            message: 'Expected ISO 8601 date string. Received "hello world".',
            path: [],
        },
    ]);

    itValidateJson("non-Date", date(), "hello", [
        {
            message: 'Expected Date object. Received "hello".',
            path: [],
        },
    ]);
});

```


## /tests/unit/schemas/enum/enum.test.ts
```typescript
import { enum_ } from "../../../../src/core/schemas/builders/enum";
import { itSchemaIdentity } from "../utils/itSchema";
import { itValidate } from "../utils/itValidate";

describe("enum", () => {
    itSchemaIdentity(enum_(["A", "B", "C"]), "A");

    itSchemaIdentity(enum_(["A", "B", "C"]), "D" as any, {
        opts: { allowUnrecognizedEnumValues: true },
    });

    itValidate("invalid enum", enum_(["A", "B", "C"]), "D", [
        {
            message: 'Expected enum. Received "D".',
            path: [],
        },
    ]);

    itValidate(
        "non-string",
        enum_(["A", "B", "C"]),
        [],
        [
            {
                message: "Expected string. Received list.",
                path: [],
            },
        ],
    );
});

```


## /tests/unit/schemas/lazy/lazy.test.ts
```typescript
import { lazy, list, object, string } from "../../../../src/core/schemas/builders";
import type { Schema } from "../../../../src/core/schemas/Schema";
import { itSchemaIdentity } from "../utils/itSchema";

describe("lazy", () => {
    it("doesn't run immediately", () => {
        let wasRun = false;
        lazy(() => {
            wasRun = true;
            return string();
        });
        expect(wasRun).toBe(false);
    });

    it("only runs first time", async () => {
        let count = 0;
        const schema = lazy(() => {
            count++;
            return string();
        });
        await schema.parse("hello");
        await schema.json("world");
        expect(count).toBe(1);
    });

    itSchemaIdentity(
        lazy(() => object({})),
        { foo: "hello" },
        {
            title: "passes opts through",
            opts: { unrecognizedObjectKeys: "passthrough" },
        },
    );

    itSchemaIdentity(
        lazy(() => object({ foo: string() })),
        { foo: "hello" },
    );

    // eslint-disable-next-line vi/expect-expect
    it("self-referencial schema doesn't compile", () => {
        () => {
            // @ts-expect-error
            const a = lazy(() => object({ foo: a }));
        };
    });

    // eslint-disable-next-line vi/expect-expect
    it("self-referencial compiles with explicit type", () => {
        () => {
            interface TreeNode {
                children: TreeNode[];
            }
            const TreeNode: Schema<TreeNode, TreeNode> = lazy(() => object({ children: list(TreeNode) }));
        };
    });
});

```


## /tests/unit/schemas/lazy/lazyObject.test.ts
```typescript
import { lazyObject, number, object, string } from "../../../../src/core/schemas/builders";
import { itSchemaIdentity } from "../utils/itSchema";

describe("lazy", () => {
    itSchemaIdentity(
        lazyObject(() => object({ foo: string() })),
        { foo: "hello" },
    );

    itSchemaIdentity(
        lazyObject(() => object({ foo: string() })).extend(object({ bar: number() })),
        {
            foo: "hello",
            bar: 42,
        },
        { title: "returned schema has object utils" },
    );
});

```


## /tests/unit/schemas/lazy/recursive/a.ts
```typescript
import { object } from "../../../../../src/core/schemas/builders/object";
import { schemaB } from "./b";

// @ts-expect-error
export const schemaA = object({
    b: schemaB,
});

```


## /tests/unit/schemas/lazy/recursive/b.ts
```typescript
import { object } from "../../../../../src/core/schemas/builders/object";
import { optional } from "../../../../../src/core/schemas/builders/schema-utils";
import { schemaA } from "./a";

// @ts-expect-error
export const schemaB = object({
    a: optional(schemaA),
});

```


## /tests/unit/schemas/list/list.test.ts
```typescript
import { list, object, property, string } from "../../../../src/core/schemas/builders";
import { itSchema, itSchemaIdentity } from "../utils/itSchema";
import { itValidate } from "../utils/itValidate";

describe("list", () => {
    itSchemaIdentity(list(string()), ["hello", "world"], {
        title: "functions as identity when item type is primitive",
    });

    itSchema(
        "converts objects correctly",
        list(
            object({
                helloWorld: property("hello_world", string()),
            }),
        ),
        {
            raw: [{ hello_world: "123" }],
            parsed: [{ helloWorld: "123" }],
        },
    );

    itValidate("not a list", list(string()), 42, [
        {
            path: [],
            message: "Expected list. Received 42.",
        },
    ]);

    itValidate(
        "invalid item type",
        list(string()),
        [42],
        [
            {
                path: ["[0]"],
                message: "Expected string. Received 42.",
            },
        ],
    );
});

```


## /tests/unit/schemas/literals/stringLiteral.test.ts
```typescript
import { stringLiteral } from "../../../../src/core/schemas/builders";
import { itSchemaIdentity } from "../utils/itSchema";
import { itValidate } from "../utils/itValidate";

describe("stringLiteral", () => {
    itSchemaIdentity(stringLiteral("A"), "A");

    itValidate("incorrect string", stringLiteral("A"), "B", [
        {
            path: [],
            message: 'Expected "A". Received "B".',
        },
    ]);

    itValidate("non-string", stringLiteral("A"), 42, [
        {
            path: [],
            message: 'Expected "A". Received 42.',
        },
    ]);
});

```


## /tests/unit/schemas/object-like/withParsedProperties.test.ts
```typescript
import { object, property, string, stringLiteral } from "../../../../src/core/schemas/builders";

describe("withParsedProperties", () => {
    it("Added properties included on parsed object", async () => {
        const schema = object({
            foo: property("raw_foo", string()),
            bar: stringLiteral("bar"),
        }).withParsedProperties({
            printFoo: (parsed) => () => parsed.foo,
            printHelloWorld: () => () => "Hello world",
            helloWorld: "Hello world",
        });

        const parsed = await schema.parse({ raw_foo: "value of foo", bar: "bar" });
        if (!parsed.ok) {
            throw new Error("Failed to parse");
        }
        expect(parsed.value.printFoo()).toBe("value of foo");
        expect(parsed.value.printHelloWorld()).toBe("Hello world");
        expect(parsed.value.helloWorld).toBe("Hello world");
    });

    it("Added property is removed on raw object", async () => {
        const schema = object({
            foo: property("raw_foo", string()),
            bar: stringLiteral("bar"),
        }).withParsedProperties({
            printFoo: (parsed) => () => parsed.foo,
        });

        const original = { raw_foo: "value of foo", bar: "bar" } as const;
        const parsed = await schema.parse(original);
        if (!parsed.ok) {
            throw new Error("Failed to parse()");
        }

        const raw = await schema.json(parsed.value);

        if (!raw.ok) {
            throw new Error("Failed to json()");
        }

        expect(raw.value).toEqual(original);
    });

    describe("compile", () => {
        // eslint-disable-next-line vi/expect-expect
        it("doesn't compile with non-object schema", () => {
            () =>
                object({
                    foo: string(),
                })
                    // @ts-expect-error
                    .withParsedProperties(42);
        });
    });
});

```


## /tests/unit/schemas/object/extend.test.ts
```typescript
import { boolean, object, property, string, stringLiteral } from "../../../../src/core/schemas/builders";
import { itSchema, itSchemaIdentity } from "../utils/itSchema";

describe("extend", () => {
    itSchemaIdentity(
        object({
            foo: string(),
        }).extend(
            object({
                bar: stringLiteral("bar"),
            }),
        ),
        {
            foo: "",
            bar: "bar",
        } as const,
        {
            title: "extended properties are included in schema",
        },
    );

    itSchemaIdentity(
        object({
            foo: string(),
        })
            .extend(
                object({
                    bar: stringLiteral("bar"),
                }),
            )
            .extend(
                object({
                    baz: boolean(),
                }),
            ),
        {
            foo: "",
            bar: "bar",
            baz: true,
        } as const,
        {
            title: "extensions can be extended",
        },
    );

    itSchema(
        "converts nested object",
        object({
            item: object({
                helloWorld: property("hello_world", string()),
            }),
        }).extend(
            object({
                goodbye: property("goodbye_raw", string()),
            }),
        ),
        {
            raw: { item: { hello_world: "yo" }, goodbye_raw: "peace" },
            parsed: { item: { helloWorld: "yo" }, goodbye: "peace" },
        },
    );

    itSchema(
        "extensions work with raw/parsed property name conversions",
        object({
            item: property("item_raw", string()),
        }).extend(
            object({
                goodbye: property("goodbye_raw", string()),
            }),
        ),
        {
            raw: { item_raw: "hi", goodbye_raw: "peace" },
            parsed: { item: "hi", goodbye: "peace" },
        },
    );

    describe("compile", () => {
        // eslint-disable-next-line vi/expect-expect
        it("doesn't compile with non-object schema", () => {
            () =>
                object({
                    foo: string(),
                })
                    // @ts-expect-error
                    .extend([]);
        });
    });
});

```


## /tests/unit/schemas/object/object.test.ts
```typescript
import { any, number, object, property, string, stringLiteral, unknown } from "../../../../src/core/schemas/builders";
import { itJson, itParse, itSchema, itSchemaIdentity } from "../utils/itSchema";
import { itValidate } from "../utils/itValidate";

describe("object", () => {
    itSchemaIdentity(
        object({
            foo: string(),
            bar: stringLiteral("bar"),
        }),
        {
            foo: "",
            bar: "bar",
        },
        {
            title: "functions as identity when values are primitives and property() isn't used",
        },
    );

    itSchema(
        "uses raw key from property()",
        object({
            foo: property("raw_foo", string()),
            bar: stringLiteral("bar"),
        }),
        {
            raw: { raw_foo: "foo", bar: "bar" },
            parsed: { foo: "foo", bar: "bar" },
        },
    );

    itSchema(
        "keys with unknown type can be omitted",
        object({
            foo: unknown(),
        }),
        {
            raw: {},
            parsed: {},
        },
    );

    itSchema(
        "keys with any type can be omitted",
        object({
            foo: any(),
        }),
        {
            raw: {},
            parsed: {},
        },
    );

    describe("unrecognizedObjectKeys", () => {
        describe("parse", () => {
            itParse(
                'includes unknown values when unrecognizedObjectKeys === "passthrough"',
                object({
                    foo: property("raw_foo", string()),
                    bar: stringLiteral("bar"),
                }),
                {
                    raw: {
                        raw_foo: "foo",
                        bar: "bar",
                        // @ts-expect-error
                        baz: "yoyo",
                    },
                    parsed: {
                        foo: "foo",
                        bar: "bar",
                        // @ts-expect-error
                        baz: "yoyo",
                    },
                    opts: {
                        unrecognizedObjectKeys: "passthrough",
                    },
                },
            );

            itParse(
                'strips unknown values when unrecognizedObjectKeys === "strip"',
                object({
                    foo: property("raw_foo", string()),
                    bar: stringLiteral("bar"),
                }),
                {
                    raw: {
                        raw_foo: "foo",
                        bar: "bar",
                        // @ts-expect-error
                        baz: "yoyo",
                    },
                    parsed: {
                        foo: "foo",
                        bar: "bar",
                    },
                    opts: {
                        unrecognizedObjectKeys: "strip",
                    },
                },
            );
        });

        describe("json", () => {
            itJson(
                'includes unknown values when unrecognizedObjectKeys === "passthrough"',
                object({
                    foo: property("raw_foo", string()),
                    bar: stringLiteral("bar"),
                }),
                {
                    raw: {
                        raw_foo: "foo",
                        bar: "bar",
                        // @ts-expect-error
                        baz: "yoyo",
                    },
                    parsed: {
                        foo: "foo",
                        bar: "bar",
                        // @ts-expect-error
                        baz: "yoyo",
                    },
                    opts: {
                        unrecognizedObjectKeys: "passthrough",
                    },
                },
            );

            itJson(
                'strips unknown values when unrecognizedObjectKeys === "strip"',
                object({
                    foo: property("raw_foo", string()),
                    bar: stringLiteral("bar"),
                }),
                {
                    raw: {
                        raw_foo: "foo",
                        bar: "bar",
                    },
                    parsed: {
                        foo: "foo",
                        bar: "bar",
                        // @ts-expect-error
                        baz: "yoyo",
                    },
                    opts: {
                        unrecognizedObjectKeys: "strip",
                    },
                },
            );
        });
    });

    describe("nullish properties", () => {
        itSchema("missing properties are not added", object({ foo: property("raw_foo", string().optional()) }), {
            raw: {},
            parsed: {},
        });

        itSchema("undefined properties are not dropped", object({ foo: property("raw_foo", string().optional()) }), {
            raw: { raw_foo: null },
            parsed: { foo: undefined },
        });

        itSchema("null properties are not dropped", object({ foo: property("raw_foo", string().optional()) }), {
            raw: { raw_foo: null },
            parsed: { foo: undefined },
        });

        describe("extensions", () => {
            itSchema(
                "undefined properties are not dropped",
                object({}).extend(object({ foo: property("raw_foo", string().optional()) })),
                {
                    raw: { raw_foo: null },
                    parsed: { foo: undefined },
                },
            );

            describe("parse()", () => {
                itParse(
                    "null properties are not dropped",
                    object({}).extend(object({ foo: property("raw_foo", string().optional()) })),
                    {
                        raw: { raw_foo: null },
                        parsed: { foo: undefined },
                    },
                );
            });
        });
    });

    itValidate(
        "missing property",
        object({
            foo: string(),
            bar: stringLiteral("bar"),
        }),
        { foo: "hello" },
        [
            {
                path: [],
                message: 'Missing required key "bar"',
            },
        ],
    );

    itValidate(
        "extra property",
        object({
            foo: string(),
            bar: stringLiteral("bar"),
        }),
        { foo: "hello", bar: "bar", baz: 42 },
        [
            {
                path: ["baz"],
                message: 'Unexpected key "baz"',
            },
        ],
    );

    itValidate(
        "not an object",
        object({
            foo: string(),
            bar: stringLiteral("bar"),
        }),
        [],
        [
            {
                path: [],
                message: "Expected object. Received list.",
            },
        ],
    );

    itValidate(
        "nested validation error",
        object({
            foo: object({
                bar: number(),
            }),
        }),
        { foo: { bar: "hello" } },
        [
            {
                path: ["foo", "bar"],
                message: 'Expected number. Received "hello".',
            },
        ],
    );
});

```


## /tests/unit/schemas/object/objectWithoutOptionalProperties.test.ts
```typescript
import { objectWithoutOptionalProperties, string, stringLiteral } from "../../../../src/core/schemas/builders";
import { itSchema } from "../utils/itSchema";

describe("objectWithoutOptionalProperties", () => {
    itSchema(
        "all properties are required",
        objectWithoutOptionalProperties({
            foo: string(),
            bar: stringLiteral("bar").optional(),
        }),
        {
            raw: {
                foo: "hello",
            },
            // @ts-expect-error
            parsed: {
                foo: "hello",
            },
        },
    );
});

```


## /tests/unit/schemas/object/passthrough.test.ts
```typescript
import { object, string, stringLiteral } from "../../../../src/core/schemas/builders";
import { itJson, itParse, itSchema } from "../utils/itSchema";
import { itValidate } from "../utils/itValidate";

describe("passthrough", () => {
    const baseSchema = object({
        foo: string(),
        bar: stringLiteral("bar"),
    });

    describe("parse", () => {
        itParse("includes unknown values", baseSchema.passthrough(), {
            raw: {
                foo: "hello",
                bar: "bar",
                baz: "extra",
            },
            parsed: {
                foo: "hello",
                bar: "bar",
                baz: "extra",
            },
        });

        itValidate(
            "preserves schema validation",
            baseSchema.passthrough(),
            {
                foo: 123,
                bar: "bar",
                baz: "extra",
            },
            [
                {
                    path: ["foo"],
                    message: "Expected string. Received 123.",
                },
            ],
        );
    });

    describe("json", () => {
        itJson("includes unknown values", baseSchema.passthrough(), {
            raw: {
                foo: "hello",
                bar: "bar",

                baz: "extra",
            },
            parsed: {
                foo: "hello",
                bar: "bar",

                baz: "extra",
            },
        });

        itValidate(
            "preserves schema validation",
            baseSchema.passthrough(),
            {
                foo: "hello",
                bar: "wrong",
                baz: "extra",
            },
            [
                {
                    path: ["bar"],
                    message: 'Expected "bar". Received "wrong".',
                },
            ],
        );
    });

    itSchema("preserves schema validation in both directions", baseSchema.passthrough(), {
        raw: {
            foo: "hello",
            bar: "bar",
            extra: 42,
        },
        parsed: {
            foo: "hello",
            bar: "bar",
            extra: 42,
        },
    });
});

```


## /tests/unit/schemas/primitives/any.test.ts
```typescript
import { any } from "../../../../src/core/schemas/builders";
import { itSchemaIdentity } from "../utils/itSchema";

describe("any", () => {
    itSchemaIdentity(any(), true);
});

```


## /tests/unit/schemas/primitives/boolean.test.ts
```typescript
import { boolean } from "../../../../src/core/schemas/builders";
import { itSchemaIdentity } from "../utils/itSchema";
import { itValidate } from "../utils/itValidate";

describe("boolean", () => {
    itSchemaIdentity(boolean(), true);

    itValidate("non-boolean", boolean(), {}, [
        {
            path: [],
            message: "Expected boolean. Received object.",
        },
    ]);
});

```


## /tests/unit/schemas/primitives/never.test.ts
```typescript
import { never } from "../../../../src/core/schemas/builders";

describe("never", () => {
    it("always fails to parse", () => {
        const schema = never();
        const result = schema.parse("test");
        expect(result.ok).toBe(false);
        if (!result.ok) {
            expect(result.errors).toHaveLength(1);
            expect(result.errors[0]?.message).toBe("Expected never");
        }
    });

    it("always fails to json", () => {
        const schema = never();
        const result = schema.json("test");
        expect(result.ok).toBe(false);
        if (!result.ok) {
            expect(result.errors).toHaveLength(1);
            expect(result.errors[0]?.message).toBe("Expected never");
        }
    });

    it("fails with any value including undefined", () => {
        const schema = never();
        expect(schema.parse(undefined).ok).toBe(false);
        expect(schema.parse(null).ok).toBe(false);
        expect(schema.parse(0).ok).toBe(false);
        expect(schema.parse("").ok).toBe(false);
        expect(schema.parse({}).ok).toBe(false);
        expect(schema.parse([]).ok).toBe(false);
    });

    it("works when called without options parameter", () => {
        const schema = never();
        // This tests that the default = {} parameter works correctly
        const result = schema.parse("test");
        expect(result.ok).toBe(false);
        if (!result.ok) {
            expect(result.errors).toHaveLength(1);
            expect(result.errors[0]?.message).toBe("Expected never");
            expect(result.errors[0]?.path).toEqual([]);
        }
    });

    it("succeeds with skipValidation", () => {
        const schema = never();
        const result = schema.parse("test", { skipValidation: true });
        expect(result.ok).toBe(true);
        if (result.ok) {
            expect(result.value).toBe("test");
        }
    });
});

```


## /tests/unit/schemas/primitives/number.test.ts
```typescript
import { number } from "../../../../src/core/schemas/builders";
import { itSchemaIdentity } from "../utils/itSchema";
import { itValidate } from "../utils/itValidate";

describe("number", () => {
    itSchemaIdentity(number(), 42);

    itValidate("non-number", number(), "hello", [
        {
            path: [],
            message: 'Expected number. Received "hello".',
        },
    ]);
});

```


## /tests/unit/schemas/primitives/string.test.ts
```typescript
import { string } from "../../../../src/core/schemas/builders";
import { itSchemaIdentity } from "../utils/itSchema";
import { itValidate } from "../utils/itValidate";

describe("string", () => {
    itSchemaIdentity(string(), "hello");

    itValidate("non-string", string(), 42, [
        {
            path: [],
            message: "Expected string. Received 42.",
        },
    ]);
});

```


## /tests/unit/schemas/primitives/unknown.test.ts
```typescript
import { unknown } from "../../../../src/core/schemas/builders";
import { itSchemaIdentity } from "../utils/itSchema";

describe("unknown", () => {
    itSchemaIdentity(unknown(), true);
});

```


## /tests/unit/schemas/record/record.test.ts
```typescript
import { number, record, string } from "../../../../src/core/schemas/builders";
import { itSchemaIdentity } from "../utils/itSchema";
import { itValidate } from "../utils/itValidate";

describe("record", () => {
    itSchemaIdentity(record(string(), string()), { hello: "world" });
    itSchemaIdentity(record(number(), string()), { 42: "world" });

    itValidate(
        "non-record",
        record(number(), string()),
        [],
        [
            {
                path: [],
                message: "Expected object. Received list.",
            },
        ],
    );

    itValidate("invalid key type", record(number(), string()), { hello: "world" }, [
        {
            path: ["hello (key)"],
            message: 'Expected number. Received "hello".',
        },
    ]);

    itValidate("invalid value type", record(string(), number()), { hello: "world" }, [
        {
            path: ["hello"],
            message: 'Expected number. Received "world".',
        },
    ]);
});

```


## /tests/unit/schemas/schema-utils/getSchemaUtils.test.ts
```typescript
import { object, string } from "../../../../src/core/schemas/builders";
import { itSchema } from "../utils/itSchema";

describe("getSchemaUtils", () => {
    describe("optional()", () => {
        itSchema("optional fields allow original schema", string().optional(), {
            raw: "hello",
            parsed: "hello",
        });

        itSchema("optional fields are not required", string().optional(), {
            raw: null,
            parsed: undefined,
        });
    });

    describe("transform()", () => {
        itSchema(
            "transform and untransform run correctly",
            string().transform({
                transform: (x) => `${x}X`,
                untransform: (x) => (x as string).slice(0, -1),
            }),
            {
                raw: "hello",
                parsed: "helloX",
            },
        );
    });

    describe("parseOrThrow()", () => {
        it("parses valid value", async () => {
            const value = string().parseOrThrow("hello");
            expect(value).toBe("hello");
        });

        it("throws on invalid value", async () => {
            const value = () => object({ a: string(), b: string() }).parseOrThrow({ a: 24 });
            expect(value).toThrowError('a: Expected string. Received 24.; Missing required key "b"');
        });
    });

    describe("jsonOrThrow()", () => {
        it("serializes valid value", async () => {
            const value = string().jsonOrThrow("hello");
            expect(value).toBe("hello");
        });

        it("throws on invalid value", async () => {
            const value = () => object({ a: string(), b: string() }).jsonOrThrow({ a: 24 });
            expect(value).toThrowError('a: Expected string. Received 24.; Missing required key "b"');
        });
    });

    describe("omitUndefined", () => {
        it("serializes undefined as null", async () => {
            const value = object({
                a: string().optional(),
                b: string().optional(),
            }).jsonOrThrow({
                a: "hello",
                b: undefined,
            });
            expect(value).toEqual({ a: "hello", b: null });
        });

        it("omits undefined values", async () => {
            const value = object({
                a: string().optional(),
                b: string().optional(),
            }).jsonOrThrow(
                {
                    a: "hello",
                    b: undefined,
                },
                {
                    omitUndefined: true,
                },
            );
            expect(value).toEqual({ a: "hello" });
        });
    });
});

```


## /tests/unit/schemas/schema.test.ts
```typescript
import {
    boolean,
    discriminant,
    list,
    number,
    object,
    string,
    stringLiteral,
    union,
} from "../../../src/core/schemas/builders";
import { booleanLiteral } from "../../../src/core/schemas/builders/literals/booleanLiteral";
import { property } from "../../../src/core/schemas/builders/object/property";
import { itSchema } from "./utils/itSchema";

describe("Schema", () => {
    itSchema(
        "large nested object",
        object({
            a: string(),
            b: stringLiteral("b value"),
            c: property(
                "raw_c",
                list(
                    object({
                        animal: union(discriminant("type", "_type"), {
                            dog: object({ value: boolean() }),
                            cat: object({ value: property("raw_cat", number()) }),
                        }),
                    }),
                ),
            ),
            d: property("raw_d", boolean()),
            e: booleanLiteral(true),
        }),
        {
            raw: {
                a: "hello",
                b: "b value",
                raw_c: [
                    {
                        animal: {
                            _type: "dog",
                            value: true,
                        },
                    },
                    {
                        animal: {
                            _type: "cat",
                            raw_cat: 42,
                        },
                    },
                ],
                raw_d: false,
                e: true,
            },
            parsed: {
                a: "hello",
                b: "b value",
                c: [
                    {
                        animal: {
                            type: "dog",
                            value: true,
                        },
                    },
                    {
                        animal: {
                            type: "cat",
                            value: 42,
                        },
                    },
                ],
                d: false,
                e: true,
            },
        },
    );
});

```


## /tests/unit/schemas/set/set.test.ts
```typescript
import { set, string } from "../../../../src/core/schemas/builders";
import { itSchema } from "../utils/itSchema";
import { itValidateJson, itValidateParse } from "../utils/itValidate";

describe("set", () => {
    itSchema("converts between raw list and parsed Set", set(string()), {
        raw: ["A", "B"],
        parsed: new Set(["A", "B"]),
    });

    itValidateParse("not a list", set(string()), 42, [
        {
            path: [],
            message: "Expected list. Received 42.",
        },
    ]);

    itValidateJson(
        "not a Set",
        set(string()),
        [],
        [
            {
                path: [],
                message: "Expected Set. Received list.",
            },
        ],
    );

    itValidateParse(
        "invalid item type",
        set(string()),
        [42],
        [
            {
                path: ["[0]"],
                message: "Expected string. Received 42.",
            },
        ],
    );

    itValidateJson("invalid item type", set(string()), new Set([42]), [
        {
            path: ["[0]"],
            message: "Expected string. Received 42.",
        },
    ]);
});

```


## /tests/unit/schemas/skipValidation.test.ts
```typescript
/* eslint-disable no-console */
import { boolean, number, object, property, string, undiscriminatedUnion } from "../../../src/core/schemas/builders";

describe("skipValidation", () => {
    it("allows data that doesn't conform to the schema", async () => {
        const warningLogs: string[] = [];
        const originalConsoleWarn = console.warn;
        console.warn = (...args) => warningLogs.push(args.join(" "));

        const schema = object({
            camelCase: property("snake_case", string()),
            numberProperty: number(),
            requiredProperty: boolean(),
            anyPrimitive: undiscriminatedUnion([string(), number(), boolean()]),
        });

        const parsed = await schema.parse(
            {
                snake_case: "hello",
                numberProperty: "oops",
                anyPrimitive: true,
            },
            {
                skipValidation: true,
            },
        );

        expect(parsed).toEqual({
            ok: true,
            value: {
                camelCase: "hello",
                numberProperty: "oops",
                anyPrimitive: true,
            },
        });

        expect(warningLogs).toEqual([
            `Failed to validate.
  - numberProperty: Expected number. Received "oops".`,
        ]);

        console.warn = originalConsoleWarn;
    });
});

```


## /tests/unit/schemas/undiscriminated-union/undiscriminatedUnion.test.ts
```typescript
import { number, object, property, string, undiscriminatedUnion } from "../../../../src/core/schemas/builders";
import { itSchema, itSchemaIdentity } from "../utils/itSchema";

describe("undiscriminatedUnion", () => {
    itSchemaIdentity(undiscriminatedUnion([string(), number()]), "hello world");

    itSchemaIdentity(undiscriminatedUnion([object({ hello: string() }), object({ goodbye: string() })]), {
        goodbye: "foo",
    });

    itSchema(
        "Correctly transforms",
        undiscriminatedUnion([object({ hello: string() }), object({ helloWorld: property("hello_world", string()) })]),
        {
            raw: { hello_world: "foo " },
            parsed: { helloWorld: "foo " },
        },
    );

    it("Returns errors for all variants", async () => {
        const result = await undiscriminatedUnion([string(), number()]).parse(true);
        if (result.ok) {
            throw new Error("Unexpectedly passed validation");
        }
        expect(result.errors).toEqual([
            {
                message: "[Variant 0] Expected string. Received true.",
                path: [],
            },
            {
                message: "[Variant 1] Expected number. Received true.",
                path: [],
            },
        ]);
    });

    describe("compile", () => {
        // eslint-disable-next-line vi/expect-expect
        it("doesn't compile with zero members", () => {
            // @ts-expect-error
            () => undiscriminatedUnion([]);
        });
    });
});

```


## /tests/unit/schemas/union/union.test.ts
```typescript
import { boolean, discriminant, number, object, string, union } from "../../../../src/core/schemas/builders";
import { itSchema, itSchemaIdentity } from "../utils/itSchema";
import { itValidate } from "../utils/itValidate";

describe("union", () => {
    itSchemaIdentity(
        union("type", {
            lion: object({
                meows: boolean(),
            }),
            giraffe: object({
                heightInInches: number(),
            }),
        }),
        { type: "lion", meows: true },
        { title: "doesn't transform discriminant when it's a string" },
    );

    itSchema(
        "transforms discriminant when it's a discriminant()",
        union(discriminant("type", "_type"), {
            lion: object({ meows: boolean() }),
            giraffe: object({ heightInInches: number() }),
        }),
        {
            raw: { _type: "lion", meows: true },
            parsed: { type: "lion", meows: true },
        },
    );

    describe("allowUnrecognizedUnionMembers", () => {
        itSchema(
            "transforms discriminant & passes through values when discriminant value is unrecognized",
            union(discriminant("type", "_type"), {
                lion: object({ meows: boolean() }),
                giraffe: object({ heightInInches: number() }),
            }),
            {
                // @ts-expect-error
                raw: { _type: "moose", isAMoose: true },
                // @ts-expect-error
                parsed: { type: "moose", isAMoose: true },
                opts: {
                    allowUnrecognizedUnionMembers: true,
                },
            },
        );
    });

    describe("withParsedProperties", () => {
        it("Added property is included on parsed object", async () => {
            const schema = union("type", {
                lion: object({}),
                tiger: object({ value: string() }),
            }).withParsedProperties({
                printType: (parsed) => () => parsed.type,
            });

            const parsed = await schema.parse({ type: "lion" });
            if (!parsed.ok) {
                throw new Error("Failed to parse");
            }
            expect(parsed.value.printType()).toBe("lion");
        });
    });

    itValidate(
        "non-object",
        union("type", {
            lion: object({}),
            tiger: object({ value: string() }),
        }),
        [],
        [
            {
                path: [],
                message: "Expected object. Received list.",
            },
        ],
    );

    itValidate(
        "missing discriminant",
        union("type", {
            lion: object({}),
            tiger: object({ value: string() }),
        }),
        {},
        [
            {
                path: [],
                message: 'Missing discriminant ("type")',
            },
        ],
    );

    itValidate(
        "unrecognized discriminant value",
        union("type", {
            lion: object({}),
            tiger: object({ value: string() }),
        }),
        {
            type: "bear",
        },
        [
            {
                path: ["type"],
                message: 'Expected enum. Received "bear".',
            },
        ],
    );
});

```


## /tests/unit/schemas/utils/itSchema.ts
```typescript
/* eslint-disable vi/no-export */
import type { Schema, SchemaOptions } from "../../../../src/core/schemas/Schema";

export function itSchemaIdentity<T>(
    schema: Schema<T, T>,
    value: T,
    { title = "functions as identity", opts }: { title?: string; opts?: SchemaOptions } = {},
): void {
    itSchema(title, schema, { raw: value, parsed: value, opts });
}

export function itSchema<Raw, Parsed>(
    title: string,
    schema: Schema<Raw, Parsed>,
    {
        raw,
        parsed,
        opts,
        only = false,
    }: {
        raw: Raw;
        parsed: Parsed;
        opts?: SchemaOptions;
        only?: boolean;
    },
): void {
    // eslint-disable-next-line vi/valid-title
    (only ? describe.only : describe)(title, () => {
        itParse("parse()", schema, { raw, parsed, opts });
        itJson("json()", schema, { raw, parsed, opts });
    });
}

export function itParse<Raw, Parsed>(
    title: string,
    schema: Schema<Raw, Parsed>,
    {
        raw,
        parsed,
        opts,
    }: {
        raw: Raw;
        parsed: Parsed;
        opts?: SchemaOptions;
    },
): void {
    // eslint-disable-next-line vi/valid-title
    it(title, () => {
        const maybeValid = schema.parse(raw, opts);
        if (!maybeValid.ok) {
            throw new Error(`Failed to parse() ${JSON.stringify(maybeValid.errors, undefined, 4)}`);
        }
        expect(maybeValid.value).toStrictEqual(parsed);
    });
}

export function itJson<Raw, Parsed>(
    title: string,
    schema: Schema<Raw, Parsed>,
    {
        raw,
        parsed,
        opts,
    }: {
        raw: Raw;
        parsed: Parsed;
        opts?: SchemaOptions;
    },
): void {
    // eslint-disable-next-line vi/valid-title
    it(title, () => {
        const maybeValid = schema.json(parsed, opts);
        if (!maybeValid.ok) {
            throw new Error(`Failed to json() ${JSON.stringify(maybeValid.errors, undefined, 4)}`);
        }
        expect(maybeValid.value).toStrictEqual(raw);
    });
}

```


## /tests/unit/schemas/utils/itValidate.ts
```typescript
/* eslint-disable vi/no-export */
import type { Schema, SchemaOptions, ValidationError } from "../../../../src/core/schemas/Schema";

export function itValidate<Raw, Parsed>(
    title: string,
    schema: Schema<Raw, Parsed>,
    input: unknown,
    errors: ValidationError[],
    opts?: SchemaOptions,
): void {
    // eslint-disable-next-line vi/valid-title
    describe("parse()", () => {
        itValidateParse(title, schema, input, errors, opts);
    });
    describe("json()", () => {
        itValidateJson(title, schema, input, errors, opts);
    });
}

export function itValidateParse<Raw, Parsed>(
    title: string,
    schema: Schema<Raw, Parsed>,
    raw: unknown,
    errors: ValidationError[],
    opts?: SchemaOptions,
): void {
    describe("parse", () => {
        // eslint-disable-next-line vi/valid-title
        it(title, async () => {
            const maybeValid = await schema.parse(raw, opts);
            if (maybeValid.ok) {
                throw new Error("Value passed validation");
            }
            expect(maybeValid.errors).toStrictEqual(errors);
        });
    });
}

export function itValidateJson<Raw, Parsed>(
    title: string,
    schema: Schema<Raw, Parsed>,
    parsed: unknown,
    errors: ValidationError[],
    opts?: SchemaOptions,
): void {
    describe("json", () => {
        // eslint-disable-next-line vi/valid-title
        it(title, async () => {
            const maybeValid = await schema.json(parsed, opts);
            if (maybeValid.ok) {
                throw new Error("Value passed validation");
            }
            expect(maybeValid.errors).toStrictEqual(errors);
        });
    });
}

```


## /tests/unit/stream/Stream.test.ts
```typescript
import { Stream } from "../../../src/core/stream/Stream";

describe("Stream", () => {
    describe("JSON streaming", () => {
        it("should parse single JSON message", async () => {
            const mockStream = createReadableStream(['{"value": 1}\n']);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "json", messageTerminator: "\n" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ value: 1 }]);
        });

        it("should parse multiple JSON messages", async () => {
            const mockStream = createReadableStream(['{"value": 1}\n{"value": 2}\n{"value": 3}\n']);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "json", messageTerminator: "\n" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ value: 1 }, { value: 2 }, { value: 3 }]);
        });

        it("should handle messages split across chunks", async () => {
            const mockStream = createReadableStream(['{"val', 'ue": 1}\n{"value":', " 2}\n"]);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "json", messageTerminator: "\n" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ value: 1 }, { value: 2 }]);
        });

        it("should skip empty lines", async () => {
            const mockStream = createReadableStream(['{"value": 1}\n\n\n{"value": 2}\n']);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "json", messageTerminator: "\n" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ value: 1 }, { value: 2 }]);
        });

        it("should handle custom message terminator", async () => {
            const mockStream = createReadableStream(['{"value": 1}|||{"value": 2}|||']);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "json", messageTerminator: "|||" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ value: 1 }, { value: 2 }]);
        });
    });

    describe("SSE streaming", () => {
        it("should parse SSE data with prefix", async () => {
            const mockStream = createReadableStream(['data: {"value": 1}\n']);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "sse" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ value: 1 }]);
        });

        it("should parse multiple SSE events", async () => {
            const mockStream = createReadableStream(['data: {"value": 1}\ndata: {"value": 2}\ndata: {"value": 3}\n']);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "sse" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ value: 1 }, { value: 2 }, { value: 3 }]);
        });

        it("should stop at stream terminator", async () => {
            const mockStream = createReadableStream(['data: {"value": 1}\ndata: [DONE]\ndata: {"value": 2}\n']);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "sse", streamTerminator: "[DONE]" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ value: 1 }]);
        });

        it("should skip lines without data prefix", async () => {
            const mockStream = createReadableStream([
                'event: message\ndata: {"value": 1}\nid: 123\ndata: {"value": 2}\n',
            ]);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "sse" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ value: 1 }, { value: 2 }]);
        });
    });

    describe("encoding and decoding", () => {
        it("should decode UTF-8 text using TextDecoder", async () => {
            const encoder = new TextEncoder();
            const mockStream = createReadableStream([encoder.encode('{"text": "café"}\n')]);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { text: string },
                eventShape: { type: "json", messageTerminator: "\n" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ text: "café" }]);
        });

        it("should decode emoji correctly", async () => {
            const encoder = new TextEncoder();
            const mockStream = createReadableStream([encoder.encode('{"emoji": "🎉"}\n')]);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { emoji: string },
                eventShape: { type: "json", messageTerminator: "\n" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ emoji: "🎉" }]);
        });

        it("should handle binary data chunks", async () => {
            const encoder = new TextEncoder();
            const mockStream = createReadableStream([encoder.encode('{"val'), encoder.encode('ue": 1}\n')]);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "json", messageTerminator: "\n" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ value: 1 }]);
        });

        it("should handle multi-byte UTF-8 characters split across chunk boundaries", async () => {
            // Test string with Japanese (3 bytes), Russian (2 bytes), German (2 bytes), and Chinese (3 bytes)
            const testString = '{"text": "こんにちは Привет Größe 你好"}\n';
            const fullBytes = new TextEncoder().encode(testString);

            // Split the bytes in the middle of multi-byte characters
            // Japanese "こ" starts at byte 11, is 3 bytes (E3 81 93)
            // Split after first byte of "こ" to test mid-character splitting
            const splitPoint = 12; // This splits "こ" in the middle
            const chunk1 = fullBytes.slice(0, splitPoint);
            const chunk2 = fullBytes.slice(splitPoint);

            const mockStream = createReadableStream([chunk1, chunk2]);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { text: string },
                eventShape: { type: "json", messageTerminator: "\n" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ text: "こんにちは Привет Größe 你好" }]);
        });
    });

    describe("abort signal", () => {
        it("should handle abort signal", async () => {
            const controller = new AbortController();
            const mockStream = createReadableStream(['{"value": 1}\n{"value": 2}\n{"value": 3}\n']);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "json", messageTerminator: "\n" },
                signal: controller.signal,
            });

            const messages: unknown[] = [];
            let count = 0;
            for await (const message of stream) {
                messages.push(message);
                count++;
                if (count === 2) {
                    controller.abort();
                    break;
                }
            }

            expect(messages.length).toBe(2);
        });
    });

    describe("async iteration", () => {
        it("should support async iterator protocol", async () => {
            const mockStream = createReadableStream(['{"value": 1}\n{"value": 2}\n']);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "json", messageTerminator: "\n" },
            });

            const iterator = stream[Symbol.asyncIterator]();
            const first = await iterator.next();
            expect(first.done).toBe(false);
            expect(first.value).toEqual({ value: 1 });

            const second = await iterator.next();
            expect(second.done).toBe(false);
            expect(second.value).toEqual({ value: 2 });

            const third = await iterator.next();
            expect(third.done).toBe(true);
        });
    });

    describe("edge cases", () => {
        it("should handle empty stream", async () => {
            const mockStream = createReadableStream([]);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "json", messageTerminator: "\n" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([]);
        });

        it("should handle stream with only whitespace", async () => {
            const mockStream = createReadableStream(["   \n\n\t\n   "]);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "json", messageTerminator: "\n" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([]);
        });

        it("should handle incomplete message at end of stream", async () => {
            const mockStream = createReadableStream(['{"value": 1}\n{"incomplete']);
            const stream = new Stream({
                stream: mockStream,
                parse: async (val: unknown) => val as { value: number },
                eventShape: { type: "json", messageTerminator: "\n" },
            });

            const messages: unknown[] = [];
            for await (const message of stream) {
                messages.push(message);
            }

            expect(messages).toEqual([{ value: 1 }]);
        });
    });
});

// Helper function to create a ReadableStream from string chunks
function createReadableStream(chunks: (string | Uint8Array)[]): ReadableStream {
    // For standard type, return ReadableStream
    let index = 0;
    return new ReadableStream({
        pull(controller) {
            if (index < chunks.length) {
                const chunk = chunks[index++];
                controller.enqueue(typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk);
            } else {
                controller.close();
            }
        },
    });
}

```


## /tests/unit/test-file.txt
```txt
This is a test file!

```


## /tests/unit/url/join.test.ts
```typescript
import { join } from "../../../src/core/url/index";

describe("join", () => {
    interface TestCase {
        description: string;
        base: string;
        segments: string[];
        expected: string;
    }

    describe("basic functionality", () => {
        const basicTests: TestCase[] = [
            { description: "should return empty string for empty base", base: "", segments: [], expected: "" },
            {
                description: "should return empty string for empty base with path",
                base: "",
                segments: ["path"],
                expected: "",
            },
            {
                description: "should handle single segment",
                base: "base",
                segments: ["segment"],
                expected: "base/segment",
            },
            {
                description: "should handle single segment with trailing slash on base",
                base: "base/",
                segments: ["segment"],
                expected: "base/segment",
            },
            {
                description: "should handle single segment with leading slash",
                base: "base",
                segments: ["/segment"],
                expected: "base/segment",
            },
            {
                description: "should handle single segment with both slashes",
                base: "base/",
                segments: ["/segment"],
                expected: "base/segment",
            },
            {
                description: "should handle multiple segments",
                base: "base",
                segments: ["path1", "path2", "path3"],
                expected: "base/path1/path2/path3",
            },
            {
                description: "should handle multiple segments with slashes",
                base: "base/",
                segments: ["/path1/", "/path2/", "/path3/"],
                expected: "base/path1/path2/path3/",
            },
        ];

        basicTests.forEach(({ description, base, segments, expected }) => {
            it(description, () => {
                expect(join(base, ...segments)).toBe(expected);
            });
        });
    });

    describe("URL handling", () => {
        const urlTests: TestCase[] = [
            {
                description: "should handle absolute URLs",
                base: "https://example.com",
                segments: ["api", "v1"],
                expected: "https://example.com/api/v1",
            },
            {
                description: "should handle absolute URLs with slashes",
                base: "https://example.com/",
                segments: ["/api/", "/v1/"],
                expected: "https://example.com/api/v1/",
            },
            {
                description: "should handle absolute URLs with base path",
                base: "https://example.com/base",
                segments: ["api", "v1"],
                expected: "https://example.com/base/api/v1",
            },
            {
                description: "should preserve URL query parameters",
                base: "https://example.com?query=1",
                segments: ["api"],
                expected: "https://example.com/api?query=1",
            },
            {
                description: "should preserve URL fragments",
                base: "https://example.com#fragment",
                segments: ["api"],
                expected: "https://example.com/api#fragment",
            },
            {
                description: "should preserve URL query and fragments",
                base: "https://example.com?query=1#fragment",
                segments: ["api"],
                expected: "https://example.com/api?query=1#fragment",
            },
            {
                description: "should handle http protocol",
                base: "http://example.com",
                segments: ["api"],
                expected: "http://example.com/api",
            },
            {
                description: "should handle ftp protocol",
                base: "ftp://example.com",
                segments: ["files"],
                expected: "ftp://example.com/files",
            },
            {
                description: "should handle ws protocol",
                base: "ws://example.com",
                segments: ["socket"],
                expected: "ws://example.com/socket",
            },
            {
                description: "should fallback to path joining for malformed URLs",
                base: "not-a-url://",
                segments: ["path"],
                expected: "not-a-url:///path",
            },
        ];

        urlTests.forEach(({ description, base, segments, expected }) => {
            it(description, () => {
                expect(join(base, ...segments)).toBe(expected);
            });
        });
    });

    describe("edge cases", () => {
        const edgeCaseTests: TestCase[] = [
            {
                description: "should handle empty segments",
                base: "base",
                segments: ["", "path"],
                expected: "base/path",
            },
            {
                description: "should handle null segments",
                base: "base",
                segments: [null as any, "path"],
                expected: "base/path",
            },
            {
                description: "should handle undefined segments",
                base: "base",
                segments: [undefined as any, "path"],
                expected: "base/path",
            },
            {
                description: "should handle segments with only single slash",
                base: "base",
                segments: ["/", "path"],
                expected: "base/path",
            },
            {
                description: "should handle segments with only double slash",
                base: "base",
                segments: ["//", "path"],
                expected: "base/path",
            },
            {
                description: "should handle base paths with trailing slashes",
                base: "base/",
                segments: ["path"],
                expected: "base/path",
            },
            {
                description: "should handle complex nested paths",
                base: "api/v1/",
                segments: ["/users/", "/123/", "/profile"],
                expected: "api/v1/users/123/profile",
            },
        ];

        edgeCaseTests.forEach(({ description, base, segments, expected }) => {
            it(description, () => {
                expect(join(base, ...segments)).toBe(expected);
            });
        });
    });

    describe("real-world scenarios", () => {
        const realWorldTests: TestCase[] = [
            {
                description: "should handle API endpoint construction",
                base: "https://api.example.com/v1",
                segments: ["users", "123", "posts"],
                expected: "https://api.example.com/v1/users/123/posts",
            },
            {
                description: "should handle file path construction",
                base: "/var/www",
                segments: ["html", "assets", "images"],
                expected: "/var/www/html/assets/images",
            },
            {
                description: "should handle relative path construction",
                base: "../parent",
                segments: ["child", "grandchild"],
                expected: "../parent/child/grandchild",
            },
            {
                description: "should handle Windows-style paths",
                base: "C:\\Users",
                segments: ["Documents", "file.txt"],
                expected: "C:\\Users/Documents/file.txt",
            },
        ];

        realWorldTests.forEach(({ description, base, segments, expected }) => {
            it(description, () => {
                expect(join(base, ...segments)).toBe(expected);
            });
        });
    });

    describe("performance scenarios", () => {
        it("should handle many segments efficiently", () => {
            const segments = Array(100).fill("segment");
            const result = join("base", ...segments);
            expect(result).toBe(`base/${segments.join("/")}`);
        });

        it("should handle long URLs", () => {
            const longPath = "a".repeat(1000);
            expect(join("https://example.com", longPath)).toBe(`https://example.com/${longPath}`);
        });
    });

    describe("trailing slash preservation", () => {
        const trailingSlashTests: TestCase[] = [
            {
                description:
                    "should preserve trailing slash on final result when base has trailing slash and no segments",
                base: "https://api.example.com/",
                segments: [],
                expected: "https://api.example.com/",
            },
            {
                description: "should preserve trailing slash on v1 path",
                base: "https://api.example.com/v1/",
                segments: [],
                expected: "https://api.example.com/v1/",
            },
            {
                description: "should preserve trailing slash when last segment has trailing slash",
                base: "https://api.example.com",
                segments: ["users/"],
                expected: "https://api.example.com/users/",
            },
            {
                description: "should preserve trailing slash with relative path",
                base: "api/v1",
                segments: ["users/"],
                expected: "api/v1/users/",
            },
            {
                description: "should preserve trailing slash with multiple segments",
                base: "https://api.example.com",
                segments: ["v1", "collections/"],
                expected: "https://api.example.com/v1/collections/",
            },
            {
                description: "should preserve trailing slash with base path",
                base: "base",
                segments: ["path1", "path2/"],
                expected: "base/path1/path2/",
            },
        ];

        trailingSlashTests.forEach(({ description, base, segments, expected }) => {
            it(description, () => {
                expect(join(base, ...segments)).toBe(expected);
            });
        });
    });
});

```


## /tests/unit/url/qs.test.ts
```typescript
import { toQueryString } from "../../../src/core/url/index";

describe("Test qs toQueryString", () => {
    interface BasicTestCase {
        description: string;
        input: any;
        expected: string;
    }

    describe("Basic functionality", () => {
        const basicTests: BasicTestCase[] = [
            { description: "should return empty string for null", input: null, expected: "" },
            { description: "should return empty string for undefined", input: undefined, expected: "" },
            { description: "should return empty string for string primitive", input: "hello", expected: "" },
            { description: "should return empty string for number primitive", input: 42, expected: "" },
            { description: "should return empty string for true boolean", input: true, expected: "" },
            { description: "should return empty string for false boolean", input: false, expected: "" },
            { description: "should handle empty objects", input: {}, expected: "" },
            {
                description: "should handle simple key-value pairs",
                input: { name: "John", age: 30 },
                expected: "name=John&age=30",
            },
        ];

        basicTests.forEach(({ description, input, expected }) => {
            it(description, () => {
                expect(toQueryString(input)).toBe(expected);
            });
        });
    });

    describe("Array handling", () => {
        interface ArrayTestCase {
            description: string;
            input: any;
            options?: { arrayFormat?: "repeat" | "indices" };
            expected: string;
        }

        const arrayTests: ArrayTestCase[] = [
            {
                description: "should handle arrays with indices format (default)",
                input: { items: ["a", "b", "c"] },
                expected: "items%5B0%5D=a&items%5B1%5D=b&items%5B2%5D=c",
            },
            {
                description: "should handle arrays with repeat format",
                input: { items: ["a", "b", "c"] },
                options: { arrayFormat: "repeat" },
                expected: "items=a&items=b&items=c",
            },
            {
                description: "should handle empty arrays",
                input: { items: [] },
                expected: "",
            },
            {
                description: "should handle arrays with mixed types",
                input: { mixed: ["string", 42, true, false] },
                expected: "mixed%5B0%5D=string&mixed%5B1%5D=42&mixed%5B2%5D=true&mixed%5B3%5D=false",
            },
            {
                description: "should handle arrays with objects",
                input: { users: [{ name: "John" }, { name: "Jane" }] },
                expected: "users%5B0%5D%5Bname%5D=John&users%5B1%5D%5Bname%5D=Jane",
            },
            {
                description: "should handle arrays with objects in repeat format",
                input: { users: [{ name: "John" }, { name: "Jane" }] },
                options: { arrayFormat: "repeat" },
                expected: "users%5Bname%5D=John&users%5Bname%5D=Jane",
            },
        ];

        arrayTests.forEach(({ description, input, options, expected }) => {
            it(description, () => {
                expect(toQueryString(input, options)).toBe(expected);
            });
        });
    });

    describe("Nested objects", () => {
        const nestedTests: BasicTestCase[] = [
            {
                description: "should handle nested objects",
                input: { user: { name: "John", age: 30 } },
                expected: "user%5Bname%5D=John&user%5Bage%5D=30",
            },
            {
                description: "should handle deeply nested objects",
                input: { user: { profile: { name: "John", settings: { theme: "dark" } } } },
                expected: "user%5Bprofile%5D%5Bname%5D=John&user%5Bprofile%5D%5Bsettings%5D%5Btheme%5D=dark",
            },
            {
                description: "should handle empty nested objects",
                input: { user: {} },
                expected: "",
            },
        ];

        nestedTests.forEach(({ description, input, expected }) => {
            it(description, () => {
                expect(toQueryString(input)).toBe(expected);
            });
        });
    });

    describe("Encoding", () => {
        interface EncodingTestCase {
            description: string;
            input: any;
            options?: { encode?: boolean };
            expected: string;
        }

        const encodingTests: EncodingTestCase[] = [
            {
                description: "should encode by default",
                input: { name: "John Doe", email: "john@example.com" },
                expected: "name=John%20Doe&email=john%40example.com",
            },
            {
                description: "should not encode when encode is false",
                input: { name: "John Doe", email: "john@example.com" },
                options: { encode: false },
                expected: "name=John Doe&email=john@example.com",
            },
            {
                description: "should encode special characters in keys",
                input: { "user name": "John", "email[primary]": "john@example.com" },
                expected: "user%20name=John&email%5Bprimary%5D=john%40example.com",
            },
            {
                description: "should not encode special characters in keys when encode is false",
                input: { "user name": "John", "email[primary]": "john@example.com" },
                options: { encode: false },
                expected: "user name=John&email[primary]=john@example.com",
            },
        ];

        encodingTests.forEach(({ description, input, options, expected }) => {
            it(description, () => {
                expect(toQueryString(input, options)).toBe(expected);
            });
        });
    });

    describe("Mixed scenarios", () => {
        interface MixedTestCase {
            description: string;
            input: any;
            options?: { arrayFormat?: "repeat" | "indices" };
            expected: string;
        }

        const mixedTests: MixedTestCase[] = [
            {
                description: "should handle complex nested structures",
                input: {
                    filters: {
                        status: ["active", "pending"],
                        category: {
                            type: "electronics",
                            subcategories: ["phones", "laptops"],
                        },
                    },
                    sort: { field: "name", direction: "asc" },
                },
                expected:
                    "filters%5Bstatus%5D%5B0%5D=active&filters%5Bstatus%5D%5B1%5D=pending&filters%5Bcategory%5D%5Btype%5D=electronics&filters%5Bcategory%5D%5Bsubcategories%5D%5B0%5D=phones&filters%5Bcategory%5D%5Bsubcategories%5D%5B1%5D=laptops&sort%5Bfield%5D=name&sort%5Bdirection%5D=asc",
            },
            {
                description: "should handle complex nested structures with repeat format",
                input: {
                    filters: {
                        status: ["active", "pending"],
                        category: {
                            type: "electronics",
                            subcategories: ["phones", "laptops"],
                        },
                    },
                    sort: { field: "name", direction: "asc" },
                },
                options: { arrayFormat: "repeat" },
                expected:
                    "filters%5Bstatus%5D=active&filters%5Bstatus%5D=pending&filters%5Bcategory%5D%5Btype%5D=electronics&filters%5Bcategory%5D%5Bsubcategories%5D=phones&filters%5Bcategory%5D%5Bsubcategories%5D=laptops&sort%5Bfield%5D=name&sort%5Bdirection%5D=asc",
            },
            {
                description: "should handle arrays with null/undefined values",
                input: { items: ["a", null, "c", undefined, "e"] },
                expected: "items%5B0%5D=a&items%5B1%5D=&items%5B2%5D=c&items%5B4%5D=e",
            },
            {
                description: "should handle objects with null/undefined values",
                input: { name: "John", age: null, email: undefined, active: true },
                expected: "name=John&age=&active=true",
            },
        ];

        mixedTests.forEach(({ description, input, options, expected }) => {
            it(description, () => {
                expect(toQueryString(input, options)).toBe(expected);
            });
        });
    });

    describe("Edge cases", () => {
        const edgeCaseTests: BasicTestCase[] = [
            {
                description: "should handle numeric keys",
                input: { "0": "zero", "1": "one" },
                expected: "0=zero&1=one",
            },
            {
                description: "should handle boolean values in objects",
                input: { enabled: true, disabled: false },
                expected: "enabled=true&disabled=false",
            },
            {
                description: "should handle empty strings",
                input: { name: "", description: "test" },
                expected: "name=&description=test",
            },
            {
                description: "should handle zero values",
                input: { count: 0, price: 0.0 },
                expected: "count=0&price=0",
            },
            {
                description: "should handle arrays with empty strings",
                input: { items: ["a", "", "c"] },
                expected: "items%5B0%5D=a&items%5B1%5D=&items%5B2%5D=c",
            },
        ];

        edgeCaseTests.forEach(({ description, input, expected }) => {
            it(description, () => {
                expect(toQueryString(input)).toBe(expected);
            });
        });
    });

    describe("Options combinations", () => {
        interface OptionsTestCase {
            description: string;
            input: any;
            options?: { arrayFormat?: "repeat" | "indices"; encode?: boolean };
            expected: string;
        }

        const optionsTests: OptionsTestCase[] = [
            {
                description: "should respect both arrayFormat and encode options",
                input: { items: ["a & b", "c & d"] },
                options: { arrayFormat: "repeat", encode: false },
                expected: "items=a & b&items=c & d",
            },
            {
                description: "should use default options when none provided",
                input: { items: ["a", "b"] },
                expected: "items%5B0%5D=a&items%5B1%5D=b",
            },
            {
                description: "should merge provided options with defaults",
                input: { items: ["a", "b"], name: "John Doe" },
                options: { encode: false },
                expected: "items[0]=a&items[1]=b&name=John Doe",
            },
        ];

        optionsTests.forEach(({ description, input, options, expected }) => {
            it(description, () => {
                expect(toQueryString(input, options)).toBe(expected);
            });
        });
    });
});

```


## /tests/unit/utils/setObjectProperty.test.ts
```typescript
import { setObjectProperty } from "../../../src/core/utils/setObjectProperty";

interface TestCase {
    description: string;
    giveObject: object;
    givePath: string;
    giveValue: any;
    wantObject: object;
}

describe("Test setObjectProperty", () => {
    const testCases: TestCase[] = [
        {
            description: "empty",
            giveObject: {},
            givePath: "",
            giveValue: 0,
            wantObject: { "": 0 },
        },
        {
            description: "top-level primitive",
            giveObject: {},
            givePath: "age",
            giveValue: 42,
            wantObject: { age: 42 },
        },
        {
            description: "top-level object",
            giveObject: {},
            givePath: "name",
            giveValue: { first: "John", last: "Doe" },
            wantObject: { name: { first: "John", last: "Doe" } },
        },
        {
            description: "top-level array",
            giveObject: {},
            givePath: "values",
            giveValue: [1, 2, 3],
            wantObject: { values: [1, 2, 3] },
        },
        {
            description: "nested object property",
            giveObject: {
                name: {
                    first: "John",
                },
            },
            givePath: "name.last",
            giveValue: "Doe",
            wantObject: { name: { first: "John", last: "Doe" } },
        },
        {
            description: "deeply nested object property",
            giveObject: {
                info: {
                    address: {
                        street: "123 Main St.",
                    },
                    age: 42,
                    name: {
                        last: "Doe",
                    },
                },
            },
            givePath: "info.name.first",
            giveValue: "John",
            wantObject: {
                info: { age: 42, address: { street: "123 Main St." }, name: { first: "John", last: "Doe" } },
            },
        },
    ];
    test.each(testCases)("$description", ({ giveObject, givePath, giveValue, wantObject }) => {
        const result = setObjectProperty(giveObject, givePath, giveValue);
        expect(result).toEqual(wantObject);
    });
});

```


## /tests/wire/.gitkeep
```gitkeep
[Empty File: /tests/wire/.gitkeep]
```


## /tests/wire/empathic-voice/chatGroups.test.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import * as Hume from "../../../src/api/index";
import { HumeClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("ChatGroupsClient", () => {
    test("list-chat-groups (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            page_number: 0,
            page_size: 1,
            total_pages: 1,
            pagination_direction: "ASC",
            chat_groups_page: [
                {
                    id: "697056f0-6c7e-487d-9bd8-9c19df79f05f",
                    first_start_timestamp: 1721844196397,
                    most_recent_start_timestamp: 1721861821717,
                    active: false,
                    most_recent_chat_id: "dfdbdd4d-0ddf-418b-8fc4-80a266579d36",
                    num_chats: 5,
                },
            ],
        };
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/chat_groups")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const expected = {
            pageNumber: 0,
            pageSize: 1,
            totalPages: 1,
            paginationDirection: "ASC",
            chatGroupsPage: [
                {
                    id: "697056f0-6c7e-487d-9bd8-9c19df79f05f",
                    firstStartTimestamp: 1721844196397,
                    mostRecentStartTimestamp: 1721861821717,
                    active: false,
                    mostRecentChatId: "dfdbdd4d-0ddf-418b-8fc4-80a266579d36",
                    numChats: 5,
                },
            ],
        };
        const page = await client.empathicVoice.chatGroups.listChatGroups({
            pageNumber: 0,
            pageSize: 1,
            ascendingOrder: true,
            configId: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
        });

        expect(expected.chatGroupsPage).toEqual(page.data);
        expect(page.hasNextPage()).toBe(true);
        const nextPage = await page.getNextPage();
        expect(expected.chatGroupsPage).toEqual(nextPage.data);
    });

    test("list-chat-groups (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/chat_groups")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.chatGroups.listChatGroups();
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("get-chat-group (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            id: "369846cf-6ad5-404d-905e-a8acb5cdfc78",
            first_start_timestamp: 1712334213647,
            most_recent_start_timestamp: 1712334213647,
            num_chats: 1,
            page_number: 0,
            page_size: 1,
            total_pages: 1,
            pagination_direction: "ASC",
            chats_page: [
                {
                    id: "6375d4f8-cd3e-4d6b-b13b-ace66b7c8aaa",
                    chat_group_id: "369846cf-6ad5-404d-905e-a8acb5cdfc78",
                    status: "USER_ENDED",
                    start_timestamp: 1712334213647,
                    end_timestamp: 1712334332571,
                    event_count: 0,
                },
            ],
            active: false,
        };
        server
            .mockEndpoint()
            .get("/v0/evi/chat_groups/697056f0-6c7e-487d-9bd8-9c19df79f05f")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.chatGroups.getChatGroup("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
            pageNumber: 0,
            pageSize: 1,
            ascendingOrder: true,
        });
        expect(response).toEqual({
            id: "369846cf-6ad5-404d-905e-a8acb5cdfc78",
            firstStartTimestamp: 1712334213647,
            mostRecentStartTimestamp: 1712334213647,
            numChats: 1,
            pageNumber: 0,
            pageSize: 1,
            totalPages: 1,
            paginationDirection: "ASC",
            chatsPage: [
                {
                    id: "6375d4f8-cd3e-4d6b-b13b-ace66b7c8aaa",
                    chatGroupId: "369846cf-6ad5-404d-905e-a8acb5cdfc78",
                    status: "USER_ENDED",
                    startTimestamp: 1712334213647,
                    endTimestamp: 1712334332571,
                    eventCount: 0,
                },
            ],
            active: false,
        });
    });

    test("get-chat-group (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v0/evi/chat_groups/id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.chatGroups.getChatGroup("id");
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("get-audio (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            id: "369846cf-6ad5-404d-905e-a8acb5cdfc78",
            user_id: "e6235940-cfda-3988-9147-ff531627cf42",
            num_chats: 1,
            page_number: 0,
            page_size: 10,
            total_pages: 1,
            pagination_direction: "ASC",
            audio_reconstructions_page: [
                {
                    id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    user_id: "e6235940-cfda-3988-9147-ff531627cf42",
                    status: "COMPLETE",
                    filename:
                        "e6235940-cfda-3988-9147-ff531627cf42/470a49f6-1dec-4afe-8b61-035d3b2d63b0/reconstructed_audio.mp4",
                    modified_at: 1729875432555,
                    signed_audio_url: "https://storage.googleapis.com/...etc.",
                    signed_url_expiration_timestamp_millis: 1730232816964,
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/v0/evi/chat_groups/369846cf-6ad5-404d-905e-a8acb5cdfc78/audio")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.chatGroups.getAudio("369846cf-6ad5-404d-905e-a8acb5cdfc78", {
            pageNumber: 0,
            pageSize: 10,
            ascendingOrder: true,
        });
        expect(response).toEqual({
            id: "369846cf-6ad5-404d-905e-a8acb5cdfc78",
            userId: "e6235940-cfda-3988-9147-ff531627cf42",
            numChats: 1,
            pageNumber: 0,
            pageSize: 10,
            totalPages: 1,
            paginationDirection: "ASC",
            audioReconstructionsPage: [
                {
                    id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    userId: "e6235940-cfda-3988-9147-ff531627cf42",
                    status: "COMPLETE",
                    filename:
                        "e6235940-cfda-3988-9147-ff531627cf42/470a49f6-1dec-4afe-8b61-035d3b2d63b0/reconstructed_audio.mp4",
                    modifiedAt: 1729875432555,
                    signedAudioUrl: "https://storage.googleapis.com/...etc.",
                    signedUrlExpirationTimestampMillis: 1730232816964,
                },
            ],
        });
    });

    test("get-audio (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v0/evi/chat_groups/id/audio")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.chatGroups.getAudio("id");
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("list-chat-group-events (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            id: "697056f0-6c7e-487d-9bd8-9c19df79f05f",
            page_number: 0,
            page_size: 3,
            total_pages: 1,
            pagination_direction: "ASC",
            events_page: [
                {
                    id: "5d44bdbb-49a3-40fb-871d-32bf7e76efe7",
                    chat_id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    timestamp: 1716244940762,
                    role: "SYSTEM",
                    type: "SYSTEM_PROMPT",
                    message_text:
                        "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                    emotion_features: "",
                    metadata: "",
                },
                {
                    id: "5976ddf6-d093-4bb9-ba60-8f6c25832dde",
                    chat_id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    timestamp: 1716244956278,
                    role: "USER",
                    type: "USER_MESSAGE",
                    message_text: "Hello.",
                    emotion_features:
                        '{"Admiration": 0.09906005859375, "Adoration": 0.12213134765625, "Aesthetic Appreciation": 0.05035400390625, "Amusement": 0.16552734375, "Anger": 0.0037384033203125, "Anxiety": 0.010101318359375, "Awe": 0.058197021484375, "Awkwardness": 0.10552978515625, "Boredom": 0.1141357421875, "Calmness": 0.115234375, "Concentration": 0.00444793701171875, "Confusion": 0.0343017578125, "Contemplation": 0.00812530517578125, "Contempt": 0.009002685546875, "Contentment": 0.087158203125, "Craving": 0.00818634033203125, "Desire": 0.018310546875, "Determination": 0.003238677978515625, "Disappointment": 0.024169921875, "Disgust": 0.00702667236328125, "Distress": 0.00936126708984375, "Doubt": 0.00632476806640625, "Ecstasy": 0.0293731689453125, "Embarrassment": 0.01800537109375, "Empathic Pain": 0.0088348388671875, "Entrancement": 0.013397216796875, "Envy": 0.02557373046875, "Excitement": 0.12109375, "Fear": 0.004413604736328125, "Guilt": 0.016571044921875, "Horror": 0.00274658203125, "Interest": 0.2142333984375, "Joy": 0.29638671875, "Love": 0.16015625, "Nostalgia": 0.007843017578125, "Pain": 0.007160186767578125, "Pride": 0.00508880615234375, "Realization": 0.054229736328125, "Relief": 0.048736572265625, "Romance": 0.026397705078125, "Sadness": 0.0265350341796875, "Satisfaction": 0.051361083984375, "Shame": 0.00974273681640625, "Surprise (negative)": 0.0218963623046875, "Surprise (positive)": 0.216064453125, "Sympathy": 0.021728515625, "Tiredness": 0.0173797607421875, "Triumph": 0.004520416259765625}',
                    metadata:
                        '{"segments": [{"content": "Hello.", "embedding": [0.6181640625, 0.1763916015625, -30.921875, 1.2705078125, 0.927734375, 0.63720703125, 2.865234375, 0.1080322265625, 0.2978515625, 1.0107421875, 1.34375, 0.74560546875, 0.416259765625, 0.99462890625, -0.333740234375, 0.361083984375, -1.388671875, 1.0107421875, 1.3173828125, 0.55615234375, 0.541015625, -0.1837158203125, 1.697265625, 0.228515625, 2.087890625, -0.311767578125, 0.053680419921875, 1.3349609375, 0.95068359375, 0.00441741943359375, 0.705078125, 1.8916015625, -0.939453125, 0.93701171875, -0.28955078125, 1.513671875, 0.5595703125, 1.0126953125, -0.1624755859375, 1.4072265625, -0.28857421875, -0.4560546875, -0.1500244140625, -0.1102294921875, -0.222412109375, 0.8779296875, 1.275390625, 1.6689453125, 0.80712890625, -0.34814453125, -0.325439453125, 0.412841796875, 0.81689453125, 0.55126953125, 1.671875, 0.6611328125, 0.7451171875, 1.50390625, 1.0224609375, -1.671875, 0.7373046875, 2.1328125, 2.166015625, 0.41015625, -0.127685546875, 1.9345703125, -4.2734375, 0.332275390625, 0.26171875, 0.76708984375, 0.2685546875, 0.468017578125, 1.208984375, -1.517578125, 1.083984375, 0.84814453125, 1.0244140625, -0.0072174072265625, 1.34375, 1.0712890625, 1.517578125, -0.52001953125, 0.59228515625, 0.8154296875, -0.951171875, -0.07757568359375, 1.3330078125, 1.125, 0.61181640625, 1.494140625, 0.357421875, 1.1796875, 1.482421875, 0.8046875, 0.1536865234375, 1.8076171875, 0.68115234375, -15.171875, 1.2294921875, 0.319091796875, 0.499755859375, 1.5771484375, 0.94677734375, -0.2490234375, 0.88525390625, 3.47265625, 0.75927734375, 0.71044921875, 1.2333984375, 1.4169921875, -0.56640625, -1.8095703125, 1.37109375, 0.428955078125, 1.89453125, -0.39013671875, 0.1734619140625, 1.5595703125, -1.2294921875, 2.552734375, 0.58349609375, 0.2156982421875, -0.00984954833984375, -0.6865234375, -0.0272979736328125, -0.2264404296875, 2.853515625, 1.3896484375, 0.52978515625, 0.783203125, 3.0390625, 0.75537109375, 0.219970703125, 0.384521484375, 0.385986328125, 2.0546875, -0.10443115234375, 1.5146484375, 1.4296875, 1.9716796875, 1.1318359375, 0.31591796875, 0.338623046875, 1.654296875, -0.88037109375, -0.21484375, 1.45703125, 1.0380859375, -0.52294921875, -0.47802734375, 0.1650390625, 1.2392578125, -1.138671875, 0.56787109375, 1.318359375, 0.4287109375, 0.1981201171875, 2.4375, 0.281005859375, 0.89404296875, -0.1552734375, 0.6474609375, -0.08331298828125, 0.00740814208984375, -0.045501708984375, -0.578125, 2.02734375, 0.59228515625, 0.35693359375, 1.2919921875, 1.22265625, 1.0537109375, 0.145263671875, 1.05859375, -0.369140625, 0.207275390625, 0.78857421875, 0.599609375, 0.99072265625, 0.24462890625, 1.26953125, 0.08404541015625, 1.349609375, 0.73291015625, 1.3212890625, 0.388916015625, 1.0869140625, 0.9931640625, -1.5673828125, 0.0462646484375, 0.650390625, 0.253662109375, 0.58251953125, 1.8134765625, 0.8642578125, 2.591796875, 0.7314453125, 0.85986328125, 0.5615234375, 0.9296875, 0.04144287109375, 1.66015625, 1.99609375, 1.171875, 1.181640625, 1.5126953125, 0.0224456787109375, 0.58349609375, -1.4931640625, 0.81884765625, 0.732421875, -0.6455078125, -0.62451171875, 1.7802734375, 0.01526641845703125, -0.423095703125, 0.461669921875, 4.87890625, 1.2392578125, -0.6953125, 0.6689453125, 0.62451171875, -1.521484375, 1.7685546875, 0.810546875, 0.65478515625, 0.26123046875, 1.6396484375, 0.87548828125, 1.7353515625, 2.046875, 1.5634765625, 0.69384765625, 1.375, 0.8916015625, 1.0107421875, 0.1304931640625, 2.009765625, 0.06402587890625, -0.08428955078125, 0.04351806640625, -1.7529296875, 2.02734375, 3.521484375, 0.404541015625, 1.6337890625, -0.276611328125, 0.8837890625, -0.1287841796875, 0.91064453125, 0.8193359375, 0.701171875, 0.036529541015625, 1.26171875, 1.0478515625, -0.1422119140625, 1.0634765625, 0.61083984375, 1.3505859375, 1.208984375, 0.57275390625, 1.3623046875, 2.267578125, 0.484375, 0.9150390625, 0.56787109375, -0.70068359375, 0.27587890625, -0.70654296875, 0.8466796875, 0.57568359375, 1.6162109375, 0.87939453125, 2.248046875, -0.5458984375, 1.7744140625, 1.328125, 1.232421875, 0.6806640625, 0.9365234375, 1.052734375, -1.08984375, 1.8330078125, -0.4033203125, 1.0673828125, 0.297607421875, 1.5703125, 1.67578125, 1.34765625, 2.8203125, 2.025390625, -0.48583984375, 0.7626953125, 0.01007843017578125, 1.435546875, 0.007205963134765625, 0.05157470703125, -0.9853515625, 0.26708984375, 1.16796875, 1.2041015625, 1.99609375, -0.07916259765625, 1.244140625, -0.32080078125, 0.6748046875, 0.419921875, 1.3212890625, 1.291015625, 0.599609375, 0.0550537109375, 0.9599609375, 0.93505859375, 0.111083984375, 1.302734375, 0.0833740234375, 2.244140625, 1.25390625, 1.6015625, 0.58349609375, 1.7568359375, -0.263427734375, -0.019866943359375, -0.24658203125, -0.1871337890625, 0.927734375, 0.62255859375, 0.275146484375, 0.79541015625, 1.1796875, 1.1767578125, -0.26123046875, -0.268310546875, 1.8994140625, 1.318359375, 2.1875, 0.2469482421875, 1.41015625, 0.03973388671875, 1.2685546875, 1.1025390625, 0.9560546875, 0.865234375, -1.92578125, 1.154296875, 0.389892578125, 1.130859375, 0.95947265625, 0.72314453125, 2.244140625, 0.048553466796875, 0.626953125, 0.42919921875, 0.82275390625, 0.311767578125, -0.320556640625, 0.01041412353515625, 0.1483154296875, 0.10809326171875, -0.3173828125, 1.1337890625, -0.8642578125, 1.4033203125, 0.048828125, 1.1787109375, 0.98779296875, 1.818359375, 1.1552734375, 0.6015625, 1.2392578125, -1.2685546875, 0.39208984375, 0.83251953125, 0.224365234375, 0.0019989013671875, 0.87548828125, 1.6572265625, 1.107421875, 0.434814453125, 1.8251953125, 0.442626953125, 1.2587890625, 0.09320068359375, -0.896484375, 1.8017578125, 1.451171875, -0.0755615234375, 0.6083984375, 2.06640625, 0.673828125, -0.33740234375, 0.192138671875, 0.21435546875, 0.80224609375, -1.490234375, 0.9501953125, 0.86083984375, -0.40283203125, 4.109375, 2.533203125, 1.2529296875, 0.8271484375, 0.225830078125, 1.0478515625, -1.9755859375, 0.841796875, 0.392822265625, 0.525390625, 0.33935546875, -0.79443359375, 0.71630859375, 0.97998046875, -0.175537109375, 0.97705078125, 1.705078125, 0.29638671875, 0.68359375, 0.54150390625, 0.435791015625, 0.99755859375, -0.369140625, 1.009765625, -0.140380859375, 0.426513671875, 0.189697265625, 1.8193359375, 1.1201171875, -0.5009765625, -0.331298828125, 0.759765625, -0.09442138671875, 0.74609375, -1.947265625, 1.3544921875, -3.935546875, 2.544921875, 1.359375, 0.1363525390625, 0.79296875, 0.79931640625, -0.3466796875, 1.1396484375, -0.33447265625, 2.0078125, -0.241455078125, 0.6318359375, 0.365234375, 0.296142578125, 0.830078125, 1.0458984375, 0.5830078125, 0.61572265625, 14.0703125, -2.0078125, -0.381591796875, 1.228515625, 0.08282470703125, -0.67822265625, -0.04339599609375, 0.397216796875, 0.1656494140625, 0.137451171875, 0.244873046875, 1.1611328125, -1.3818359375, 0.8447265625, 1.171875, 0.36328125, 0.252685546875, 0.1197509765625, 0.232177734375, -0.020172119140625, 0.64404296875, -0.01100921630859375, -1.9267578125, 0.222412109375, 0.56005859375, 1.3046875, 1.1630859375, 1.197265625, 1.02734375, 1.6806640625, -0.043731689453125, 1.4697265625, 0.81201171875, 1.5390625, 1.240234375, -0.7353515625, 1.828125, 1.115234375, 1.931640625, -0.517578125, 0.77880859375, 1.0546875, 0.95361328125, 3.42578125, 0.0160369873046875, 0.875, 0.56005859375, 1.2421875, 1.986328125, 1.4814453125, 0.0948486328125, 1.115234375, 0.00665283203125, 2.09375, 0.3544921875, -0.52783203125, 1.2099609375, 0.45068359375, 0.65625, 0.1112060546875, 1.0751953125, -0.9521484375, -0.30029296875, 1.4462890625, 2.046875, 3.212890625, 1.68359375, 1.07421875, -0.5263671875, 0.74560546875, 1.37890625, 0.15283203125, 0.2440185546875, 0.62646484375, -0.1280517578125, 0.7646484375, -0.515625, -0.35693359375, 1.2958984375, 0.96923828125, 0.58935546875, 1.3701171875, 1.0673828125, 0.2337646484375, 0.93115234375, 0.66357421875, 6.0, 1.1025390625, -0.51708984375, -0.38330078125, 0.7197265625, 0.246826171875, -0.45166015625, 1.9521484375, 0.5546875, 0.08807373046875, 0.18505859375, 0.8857421875, -0.57177734375, 0.251708984375, 0.234375, 2.57421875, 0.9599609375, 0.5029296875, 0.10382080078125, 0.08331298828125, 0.66748046875, -0.349609375, 1.287109375, 0.259765625, 2.015625, 2.828125, -0.3095703125, -0.164306640625, -0.3408203125, 0.486572265625, 0.8466796875, 1.9130859375, 0.09088134765625, 0.66552734375, 0.00972747802734375, -0.83154296875, 1.755859375, 0.654296875, 0.173828125, 0.27587890625, -0.47607421875, -0.264404296875, 0.7529296875, 0.6533203125, 0.7275390625, 0.499755859375, 0.833984375, -0.44775390625, -0.05078125, -0.454833984375, 0.75439453125, 0.68505859375, 0.210693359375, -0.283935546875, -0.53564453125, 0.96826171875, 0.861328125, -3.33984375, -0.26171875, 0.77734375, 0.26513671875, -0.14111328125, -0.042236328125, -0.84814453125, 0.2137451171875, 0.94921875, 0.65185546875, -0.5380859375, 0.1529541015625, -0.360595703125, -0.0333251953125, -0.69189453125, 0.8974609375, 0.7109375, 0.81494140625, -0.259521484375, 1.1904296875, 0.62158203125, 1.345703125, 0.89404296875, 0.70556640625, 1.0673828125, 1.392578125, 0.5068359375, 0.962890625, 0.736328125, 1.55078125, 0.50390625, -0.398681640625, 2.361328125, 0.345947265625, -0.61962890625, 0.330078125, 0.75439453125, -0.673828125, -0.2379150390625, 1.5673828125, 1.369140625, 0.1119384765625, -0.1834716796875, 1.4599609375, -0.77587890625, 0.5556640625, 0.09954833984375, 0.0285186767578125, 0.58935546875, -0.501953125, 0.212890625, 0.02679443359375, 0.1715087890625, 0.03466796875, -0.564453125, 2.029296875, 2.45703125, -0.72216796875, 2.138671875, 0.50830078125, -0.09356689453125, 0.230224609375, 1.6943359375, 1.5126953125, 0.39453125, 0.411376953125, 1.07421875, -0.8046875, 0.51416015625, 0.2271728515625, -0.283447265625, 0.38427734375, 0.73388671875, 0.6962890625, 1.4990234375, 0.02813720703125, 0.40478515625, 1.2451171875, 1.1162109375, -5.5703125, 0.76171875, 0.322021484375, 1.0361328125, 1.197265625, 0.1163330078125, 0.2425537109375, 1.5595703125, 1.5791015625, -0.0921630859375, 0.484619140625, 1.9052734375, 5.31640625, 1.6337890625, 0.95947265625, -0.1751708984375, 0.466552734375, 0.8330078125, 1.03125, 0.2044677734375, 0.31298828125, -1.1220703125, 0.5517578125, 0.93505859375, 0.45166015625, 1.951171875, 0.65478515625, 1.30859375, 1.0859375, 0.56494140625, 2.322265625, 0.242919921875, 1.81640625, -0.469970703125, -0.841796875, 0.90869140625, 1.5361328125, 0.923828125, 1.0595703125, 0.356689453125, -0.46142578125, 2.134765625, 1.3037109375, -0.32373046875, -9.2265625, 0.4521484375, 0.88037109375, -0.53955078125, 0.96484375, 0.7705078125, 0.84521484375, 1.580078125, -0.1448974609375, 0.7607421875, 1.0166015625, -0.086669921875, 1.611328125, 0.05938720703125, 0.5078125, 0.8427734375, 2.431640625, 0.66357421875, 3.203125, 0.132080078125, 0.461181640625, 0.779296875, 1.9482421875, 1.8720703125, 0.845703125, -1.3837890625, -0.138916015625, 0.35546875, 0.2457275390625, 0.75341796875, 1.828125, 1.4169921875, 0.60791015625, 1.0068359375, 1.109375, 0.484130859375, -0.302001953125, 0.4951171875, 0.802734375, 1.9482421875, 0.916015625, 0.1646728515625, 2.599609375, 1.7177734375, -0.2374267578125, 0.98046875, 0.39306640625, -1.1396484375, 1.6533203125, 0.375244140625], "scores": [0.09906005859375, 0.12213134765625, 0.05035400390625, 0.16552734375, 0.0037384033203125, 0.010101318359375, 0.058197021484375, 0.10552978515625, 0.1141357421875, 0.115234375, 0.00444793701171875, 0.00812530517578125, 0.0343017578125, 0.009002685546875, 0.087158203125, 0.00818634033203125, 0.003238677978515625, 0.024169921875, 0.00702667236328125, 0.00936126708984375, 0.00632476806640625, 0.0293731689453125, 0.01800537109375, 0.0088348388671875, 0.013397216796875, 0.02557373046875, 0.12109375, 0.004413604736328125, 0.016571044921875, 0.00274658203125, 0.2142333984375, 0.29638671875, 0.16015625, 0.007843017578125, 0.007160186767578125, 0.00508880615234375, 0.054229736328125, 0.048736572265625, 0.026397705078125, 0.0265350341796875, 0.051361083984375, 0.018310546875, 0.00974273681640625, 0.0218963623046875, 0.216064453125, 0.021728515625, 0.0173797607421875, 0.004520416259765625], "stoks": [52, 52, 52, 52, 52, 41, 41, 374, 303, 303, 303, 427], "time": {"begin_ms": 640, "end_ms": 1140}}]}',
                },
                {
                    id: "7645a0d1-2e64-410d-83a8-b96040432e9a",
                    chat_id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    timestamp: 1716244957031,
                    role: "AGENT",
                    type: "AGENT_MESSAGE",
                    message_text: "Hello!",
                    emotion_features:
                        '{"Admiration": 0.044921875, "Adoration": 0.0253753662109375, "Aesthetic Appreciation": 0.03265380859375, "Amusement": 0.118408203125, "Anger": 0.06719970703125, "Anxiety": 0.0411376953125, "Awe": 0.03802490234375, "Awkwardness": 0.056549072265625, "Boredom": 0.04217529296875, "Calmness": 0.08709716796875, "Concentration": 0.070556640625, "Confusion": 0.06964111328125, "Contemplation": 0.0343017578125, "Contempt": 0.037689208984375, "Contentment": 0.059417724609375, "Craving": 0.01132965087890625, "Desire": 0.01406097412109375, "Determination": 0.1143798828125, "Disappointment": 0.051177978515625, "Disgust": 0.028594970703125, "Distress": 0.054901123046875, "Doubt": 0.04638671875, "Ecstasy": 0.0258026123046875, "Embarrassment": 0.0222015380859375, "Empathic Pain": 0.015777587890625, "Entrancement": 0.0160980224609375, "Envy": 0.0163421630859375, "Excitement": 0.129638671875, "Fear": 0.03125, "Guilt": 0.01483917236328125, "Horror": 0.0194549560546875, "Interest": 0.1341552734375, "Joy": 0.0738525390625, "Love": 0.0216522216796875, "Nostalgia": 0.0210418701171875, "Pain": 0.020721435546875, "Pride": 0.05499267578125, "Realization": 0.0728759765625, "Relief": 0.04052734375, "Romance": 0.0129241943359375, "Sadness": 0.0254669189453125, "Satisfaction": 0.07159423828125, "Shame": 0.01495361328125, "Surprise (negative)": 0.05560302734375, "Surprise (positive)": 0.07965087890625, "Sympathy": 0.022247314453125, "Tiredness": 0.0194549560546875, "Triumph": 0.04107666015625}',
                    metadata: "",
                },
            ],
        };
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/chat_groups/697056f0-6c7e-487d-9bd8-9c19df79f05f/events")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const expected = {
            id: "697056f0-6c7e-487d-9bd8-9c19df79f05f",
            pageNumber: 0,
            pageSize: 3,
            totalPages: 1,
            paginationDirection: "ASC",
            eventsPage: [
                {
                    id: "5d44bdbb-49a3-40fb-871d-32bf7e76efe7",
                    chatId: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    timestamp: 1716244940762,
                    role: "SYSTEM",
                    type: "SYSTEM_PROMPT",
                    messageText:
                        "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                    emotionFeatures: "",
                    metadata: "",
                },
                {
                    id: "5976ddf6-d093-4bb9-ba60-8f6c25832dde",
                    chatId: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    timestamp: 1716244956278,
                    role: "USER",
                    type: "USER_MESSAGE",
                    messageText: "Hello.",
                    emotionFeatures:
                        '{"Admiration": 0.09906005859375, "Adoration": 0.12213134765625, "Aesthetic Appreciation": 0.05035400390625, "Amusement": 0.16552734375, "Anger": 0.0037384033203125, "Anxiety": 0.010101318359375, "Awe": 0.058197021484375, "Awkwardness": 0.10552978515625, "Boredom": 0.1141357421875, "Calmness": 0.115234375, "Concentration": 0.00444793701171875, "Confusion": 0.0343017578125, "Contemplation": 0.00812530517578125, "Contempt": 0.009002685546875, "Contentment": 0.087158203125, "Craving": 0.00818634033203125, "Desire": 0.018310546875, "Determination": 0.003238677978515625, "Disappointment": 0.024169921875, "Disgust": 0.00702667236328125, "Distress": 0.00936126708984375, "Doubt": 0.00632476806640625, "Ecstasy": 0.0293731689453125, "Embarrassment": 0.01800537109375, "Empathic Pain": 0.0088348388671875, "Entrancement": 0.013397216796875, "Envy": 0.02557373046875, "Excitement": 0.12109375, "Fear": 0.004413604736328125, "Guilt": 0.016571044921875, "Horror": 0.00274658203125, "Interest": 0.2142333984375, "Joy": 0.29638671875, "Love": 0.16015625, "Nostalgia": 0.007843017578125, "Pain": 0.007160186767578125, "Pride": 0.00508880615234375, "Realization": 0.054229736328125, "Relief": 0.048736572265625, "Romance": 0.026397705078125, "Sadness": 0.0265350341796875, "Satisfaction": 0.051361083984375, "Shame": 0.00974273681640625, "Surprise (negative)": 0.0218963623046875, "Surprise (positive)": 0.216064453125, "Sympathy": 0.021728515625, "Tiredness": 0.0173797607421875, "Triumph": 0.004520416259765625}',
                    metadata:
                        '{"segments": [{"content": "Hello.", "embedding": [0.6181640625, 0.1763916015625, -30.921875, 1.2705078125, 0.927734375, 0.63720703125, 2.865234375, 0.1080322265625, 0.2978515625, 1.0107421875, 1.34375, 0.74560546875, 0.416259765625, 0.99462890625, -0.333740234375, 0.361083984375, -1.388671875, 1.0107421875, 1.3173828125, 0.55615234375, 0.541015625, -0.1837158203125, 1.697265625, 0.228515625, 2.087890625, -0.311767578125, 0.053680419921875, 1.3349609375, 0.95068359375, 0.00441741943359375, 0.705078125, 1.8916015625, -0.939453125, 0.93701171875, -0.28955078125, 1.513671875, 0.5595703125, 1.0126953125, -0.1624755859375, 1.4072265625, -0.28857421875, -0.4560546875, -0.1500244140625, -0.1102294921875, -0.222412109375, 0.8779296875, 1.275390625, 1.6689453125, 0.80712890625, -0.34814453125, -0.325439453125, 0.412841796875, 0.81689453125, 0.55126953125, 1.671875, 0.6611328125, 0.7451171875, 1.50390625, 1.0224609375, -1.671875, 0.7373046875, 2.1328125, 2.166015625, 0.41015625, -0.127685546875, 1.9345703125, -4.2734375, 0.332275390625, 0.26171875, 0.76708984375, 0.2685546875, 0.468017578125, 1.208984375, -1.517578125, 1.083984375, 0.84814453125, 1.0244140625, -0.0072174072265625, 1.34375, 1.0712890625, 1.517578125, -0.52001953125, 0.59228515625, 0.8154296875, -0.951171875, -0.07757568359375, 1.3330078125, 1.125, 0.61181640625, 1.494140625, 0.357421875, 1.1796875, 1.482421875, 0.8046875, 0.1536865234375, 1.8076171875, 0.68115234375, -15.171875, 1.2294921875, 0.319091796875, 0.499755859375, 1.5771484375, 0.94677734375, -0.2490234375, 0.88525390625, 3.47265625, 0.75927734375, 0.71044921875, 1.2333984375, 1.4169921875, -0.56640625, -1.8095703125, 1.37109375, 0.428955078125, 1.89453125, -0.39013671875, 0.1734619140625, 1.5595703125, -1.2294921875, 2.552734375, 0.58349609375, 0.2156982421875, -0.00984954833984375, -0.6865234375, -0.0272979736328125, -0.2264404296875, 2.853515625, 1.3896484375, 0.52978515625, 0.783203125, 3.0390625, 0.75537109375, 0.219970703125, 0.384521484375, 0.385986328125, 2.0546875, -0.10443115234375, 1.5146484375, 1.4296875, 1.9716796875, 1.1318359375, 0.31591796875, 0.338623046875, 1.654296875, -0.88037109375, -0.21484375, 1.45703125, 1.0380859375, -0.52294921875, -0.47802734375, 0.1650390625, 1.2392578125, -1.138671875, 0.56787109375, 1.318359375, 0.4287109375, 0.1981201171875, 2.4375, 0.281005859375, 0.89404296875, -0.1552734375, 0.6474609375, -0.08331298828125, 0.00740814208984375, -0.045501708984375, -0.578125, 2.02734375, 0.59228515625, 0.35693359375, 1.2919921875, 1.22265625, 1.0537109375, 0.145263671875, 1.05859375, -0.369140625, 0.207275390625, 0.78857421875, 0.599609375, 0.99072265625, 0.24462890625, 1.26953125, 0.08404541015625, 1.349609375, 0.73291015625, 1.3212890625, 0.388916015625, 1.0869140625, 0.9931640625, -1.5673828125, 0.0462646484375, 0.650390625, 0.253662109375, 0.58251953125, 1.8134765625, 0.8642578125, 2.591796875, 0.7314453125, 0.85986328125, 0.5615234375, 0.9296875, 0.04144287109375, 1.66015625, 1.99609375, 1.171875, 1.181640625, 1.5126953125, 0.0224456787109375, 0.58349609375, -1.4931640625, 0.81884765625, 0.732421875, -0.6455078125, -0.62451171875, 1.7802734375, 0.01526641845703125, -0.423095703125, 0.461669921875, 4.87890625, 1.2392578125, -0.6953125, 0.6689453125, 0.62451171875, -1.521484375, 1.7685546875, 0.810546875, 0.65478515625, 0.26123046875, 1.6396484375, 0.87548828125, 1.7353515625, 2.046875, 1.5634765625, 0.69384765625, 1.375, 0.8916015625, 1.0107421875, 0.1304931640625, 2.009765625, 0.06402587890625, -0.08428955078125, 0.04351806640625, -1.7529296875, 2.02734375, 3.521484375, 0.404541015625, 1.6337890625, -0.276611328125, 0.8837890625, -0.1287841796875, 0.91064453125, 0.8193359375, 0.701171875, 0.036529541015625, 1.26171875, 1.0478515625, -0.1422119140625, 1.0634765625, 0.61083984375, 1.3505859375, 1.208984375, 0.57275390625, 1.3623046875, 2.267578125, 0.484375, 0.9150390625, 0.56787109375, -0.70068359375, 0.27587890625, -0.70654296875, 0.8466796875, 0.57568359375, 1.6162109375, 0.87939453125, 2.248046875, -0.5458984375, 1.7744140625, 1.328125, 1.232421875, 0.6806640625, 0.9365234375, 1.052734375, -1.08984375, 1.8330078125, -0.4033203125, 1.0673828125, 0.297607421875, 1.5703125, 1.67578125, 1.34765625, 2.8203125, 2.025390625, -0.48583984375, 0.7626953125, 0.01007843017578125, 1.435546875, 0.007205963134765625, 0.05157470703125, -0.9853515625, 0.26708984375, 1.16796875, 1.2041015625, 1.99609375, -0.07916259765625, 1.244140625, -0.32080078125, 0.6748046875, 0.419921875, 1.3212890625, 1.291015625, 0.599609375, 0.0550537109375, 0.9599609375, 0.93505859375, 0.111083984375, 1.302734375, 0.0833740234375, 2.244140625, 1.25390625, 1.6015625, 0.58349609375, 1.7568359375, -0.263427734375, -0.019866943359375, -0.24658203125, -0.1871337890625, 0.927734375, 0.62255859375, 0.275146484375, 0.79541015625, 1.1796875, 1.1767578125, -0.26123046875, -0.268310546875, 1.8994140625, 1.318359375, 2.1875, 0.2469482421875, 1.41015625, 0.03973388671875, 1.2685546875, 1.1025390625, 0.9560546875, 0.865234375, -1.92578125, 1.154296875, 0.389892578125, 1.130859375, 0.95947265625, 0.72314453125, 2.244140625, 0.048553466796875, 0.626953125, 0.42919921875, 0.82275390625, 0.311767578125, -0.320556640625, 0.01041412353515625, 0.1483154296875, 0.10809326171875, -0.3173828125, 1.1337890625, -0.8642578125, 1.4033203125, 0.048828125, 1.1787109375, 0.98779296875, 1.818359375, 1.1552734375, 0.6015625, 1.2392578125, -1.2685546875, 0.39208984375, 0.83251953125, 0.224365234375, 0.0019989013671875, 0.87548828125, 1.6572265625, 1.107421875, 0.434814453125, 1.8251953125, 0.442626953125, 1.2587890625, 0.09320068359375, -0.896484375, 1.8017578125, 1.451171875, -0.0755615234375, 0.6083984375, 2.06640625, 0.673828125, -0.33740234375, 0.192138671875, 0.21435546875, 0.80224609375, -1.490234375, 0.9501953125, 0.86083984375, -0.40283203125, 4.109375, 2.533203125, 1.2529296875, 0.8271484375, 0.225830078125, 1.0478515625, -1.9755859375, 0.841796875, 0.392822265625, 0.525390625, 0.33935546875, -0.79443359375, 0.71630859375, 0.97998046875, -0.175537109375, 0.97705078125, 1.705078125, 0.29638671875, 0.68359375, 0.54150390625, 0.435791015625, 0.99755859375, -0.369140625, 1.009765625, -0.140380859375, 0.426513671875, 0.189697265625, 1.8193359375, 1.1201171875, -0.5009765625, -0.331298828125, 0.759765625, -0.09442138671875, 0.74609375, -1.947265625, 1.3544921875, -3.935546875, 2.544921875, 1.359375, 0.1363525390625, 0.79296875, 0.79931640625, -0.3466796875, 1.1396484375, -0.33447265625, 2.0078125, -0.241455078125, 0.6318359375, 0.365234375, 0.296142578125, 0.830078125, 1.0458984375, 0.5830078125, 0.61572265625, 14.0703125, -2.0078125, -0.381591796875, 1.228515625, 0.08282470703125, -0.67822265625, -0.04339599609375, 0.397216796875, 0.1656494140625, 0.137451171875, 0.244873046875, 1.1611328125, -1.3818359375, 0.8447265625, 1.171875, 0.36328125, 0.252685546875, 0.1197509765625, 0.232177734375, -0.020172119140625, 0.64404296875, -0.01100921630859375, -1.9267578125, 0.222412109375, 0.56005859375, 1.3046875, 1.1630859375, 1.197265625, 1.02734375, 1.6806640625, -0.043731689453125, 1.4697265625, 0.81201171875, 1.5390625, 1.240234375, -0.7353515625, 1.828125, 1.115234375, 1.931640625, -0.517578125, 0.77880859375, 1.0546875, 0.95361328125, 3.42578125, 0.0160369873046875, 0.875, 0.56005859375, 1.2421875, 1.986328125, 1.4814453125, 0.0948486328125, 1.115234375, 0.00665283203125, 2.09375, 0.3544921875, -0.52783203125, 1.2099609375, 0.45068359375, 0.65625, 0.1112060546875, 1.0751953125, -0.9521484375, -0.30029296875, 1.4462890625, 2.046875, 3.212890625, 1.68359375, 1.07421875, -0.5263671875, 0.74560546875, 1.37890625, 0.15283203125, 0.2440185546875, 0.62646484375, -0.1280517578125, 0.7646484375, -0.515625, -0.35693359375, 1.2958984375, 0.96923828125, 0.58935546875, 1.3701171875, 1.0673828125, 0.2337646484375, 0.93115234375, 0.66357421875, 6.0, 1.1025390625, -0.51708984375, -0.38330078125, 0.7197265625, 0.246826171875, -0.45166015625, 1.9521484375, 0.5546875, 0.08807373046875, 0.18505859375, 0.8857421875, -0.57177734375, 0.251708984375, 0.234375, 2.57421875, 0.9599609375, 0.5029296875, 0.10382080078125, 0.08331298828125, 0.66748046875, -0.349609375, 1.287109375, 0.259765625, 2.015625, 2.828125, -0.3095703125, -0.164306640625, -0.3408203125, 0.486572265625, 0.8466796875, 1.9130859375, 0.09088134765625, 0.66552734375, 0.00972747802734375, -0.83154296875, 1.755859375, 0.654296875, 0.173828125, 0.27587890625, -0.47607421875, -0.264404296875, 0.7529296875, 0.6533203125, 0.7275390625, 0.499755859375, 0.833984375, -0.44775390625, -0.05078125, -0.454833984375, 0.75439453125, 0.68505859375, 0.210693359375, -0.283935546875, -0.53564453125, 0.96826171875, 0.861328125, -3.33984375, -0.26171875, 0.77734375, 0.26513671875, -0.14111328125, -0.042236328125, -0.84814453125, 0.2137451171875, 0.94921875, 0.65185546875, -0.5380859375, 0.1529541015625, -0.360595703125, -0.0333251953125, -0.69189453125, 0.8974609375, 0.7109375, 0.81494140625, -0.259521484375, 1.1904296875, 0.62158203125, 1.345703125, 0.89404296875, 0.70556640625, 1.0673828125, 1.392578125, 0.5068359375, 0.962890625, 0.736328125, 1.55078125, 0.50390625, -0.398681640625, 2.361328125, 0.345947265625, -0.61962890625, 0.330078125, 0.75439453125, -0.673828125, -0.2379150390625, 1.5673828125, 1.369140625, 0.1119384765625, -0.1834716796875, 1.4599609375, -0.77587890625, 0.5556640625, 0.09954833984375, 0.0285186767578125, 0.58935546875, -0.501953125, 0.212890625, 0.02679443359375, 0.1715087890625, 0.03466796875, -0.564453125, 2.029296875, 2.45703125, -0.72216796875, 2.138671875, 0.50830078125, -0.09356689453125, 0.230224609375, 1.6943359375, 1.5126953125, 0.39453125, 0.411376953125, 1.07421875, -0.8046875, 0.51416015625, 0.2271728515625, -0.283447265625, 0.38427734375, 0.73388671875, 0.6962890625, 1.4990234375, 0.02813720703125, 0.40478515625, 1.2451171875, 1.1162109375, -5.5703125, 0.76171875, 0.322021484375, 1.0361328125, 1.197265625, 0.1163330078125, 0.2425537109375, 1.5595703125, 1.5791015625, -0.0921630859375, 0.484619140625, 1.9052734375, 5.31640625, 1.6337890625, 0.95947265625, -0.1751708984375, 0.466552734375, 0.8330078125, 1.03125, 0.2044677734375, 0.31298828125, -1.1220703125, 0.5517578125, 0.93505859375, 0.45166015625, 1.951171875, 0.65478515625, 1.30859375, 1.0859375, 0.56494140625, 2.322265625, 0.242919921875, 1.81640625, -0.469970703125, -0.841796875, 0.90869140625, 1.5361328125, 0.923828125, 1.0595703125, 0.356689453125, -0.46142578125, 2.134765625, 1.3037109375, -0.32373046875, -9.2265625, 0.4521484375, 0.88037109375, -0.53955078125, 0.96484375, 0.7705078125, 0.84521484375, 1.580078125, -0.1448974609375, 0.7607421875, 1.0166015625, -0.086669921875, 1.611328125, 0.05938720703125, 0.5078125, 0.8427734375, 2.431640625, 0.66357421875, 3.203125, 0.132080078125, 0.461181640625, 0.779296875, 1.9482421875, 1.8720703125, 0.845703125, -1.3837890625, -0.138916015625, 0.35546875, 0.2457275390625, 0.75341796875, 1.828125, 1.4169921875, 0.60791015625, 1.0068359375, 1.109375, 0.484130859375, -0.302001953125, 0.4951171875, 0.802734375, 1.9482421875, 0.916015625, 0.1646728515625, 2.599609375, 1.7177734375, -0.2374267578125, 0.98046875, 0.39306640625, -1.1396484375, 1.6533203125, 0.375244140625], "scores": [0.09906005859375, 0.12213134765625, 0.05035400390625, 0.16552734375, 0.0037384033203125, 0.010101318359375, 0.058197021484375, 0.10552978515625, 0.1141357421875, 0.115234375, 0.00444793701171875, 0.00812530517578125, 0.0343017578125, 0.009002685546875, 0.087158203125, 0.00818634033203125, 0.003238677978515625, 0.024169921875, 0.00702667236328125, 0.00936126708984375, 0.00632476806640625, 0.0293731689453125, 0.01800537109375, 0.0088348388671875, 0.013397216796875, 0.02557373046875, 0.12109375, 0.004413604736328125, 0.016571044921875, 0.00274658203125, 0.2142333984375, 0.29638671875, 0.16015625, 0.007843017578125, 0.007160186767578125, 0.00508880615234375, 0.054229736328125, 0.048736572265625, 0.026397705078125, 0.0265350341796875, 0.051361083984375, 0.018310546875, 0.00974273681640625, 0.0218963623046875, 0.216064453125, 0.021728515625, 0.0173797607421875, 0.004520416259765625], "stoks": [52, 52, 52, 52, 52, 41, 41, 374, 303, 303, 303, 427], "time": {"begin_ms": 640, "end_ms": 1140}}]}',
                },
                {
                    id: "7645a0d1-2e64-410d-83a8-b96040432e9a",
                    chatId: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    timestamp: 1716244957031,
                    role: "AGENT",
                    type: "AGENT_MESSAGE",
                    messageText: "Hello!",
                    emotionFeatures:
                        '{"Admiration": 0.044921875, "Adoration": 0.0253753662109375, "Aesthetic Appreciation": 0.03265380859375, "Amusement": 0.118408203125, "Anger": 0.06719970703125, "Anxiety": 0.0411376953125, "Awe": 0.03802490234375, "Awkwardness": 0.056549072265625, "Boredom": 0.04217529296875, "Calmness": 0.08709716796875, "Concentration": 0.070556640625, "Confusion": 0.06964111328125, "Contemplation": 0.0343017578125, "Contempt": 0.037689208984375, "Contentment": 0.059417724609375, "Craving": 0.01132965087890625, "Desire": 0.01406097412109375, "Determination": 0.1143798828125, "Disappointment": 0.051177978515625, "Disgust": 0.028594970703125, "Distress": 0.054901123046875, "Doubt": 0.04638671875, "Ecstasy": 0.0258026123046875, "Embarrassment": 0.0222015380859375, "Empathic Pain": 0.015777587890625, "Entrancement": 0.0160980224609375, "Envy": 0.0163421630859375, "Excitement": 0.129638671875, "Fear": 0.03125, "Guilt": 0.01483917236328125, "Horror": 0.0194549560546875, "Interest": 0.1341552734375, "Joy": 0.0738525390625, "Love": 0.0216522216796875, "Nostalgia": 0.0210418701171875, "Pain": 0.020721435546875, "Pride": 0.05499267578125, "Realization": 0.0728759765625, "Relief": 0.04052734375, "Romance": 0.0129241943359375, "Sadness": 0.0254669189453125, "Satisfaction": 0.07159423828125, "Shame": 0.01495361328125, "Surprise (negative)": 0.05560302734375, "Surprise (positive)": 0.07965087890625, "Sympathy": 0.022247314453125, "Tiredness": 0.0194549560546875, "Triumph": 0.04107666015625}',
                    metadata: "",
                },
            ],
        };
        const page = await client.empathicVoice.chatGroups.listChatGroupEvents("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
            pageNumber: 0,
            pageSize: 3,
            ascendingOrder: true,
        });

        expect(expected.eventsPage).toEqual(page.data);
        expect(page.hasNextPage()).toBe(true);
        const nextPage = await page.getNextPage();
        expect(expected.eventsPage).toEqual(nextPage.data);
    });

    test("list-chat-group-events (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/chat_groups/id/events")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.chatGroups.listChatGroupEvents("id");
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });
});

```


## /tests/wire/empathic-voice/chats.test.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import * as Hume from "../../../src/api/index";
import { HumeClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("ChatsClient", () => {
    test("list-chats (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            page_number: 0,
            page_size: 1,
            total_pages: 1,
            pagination_direction: "ASC",
            chats_page: [
                {
                    id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    chat_group_id: "9fc18597-3567-42d5-94d6-935bde84bf2f",
                    status: "USER_ENDED",
                    start_timestamp: 1716244940648,
                    end_timestamp: 1716244958546,
                    event_count: 3,
                    metadata: "",
                    config: { id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3", version: 0 },
                },
            ],
        };
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/chats")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const expected = {
            pageNumber: 0,
            pageSize: 1,
            totalPages: 1,
            paginationDirection: "ASC",
            chatsPage: [
                {
                    id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    chatGroupId: "9fc18597-3567-42d5-94d6-935bde84bf2f",
                    status: "USER_ENDED",
                    startTimestamp: 1716244940648,
                    endTimestamp: 1716244958546,
                    eventCount: 3,
                    metadata: "",
                    config: {
                        id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
                        version: 0,
                    },
                },
            ],
        };
        const page = await client.empathicVoice.chats.listChats({
            pageNumber: 0,
            pageSize: 1,
            ascendingOrder: true,
        });

        expect(expected.chatsPage).toEqual(page.data);
        expect(page.hasNextPage()).toBe(true);
        const nextPage = await page.getNextPage();
        expect(expected.chatsPage).toEqual(nextPage.data);
    });

    test("list-chats (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/chats")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.chats.listChats();
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("list-chat-events (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
            chat_group_id: "9fc18597-3567-42d5-94d6-935bde84bf2f",
            status: "USER_ENDED",
            start_timestamp: 1716244940648,
            pagination_direction: "ASC",
            events_page: [
                {
                    id: "5d44bdbb-49a3-40fb-871d-32bf7e76efe7",
                    chat_id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    timestamp: 1716244940762,
                    role: "SYSTEM",
                    type: "SYSTEM_PROMPT",
                    message_text:
                        "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                    emotion_features: "",
                    metadata: "",
                },
                {
                    id: "5976ddf6-d093-4bb9-ba60-8f6c25832dde",
                    chat_id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    timestamp: 1716244956278,
                    role: "USER",
                    type: "USER_MESSAGE",
                    message_text: "Hello.",
                    emotion_features:
                        '{"Admiration": 0.09906005859375, "Adoration": 0.12213134765625, "Aesthetic Appreciation": 0.05035400390625, "Amusement": 0.16552734375, "Anger": 0.0037384033203125, "Anxiety": 0.010101318359375, "Awe": 0.058197021484375, "Awkwardness": 0.10552978515625, "Boredom": 0.1141357421875, "Calmness": 0.115234375, "Concentration": 0.00444793701171875, "Confusion": 0.0343017578125, "Contemplation": 0.00812530517578125, "Contempt": 0.009002685546875, "Contentment": 0.087158203125, "Craving": 0.00818634033203125, "Desire": 0.018310546875, "Determination": 0.003238677978515625, "Disappointment": 0.024169921875, "Disgust": 0.00702667236328125, "Distress": 0.00936126708984375, "Doubt": 0.00632476806640625, "Ecstasy": 0.0293731689453125, "Embarrassment": 0.01800537109375, "Empathic Pain": 0.0088348388671875, "Entrancement": 0.013397216796875, "Envy": 0.02557373046875, "Excitement": 0.12109375, "Fear": 0.004413604736328125, "Guilt": 0.016571044921875, "Horror": 0.00274658203125, "Interest": 0.2142333984375, "Joy": 0.29638671875, "Love": 0.16015625, "Nostalgia": 0.007843017578125, "Pain": 0.007160186767578125, "Pride": 0.00508880615234375, "Realization": 0.054229736328125, "Relief": 0.048736572265625, "Romance": 0.026397705078125, "Sadness": 0.0265350341796875, "Satisfaction": 0.051361083984375, "Shame": 0.00974273681640625, "Surprise (negative)": 0.0218963623046875, "Surprise (positive)": 0.216064453125, "Sympathy": 0.021728515625, "Tiredness": 0.0173797607421875, "Triumph": 0.004520416259765625}',
                    metadata:
                        '{"segments": [{"content": "Hello.", "embedding": [0.6181640625, 0.1763916015625, -30.921875, 1.2705078125, 0.927734375, 0.63720703125, 2.865234375, 0.1080322265625, 0.2978515625, 1.0107421875, 1.34375, 0.74560546875, 0.416259765625, 0.99462890625, -0.333740234375, 0.361083984375, -1.388671875, 1.0107421875, 1.3173828125, 0.55615234375, 0.541015625, -0.1837158203125, 1.697265625, 0.228515625, 2.087890625, -0.311767578125, 0.053680419921875, 1.3349609375, 0.95068359375, 0.00441741943359375, 0.705078125, 1.8916015625, -0.939453125, 0.93701171875, -0.28955078125, 1.513671875, 0.5595703125, 1.0126953125, -0.1624755859375, 1.4072265625, -0.28857421875, -0.4560546875, -0.1500244140625, -0.1102294921875, -0.222412109375, 0.8779296875, 1.275390625, 1.6689453125, 0.80712890625, -0.34814453125, -0.325439453125, 0.412841796875, 0.81689453125, 0.55126953125, 1.671875, 0.6611328125, 0.7451171875, 1.50390625, 1.0224609375, -1.671875, 0.7373046875, 2.1328125, 2.166015625, 0.41015625, -0.127685546875, 1.9345703125, -4.2734375, 0.332275390625, 0.26171875, 0.76708984375, 0.2685546875, 0.468017578125, 1.208984375, -1.517578125, 1.083984375, 0.84814453125, 1.0244140625, -0.0072174072265625, 1.34375, 1.0712890625, 1.517578125, -0.52001953125, 0.59228515625, 0.8154296875, -0.951171875, -0.07757568359375, 1.3330078125, 1.125, 0.61181640625, 1.494140625, 0.357421875, 1.1796875, 1.482421875, 0.8046875, 0.1536865234375, 1.8076171875, 0.68115234375, -15.171875, 1.2294921875, 0.319091796875, 0.499755859375, 1.5771484375, 0.94677734375, -0.2490234375, 0.88525390625, 3.47265625, 0.75927734375, 0.71044921875, 1.2333984375, 1.4169921875, -0.56640625, -1.8095703125, 1.37109375, 0.428955078125, 1.89453125, -0.39013671875, 0.1734619140625, 1.5595703125, -1.2294921875, 2.552734375, 0.58349609375, 0.2156982421875, -0.00984954833984375, -0.6865234375, -0.0272979736328125, -0.2264404296875, 2.853515625, 1.3896484375, 0.52978515625, 0.783203125, 3.0390625, 0.75537109375, 0.219970703125, 0.384521484375, 0.385986328125, 2.0546875, -0.10443115234375, 1.5146484375, 1.4296875, 1.9716796875, 1.1318359375, 0.31591796875, 0.338623046875, 1.654296875, -0.88037109375, -0.21484375, 1.45703125, 1.0380859375, -0.52294921875, -0.47802734375, 0.1650390625, 1.2392578125, -1.138671875, 0.56787109375, 1.318359375, 0.4287109375, 0.1981201171875, 2.4375, 0.281005859375, 0.89404296875, -0.1552734375, 0.6474609375, -0.08331298828125, 0.00740814208984375, -0.045501708984375, -0.578125, 2.02734375, 0.59228515625, 0.35693359375, 1.2919921875, 1.22265625, 1.0537109375, 0.145263671875, 1.05859375, -0.369140625, 0.207275390625, 0.78857421875, 0.599609375, 0.99072265625, 0.24462890625, 1.26953125, 0.08404541015625, 1.349609375, 0.73291015625, 1.3212890625, 0.388916015625, 1.0869140625, 0.9931640625, -1.5673828125, 0.0462646484375, 0.650390625, 0.253662109375, 0.58251953125, 1.8134765625, 0.8642578125, 2.591796875, 0.7314453125, 0.85986328125, 0.5615234375, 0.9296875, 0.04144287109375, 1.66015625, 1.99609375, 1.171875, 1.181640625, 1.5126953125, 0.0224456787109375, 0.58349609375, -1.4931640625, 0.81884765625, 0.732421875, -0.6455078125, -0.62451171875, 1.7802734375, 0.01526641845703125, -0.423095703125, 0.461669921875, 4.87890625, 1.2392578125, -0.6953125, 0.6689453125, 0.62451171875, -1.521484375, 1.7685546875, 0.810546875, 0.65478515625, 0.26123046875, 1.6396484375, 0.87548828125, 1.7353515625, 2.046875, 1.5634765625, 0.69384765625, 1.375, 0.8916015625, 1.0107421875, 0.1304931640625, 2.009765625, 0.06402587890625, -0.08428955078125, 0.04351806640625, -1.7529296875, 2.02734375, 3.521484375, 0.404541015625, 1.6337890625, -0.276611328125, 0.8837890625, -0.1287841796875, 0.91064453125, 0.8193359375, 0.701171875, 0.036529541015625, 1.26171875, 1.0478515625, -0.1422119140625, 1.0634765625, 0.61083984375, 1.3505859375, 1.208984375, 0.57275390625, 1.3623046875, 2.267578125, 0.484375, 0.9150390625, 0.56787109375, -0.70068359375, 0.27587890625, -0.70654296875, 0.8466796875, 0.57568359375, 1.6162109375, 0.87939453125, 2.248046875, -0.5458984375, 1.7744140625, 1.328125, 1.232421875, 0.6806640625, 0.9365234375, 1.052734375, -1.08984375, 1.8330078125, -0.4033203125, 1.0673828125, 0.297607421875, 1.5703125, 1.67578125, 1.34765625, 2.8203125, 2.025390625, -0.48583984375, 0.7626953125, 0.01007843017578125, 1.435546875, 0.007205963134765625, 0.05157470703125, -0.9853515625, 0.26708984375, 1.16796875, 1.2041015625, 1.99609375, -0.07916259765625, 1.244140625, -0.32080078125, 0.6748046875, 0.419921875, 1.3212890625, 1.291015625, 0.599609375, 0.0550537109375, 0.9599609375, 0.93505859375, 0.111083984375, 1.302734375, 0.0833740234375, 2.244140625, 1.25390625, 1.6015625, 0.58349609375, 1.7568359375, -0.263427734375, -0.019866943359375, -0.24658203125, -0.1871337890625, 0.927734375, 0.62255859375, 0.275146484375, 0.79541015625, 1.1796875, 1.1767578125, -0.26123046875, -0.268310546875, 1.8994140625, 1.318359375, 2.1875, 0.2469482421875, 1.41015625, 0.03973388671875, 1.2685546875, 1.1025390625, 0.9560546875, 0.865234375, -1.92578125, 1.154296875, 0.389892578125, 1.130859375, 0.95947265625, 0.72314453125, 2.244140625, 0.048553466796875, 0.626953125, 0.42919921875, 0.82275390625, 0.311767578125, -0.320556640625, 0.01041412353515625, 0.1483154296875, 0.10809326171875, -0.3173828125, 1.1337890625, -0.8642578125, 1.4033203125, 0.048828125, 1.1787109375, 0.98779296875, 1.818359375, 1.1552734375, 0.6015625, 1.2392578125, -1.2685546875, 0.39208984375, 0.83251953125, 0.224365234375, 0.0019989013671875, 0.87548828125, 1.6572265625, 1.107421875, 0.434814453125, 1.8251953125, 0.442626953125, 1.2587890625, 0.09320068359375, -0.896484375, 1.8017578125, 1.451171875, -0.0755615234375, 0.6083984375, 2.06640625, 0.673828125, -0.33740234375, 0.192138671875, 0.21435546875, 0.80224609375, -1.490234375, 0.9501953125, 0.86083984375, -0.40283203125, 4.109375, 2.533203125, 1.2529296875, 0.8271484375, 0.225830078125, 1.0478515625, -1.9755859375, 0.841796875, 0.392822265625, 0.525390625, 0.33935546875, -0.79443359375, 0.71630859375, 0.97998046875, -0.175537109375, 0.97705078125, 1.705078125, 0.29638671875, 0.68359375, 0.54150390625, 0.435791015625, 0.99755859375, -0.369140625, 1.009765625, -0.140380859375, 0.426513671875, 0.189697265625, 1.8193359375, 1.1201171875, -0.5009765625, -0.331298828125, 0.759765625, -0.09442138671875, 0.74609375, -1.947265625, 1.3544921875, -3.935546875, 2.544921875, 1.359375, 0.1363525390625, 0.79296875, 0.79931640625, -0.3466796875, 1.1396484375, -0.33447265625, 2.0078125, -0.241455078125, 0.6318359375, 0.365234375, 0.296142578125, 0.830078125, 1.0458984375, 0.5830078125, 0.61572265625, 14.0703125, -2.0078125, -0.381591796875, 1.228515625, 0.08282470703125, -0.67822265625, -0.04339599609375, 0.397216796875, 0.1656494140625, 0.137451171875, 0.244873046875, 1.1611328125, -1.3818359375, 0.8447265625, 1.171875, 0.36328125, 0.252685546875, 0.1197509765625, 0.232177734375, -0.020172119140625, 0.64404296875, -0.01100921630859375, -1.9267578125, 0.222412109375, 0.56005859375, 1.3046875, 1.1630859375, 1.197265625, 1.02734375, 1.6806640625, -0.043731689453125, 1.4697265625, 0.81201171875, 1.5390625, 1.240234375, -0.7353515625, 1.828125, 1.115234375, 1.931640625, -0.517578125, 0.77880859375, 1.0546875, 0.95361328125, 3.42578125, 0.0160369873046875, 0.875, 0.56005859375, 1.2421875, 1.986328125, 1.4814453125, 0.0948486328125, 1.115234375, 0.00665283203125, 2.09375, 0.3544921875, -0.52783203125, 1.2099609375, 0.45068359375, 0.65625, 0.1112060546875, 1.0751953125, -0.9521484375, -0.30029296875, 1.4462890625, 2.046875, 3.212890625, 1.68359375, 1.07421875, -0.5263671875, 0.74560546875, 1.37890625, 0.15283203125, 0.2440185546875, 0.62646484375, -0.1280517578125, 0.7646484375, -0.515625, -0.35693359375, 1.2958984375, 0.96923828125, 0.58935546875, 1.3701171875, 1.0673828125, 0.2337646484375, 0.93115234375, 0.66357421875, 6.0, 1.1025390625, -0.51708984375, -0.38330078125, 0.7197265625, 0.246826171875, -0.45166015625, 1.9521484375, 0.5546875, 0.08807373046875, 0.18505859375, 0.8857421875, -0.57177734375, 0.251708984375, 0.234375, 2.57421875, 0.9599609375, 0.5029296875, 0.10382080078125, 0.08331298828125, 0.66748046875, -0.349609375, 1.287109375, 0.259765625, 2.015625, 2.828125, -0.3095703125, -0.164306640625, -0.3408203125, 0.486572265625, 0.8466796875, 1.9130859375, 0.09088134765625, 0.66552734375, 0.00972747802734375, -0.83154296875, 1.755859375, 0.654296875, 0.173828125, 0.27587890625, -0.47607421875, -0.264404296875, 0.7529296875, 0.6533203125, 0.7275390625, 0.499755859375, 0.833984375, -0.44775390625, -0.05078125, -0.454833984375, 0.75439453125, 0.68505859375, 0.210693359375, -0.283935546875, -0.53564453125, 0.96826171875, 0.861328125, -3.33984375, -0.26171875, 0.77734375, 0.26513671875, -0.14111328125, -0.042236328125, -0.84814453125, 0.2137451171875, 0.94921875, 0.65185546875, -0.5380859375, 0.1529541015625, -0.360595703125, -0.0333251953125, -0.69189453125, 0.8974609375, 0.7109375, 0.81494140625, -0.259521484375, 1.1904296875, 0.62158203125, 1.345703125, 0.89404296875, 0.70556640625, 1.0673828125, 1.392578125, 0.5068359375, 0.962890625, 0.736328125, 1.55078125, 0.50390625, -0.398681640625, 2.361328125, 0.345947265625, -0.61962890625, 0.330078125, 0.75439453125, -0.673828125, -0.2379150390625, 1.5673828125, 1.369140625, 0.1119384765625, -0.1834716796875, 1.4599609375, -0.77587890625, 0.5556640625, 0.09954833984375, 0.0285186767578125, 0.58935546875, -0.501953125, 0.212890625, 0.02679443359375, 0.1715087890625, 0.03466796875, -0.564453125, 2.029296875, 2.45703125, -0.72216796875, 2.138671875, 0.50830078125, -0.09356689453125, 0.230224609375, 1.6943359375, 1.5126953125, 0.39453125, 0.411376953125, 1.07421875, -0.8046875, 0.51416015625, 0.2271728515625, -0.283447265625, 0.38427734375, 0.73388671875, 0.6962890625, 1.4990234375, 0.02813720703125, 0.40478515625, 1.2451171875, 1.1162109375, -5.5703125, 0.76171875, 0.322021484375, 1.0361328125, 1.197265625, 0.1163330078125, 0.2425537109375, 1.5595703125, 1.5791015625, -0.0921630859375, 0.484619140625, 1.9052734375, 5.31640625, 1.6337890625, 0.95947265625, -0.1751708984375, 0.466552734375, 0.8330078125, 1.03125, 0.2044677734375, 0.31298828125, -1.1220703125, 0.5517578125, 0.93505859375, 0.45166015625, 1.951171875, 0.65478515625, 1.30859375, 1.0859375, 0.56494140625, 2.322265625, 0.242919921875, 1.81640625, -0.469970703125, -0.841796875, 0.90869140625, 1.5361328125, 0.923828125, 1.0595703125, 0.356689453125, -0.46142578125, 2.134765625, 1.3037109375, -0.32373046875, -9.2265625, 0.4521484375, 0.88037109375, -0.53955078125, 0.96484375, 0.7705078125, 0.84521484375, 1.580078125, -0.1448974609375, 0.7607421875, 1.0166015625, -0.086669921875, 1.611328125, 0.05938720703125, 0.5078125, 0.8427734375, 2.431640625, 0.66357421875, 3.203125, 0.132080078125, 0.461181640625, 0.779296875, 1.9482421875, 1.8720703125, 0.845703125, -1.3837890625, -0.138916015625, 0.35546875, 0.2457275390625, 0.75341796875, 1.828125, 1.4169921875, 0.60791015625, 1.0068359375, 1.109375, 0.484130859375, -0.302001953125, 0.4951171875, 0.802734375, 1.9482421875, 0.916015625, 0.1646728515625, 2.599609375, 1.7177734375, -0.2374267578125, 0.98046875, 0.39306640625, -1.1396484375, 1.6533203125, 0.375244140625], "scores": [0.09906005859375, 0.12213134765625, 0.05035400390625, 0.16552734375, 0.0037384033203125, 0.010101318359375, 0.058197021484375, 0.10552978515625, 0.1141357421875, 0.115234375, 0.00444793701171875, 0.00812530517578125, 0.0343017578125, 0.009002685546875, 0.087158203125, 0.00818634033203125, 0.003238677978515625, 0.024169921875, 0.00702667236328125, 0.00936126708984375, 0.00632476806640625, 0.0293731689453125, 0.01800537109375, 0.0088348388671875, 0.013397216796875, 0.02557373046875, 0.12109375, 0.004413604736328125, 0.016571044921875, 0.00274658203125, 0.2142333984375, 0.29638671875, 0.16015625, 0.007843017578125, 0.007160186767578125, 0.00508880615234375, 0.054229736328125, 0.048736572265625, 0.026397705078125, 0.0265350341796875, 0.051361083984375, 0.018310546875, 0.00974273681640625, 0.0218963623046875, 0.216064453125, 0.021728515625, 0.0173797607421875, 0.004520416259765625], "stoks": [52, 52, 52, 52, 52, 41, 41, 374, 303, 303, 303, 427], "time": {"begin_ms": 640, "end_ms": 1140}}]}',
                },
                {
                    id: "7645a0d1-2e64-410d-83a8-b96040432e9a",
                    chat_id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    timestamp: 1716244957031,
                    role: "AGENT",
                    type: "AGENT_MESSAGE",
                    message_text: "Hello!",
                    emotion_features:
                        '{"Admiration": 0.044921875, "Adoration": 0.0253753662109375, "Aesthetic Appreciation": 0.03265380859375, "Amusement": 0.118408203125, "Anger": 0.06719970703125, "Anxiety": 0.0411376953125, "Awe": 0.03802490234375, "Awkwardness": 0.056549072265625, "Boredom": 0.04217529296875, "Calmness": 0.08709716796875, "Concentration": 0.070556640625, "Confusion": 0.06964111328125, "Contemplation": 0.0343017578125, "Contempt": 0.037689208984375, "Contentment": 0.059417724609375, "Craving": 0.01132965087890625, "Desire": 0.01406097412109375, "Determination": 0.1143798828125, "Disappointment": 0.051177978515625, "Disgust": 0.028594970703125, "Distress": 0.054901123046875, "Doubt": 0.04638671875, "Ecstasy": 0.0258026123046875, "Embarrassment": 0.0222015380859375, "Empathic Pain": 0.015777587890625, "Entrancement": 0.0160980224609375, "Envy": 0.0163421630859375, "Excitement": 0.129638671875, "Fear": 0.03125, "Guilt": 0.01483917236328125, "Horror": 0.0194549560546875, "Interest": 0.1341552734375, "Joy": 0.0738525390625, "Love": 0.0216522216796875, "Nostalgia": 0.0210418701171875, "Pain": 0.020721435546875, "Pride": 0.05499267578125, "Realization": 0.0728759765625, "Relief": 0.04052734375, "Romance": 0.0129241943359375, "Sadness": 0.0254669189453125, "Satisfaction": 0.07159423828125, "Shame": 0.01495361328125, "Surprise (negative)": 0.05560302734375, "Surprise (positive)": 0.07965087890625, "Sympathy": 0.022247314453125, "Tiredness": 0.0194549560546875, "Triumph": 0.04107666015625}',
                    metadata: "",
                },
            ],
            page_number: 0,
            page_size: 3,
            total_pages: 1,
            end_timestamp: 1716244958546,
            metadata: "",
            config: { id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3", version: 0 },
        };
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/chats/470a49f6-1dec-4afe-8b61-035d3b2d63b0")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const expected = {
            id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
            chatGroupId: "9fc18597-3567-42d5-94d6-935bde84bf2f",
            status: "USER_ENDED",
            startTimestamp: 1716244940648,
            paginationDirection: "ASC",
            eventsPage: [
                {
                    id: "5d44bdbb-49a3-40fb-871d-32bf7e76efe7",
                    chatId: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    timestamp: 1716244940762,
                    role: "SYSTEM",
                    type: "SYSTEM_PROMPT",
                    messageText:
                        "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                    emotionFeatures: "",
                    metadata: "",
                },
                {
                    id: "5976ddf6-d093-4bb9-ba60-8f6c25832dde",
                    chatId: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    timestamp: 1716244956278,
                    role: "USER",
                    type: "USER_MESSAGE",
                    messageText: "Hello.",
                    emotionFeatures:
                        '{"Admiration": 0.09906005859375, "Adoration": 0.12213134765625, "Aesthetic Appreciation": 0.05035400390625, "Amusement": 0.16552734375, "Anger": 0.0037384033203125, "Anxiety": 0.010101318359375, "Awe": 0.058197021484375, "Awkwardness": 0.10552978515625, "Boredom": 0.1141357421875, "Calmness": 0.115234375, "Concentration": 0.00444793701171875, "Confusion": 0.0343017578125, "Contemplation": 0.00812530517578125, "Contempt": 0.009002685546875, "Contentment": 0.087158203125, "Craving": 0.00818634033203125, "Desire": 0.018310546875, "Determination": 0.003238677978515625, "Disappointment": 0.024169921875, "Disgust": 0.00702667236328125, "Distress": 0.00936126708984375, "Doubt": 0.00632476806640625, "Ecstasy": 0.0293731689453125, "Embarrassment": 0.01800537109375, "Empathic Pain": 0.0088348388671875, "Entrancement": 0.013397216796875, "Envy": 0.02557373046875, "Excitement": 0.12109375, "Fear": 0.004413604736328125, "Guilt": 0.016571044921875, "Horror": 0.00274658203125, "Interest": 0.2142333984375, "Joy": 0.29638671875, "Love": 0.16015625, "Nostalgia": 0.007843017578125, "Pain": 0.007160186767578125, "Pride": 0.00508880615234375, "Realization": 0.054229736328125, "Relief": 0.048736572265625, "Romance": 0.026397705078125, "Sadness": 0.0265350341796875, "Satisfaction": 0.051361083984375, "Shame": 0.00974273681640625, "Surprise (negative)": 0.0218963623046875, "Surprise (positive)": 0.216064453125, "Sympathy": 0.021728515625, "Tiredness": 0.0173797607421875, "Triumph": 0.004520416259765625}',
                    metadata:
                        '{"segments": [{"content": "Hello.", "embedding": [0.6181640625, 0.1763916015625, -30.921875, 1.2705078125, 0.927734375, 0.63720703125, 2.865234375, 0.1080322265625, 0.2978515625, 1.0107421875, 1.34375, 0.74560546875, 0.416259765625, 0.99462890625, -0.333740234375, 0.361083984375, -1.388671875, 1.0107421875, 1.3173828125, 0.55615234375, 0.541015625, -0.1837158203125, 1.697265625, 0.228515625, 2.087890625, -0.311767578125, 0.053680419921875, 1.3349609375, 0.95068359375, 0.00441741943359375, 0.705078125, 1.8916015625, -0.939453125, 0.93701171875, -0.28955078125, 1.513671875, 0.5595703125, 1.0126953125, -0.1624755859375, 1.4072265625, -0.28857421875, -0.4560546875, -0.1500244140625, -0.1102294921875, -0.222412109375, 0.8779296875, 1.275390625, 1.6689453125, 0.80712890625, -0.34814453125, -0.325439453125, 0.412841796875, 0.81689453125, 0.55126953125, 1.671875, 0.6611328125, 0.7451171875, 1.50390625, 1.0224609375, -1.671875, 0.7373046875, 2.1328125, 2.166015625, 0.41015625, -0.127685546875, 1.9345703125, -4.2734375, 0.332275390625, 0.26171875, 0.76708984375, 0.2685546875, 0.468017578125, 1.208984375, -1.517578125, 1.083984375, 0.84814453125, 1.0244140625, -0.0072174072265625, 1.34375, 1.0712890625, 1.517578125, -0.52001953125, 0.59228515625, 0.8154296875, -0.951171875, -0.07757568359375, 1.3330078125, 1.125, 0.61181640625, 1.494140625, 0.357421875, 1.1796875, 1.482421875, 0.8046875, 0.1536865234375, 1.8076171875, 0.68115234375, -15.171875, 1.2294921875, 0.319091796875, 0.499755859375, 1.5771484375, 0.94677734375, -0.2490234375, 0.88525390625, 3.47265625, 0.75927734375, 0.71044921875, 1.2333984375, 1.4169921875, -0.56640625, -1.8095703125, 1.37109375, 0.428955078125, 1.89453125, -0.39013671875, 0.1734619140625, 1.5595703125, -1.2294921875, 2.552734375, 0.58349609375, 0.2156982421875, -0.00984954833984375, -0.6865234375, -0.0272979736328125, -0.2264404296875, 2.853515625, 1.3896484375, 0.52978515625, 0.783203125, 3.0390625, 0.75537109375, 0.219970703125, 0.384521484375, 0.385986328125, 2.0546875, -0.10443115234375, 1.5146484375, 1.4296875, 1.9716796875, 1.1318359375, 0.31591796875, 0.338623046875, 1.654296875, -0.88037109375, -0.21484375, 1.45703125, 1.0380859375, -0.52294921875, -0.47802734375, 0.1650390625, 1.2392578125, -1.138671875, 0.56787109375, 1.318359375, 0.4287109375, 0.1981201171875, 2.4375, 0.281005859375, 0.89404296875, -0.1552734375, 0.6474609375, -0.08331298828125, 0.00740814208984375, -0.045501708984375, -0.578125, 2.02734375, 0.59228515625, 0.35693359375, 1.2919921875, 1.22265625, 1.0537109375, 0.145263671875, 1.05859375, -0.369140625, 0.207275390625, 0.78857421875, 0.599609375, 0.99072265625, 0.24462890625, 1.26953125, 0.08404541015625, 1.349609375, 0.73291015625, 1.3212890625, 0.388916015625, 1.0869140625, 0.9931640625, -1.5673828125, 0.0462646484375, 0.650390625, 0.253662109375, 0.58251953125, 1.8134765625, 0.8642578125, 2.591796875, 0.7314453125, 0.85986328125, 0.5615234375, 0.9296875, 0.04144287109375, 1.66015625, 1.99609375, 1.171875, 1.181640625, 1.5126953125, 0.0224456787109375, 0.58349609375, -1.4931640625, 0.81884765625, 0.732421875, -0.6455078125, -0.62451171875, 1.7802734375, 0.01526641845703125, -0.423095703125, 0.461669921875, 4.87890625, 1.2392578125, -0.6953125, 0.6689453125, 0.62451171875, -1.521484375, 1.7685546875, 0.810546875, 0.65478515625, 0.26123046875, 1.6396484375, 0.87548828125, 1.7353515625, 2.046875, 1.5634765625, 0.69384765625, 1.375, 0.8916015625, 1.0107421875, 0.1304931640625, 2.009765625, 0.06402587890625, -0.08428955078125, 0.04351806640625, -1.7529296875, 2.02734375, 3.521484375, 0.404541015625, 1.6337890625, -0.276611328125, 0.8837890625, -0.1287841796875, 0.91064453125, 0.8193359375, 0.701171875, 0.036529541015625, 1.26171875, 1.0478515625, -0.1422119140625, 1.0634765625, 0.61083984375, 1.3505859375, 1.208984375, 0.57275390625, 1.3623046875, 2.267578125, 0.484375, 0.9150390625, 0.56787109375, -0.70068359375, 0.27587890625, -0.70654296875, 0.8466796875, 0.57568359375, 1.6162109375, 0.87939453125, 2.248046875, -0.5458984375, 1.7744140625, 1.328125, 1.232421875, 0.6806640625, 0.9365234375, 1.052734375, -1.08984375, 1.8330078125, -0.4033203125, 1.0673828125, 0.297607421875, 1.5703125, 1.67578125, 1.34765625, 2.8203125, 2.025390625, -0.48583984375, 0.7626953125, 0.01007843017578125, 1.435546875, 0.007205963134765625, 0.05157470703125, -0.9853515625, 0.26708984375, 1.16796875, 1.2041015625, 1.99609375, -0.07916259765625, 1.244140625, -0.32080078125, 0.6748046875, 0.419921875, 1.3212890625, 1.291015625, 0.599609375, 0.0550537109375, 0.9599609375, 0.93505859375, 0.111083984375, 1.302734375, 0.0833740234375, 2.244140625, 1.25390625, 1.6015625, 0.58349609375, 1.7568359375, -0.263427734375, -0.019866943359375, -0.24658203125, -0.1871337890625, 0.927734375, 0.62255859375, 0.275146484375, 0.79541015625, 1.1796875, 1.1767578125, -0.26123046875, -0.268310546875, 1.8994140625, 1.318359375, 2.1875, 0.2469482421875, 1.41015625, 0.03973388671875, 1.2685546875, 1.1025390625, 0.9560546875, 0.865234375, -1.92578125, 1.154296875, 0.389892578125, 1.130859375, 0.95947265625, 0.72314453125, 2.244140625, 0.048553466796875, 0.626953125, 0.42919921875, 0.82275390625, 0.311767578125, -0.320556640625, 0.01041412353515625, 0.1483154296875, 0.10809326171875, -0.3173828125, 1.1337890625, -0.8642578125, 1.4033203125, 0.048828125, 1.1787109375, 0.98779296875, 1.818359375, 1.1552734375, 0.6015625, 1.2392578125, -1.2685546875, 0.39208984375, 0.83251953125, 0.224365234375, 0.0019989013671875, 0.87548828125, 1.6572265625, 1.107421875, 0.434814453125, 1.8251953125, 0.442626953125, 1.2587890625, 0.09320068359375, -0.896484375, 1.8017578125, 1.451171875, -0.0755615234375, 0.6083984375, 2.06640625, 0.673828125, -0.33740234375, 0.192138671875, 0.21435546875, 0.80224609375, -1.490234375, 0.9501953125, 0.86083984375, -0.40283203125, 4.109375, 2.533203125, 1.2529296875, 0.8271484375, 0.225830078125, 1.0478515625, -1.9755859375, 0.841796875, 0.392822265625, 0.525390625, 0.33935546875, -0.79443359375, 0.71630859375, 0.97998046875, -0.175537109375, 0.97705078125, 1.705078125, 0.29638671875, 0.68359375, 0.54150390625, 0.435791015625, 0.99755859375, -0.369140625, 1.009765625, -0.140380859375, 0.426513671875, 0.189697265625, 1.8193359375, 1.1201171875, -0.5009765625, -0.331298828125, 0.759765625, -0.09442138671875, 0.74609375, -1.947265625, 1.3544921875, -3.935546875, 2.544921875, 1.359375, 0.1363525390625, 0.79296875, 0.79931640625, -0.3466796875, 1.1396484375, -0.33447265625, 2.0078125, -0.241455078125, 0.6318359375, 0.365234375, 0.296142578125, 0.830078125, 1.0458984375, 0.5830078125, 0.61572265625, 14.0703125, -2.0078125, -0.381591796875, 1.228515625, 0.08282470703125, -0.67822265625, -0.04339599609375, 0.397216796875, 0.1656494140625, 0.137451171875, 0.244873046875, 1.1611328125, -1.3818359375, 0.8447265625, 1.171875, 0.36328125, 0.252685546875, 0.1197509765625, 0.232177734375, -0.020172119140625, 0.64404296875, -0.01100921630859375, -1.9267578125, 0.222412109375, 0.56005859375, 1.3046875, 1.1630859375, 1.197265625, 1.02734375, 1.6806640625, -0.043731689453125, 1.4697265625, 0.81201171875, 1.5390625, 1.240234375, -0.7353515625, 1.828125, 1.115234375, 1.931640625, -0.517578125, 0.77880859375, 1.0546875, 0.95361328125, 3.42578125, 0.0160369873046875, 0.875, 0.56005859375, 1.2421875, 1.986328125, 1.4814453125, 0.0948486328125, 1.115234375, 0.00665283203125, 2.09375, 0.3544921875, -0.52783203125, 1.2099609375, 0.45068359375, 0.65625, 0.1112060546875, 1.0751953125, -0.9521484375, -0.30029296875, 1.4462890625, 2.046875, 3.212890625, 1.68359375, 1.07421875, -0.5263671875, 0.74560546875, 1.37890625, 0.15283203125, 0.2440185546875, 0.62646484375, -0.1280517578125, 0.7646484375, -0.515625, -0.35693359375, 1.2958984375, 0.96923828125, 0.58935546875, 1.3701171875, 1.0673828125, 0.2337646484375, 0.93115234375, 0.66357421875, 6.0, 1.1025390625, -0.51708984375, -0.38330078125, 0.7197265625, 0.246826171875, -0.45166015625, 1.9521484375, 0.5546875, 0.08807373046875, 0.18505859375, 0.8857421875, -0.57177734375, 0.251708984375, 0.234375, 2.57421875, 0.9599609375, 0.5029296875, 0.10382080078125, 0.08331298828125, 0.66748046875, -0.349609375, 1.287109375, 0.259765625, 2.015625, 2.828125, -0.3095703125, -0.164306640625, -0.3408203125, 0.486572265625, 0.8466796875, 1.9130859375, 0.09088134765625, 0.66552734375, 0.00972747802734375, -0.83154296875, 1.755859375, 0.654296875, 0.173828125, 0.27587890625, -0.47607421875, -0.264404296875, 0.7529296875, 0.6533203125, 0.7275390625, 0.499755859375, 0.833984375, -0.44775390625, -0.05078125, -0.454833984375, 0.75439453125, 0.68505859375, 0.210693359375, -0.283935546875, -0.53564453125, 0.96826171875, 0.861328125, -3.33984375, -0.26171875, 0.77734375, 0.26513671875, -0.14111328125, -0.042236328125, -0.84814453125, 0.2137451171875, 0.94921875, 0.65185546875, -0.5380859375, 0.1529541015625, -0.360595703125, -0.0333251953125, -0.69189453125, 0.8974609375, 0.7109375, 0.81494140625, -0.259521484375, 1.1904296875, 0.62158203125, 1.345703125, 0.89404296875, 0.70556640625, 1.0673828125, 1.392578125, 0.5068359375, 0.962890625, 0.736328125, 1.55078125, 0.50390625, -0.398681640625, 2.361328125, 0.345947265625, -0.61962890625, 0.330078125, 0.75439453125, -0.673828125, -0.2379150390625, 1.5673828125, 1.369140625, 0.1119384765625, -0.1834716796875, 1.4599609375, -0.77587890625, 0.5556640625, 0.09954833984375, 0.0285186767578125, 0.58935546875, -0.501953125, 0.212890625, 0.02679443359375, 0.1715087890625, 0.03466796875, -0.564453125, 2.029296875, 2.45703125, -0.72216796875, 2.138671875, 0.50830078125, -0.09356689453125, 0.230224609375, 1.6943359375, 1.5126953125, 0.39453125, 0.411376953125, 1.07421875, -0.8046875, 0.51416015625, 0.2271728515625, -0.283447265625, 0.38427734375, 0.73388671875, 0.6962890625, 1.4990234375, 0.02813720703125, 0.40478515625, 1.2451171875, 1.1162109375, -5.5703125, 0.76171875, 0.322021484375, 1.0361328125, 1.197265625, 0.1163330078125, 0.2425537109375, 1.5595703125, 1.5791015625, -0.0921630859375, 0.484619140625, 1.9052734375, 5.31640625, 1.6337890625, 0.95947265625, -0.1751708984375, 0.466552734375, 0.8330078125, 1.03125, 0.2044677734375, 0.31298828125, -1.1220703125, 0.5517578125, 0.93505859375, 0.45166015625, 1.951171875, 0.65478515625, 1.30859375, 1.0859375, 0.56494140625, 2.322265625, 0.242919921875, 1.81640625, -0.469970703125, -0.841796875, 0.90869140625, 1.5361328125, 0.923828125, 1.0595703125, 0.356689453125, -0.46142578125, 2.134765625, 1.3037109375, -0.32373046875, -9.2265625, 0.4521484375, 0.88037109375, -0.53955078125, 0.96484375, 0.7705078125, 0.84521484375, 1.580078125, -0.1448974609375, 0.7607421875, 1.0166015625, -0.086669921875, 1.611328125, 0.05938720703125, 0.5078125, 0.8427734375, 2.431640625, 0.66357421875, 3.203125, 0.132080078125, 0.461181640625, 0.779296875, 1.9482421875, 1.8720703125, 0.845703125, -1.3837890625, -0.138916015625, 0.35546875, 0.2457275390625, 0.75341796875, 1.828125, 1.4169921875, 0.60791015625, 1.0068359375, 1.109375, 0.484130859375, -0.302001953125, 0.4951171875, 0.802734375, 1.9482421875, 0.916015625, 0.1646728515625, 2.599609375, 1.7177734375, -0.2374267578125, 0.98046875, 0.39306640625, -1.1396484375, 1.6533203125, 0.375244140625], "scores": [0.09906005859375, 0.12213134765625, 0.05035400390625, 0.16552734375, 0.0037384033203125, 0.010101318359375, 0.058197021484375, 0.10552978515625, 0.1141357421875, 0.115234375, 0.00444793701171875, 0.00812530517578125, 0.0343017578125, 0.009002685546875, 0.087158203125, 0.00818634033203125, 0.003238677978515625, 0.024169921875, 0.00702667236328125, 0.00936126708984375, 0.00632476806640625, 0.0293731689453125, 0.01800537109375, 0.0088348388671875, 0.013397216796875, 0.02557373046875, 0.12109375, 0.004413604736328125, 0.016571044921875, 0.00274658203125, 0.2142333984375, 0.29638671875, 0.16015625, 0.007843017578125, 0.007160186767578125, 0.00508880615234375, 0.054229736328125, 0.048736572265625, 0.026397705078125, 0.0265350341796875, 0.051361083984375, 0.018310546875, 0.00974273681640625, 0.0218963623046875, 0.216064453125, 0.021728515625, 0.0173797607421875, 0.004520416259765625], "stoks": [52, 52, 52, 52, 52, 41, 41, 374, 303, 303, 303, 427], "time": {"begin_ms": 640, "end_ms": 1140}}]}',
                },
                {
                    id: "7645a0d1-2e64-410d-83a8-b96040432e9a",
                    chatId: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
                    timestamp: 1716244957031,
                    role: "AGENT",
                    type: "AGENT_MESSAGE",
                    messageText: "Hello!",
                    emotionFeatures:
                        '{"Admiration": 0.044921875, "Adoration": 0.0253753662109375, "Aesthetic Appreciation": 0.03265380859375, "Amusement": 0.118408203125, "Anger": 0.06719970703125, "Anxiety": 0.0411376953125, "Awe": 0.03802490234375, "Awkwardness": 0.056549072265625, "Boredom": 0.04217529296875, "Calmness": 0.08709716796875, "Concentration": 0.070556640625, "Confusion": 0.06964111328125, "Contemplation": 0.0343017578125, "Contempt": 0.037689208984375, "Contentment": 0.059417724609375, "Craving": 0.01132965087890625, "Desire": 0.01406097412109375, "Determination": 0.1143798828125, "Disappointment": 0.051177978515625, "Disgust": 0.028594970703125, "Distress": 0.054901123046875, "Doubt": 0.04638671875, "Ecstasy": 0.0258026123046875, "Embarrassment": 0.0222015380859375, "Empathic Pain": 0.015777587890625, "Entrancement": 0.0160980224609375, "Envy": 0.0163421630859375, "Excitement": 0.129638671875, "Fear": 0.03125, "Guilt": 0.01483917236328125, "Horror": 0.0194549560546875, "Interest": 0.1341552734375, "Joy": 0.0738525390625, "Love": 0.0216522216796875, "Nostalgia": 0.0210418701171875, "Pain": 0.020721435546875, "Pride": 0.05499267578125, "Realization": 0.0728759765625, "Relief": 0.04052734375, "Romance": 0.0129241943359375, "Sadness": 0.0254669189453125, "Satisfaction": 0.07159423828125, "Shame": 0.01495361328125, "Surprise (negative)": 0.05560302734375, "Surprise (positive)": 0.07965087890625, "Sympathy": 0.022247314453125, "Tiredness": 0.0194549560546875, "Triumph": 0.04107666015625}',
                    metadata: "",
                },
            ],
            pageNumber: 0,
            pageSize: 3,
            totalPages: 1,
            endTimestamp: 1716244958546,
            metadata: "",
            config: {
                id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
                version: 0,
            },
        };
        const page = await client.empathicVoice.chats.listChatEvents("470a49f6-1dec-4afe-8b61-035d3b2d63b0", {
            pageNumber: 0,
            pageSize: 3,
            ascendingOrder: true,
        });

        expect(expected.eventsPage).toEqual(page.data);
        expect(page.hasNextPage()).toBe(true);
        const nextPage = await page.getNextPage();
        expect(expected.eventsPage).toEqual(nextPage.data);
    });

    test("list-chat-events (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/chats/id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.chats.listChatEvents("id");
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("get-audio (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
            user_id: "e6235940-cfda-3988-9147-ff531627cf42",
            status: "COMPLETE",
            filename:
                "e6235940-cfda-3988-9147-ff531627cf42/470a49f6-1dec-4afe-8b61-035d3b2d63b0/reconstructed_audio.mp4",
            modified_at: 1729875432555,
            signed_audio_url: "https://storage.googleapis.com/...etc.",
            signed_url_expiration_timestamp_millis: 1730232816964,
        };
        server
            .mockEndpoint()
            .get("/v0/evi/chats/470a49f6-1dec-4afe-8b61-035d3b2d63b0/audio")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.chats.getAudio("470a49f6-1dec-4afe-8b61-035d3b2d63b0");
        expect(response).toEqual({
            id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
            userId: "e6235940-cfda-3988-9147-ff531627cf42",
            status: "COMPLETE",
            filename:
                "e6235940-cfda-3988-9147-ff531627cf42/470a49f6-1dec-4afe-8b61-035d3b2d63b0/reconstructed_audio.mp4",
            modifiedAt: 1729875432555,
            signedAudioUrl: "https://storage.googleapis.com/...etc.",
            signedUrlExpirationTimestampMillis: 1730232816964,
        });
    });

    test("get-audio (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v0/evi/chats/id/audio")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.chats.getAudio("id");
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });
});

```


## /tests/wire/empathic-voice/configs.test.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import * as Hume from "../../../src/api/index";
import { HumeClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("ConfigsClient", () => {
    test("list-configs (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            page_number: 0,
            page_size: 1,
            total_pages: 1,
            configs_page: [
                {
                    id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
                    version: 0,
                    version_description: "",
                    name: "Weather Assistant Config",
                    created_on: 1715267200693,
                    modified_on: 1715267200693,
                    evi_version: "3",
                    prompt: {
                        id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                        version: 0,
                        version_type: "FIXED",
                        version_description: "",
                        name: "Weather Assistant Prompt",
                        created_on: 1715267200693,
                        modified_on: 1715267200693,
                        text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                    },
                    voice: { provider: "HUME_AI", name: "Ava Song", id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c" },
                    language_model: {
                        model_provider: "ANTHROPIC",
                        model_resource: "claude-3-7-sonnet-latest",
                        temperature: 1,
                    },
                    ellm_model: { allow_short_responses: false },
                    tools: [],
                    builtin_tools: [],
                    event_messages: {
                        on_new_chat: { enabled: false, text: "" },
                        on_inactivity_timeout: { enabled: false, text: "" },
                        on_max_duration_timeout: { enabled: false, text: "" },
                    },
                    timeouts: {
                        inactivity: { enabled: true, duration_secs: 600 },
                        max_duration: { enabled: true, duration_secs: 1800 },
                    },
                },
            ],
        };
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/configs")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const expected = {
            pageNumber: 0,
            pageSize: 1,
            totalPages: 1,
            configsPage: [
                {
                    id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
                    version: 0,
                    versionDescription: "",
                    name: "Weather Assistant Config",
                    createdOn: 1715267200693,
                    modifiedOn: 1715267200693,
                    eviVersion: "3",
                    prompt: {
                        id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                        version: 0,
                        versionType: "FIXED",
                        versionDescription: "",
                        name: "Weather Assistant Prompt",
                        createdOn: 1715267200693,
                        modifiedOn: 1715267200693,
                        text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                    },
                    voice: {
                        provider: "HUME_AI",
                        name: "Ava Song",
                        id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c",
                    },
                    languageModel: {
                        modelProvider: "ANTHROPIC",
                        modelResource: "claude-3-7-sonnet-latest",
                        temperature: 1,
                    },
                    ellmModel: {
                        allowShortResponses: false,
                    },
                    tools: [],
                    builtinTools: [],
                    eventMessages: {
                        onNewChat: {
                            enabled: false,
                            text: "",
                        },
                        onInactivityTimeout: {
                            enabled: false,
                            text: "",
                        },
                        onMaxDurationTimeout: {
                            enabled: false,
                            text: "",
                        },
                    },
                    timeouts: {
                        inactivity: {
                            enabled: true,
                            durationSecs: 600,
                        },
                        maxDuration: {
                            enabled: true,
                            durationSecs: 1800,
                        },
                    },
                },
            ],
        };
        const page = await client.empathicVoice.configs.listConfigs({
            pageNumber: 0,
            pageSize: 1,
        });

        expect(expected.configsPage).toEqual(page.data);
        expect(page.hasNextPage()).toBe(true);
        const nextPage = await page.getNextPage();
        expect(expected.configsPage).toEqual(nextPage.data);
    });

    test("list-configs (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/configs")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.configs.listConfigs();
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("create-config (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = {
            name: "Weather Assistant Config",
            prompt: { id: "af699d45-2985-42cc-91b9-af9e5da3bac5", version: 0 },
            evi_version: "3",
            voice: { provider: "HUME_AI", name: "Ava Song" },
            language_model: { model_provider: "ANTHROPIC", model_resource: "claude-3-7-sonnet-latest", temperature: 1 },
            event_messages: {
                on_new_chat: { enabled: false, text: "" },
                on_inactivity_timeout: { enabled: false, text: "" },
                on_max_duration_timeout: { enabled: false, text: "" },
            },
        };
        const rawResponseBody = {
            id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
            version: 0,
            version_description: "",
            name: "Weather Assistant Config",
            created_on: 1715275452390,
            modified_on: 1715275452390,
            evi_version: "3",
            prompt: {
                id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                version: 0,
                version_type: "FIXED",
                version_description: "",
                name: "Weather Assistant Prompt",
                created_on: 1715267200693,
                modified_on: 1715267200693,
                text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
            },
            voice: { provider: "HUME_AI", name: "Ava Song", id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c" },
            language_model: { model_provider: "ANTHROPIC", model_resource: "claude-3-7-sonnet-latest", temperature: 1 },
            ellm_model: { allow_short_responses: false },
            tools: [],
            builtin_tools: [],
            event_messages: {
                on_new_chat: { enabled: false, text: "" },
                on_inactivity_timeout: { enabled: false, text: "" },
                on_max_duration_timeout: { enabled: false, text: "" },
            },
            timeouts: {
                inactivity: { enabled: true, duration_secs: 600 },
                max_duration: { enabled: true, duration_secs: 1800 },
            },
        };
        server
            .mockEndpoint()
            .post("/v0/evi/configs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.configs.createConfig({
            name: "Weather Assistant Config",
            prompt: {
                id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                version: 0,
            },
            eviVersion: "3",
            voice: {
                provider: "HUME_AI",
                name: "Ava Song",
            },
            languageModel: {
                modelProvider: "ANTHROPIC",
                modelResource: "claude-3-7-sonnet-latest",
                temperature: 1,
            },
            eventMessages: {
                onNewChat: {
                    enabled: false,
                    text: "",
                },
                onInactivityTimeout: {
                    enabled: false,
                    text: "",
                },
                onMaxDurationTimeout: {
                    enabled: false,
                    text: "",
                },
            },
        });
        expect(response).toEqual({
            id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
            version: 0,
            versionDescription: "",
            name: "Weather Assistant Config",
            createdOn: 1715275452390,
            modifiedOn: 1715275452390,
            eviVersion: "3",
            prompt: {
                id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                version: 0,
                versionType: "FIXED",
                versionDescription: "",
                name: "Weather Assistant Prompt",
                createdOn: 1715267200693,
                modifiedOn: 1715267200693,
                text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
            },
            voice: {
                provider: "HUME_AI",
                name: "Ava Song",
                id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c",
            },
            languageModel: {
                modelProvider: "ANTHROPIC",
                modelResource: "claude-3-7-sonnet-latest",
                temperature: 1,
            },
            ellmModel: {
                allowShortResponses: false,
            },
            tools: [],
            builtinTools: [],
            eventMessages: {
                onNewChat: {
                    enabled: false,
                    text: "",
                },
                onInactivityTimeout: {
                    enabled: false,
                    text: "",
                },
                onMaxDurationTimeout: {
                    enabled: false,
                    text: "",
                },
            },
            timeouts: {
                inactivity: {
                    enabled: true,
                    durationSecs: 600,
                },
                maxDuration: {
                    enabled: true,
                    durationSecs: 1800,
                },
            },
        });
    });

    test("create-config (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { evi_version: "evi_version", name: "name" };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v0/evi/configs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.configs.createConfig({
                eviVersion: "evi_version",
                name: "name",
            });
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("list-config-versions (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            page_number: 0,
            page_size: 10,
            total_pages: 1,
            configs_page: [
                {
                    id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
                    version: 0,
                    version_description: "",
                    name: "Weather Assistant Config",
                    created_on: 1715275452390,
                    modified_on: 1715275452390,
                    evi_version: "3",
                    prompt: {
                        id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                        version: 0,
                        version_type: "FIXED",
                        version_description: "",
                        name: "Weather Assistant Prompt",
                        created_on: 1715267200693,
                        modified_on: 1715267200693,
                        text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                    },
                    voice: { provider: "HUME_AI", name: "Ava Song", id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c" },
                    language_model: {
                        model_provider: "ANTHROPIC",
                        model_resource: "claude-3-7-sonnet-latest",
                        temperature: 1,
                    },
                    ellm_model: { allow_short_responses: false },
                    tools: [],
                    builtin_tools: [],
                    event_messages: {
                        on_new_chat: { enabled: false, text: "" },
                        on_inactivity_timeout: { enabled: false, text: "" },
                        on_max_duration_timeout: { enabled: false, text: "" },
                    },
                    timeouts: {
                        inactivity: { enabled: true, duration_secs: 600 },
                        max_duration: { enabled: true, duration_secs: 1800 },
                    },
                },
            ],
        };
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/configs/1b60e1a0-cc59-424a-8d2c-189d354db3f3")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const expected = {
            pageNumber: 0,
            pageSize: 10,
            totalPages: 1,
            configsPage: [
                {
                    id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
                    version: 0,
                    versionDescription: "",
                    name: "Weather Assistant Config",
                    createdOn: 1715275452390,
                    modifiedOn: 1715275452390,
                    eviVersion: "3",
                    prompt: {
                        id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                        version: 0,
                        versionType: "FIXED",
                        versionDescription: "",
                        name: "Weather Assistant Prompt",
                        createdOn: 1715267200693,
                        modifiedOn: 1715267200693,
                        text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                    },
                    voice: {
                        provider: "HUME_AI",
                        name: "Ava Song",
                        id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c",
                    },
                    languageModel: {
                        modelProvider: "ANTHROPIC",
                        modelResource: "claude-3-7-sonnet-latest",
                        temperature: 1,
                    },
                    ellmModel: {
                        allowShortResponses: false,
                    },
                    tools: [],
                    builtinTools: [],
                    eventMessages: {
                        onNewChat: {
                            enabled: false,
                            text: "",
                        },
                        onInactivityTimeout: {
                            enabled: false,
                            text: "",
                        },
                        onMaxDurationTimeout: {
                            enabled: false,
                            text: "",
                        },
                    },
                    timeouts: {
                        inactivity: {
                            enabled: true,
                            durationSecs: 600,
                        },
                        maxDuration: {
                            enabled: true,
                            durationSecs: 1800,
                        },
                    },
                },
            ],
        };
        const page = await client.empathicVoice.configs.listConfigVersions("1b60e1a0-cc59-424a-8d2c-189d354db3f3");

        expect(expected.configsPage).toEqual(page.data);
        expect(page.hasNextPage()).toBe(true);
        const nextPage = await page.getNextPage();
        expect(expected.configsPage).toEqual(nextPage.data);
    });

    test("list-config-versions (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/configs/id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.configs.listConfigVersions("id");
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("create-config-version (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = {
            version_description: "This is an updated version of the Weather Assistant Config.",
            evi_version: "3",
            prompt: { id: "af699d45-2985-42cc-91b9-af9e5da3bac5", version: 0 },
            voice: { provider: "HUME_AI", name: "Ava Song" },
            language_model: { model_provider: "ANTHROPIC", model_resource: "claude-3-7-sonnet-latest", temperature: 1 },
            ellm_model: { allow_short_responses: true },
            event_messages: {
                on_new_chat: { enabled: false, text: "" },
                on_inactivity_timeout: { enabled: false, text: "" },
                on_max_duration_timeout: { enabled: false, text: "" },
            },
        };
        const rawResponseBody = {
            id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
            version: 1,
            version_description: "This is an updated version of the Weather Assistant Config.",
            name: "Weather Assistant Config",
            created_on: 1715275452390,
            modified_on: 1722642242998,
            evi_version: "3",
            prompt: {
                id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                version: 0,
                version_type: "FIXED",
                version_description: "",
                name: "Weather Assistant Prompt",
                created_on: 1715267200693,
                modified_on: 1715267200693,
                text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
            },
            voice: { provider: "HUME_AI", name: "Ava Song", id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c" },
            language_model: { model_provider: "ANTHROPIC", model_resource: "claude-3-7-sonnet-latest", temperature: 1 },
            ellm_model: { allow_short_responses: true },
            tools: [],
            builtin_tools: [],
            event_messages: {
                on_new_chat: { enabled: false, text: "" },
                on_inactivity_timeout: { enabled: false, text: "" },
                on_max_duration_timeout: { enabled: false, text: "" },
            },
            timeouts: {
                inactivity: { enabled: true, duration_secs: 600 },
                max_duration: { enabled: true, duration_secs: 1800 },
            },
        };
        server
            .mockEndpoint()
            .post("/v0/evi/configs/1b60e1a0-cc59-424a-8d2c-189d354db3f3")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.configs.createConfigVersion(
            "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
            {
                versionDescription: "This is an updated version of the Weather Assistant Config.",
                eviVersion: "3",
                prompt: {
                    id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                    version: 0,
                },
                voice: {
                    provider: "HUME_AI",
                    name: "Ava Song",
                },
                languageModel: {
                    modelProvider: "ANTHROPIC",
                    modelResource: "claude-3-7-sonnet-latest",
                    temperature: 1,
                },
                ellmModel: {
                    allowShortResponses: true,
                },
                eventMessages: {
                    onNewChat: {
                        enabled: false,
                        text: "",
                    },
                    onInactivityTimeout: {
                        enabled: false,
                        text: "",
                    },
                    onMaxDurationTimeout: {
                        enabled: false,
                        text: "",
                    },
                },
            },
        );
        expect(response).toEqual({
            id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
            version: 1,
            versionDescription: "This is an updated version of the Weather Assistant Config.",
            name: "Weather Assistant Config",
            createdOn: 1715275452390,
            modifiedOn: 1722642242998,
            eviVersion: "3",
            prompt: {
                id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                version: 0,
                versionType: "FIXED",
                versionDescription: "",
                name: "Weather Assistant Prompt",
                createdOn: 1715267200693,
                modifiedOn: 1715267200693,
                text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
            },
            voice: {
                provider: "HUME_AI",
                name: "Ava Song",
                id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c",
            },
            languageModel: {
                modelProvider: "ANTHROPIC",
                modelResource: "claude-3-7-sonnet-latest",
                temperature: 1,
            },
            ellmModel: {
                allowShortResponses: true,
            },
            tools: [],
            builtinTools: [],
            eventMessages: {
                onNewChat: {
                    enabled: false,
                    text: "",
                },
                onInactivityTimeout: {
                    enabled: false,
                    text: "",
                },
                onMaxDurationTimeout: {
                    enabled: false,
                    text: "",
                },
            },
            timeouts: {
                inactivity: {
                    enabled: true,
                    durationSecs: 600,
                },
                maxDuration: {
                    enabled: true,
                    durationSecs: 1800,
                },
            },
        });
    });

    test("create-config-version (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { evi_version: "evi_version" };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v0/evi/configs/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.configs.createConfigVersion("id", {
                eviVersion: "evi_version",
            });
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("delete-config (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        server
            .mockEndpoint()
            .delete("/v0/evi/configs/1b60e1a0-cc59-424a-8d2c-189d354db3f3")
            .respondWith()
            .statusCode(200)
            .build();

        const response = await client.empathicVoice.configs.deleteConfig("1b60e1a0-cc59-424a-8d2c-189d354db3f3");
        expect(response).toEqual(undefined);
    });

    test("delete-config (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .delete("/v0/evi/configs/id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.configs.deleteConfig("id");
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("get-config-version (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
            version: 1,
            version_description: "",
            name: "Weather Assistant Config",
            created_on: 1715275452390,
            modified_on: 1715275452390,
            evi_version: "3",
            prompt: {
                id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                version: 0,
                version_type: "FIXED",
                version_description: "",
                name: "Weather Assistant Prompt",
                created_on: 1715267200693,
                modified_on: 1715267200693,
                text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
            },
            voice: { provider: "HUME_AI", name: "Ava Song", id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c" },
            language_model: { model_provider: "ANTHROPIC", model_resource: "claude-3-7-sonnet-latest", temperature: 1 },
            ellm_model: { allow_short_responses: false },
            tools: [],
            builtin_tools: [],
            event_messages: {
                on_new_chat: { enabled: false, text: "" },
                on_inactivity_timeout: { enabled: false, text: "" },
                on_max_duration_timeout: { enabled: false, text: "" },
            },
            timeouts: {
                inactivity: { enabled: true, duration_secs: 600 },
                max_duration: { enabled: true, duration_secs: 1800 },
            },
        };
        server
            .mockEndpoint()
            .get("/v0/evi/configs/1b60e1a0-cc59-424a-8d2c-189d354db3f3/version/1")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.configs.getConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1);
        expect(response).toEqual({
            id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
            version: 1,
            versionDescription: "",
            name: "Weather Assistant Config",
            createdOn: 1715275452390,
            modifiedOn: 1715275452390,
            eviVersion: "3",
            prompt: {
                id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                version: 0,
                versionType: "FIXED",
                versionDescription: "",
                name: "Weather Assistant Prompt",
                createdOn: 1715267200693,
                modifiedOn: 1715267200693,
                text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
            },
            voice: {
                provider: "HUME_AI",
                name: "Ava Song",
                id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c",
            },
            languageModel: {
                modelProvider: "ANTHROPIC",
                modelResource: "claude-3-7-sonnet-latest",
                temperature: 1,
            },
            ellmModel: {
                allowShortResponses: false,
            },
            tools: [],
            builtinTools: [],
            eventMessages: {
                onNewChat: {
                    enabled: false,
                    text: "",
                },
                onInactivityTimeout: {
                    enabled: false,
                    text: "",
                },
                onMaxDurationTimeout: {
                    enabled: false,
                    text: "",
                },
            },
            timeouts: {
                inactivity: {
                    enabled: true,
                    durationSecs: 600,
                },
                maxDuration: {
                    enabled: true,
                    durationSecs: 1800,
                },
            },
        });
    });

    test("get-config-version (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v0/evi/configs/id/version/1")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.configs.getConfigVersion("id", 1);
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("delete-config-version (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        server
            .mockEndpoint()
            .delete("/v0/evi/configs/1b60e1a0-cc59-424a-8d2c-189d354db3f3/version/1")
            .respondWith()
            .statusCode(200)
            .build();

        const response = await client.empathicVoice.configs.deleteConfigVersion(
            "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
            1,
        );
        expect(response).toEqual(undefined);
    });

    test("delete-config-version (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .delete("/v0/evi/configs/id/version/1")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.configs.deleteConfigVersion("id", 1);
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("update-config-description (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { version_description: "This is an updated version_description." };
        const rawResponseBody = {
            id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
            version: 1,
            version_description: "This is an updated version_description.",
            name: "Weather Assistant Config",
            created_on: 1715275452390,
            modified_on: 1715275452390,
            evi_version: "3",
            prompt: {
                id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                version: 0,
                version_type: "FIXED",
                version_description: "",
                name: "Weather Assistant Prompt",
                created_on: 1715267200693,
                modified_on: 1715267200693,
                text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
            },
            voice: { provider: "HUME_AI", name: "Ava Song", id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c" },
            language_model: { model_provider: "ANTHROPIC", model_resource: "claude-3-7-sonnet-latest", temperature: 1 },
            ellm_model: { allow_short_responses: false },
            tools: [],
            builtin_tools: [],
            event_messages: {
                on_new_chat: { enabled: false, text: "" },
                on_inactivity_timeout: { enabled: false, text: "" },
                on_max_duration_timeout: { enabled: false, text: "" },
            },
            timeouts: {
                inactivity: { enabled: true, duration_secs: 600 },
                max_duration: { enabled: true, duration_secs: 1800 },
            },
        };
        server
            .mockEndpoint()
            .patch("/v0/evi/configs/1b60e1a0-cc59-424a-8d2c-189d354db3f3/version/1")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.configs.updateConfigDescription(
            "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
            1,
            {
                versionDescription: "This is an updated version_description.",
            },
        );
        expect(response).toEqual({
            id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
            version: 1,
            versionDescription: "This is an updated version_description.",
            name: "Weather Assistant Config",
            createdOn: 1715275452390,
            modifiedOn: 1715275452390,
            eviVersion: "3",
            prompt: {
                id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                version: 0,
                versionType: "FIXED",
                versionDescription: "",
                name: "Weather Assistant Prompt",
                createdOn: 1715267200693,
                modifiedOn: 1715267200693,
                text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
            },
            voice: {
                provider: "HUME_AI",
                name: "Ava Song",
                id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c",
            },
            languageModel: {
                modelProvider: "ANTHROPIC",
                modelResource: "claude-3-7-sonnet-latest",
                temperature: 1,
            },
            ellmModel: {
                allowShortResponses: false,
            },
            tools: [],
            builtinTools: [],
            eventMessages: {
                onNewChat: {
                    enabled: false,
                    text: "",
                },
                onInactivityTimeout: {
                    enabled: false,
                    text: "",
                },
                onMaxDurationTimeout: {
                    enabled: false,
                    text: "",
                },
            },
            timeouts: {
                inactivity: {
                    enabled: true,
                    durationSecs: 600,
                },
                maxDuration: {
                    enabled: true,
                    durationSecs: 1800,
                },
            },
        });
    });

    test("update-config-description (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = {};
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .patch("/v0/evi/configs/id/version/1")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.configs.updateConfigDescription("id", 1);
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });
});

```


## /tests/wire/empathic-voice/controlPlane.test.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import * as Hume from "../../../src/api/index";
import { HumeClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("ControlPlaneClient", () => {
    test("send (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { type: "session_settings" };

        server
            .mockEndpoint()
            .post("/v0/evi/chat/chat_id/send")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .build();

        const response = await client.empathicVoice.controlPlane.send("chat_id", {
            type: "session_settings",
        });
        expect(response).toEqual(undefined);
    });

    test("send (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { type: "session_settings" };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v0/evi/chat/chat_id/send")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.controlPlane.send("chat_id", {
                type: "session_settings",
            });
        }).rejects.toThrow(Hume.empathicVoice.UnprocessableEntityError);
    });
});

```


## /tests/wire/empathic-voice/prompts.test.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import * as Hume from "../../../src/api/index";
import { HumeClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("PromptsClient", () => {
    test("list-prompts (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            page_number: 0,
            page_size: 2,
            total_pages: 1,
            prompts_page: [
                {
                    id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                    version: 0,
                    version_type: "FIXED",
                    version_description: "",
                    name: "Weather Assistant Prompt",
                    created_on: 1715267200693,
                    modified_on: 1715267200693,
                    text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                },
                {
                    id: "616b2b4c-a096-4445-9c23-64058b564fc2",
                    version: 0,
                    version_type: "FIXED",
                    version_description: "",
                    name: "Web Search Assistant Prompt",
                    created_on: 1715267200693,
                    modified_on: 1715267200693,
                    text: "<role>You are an AI web search assistant designed to help users find accurate and relevant information on the web. Respond to user queries promptly, using the built-in web search tool to retrieve up-to-date results. Present information clearly and concisely, summarizing key points where necessary. Use simple language and avoid technical jargon. If needed, provide helpful tips for refining search queries to obtain better results.</role>",
                },
            ],
        };
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/prompts")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const expected = {
            pageNumber: 0,
            pageSize: 2,
            totalPages: 1,
            promptsPage: [
                {
                    id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                    version: 0,
                    versionType: "FIXED",
                    versionDescription: "",
                    name: "Weather Assistant Prompt",
                    createdOn: 1715267200693,
                    modifiedOn: 1715267200693,
                    text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                },
                {
                    id: "616b2b4c-a096-4445-9c23-64058b564fc2",
                    version: 0,
                    versionType: "FIXED",
                    versionDescription: "",
                    name: "Web Search Assistant Prompt",
                    createdOn: 1715267200693,
                    modifiedOn: 1715267200693,
                    text: "<role>You are an AI web search assistant designed to help users find accurate and relevant information on the web. Respond to user queries promptly, using the built-in web search tool to retrieve up-to-date results. Present information clearly and concisely, summarizing key points where necessary. Use simple language and avoid technical jargon. If needed, provide helpful tips for refining search queries to obtain better results.</role>",
                },
            ],
        };
        const page = await client.empathicVoice.prompts.listPrompts({
            pageNumber: 0,
            pageSize: 2,
        });

        expect(expected.promptsPage).toEqual(page.data);
        expect(page.hasNextPage()).toBe(true);
        const nextPage = await page.getNextPage();
        expect(expected.promptsPage).toEqual(nextPage.data);
    });

    test("list-prompts (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/prompts")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.prompts.listPrompts();
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("create-prompt (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = {
            name: "Weather Assistant Prompt",
            text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
        };
        const rawResponseBody = {
            id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
            version: 0,
            version_type: "FIXED",
            name: "Weather Assistant Prompt",
            created_on: 1722633247488,
            modified_on: 1722633247488,
            text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
        };
        server
            .mockEndpoint()
            .post("/v0/evi/prompts")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.prompts.createPrompt({
            name: "Weather Assistant Prompt",
            text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
        });
        expect(response).toEqual({
            id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
            version: 0,
            versionType: "FIXED",
            name: "Weather Assistant Prompt",
            createdOn: 1722633247488,
            modifiedOn: 1722633247488,
            text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
        });
    });

    test("create-prompt (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { name: "name", text: "text" };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v0/evi/prompts")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.prompts.createPrompt({
                name: "name",
                text: "text",
            });
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("list-prompt-versions (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            page_number: 0,
            page_size: 10,
            total_pages: 1,
            prompts_page: [
                {
                    id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                    version: 0,
                    version_type: "FIXED",
                    version_description: "",
                    name: "Weather Assistant Prompt",
                    created_on: 1722633247488,
                    modified_on: 1722633247488,
                    text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/v0/evi/prompts/af699d45-2985-42cc-91b9-af9e5da3bac5")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.prompts.listPromptVersions("af699d45-2985-42cc-91b9-af9e5da3bac5");
        expect(response).toEqual({
            pageNumber: 0,
            pageSize: 10,
            totalPages: 1,
            promptsPage: [
                {
                    id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
                    version: 0,
                    versionType: "FIXED",
                    versionDescription: "",
                    name: "Weather Assistant Prompt",
                    createdOn: 1722633247488,
                    modifiedOn: 1722633247488,
                    text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                },
            ],
        });
    });

    test("list-prompt-versions (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server.mockEndpoint().get("/v0/evi/prompts/id").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.empathicVoice.prompts.listPromptVersions("id");
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("create-prompt-version (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = {
            text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
            version_description: "This is an updated version of the Weather Assistant Prompt.",
        };
        const rawResponseBody = {
            id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
            version: 1,
            version_type: "FIXED",
            version_description: "This is an updated version of the Weather Assistant Prompt.",
            name: "Weather Assistant Prompt",
            created_on: 1722633247488,
            modified_on: 1722635140150,
            text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
        };
        server
            .mockEndpoint()
            .post("/v0/evi/prompts/af699d45-2985-42cc-91b9-af9e5da3bac5")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.prompts.createPromptVersion(
            "af699d45-2985-42cc-91b9-af9e5da3bac5",
            {
                text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
                versionDescription: "This is an updated version of the Weather Assistant Prompt.",
            },
        );
        expect(response).toEqual({
            id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
            version: 1,
            versionType: "FIXED",
            versionDescription: "This is an updated version of the Weather Assistant Prompt.",
            name: "Weather Assistant Prompt",
            createdOn: 1722633247488,
            modifiedOn: 1722635140150,
            text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
        });
    });

    test("create-prompt-version (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { text: "text" };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v0/evi/prompts/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.prompts.createPromptVersion("id", {
                text: "text",
            });
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("delete-prompt (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        server
            .mockEndpoint()
            .delete("/v0/evi/prompts/af699d45-2985-42cc-91b9-af9e5da3bac5")
            .respondWith()
            .statusCode(200)
            .build();

        const response = await client.empathicVoice.prompts.deletePrompt("af699d45-2985-42cc-91b9-af9e5da3bac5");
        expect(response).toEqual(undefined);
    });

    test("delete-prompt (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .delete("/v0/evi/prompts/id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.prompts.deletePrompt("id");
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("get-prompt-version (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
            version: 0,
            version_type: "FIXED",
            version_description: "",
            name: "Weather Assistant Prompt",
            created_on: 1722633247488,
            modified_on: 1722633247488,
            text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
        };
        server
            .mockEndpoint()
            .get("/v0/evi/prompts/af699d45-2985-42cc-91b9-af9e5da3bac5/version/0")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.prompts.getPromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", 0);
        expect(response).toEqual({
            id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
            version: 0,
            versionType: "FIXED",
            versionDescription: "",
            name: "Weather Assistant Prompt",
            createdOn: 1722633247488,
            modifiedOn: 1722633247488,
            text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
        });
    });

    test("get-prompt-version (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v0/evi/prompts/id/version/1")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.prompts.getPromptVersion("id", 1);
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("delete-prompt-version (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        server
            .mockEndpoint()
            .delete("/v0/evi/prompts/af699d45-2985-42cc-91b9-af9e5da3bac5/version/1")
            .respondWith()
            .statusCode(200)
            .build();

        const response = await client.empathicVoice.prompts.deletePromptVersion(
            "af699d45-2985-42cc-91b9-af9e5da3bac5",
            1,
        );
        expect(response).toEqual(undefined);
    });

    test("delete-prompt-version (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .delete("/v0/evi/prompts/id/version/1")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.prompts.deletePromptVersion("id", 1);
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("update-prompt-description (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { version_description: "This is an updated version_description." };
        const rawResponseBody = {
            id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
            version: 1,
            version_type: "FIXED",
            version_description: "This is an updated version_description.",
            name: "string",
            created_on: 1722633247488,
            modified_on: 1722634770585,
            text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
        };
        server
            .mockEndpoint()
            .patch("/v0/evi/prompts/af699d45-2985-42cc-91b9-af9e5da3bac5/version/1")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.prompts.updatePromptDescription(
            "af699d45-2985-42cc-91b9-af9e5da3bac5",
            1,
            {
                versionDescription: "This is an updated version_description.",
            },
        );
        expect(response).toEqual({
            id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
            version: 1,
            versionType: "FIXED",
            versionDescription: "This is an updated version_description.",
            name: "string",
            createdOn: 1722633247488,
            modifiedOn: 1722634770585,
            text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
        });
    });

    test("update-prompt-description (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = {};
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .patch("/v0/evi/prompts/id/version/1")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.prompts.updatePromptDescription("id", 1);
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });
});

```


## /tests/wire/empathic-voice/tools.test.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import * as Hume from "../../../src/api/index";
import { HumeClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("ToolsClient", () => {
    test("list-tools (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            page_number: 0,
            page_size: 2,
            total_pages: 1,
            tools_page: [
                {
                    tool_type: "FUNCTION",
                    id: "d20827af-5d8d-4f66-b6b9-ce2e3e1ea2b2",
                    version: 0,
                    version_type: "FIXED",
                    version_description: "Fetches user's current location.",
                    name: "get_current_location",
                    created_on: 1715267200693,
                    modified_on: 1715267200693,
                    fallback_content: "Unable to fetch location.",
                    description: "Fetches user's current location.",
                    parameters:
                        '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }}, "required": ["location"] }',
                },
                {
                    tool_type: "FUNCTION",
                    id: "4442f3ea-9038-40e3-a2ce-1522b7de770f",
                    version: 0,
                    version_type: "FIXED",
                    version_description:
                        "Fetches current weather and uses celsius or fahrenheit based on location of user.",
                    name: "get_current_weather",
                    created_on: 1715266126705,
                    modified_on: 1715266126705,
                    fallback_content: "Unable to fetch location.",
                    description: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
                    parameters:
                        '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
                },
            ],
        };
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/tools")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const expected = {
            pageNumber: 0,
            pageSize: 2,
            totalPages: 1,
            toolsPage: [
                {
                    toolType: "FUNCTION",
                    id: "d20827af-5d8d-4f66-b6b9-ce2e3e1ea2b2",
                    version: 0,
                    versionType: "FIXED",
                    versionDescription: "Fetches user's current location.",
                    name: "get_current_location",
                    createdOn: 1715267200693,
                    modifiedOn: 1715267200693,
                    fallbackContent: "Unable to fetch location.",
                    description: "Fetches user's current location.",
                    parameters:
                        '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }}, "required": ["location"] }',
                },
                {
                    toolType: "FUNCTION",
                    id: "4442f3ea-9038-40e3-a2ce-1522b7de770f",
                    version: 0,
                    versionType: "FIXED",
                    versionDescription:
                        "Fetches current weather and uses celsius or fahrenheit based on location of user.",
                    name: "get_current_weather",
                    createdOn: 1715266126705,
                    modifiedOn: 1715266126705,
                    fallbackContent: "Unable to fetch location.",
                    description: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
                    parameters:
                        '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
                },
            ],
        };
        const page = await client.empathicVoice.tools.listTools({
            pageNumber: 0,
            pageSize: 2,
        });

        expect(expected.toolsPage).toEqual(page.data);
        expect(page.hasNextPage()).toBe(true);
        const nextPage = await page.getNextPage();
        expect(expected.toolsPage).toEqual(nextPage.data);
    });

    test("list-tools (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/tools")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.tools.listTools();
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("create-tool (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = {
            name: "get_current_weather",
            parameters:
                '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
            version_description: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
            description: "This tool is for getting the current weather.",
            fallback_content: "Unable to fetch current weather.",
        };
        const rawResponseBody = {
            tool_type: "FUNCTION",
            id: "aa9b71c4-723c-47ff-9f83-1a1829e74376",
            version: 0,
            version_type: "FIXED",
            version_description: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
            name: "get_current_weather",
            created_on: 1715275452390,
            modified_on: 1715275452390,
            fallback_content: "Unable to fetch current weather.",
            description: "This tool is for getting the current weather.",
            parameters:
                '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
        };
        server
            .mockEndpoint()
            .post("/v0/evi/tools")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.tools.createTool({
            name: "get_current_weather",
            parameters:
                '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
            versionDescription: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
            description: "This tool is for getting the current weather.",
            fallbackContent: "Unable to fetch current weather.",
        });
        expect(response).toEqual({
            toolType: "FUNCTION",
            id: "aa9b71c4-723c-47ff-9f83-1a1829e74376",
            version: 0,
            versionType: "FIXED",
            versionDescription: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
            name: "get_current_weather",
            createdOn: 1715275452390,
            modifiedOn: 1715275452390,
            fallbackContent: "Unable to fetch current weather.",
            description: "This tool is for getting the current weather.",
            parameters:
                '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
        });
    });

    test("create-tool (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { name: "name", parameters: "parameters" };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v0/evi/tools")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.tools.createTool({
                name: "name",
                parameters: "parameters",
            });
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("list-tool-versions (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            page_number: 0,
            page_size: 10,
            total_pages: 1,
            tools_page: [
                {
                    tool_type: "FUNCTION",
                    id: "00183a3f-79ba-413d-9f3b-609864268bea",
                    version: 1,
                    version_type: "FIXED",
                    version_description:
                        "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
                    name: "get_current_weather",
                    created_on: 1715277014228,
                    modified_on: 1715277602313,
                    fallback_content: "Unable to fetch current weather.",
                    description: "This tool is for getting the current weather.",
                    parameters:
                        '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
                },
            ],
        };
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/tools/00183a3f-79ba-413d-9f3b-609864268bea")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const expected = {
            pageNumber: 0,
            pageSize: 10,
            totalPages: 1,
            toolsPage: [
                {
                    toolType: "FUNCTION",
                    id: "00183a3f-79ba-413d-9f3b-609864268bea",
                    version: 1,
                    versionType: "FIXED",
                    versionDescription:
                        "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
                    name: "get_current_weather",
                    createdOn: 1715277014228,
                    modifiedOn: 1715277602313,
                    fallbackContent: "Unable to fetch current weather.",
                    description: "This tool is for getting the current weather.",
                    parameters:
                        '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
                },
            ],
        };
        const page = await client.empathicVoice.tools.listToolVersions("00183a3f-79ba-413d-9f3b-609864268bea");

        expect(expected.toolsPage).toEqual(page.data);
        expect(page.hasNextPage()).toBe(true);
        const nextPage = await page.getNextPage();
        expect(expected.toolsPage).toEqual(nextPage.data);
    });

    test("list-tool-versions (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint({ once: false })
            .get("/v0/evi/tools/id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.tools.listToolVersions("id");
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("create-tool-version (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = {
            parameters:
                '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
            version_description:
                "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
            fallback_content: "Unable to fetch current weather.",
            description: "This tool is for getting the current weather.",
        };
        const rawResponseBody = {
            tool_type: "FUNCTION",
            id: "00183a3f-79ba-413d-9f3b-609864268bea",
            version: 1,
            version_type: "FIXED",
            version_description:
                "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
            name: "get_current_weather",
            created_on: 1715277014228,
            modified_on: 1715277602313,
            fallback_content: "Unable to fetch current weather.",
            description: "This tool is for getting the current weather.",
            parameters:
                '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
        };
        server
            .mockEndpoint()
            .post("/v0/evi/tools/00183a3f-79ba-413d-9f3b-609864268bea")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.tools.createToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", {
            parameters:
                '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
            versionDescription:
                "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
            fallbackContent: "Unable to fetch current weather.",
            description: "This tool is for getting the current weather.",
        });
        expect(response).toEqual({
            toolType: "FUNCTION",
            id: "00183a3f-79ba-413d-9f3b-609864268bea",
            version: 1,
            versionType: "FIXED",
            versionDescription:
                "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
            name: "get_current_weather",
            createdOn: 1715277014228,
            modifiedOn: 1715277602313,
            fallbackContent: "Unable to fetch current weather.",
            description: "This tool is for getting the current weather.",
            parameters:
                '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
        });
    });

    test("create-tool-version (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { parameters: "parameters" };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v0/evi/tools/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.tools.createToolVersion("id", {
                parameters: "parameters",
            });
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("delete-tool (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        server
            .mockEndpoint()
            .delete("/v0/evi/tools/00183a3f-79ba-413d-9f3b-609864268bea")
            .respondWith()
            .statusCode(200)
            .build();

        const response = await client.empathicVoice.tools.deleteTool("00183a3f-79ba-413d-9f3b-609864268bea");
        expect(response).toEqual(undefined);
    });

    test("delete-tool (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .delete("/v0/evi/tools/id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.tools.deleteTool("id");
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("get-tool-version (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            tool_type: "FUNCTION",
            id: "00183a3f-79ba-413d-9f3b-609864268bea",
            version: 1,
            version_type: "FIXED",
            version_description:
                "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
            name: "string",
            created_on: 1715277014228,
            modified_on: 1715277602313,
            fallback_content: "Unable to fetch current weather.",
            description: "This tool is for getting the current weather.",
            parameters:
                '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
        };
        server
            .mockEndpoint()
            .get("/v0/evi/tools/00183a3f-79ba-413d-9f3b-609864268bea/version/1")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.tools.getToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1);
        expect(response).toEqual({
            toolType: "FUNCTION",
            id: "00183a3f-79ba-413d-9f3b-609864268bea",
            version: 1,
            versionType: "FIXED",
            versionDescription:
                "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
            name: "string",
            createdOn: 1715277014228,
            modifiedOn: 1715277602313,
            fallbackContent: "Unable to fetch current weather.",
            description: "This tool is for getting the current weather.",
            parameters:
                '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
        });
    });

    test("get-tool-version (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v0/evi/tools/id/version/1")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.tools.getToolVersion("id", 1);
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("delete-tool-version (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        server
            .mockEndpoint()
            .delete("/v0/evi/tools/00183a3f-79ba-413d-9f3b-609864268bea/version/1")
            .respondWith()
            .statusCode(200)
            .build();

        const response = await client.empathicVoice.tools.deleteToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1);
        expect(response).toEqual(undefined);
    });

    test("delete-tool-version (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .delete("/v0/evi/tools/id/version/1")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.tools.deleteToolVersion("id", 1);
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });

    test("update-tool-description (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = {
            version_description:
                "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region.",
        };
        const rawResponseBody = {
            tool_type: "FUNCTION",
            id: "00183a3f-79ba-413d-9f3b-609864268bea",
            version: 1,
            version_type: "FIXED",
            version_description:
                "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region.",
            name: "string",
            created_on: 1715277014228,
            modified_on: 1715277602313,
            fallback_content: "Unable to fetch current weather.",
            description: "This tool is for getting the current weather.",
            parameters:
                '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
        };
        server
            .mockEndpoint()
            .patch("/v0/evi/tools/00183a3f-79ba-413d-9f3b-609864268bea/version/1")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.empathicVoice.tools.updateToolDescription(
            "00183a3f-79ba-413d-9f3b-609864268bea",
            1,
            {
                versionDescription:
                    "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region.",
            },
        );
        expect(response).toEqual({
            toolType: "FUNCTION",
            id: "00183a3f-79ba-413d-9f3b-609864268bea",
            version: 1,
            versionType: "FIXED",
            versionDescription:
                "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region.",
            name: "string",
            createdOn: 1715277014228,
            modifiedOn: 1715277602313,
            fallbackContent: "Unable to fetch current weather.",
            description: "This tool is for getting the current weather.",
            parameters:
                '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
        });
    });

    test("update-tool-description (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = {};
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .patch("/v0/evi/tools/id/version/1")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.empathicVoice.tools.updateToolDescription("id", 1);
        }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
    });
});

```


## /tests/wire/expression-measurement/batch/main.test.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import { HumeClient } from "../../../../src/Client";
import { mockServerPool } from "../../../mock-server/MockServerPool";

describe("BatchClient", () => {
    test("list-jobs", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = [
            {
                job_id: "job_id",
                request: {
                    files: [{ filename: "filename", md5sum: "md5sum", content_type: "content_type" }],
                    models: {
                        burst: {},
                        face: {
                            fps_pred: 3,
                            identify_faces: false,
                            min_face_size: 60,
                            prob_threshold: 0.99,
                            save_faces: false,
                        },
                        facemesh: {},
                        language: { granularity: "word", identify_speakers: false },
                        ner: { identify_speakers: false },
                        prosody: { granularity: "utterance", identify_speakers: false },
                    },
                    notify: true,
                    text: [],
                    urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
                },
                state: {
                    status: "COMPLETED",
                    created_timestamp_ms: 1712587158717,
                    ended_timestamp_ms: 1712587159274,
                    num_errors: 0,
                    num_predictions: 10,
                    started_timestamp_ms: 1712587158800,
                },
                type: "INFERENCE",
            },
        ];
        server.mockEndpoint().get("/v0/batch/jobs").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.expressionMeasurement.batch.listJobs();
        expect(response).toEqual([
            {
                jobId: "job_id",
                request: {
                    files: [
                        {
                            filename: "filename",
                            md5Sum: "md5sum",
                            contentType: "content_type",
                        },
                    ],
                    models: {
                        burst: {},
                        face: {
                            fpsPred: 3,
                            identifyFaces: false,
                            minFaceSize: 60,
                            probThreshold: 0.99,
                            saveFaces: false,
                        },
                        facemesh: {},
                        language: {
                            granularity: "word",
                            identifySpeakers: false,
                        },
                        ner: {
                            identifySpeakers: false,
                        },
                        prosody: {
                            granularity: "utterance",
                            identifySpeakers: false,
                        },
                    },
                    notify: true,
                    text: [],
                    urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
                },
                state: {
                    status: "COMPLETED",
                    createdTimestampMs: 1712587158717,
                    endedTimestampMs: 1712587159274,
                    numErrors: 0,
                    numPredictions: 10,
                    startedTimestampMs: 1712587158800,
                },
                type: "INFERENCE",
            },
        ]);
    });

    test("start-inference-job", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"], notify: true };
        const rawResponseBody = { job_id: "job_id" };
        server
            .mockEndpoint()
            .post("/v0/batch/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.expressionMeasurement.batch.startInferenceJob({
            urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
            notify: true,
        });
        expect(response).toEqual({
            jobId: "job_id",
        });
    });

    test("get-job-details", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            type: "INFERENCE",
            job_id: "job_id",
            request: {
                files: [],
                models: {
                    burst: {},
                    face: {
                        fps_pred: 3,
                        identify_faces: false,
                        min_face_size: 60,
                        prob_threshold: 0.99,
                        save_faces: false,
                    },
                    facemesh: {},
                    language: { granularity: "word", identify_speakers: false },
                    ner: { identify_speakers: false },
                    prosody: { granularity: "utterance", identify_speakers: false },
                },
                notify: true,
                text: [],
                urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
            },
            state: {
                status: "COMPLETED",
                created_timestamp_ms: 1712590457884,
                ended_timestamp_ms: 1712590462252,
                num_errors: 0,
                num_predictions: 10,
                started_timestamp_ms: 1712590457995,
            },
        };
        server
            .mockEndpoint()
            .get("/v0/batch/jobs/job_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.expressionMeasurement.batch.getJobDetails("job_id");
        expect(response).toEqual({
            type: "INFERENCE",
            jobId: "job_id",
            request: {
                files: [],
                models: {
                    burst: {},
                    face: {
                        fpsPred: 3,
                        identifyFaces: false,
                        minFaceSize: 60,
                        probThreshold: 0.99,
                        saveFaces: false,
                    },
                    facemesh: {},
                    language: {
                        granularity: "word",
                        identifySpeakers: false,
                    },
                    ner: {
                        identifySpeakers: false,
                    },
                    prosody: {
                        granularity: "utterance",
                        identifySpeakers: false,
                    },
                },
                notify: true,
                text: [],
                urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
            },
            state: {
                status: "COMPLETED",
                createdTimestampMs: 1712590457884,
                endedTimestampMs: 1712590462252,
                numErrors: 0,
                numPredictions: 10,
                startedTimestampMs: 1712590457995,
            },
        });
    });

    test("get-job-predictions", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = [
            {
                source: { type: "url", url: "https://hume-tutorials.s3.amazonaws.com/faces.zip" },
                results: {
                    predictions: [
                        {
                            file: "faces/100.jpg",
                            models: {
                                face: {
                                    grouped_predictions: [
                                        {
                                            id: "unknown",
                                            predictions: [
                                                {
                                                    frame: 0,
                                                    time: 0,
                                                    prob: 0.9994111061096191,
                                                    box: {
                                                        x: 1187.885986328125,
                                                        y: 1397.697509765625,
                                                        w: 1401.668701171875,
                                                        h: 1961.424560546875,
                                                    },
                                                    emotions: [
                                                        { name: "Admiration", score: 0.10722749680280685 },
                                                        { name: "Adoration", score: 0.06395940482616425 },
                                                        { name: "Aesthetic Appreciation", score: 0.05811462551355362 },
                                                        { name: "Amusement", score: 0.14187128841876984 },
                                                        { name: "Anger", score: 0.02804684266448021 },
                                                        { name: "Anxiety", score: 0.2713485360145569 },
                                                        { name: "Awe", score: 0.33812594413757324 },
                                                        { name: "Awkwardness", score: 0.1745193600654602 },
                                                        { name: "Boredom", score: 0.23600080609321594 },
                                                        { name: "Calmness", score: 0.18988418579101562 },
                                                        { name: "Concentration", score: 0.44288986921310425 },
                                                        { name: "Confusion", score: 0.39346569776535034 },
                                                        { name: "Contemplation", score: 0.31002455949783325 },
                                                        { name: "Contempt", score: 0.048870109021663666 },
                                                        { name: "Contentment", score: 0.0579497292637825 },
                                                        { name: "Craving", score: 0.06544201076030731 },
                                                        { name: "Desire", score: 0.05526508390903473 },
                                                        { name: "Determination", score: 0.08590991795063019 },
                                                        { name: "Disappointment", score: 0.19508258998394012 },
                                                        { name: "Disgust", score: 0.031529419124126434 },
                                                        { name: "Distress", score: 0.23210826516151428 },
                                                        { name: "Doubt", score: 0.3284550905227661 },
                                                        { name: "Ecstasy", score: 0.040716782212257385 },
                                                        { name: "Embarrassment", score: 0.1467227339744568 },
                                                        { name: "Empathic Pain", score: 0.07633581757545471 },
                                                        { name: "Entrancement", score: 0.16245244443416595 },
                                                        { name: "Envy", score: 0.03267110139131546 },
                                                        { name: "Excitement", score: 0.10656816512346268 },
                                                        { name: "Fear", score: 0.3115977346897125 },
                                                        { name: "Guilt", score: 0.11615975946187973 },
                                                        { name: "Horror", score: 0.19795553386211395 },
                                                        { name: "Interest", score: 0.3136432468891144 },
                                                        { name: "Joy", score: 0.06285581737756729 },
                                                        { name: "Love", score: 0.06339752674102783 },
                                                        { name: "Nostalgia", score: 0.05866732448339462 },
                                                        { name: "Pain", score: 0.07684041559696198 },
                                                        { name: "Pride", score: 0.026822954416275024 },
                                                        { name: "Realization", score: 0.30000734329223633 },
                                                        { name: "Relief", score: 0.04414166510105133 },
                                                        { name: "Romance", score: 0.042728863656520844 },
                                                        { name: "Sadness", score: 0.14773206412792206 },
                                                        { name: "Satisfaction", score: 0.05902980640530586 },
                                                        { name: "Shame", score: 0.08103451132774353 },
                                                        { name: "Surprise (negative)", score: 0.25518184900283813 },
                                                        { name: "Surprise (positive)", score: 0.28845661878585815 },
                                                        { name: "Sympathy", score: 0.062488824129104614 },
                                                        { name: "Tiredness", score: 0.1559651643037796 },
                                                        { name: "Triumph", score: 0.01955239288508892 },
                                                    ],
                                                },
                                            ],
                                        },
                                    ],
                                },
                            },
                        },
                    ],
                    errors: [],
                },
            },
        ];
        server
            .mockEndpoint()
            .get("/v0/batch/jobs/job_id/predictions")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.expressionMeasurement.batch.getJobPredictions("job_id");
        expect(response).toEqual([
            {
                source: {
                    type: "url",
                    url: "https://hume-tutorials.s3.amazonaws.com/faces.zip",
                },
                results: {
                    predictions: [
                        {
                            file: "faces/100.jpg",
                            models: {
                                face: {
                                    groupedPredictions: [
                                        {
                                            id: "unknown",
                                            predictions: [
                                                {
                                                    frame: 0,
                                                    time: 0,
                                                    prob: 0.9994111061096191,
                                                    box: {
                                                        x: 1187.885986328125,
                                                        y: 1397.697509765625,
                                                        w: 1401.668701171875,
                                                        h: 1961.424560546875,
                                                    },
                                                    emotions: [
                                                        {
                                                            name: "Admiration",
                                                            score: 0.10722749680280685,
                                                        },
                                                        {
                                                            name: "Adoration",
                                                            score: 0.06395940482616425,
                                                        },
                                                        {
                                                            name: "Aesthetic Appreciation",
                                                            score: 0.05811462551355362,
                                                        },
                                                        {
                                                            name: "Amusement",
                                                            score: 0.14187128841876984,
                                                        },
                                                        {
                                                            name: "Anger",
                                                            score: 0.02804684266448021,
                                                        },
                                                        {
                                                            name: "Anxiety",
                                                            score: 0.2713485360145569,
                                                        },
                                                        {
                                                            name: "Awe",
                                                            score: 0.33812594413757324,
                                                        },
                                                        {
                                                            name: "Awkwardness",
                                                            score: 0.1745193600654602,
                                                        },
                                                        {
                                                            name: "Boredom",
                                                            score: 0.23600080609321594,
                                                        },
                                                        {
                                                            name: "Calmness",
                                                            score: 0.18988418579101562,
                                                        },
                                                        {
                                                            name: "Concentration",
                                                            score: 0.44288986921310425,
                                                        },
                                                        {
                                                            name: "Confusion",
                                                            score: 0.39346569776535034,
                                                        },
                                                        {
                                                            name: "Contemplation",
                                                            score: 0.31002455949783325,
                                                        },
                                                        {
                                                            name: "Contempt",
                                                            score: 0.048870109021663666,
                                                        },
                                                        {
                                                            name: "Contentment",
                                                            score: 0.0579497292637825,
                                                        },
                                                        {
                                                            name: "Craving",
                                                            score: 0.06544201076030731,
                                                        },
                                                        {
                                                            name: "Desire",
                                                            score: 0.05526508390903473,
                                                        },
                                                        {
                                                            name: "Determination",
                                                            score: 0.08590991795063019,
                                                        },
                                                        {
                                                            name: "Disappointment",
                                                            score: 0.19508258998394012,
                                                        },
                                                        {
                                                            name: "Disgust",
                                                            score: 0.031529419124126434,
                                                        },
                                                        {
                                                            name: "Distress",
                                                            score: 0.23210826516151428,
                                                        },
                                                        {
                                                            name: "Doubt",
                                                            score: 0.3284550905227661,
                                                        },
                                                        {
                                                            name: "Ecstasy",
                                                            score: 0.040716782212257385,
                                                        },
                                                        {
                                                            name: "Embarrassment",
                                                            score: 0.1467227339744568,
                                                        },
                                                        {
                                                            name: "Empathic Pain",
                                                            score: 0.07633581757545471,
                                                        },
                                                        {
                                                            name: "Entrancement",
                                                            score: 0.16245244443416595,
                                                        },
                                                        {
                                                            name: "Envy",
                                                            score: 0.03267110139131546,
                                                        },
                                                        {
                                                            name: "Excitement",
                                                            score: 0.10656816512346268,
                                                        },
                                                        {
                                                            name: "Fear",
                                                            score: 0.3115977346897125,
                                                        },
                                                        {
                                                            name: "Guilt",
                                                            score: 0.11615975946187973,
                                                        },
                                                        {
                                                            name: "Horror",
                                                            score: 0.19795553386211395,
                                                        },
                                                        {
                                                            name: "Interest",
                                                            score: 0.3136432468891144,
                                                        },
                                                        {
                                                            name: "Joy",
                                                            score: 0.06285581737756729,
                                                        },
                                                        {
                                                            name: "Love",
                                                            score: 0.06339752674102783,
                                                        },
                                                        {
                                                            name: "Nostalgia",
                                                            score: 0.05866732448339462,
                                                        },
                                                        {
                                                            name: "Pain",
                                                            score: 0.07684041559696198,
                                                        },
                                                        {
                                                            name: "Pride",
                                                            score: 0.026822954416275024,
                                                        },
                                                        {
                                                            name: "Realization",
                                                            score: 0.30000734329223633,
                                                        },
                                                        {
                                                            name: "Relief",
                                                            score: 0.04414166510105133,
                                                        },
                                                        {
                                                            name: "Romance",
                                                            score: 0.042728863656520844,
                                                        },
                                                        {
                                                            name: "Sadness",
                                                            score: 0.14773206412792206,
                                                        },
                                                        {
                                                            name: "Satisfaction",
                                                            score: 0.05902980640530586,
                                                        },
                                                        {
                                                            name: "Shame",
                                                            score: 0.08103451132774353,
                                                        },
                                                        {
                                                            name: "Surprise (negative)",
                                                            score: 0.25518184900283813,
                                                        },
                                                        {
                                                            name: "Surprise (positive)",
                                                            score: 0.28845661878585815,
                                                        },
                                                        {
                                                            name: "Sympathy",
                                                            score: 0.062488824129104614,
                                                        },
                                                        {
                                                            name: "Tiredness",
                                                            score: 0.1559651643037796,
                                                        },
                                                        {
                                                            name: "Triumph",
                                                            score: 0.01955239288508892,
                                                        },
                                                    ],
                                                },
                                            ],
                                        },
                                    ],
                                },
                            },
                        },
                    ],
                    errors: [],
                },
            },
        ]);
    });
});

```


## /tests/wire/tts/main.test.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import * as Hume from "../../../src/api/index";
import { HumeClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("TtsClient", () => {
    test("synthesize-json (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = {
            context: {
                utterances: [
                    {
                        text: "How can people see beauty so differently?",
                        description:
                            "A curious student with a clear and respectful tone, seeking clarification on Hume's ideas with a straightforward question.",
                    },
                ],
            },
            format: { type: "mp3" },
            num_generations: 1,
            utterances: [
                {
                    text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
                    description:
                        "Middle-aged masculine voice with a clear, rhythmic Scots lilt, rounded vowels, and a warm, steady tone with an articulate, academic quality.",
                },
            ],
        };
        const rawResponseBody = {
            generations: [
                {
                    audio: "//PExAA0DDYRvkpNfhv3JI5JZ...etc.",
                    duration: 7.44225,
                    encoding: { format: "mp3", sample_rate: 48000 },
                    file_size: 120192,
                    generation_id: "795c949a-1510-4a80-9646-7d0863b023ab",
                    snippets: [
                        [
                            {
                                audio: "//PExAA0DDYRvkpNfhv3JI5JZ...etc.",
                                generation_id: "795c949a-1510-4a80-9646-7d0863b023ab",
                                id: "37b1b1b1-1b1b-1b1b-1b1b-1b1b1b1b1b1b",
                                text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
                                utterance_index: 0,
                                timestamps: [],
                            },
                        ],
                    ],
                },
            ],
            request_id: "66e01f90-4501-4aa0-bbaf-74f45dc15aa725906",
        };
        server
            .mockEndpoint()
            .post("/v0/tts")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.tts.synthesizeJson({
            context: {
                utterances: [
                    {
                        text: "How can people see beauty so differently?",
                        description:
                            "A curious student with a clear and respectful tone, seeking clarification on Hume's ideas with a straightforward question.",
                    },
                ],
            },
            format: {
                type: "mp3",
            },
            numGenerations: 1,
            utterances: [
                {
                    text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
                    description:
                        "Middle-aged masculine voice with a clear, rhythmic Scots lilt, rounded vowels, and a warm, steady tone with an articulate, academic quality.",
                },
            ],
        });
        expect(response).toEqual({
            generations: [
                {
                    audio: "//PExAA0DDYRvkpNfhv3JI5JZ...etc.",
                    duration: 7.44225,
                    encoding: {
                        format: "mp3",
                        sampleRate: 48000,
                    },
                    fileSize: 120192,
                    generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
                    snippets: [
                        [
                            {
                                audio: "//PExAA0DDYRvkpNfhv3JI5JZ...etc.",
                                generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
                                id: "37b1b1b1-1b1b-1b1b-1b1b-1b1b1b1b1b1b",
                                text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
                                utteranceIndex: 0,
                                timestamps: [],
                            },
                        ],
                    ],
                },
            ],
            requestId: "66e01f90-4501-4aa0-bbaf-74f45dc15aa725906",
        });
    });

    test("synthesize-json (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { utterances: [{ text: "text" }, { text: "text" }] };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v0/tts")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tts.synthesizeJson({
                utterances: [
                    {
                        text: "text",
                    },
                    {
                        text: "text",
                    },
                ],
            });
        }).rejects.toThrow(Hume.tts.UnprocessableEntityError);
    });
});

```


## /tests/wire/tts/voices.test.ts
```typescript
// This file was auto-generated by Fern from our API Definition.

import * as Hume from "../../../src/api/index";
import { HumeClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("VoicesClient", () => {
    test("list (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {
            page_number: 0,
            page_size: 10,
            total_pages: 1,
            voices_page: [
                { id: "c42352c0-4566-455d-b180-0f654b65b525", name: "David Hume", provider: "CUSTOM_VOICE" },
                { id: "d87352b0-26a3-4b11-081b-d157a5674d19", name: "Goliath Hume", provider: "CUSTOM_VOICE" },
            ],
        };
        server
            .mockEndpoint({ once: false })
            .get("/v0/tts/voices")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const expected = {
            pageNumber: 0,
            pageSize: 10,
            totalPages: 1,
            voicesPage: [
                {
                    id: "c42352c0-4566-455d-b180-0f654b65b525",
                    name: "David Hume",
                    provider: "CUSTOM_VOICE",
                },
                {
                    id: "d87352b0-26a3-4b11-081b-d157a5674d19",
                    name: "Goliath Hume",
                    provider: "CUSTOM_VOICE",
                },
            ],
        };
        const page = await client.tts.voices.list({
            provider: "CUSTOM_VOICE",
        });

        expect(expected.voicesPage).toEqual(page.data);
        expect(page.hasNextPage()).toBe(true);
        const nextPage = await page.getNextPage();
        expect(expected.voicesPage).toEqual(nextPage.data);
    });

    test("list (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server
            .mockEndpoint({ once: false })
            .get("/v0/tts/voices")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tts.voices.list({
                provider: "HUME_AI",
            });
        }).rejects.toThrow(Hume.tts.BadRequestError);
    });

    test("create (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { generation_id: "795c949a-1510-4a80-9646-7d0863b023ab", name: "David Hume" };
        const rawResponseBody = {
            id: "c42352c0-4566-455d-b180-0f654b65b525",
            name: "David Hume",
            provider: "CUSTOM_VOICE",
        };
        server
            .mockEndpoint()
            .post("/v0/tts/voices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.tts.voices.create({
            generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
            name: "David Hume",
        });
        expect(response).toEqual({
            id: "c42352c0-4566-455d-b180-0f654b65b525",
            name: "David Hume",
            provider: "CUSTOM_VOICE",
        });
    });

    test("create (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });
        const rawRequestBody = { generation_id: "generation_id", name: "name" };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v0/tts/voices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tts.voices.create({
                generationId: "generation_id",
                name: "name",
            });
        }).rejects.toThrow(Hume.tts.UnprocessableEntityError);
    });

    test("delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        server.mockEndpoint().delete("/v0/tts/voices").respondWith().statusCode(200).build();

        const response = await client.tts.voices.delete({
            name: "David Hume",
        });
        expect(response).toEqual(undefined);
    });

    test("delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new HumeClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
        });

        const rawResponseBody = {};
        server.mockEndpoint().delete("/v0/tts/voices").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.tts.voices.delete({
                name: "name",
            });
        }).rejects.toThrow(Hume.tts.BadRequestError);
    });
});

```


## /tsconfig.base.json
```json
{
    "compilerOptions": {
        "extendedDiagnostics": true,
        "strict": true,
        "target": "ES6",
        "moduleResolution": "node",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "declaration": true,
        "outDir": "dist",
        "rootDir": "src",
        "baseUrl": "src",
        "isolatedModules": true,
        "isolatedDeclarations": true
    },
    "include": ["src"],
    "exclude": []
}

```


## /tsconfig.cjs.json
```json
{
    "extends": "./tsconfig.base.json",
    "compilerOptions": {
        "module": "CommonJS",
        "outDir": "dist/cjs"
    },
    "include": ["src"],
    "exclude": []
}

```


## /tsconfig.dev.json
```json
{
    "extends": "./tsconfig.json",
    "include": ["src/**/*.ts", "src/**/*.js", "tests", "eslint.config.mjs", "jest.config.mjs"],
    "exclude": ["dist"]
}

```


## /tsconfig.esm.json
```json
{
    "extends": "./tsconfig.base.json",
    "compilerOptions": {
        "module": "esnext",
        "outDir": "dist/esm",
        "verbatimModuleSyntax": true
    },
    "include": ["src"],
    "exclude": []
}

```


## /tsconfig.json
```json
{
    "extends": "./tsconfig.cjs.json"
}

```


## /vitest.config.mts
```mts
import { defineConfig } from "vitest/config";
export default defineConfig({
    test: {
        projects: [
            {
                test: {
                    globals: true,
                    name: "unit",
                    environment: "node",
                    root: "./tests",
                    include: ["**/*.test.{js,ts,jsx,tsx}"],
                    exclude: ["wire/**"],
                    setupFiles: ["./setup.ts"],
                },
            },
            {
                test: {
                    globals: true,
                    name: "wire",
                    environment: "node",
                    root: "./tests/wire",
                    setupFiles: ["../setup.ts", "../mock-server/setup.ts"],
                },
            },
        ],
        passWithNoTests: true,
    },
});

```



<!-- Generated with repo.md (https://repo-md.com) -->