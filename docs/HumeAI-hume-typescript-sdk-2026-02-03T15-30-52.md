This document contains the complete source code of the repository consolidated into a single file for streamlined AI analysis.
The repository contents have been processed and combined with security validation bypassed.

# Repository Overview

## About This Document
This consolidated file represents the complete codebase from the repository, 
merged into a unified document optimized for AI consumption and automated 
analysis workflows.

## Repository Information
- **Repository:** HumeAI/hume-typescript-sdk
- **Branch:** main
- **Total Files:** 1042
- **Generated:** 2026-02-03T12:38:53.654Z

## Document Structure
The content is organized in the following sequence:
1. This overview section
2. Repository metadata and information  
3. File system hierarchy
4. Repository files (when included)
5. Individual source files, each containing:
   a. File path header (## File: path/to/file)
   b. Complete file contents within code blocks

## Best Practices
- Treat this document as read-only - make changes in the original repository
- Use file path headers to navigate between different source files
- Handle with appropriate security measures as this may contain sensitive data
- This consolidated view is generated from the live repository state

## Important Notes
- Files excluded by .gitignore and configuration rules are omitted
- Binary assets are not included - refer to the file structure for complete file listings
- Default ignore patterns have been applied to filter content
- Security validation is disabled - review content for sensitive information carefully

# Repository Structure

```
HumeAI/hume-typescript-sdk/
├── .fern
│   └── metadata.json
├── .github
│   ├── workflows
│   │   ├── ci.yml
│   │   ├── publish.yml
│   │   └── test-examples-dependabot.yml
│   └── dependabot.yml
├── scripts
│   └── rename-to-esm-files.js
├── src
│   ├── api
│   │   ├── resources
│   │   │   ├── empathicVoice
│   │   │   │   ├── client
│   │   │   │   │   ├── Client.ts
│   │   │   │   │   └── index.ts
│   │   │   │   ├── errors
│   │   │   │   │   ├── BadRequestError.ts
│   │   │   │   │   ├── index.ts
│   │   │   │   │   └── UnprocessableEntityError.ts
│   │   │   │   ├── resources
│   │   │   │   │   ├── chat
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── Client.ts
│   │   │   │   │   │   │   ├── Client.ts.diff
│   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   ├── index.ts.diff
│   │   │   │   │   │   │   ├── Socket.ts
│   │   │   │   │   │   │   └── Socket.ts.diff
│   │   │   │   │   │   ├── types
│   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   ├── PublishEvent.ts
│   │   │   │   │   │   │   └── SubscribeEvent.ts
│   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   └── index.ts.diff
│   │   │   │   │   ├── chatGroups
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── requests
│   │   │   │   │   │   │   │   ├── ChatGroupsGetAudioRequest.ts
│   │   │   │   │   │   │   │   ├── ChatGroupsGetChatGroupRequest.ts
│   │   │   │   │   │   │   │   ├── ChatGroupsListChatGroupEventsRequest.ts
│   │   │   │   │   │   │   │   ├── ChatGroupsListChatGroupsRequest.ts
│   │   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   │   ├── Client.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── chats
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── requests
│   │   │   │   │   │   │   │   ├── ChatsListChatEventsRequest.ts
│   │   │   │   │   │   │   │   ├── ChatsListChatsRequest.ts
│   │   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   │   ├── Client.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── configs
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── requests
│   │   │   │   │   │   │   │   ├── ConfigsListConfigsRequest.ts
│   │   │   │   │   │   │   │   ├── ConfigsListConfigVersionsRequest.ts
│   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   ├── PostedConfig.ts
│   │   │   │   │   │   │   │   ├── PostedConfigName.ts
│   │   │   │   │   │   │   │   ├── PostedConfigVersion.ts
│   │   │   │   │   │   │   │   └── PostedConfigVersionDescription.ts
│   │   │   │   │   │   │   ├── Client.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── controlPlane
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── Client.ts
│   │   │   │   │   │   │   ├── Client.ts.diff
│   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   └── Socket.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── prompts
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── requests
│   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   ├── PostedPrompt.ts
│   │   │   │   │   │   │   │   ├── PostedPromptName.ts
│   │   │   │   │   │   │   │   ├── PostedPromptVersion.ts
│   │   │   │   │   │   │   │   ├── PostedPromptVersionDescription.ts
│   │   │   │   │   │   │   │   ├── PromptsListPromptsRequest.ts
│   │   │   │   │   │   │   │   └── PromptsListPromptVersionsRequest.ts
│   │   │   │   │   │   │   ├── Client.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── tools
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── requests
│   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   ├── PostedUserDefinedTool.ts
│   │   │   │   │   │   │   │   ├── PostedUserDefinedToolName.ts
│   │   │   │   │   │   │   │   ├── PostedUserDefinedToolVersion.ts
│   │   │   │   │   │   │   │   ├── PostedUserDefinedToolVersionDescription.ts
│   │   │   │   │   │   │   │   ├── ToolsListToolsRequest.ts
│   │   │   │   │   │   │   │   └── ToolsListToolVersionsRequest.ts
│   │   │   │   │   │   │   ├── Client.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   └── index.ts
│   │   │   │   ├── types
│   │   │   │   │   ├── AssistantEnd.ts
│   │   │   │   │   ├── AssistantInput.ts
│   │   │   │   │   ├── AssistantMessage.ts
│   │   │   │   │   ├── AssistantProsody.ts
│   │   │   │   │   ├── AudioConfiguration.ts
│   │   │   │   │   ├── AudioInput.ts
│   │   │   │   │   ├── AudioOutput.ts
│   │   │   │   │   ├── BuiltInTool.ts
│   │   │   │   │   ├── BuiltinToolConfig.ts
│   │   │   │   │   ├── ChatMessage.ts
│   │   │   │   │   ├── ChatMessageToolResult.ts
│   │   │   │   │   ├── ChatMetadata.ts
│   │   │   │   │   ├── ConnectSessionSettings.ts
│   │   │   │   │   ├── ConnectSessionSettingsAudio.ts
│   │   │   │   │   ├── ConnectSessionSettingsContext.ts
│   │   │   │   │   ├── ConnectSessionSettingsVariablesValue.ts
│   │   │   │   │   ├── Context.ts
│   │   │   │   │   ├── ContextType.ts
│   │   │   │   │   ├── ControlPlanePublishEvent.ts
│   │   │   │   │   ├── Encoding.ts
│   │   │   │   │   ├── ErrorLevel.ts
│   │   │   │   │   ├── ErrorResponse.ts
│   │   │   │   │   ├── HttpValidationError.ts
│   │   │   │   │   ├── index.ts
│   │   │   │   │   ├── Inference.ts
│   │   │   │   │   ├── JsonMessage.ts
│   │   │   │   │   ├── LanguageModelType.ts
│   │   │   │   │   ├── MillisecondInterval.ts
│   │   │   │   │   ├── ModelProviderEnum.ts
│   │   │   │   │   ├── PauseAssistantMessage.ts
│   │   │   │   │   ├── PostedBuiltinTool.ts
│   │   │   │   │   ├── PostedBuiltinToolName.ts
│   │   │   │   │   ├── PostedConfigPromptSpec.ts
│   │   │   │   │   ├── PostedEllmModel.ts
│   │   │   │   │   ├── PostedEventMessageSpec.ts
│   │   │   │   │   ├── PostedEventMessageSpecs.ts
│   │   │   │   │   ├── PostedLanguageModel.ts
│   │   │   │   │   ├── PostedNudgeSpec.ts
│   │   │   │   │   ├── PostedTimeoutSpec.ts
│   │   │   │   │   ├── PostedTimeoutSpecs.ts
│   │   │   │   │   ├── PostedTimeoutSpecsInactivity.ts
│   │   │   │   │   ├── PostedTimeoutSpecsMaxDuration.ts
│   │   │   │   │   ├── PostedUserDefinedToolSpec.ts
│   │   │   │   │   ├── PostedWebhookEventType.ts
│   │   │   │   │   ├── PostedWebhookSpec.ts
│   │   │   │   │   ├── ProsodyInference.ts
│   │   │   │   │   ├── ResumeAssistantMessage.ts
│   │   │   │   │   ├── ReturnBuiltinTool.ts
│   │   │   │   │   ├── ReturnBuiltinToolToolType.ts
│   │   │   │   │   ├── ReturnChat.ts
│   │   │   │   │   ├── ReturnChatAudioReconstruction.ts
│   │   │   │   │   ├── ReturnChatAudioReconstructionStatus.ts
│   │   │   │   │   ├── ReturnChatEvent.ts
│   │   │   │   │   ├── ReturnChatEventRole.ts
│   │   │   │   │   ├── ReturnChatEventType.ts
│   │   │   │   │   ├── ReturnChatGroup.ts
│   │   │   │   │   ├── ReturnChatGroupPagedAudioReconstructions.ts
│   │   │   │   │   ├── ReturnChatGroupPagedAudioReconstructionsPaginationDirection.ts
│   │   │   │   │   ├── ReturnChatGroupPagedChats.ts
│   │   │   │   │   ├── ReturnChatGroupPagedChatsPaginationDirection.ts
│   │   │   │   │   ├── ReturnChatGroupPagedEvents.ts
│   │   │   │   │   ├── ReturnChatGroupPagedEventsPaginationDirection.ts
│   │   │   │   │   ├── ReturnChatPagedEvents.ts
│   │   │   │   │   ├── ReturnChatPagedEventsPaginationDirection.ts
│   │   │   │   │   ├── ReturnChatPagedEventsStatus.ts
│   │   │   │   │   ├── ReturnChatStatus.ts
│   │   │   │   │   ├── ReturnConfig.ts
│   │   │   │   │   ├── ReturnConfigSpec.ts
│   │   │   │   │   ├── ReturnEllmModel.ts
│   │   │   │   │   ├── ReturnEventMessageSpec.ts
│   │   │   │   │   ├── ReturnEventMessageSpecs.ts
│   │   │   │   │   ├── ReturnLanguageModel.ts
│   │   │   │   │   ├── ReturnNudgeSpec.ts
│   │   │   │   │   ├── ReturnPagedChatGroups.ts
│   │   │   │   │   ├── ReturnPagedChatGroupsPaginationDirection.ts
│   │   │   │   │   ├── ReturnPagedChats.ts
│   │   │   │   │   ├── ReturnPagedChatsPaginationDirection.ts
│   │   │   │   │   ├── ReturnPagedConfigs.ts
│   │   │   │   │   ├── ReturnPagedPrompts.ts
│   │   │   │   │   ├── ReturnPagedUserDefinedTools.ts
│   │   │   │   │   ├── ReturnPrompt.ts
│   │   │   │   │   ├── ReturnPromptVersionType.ts
│   │   │   │   │   ├── ReturnTimeoutSpec.ts
│   │   │   │   │   ├── ReturnTimeoutSpecs.ts
│   │   │   │   │   ├── ReturnUserDefinedTool.ts
│   │   │   │   │   ├── ReturnUserDefinedToolToolType.ts
│   │   │   │   │   ├── ReturnUserDefinedToolVersionType.ts
│   │   │   │   │   ├── ReturnVoice.ts
│   │   │   │   │   ├── ReturnWebhookEventType.ts
│   │   │   │   │   ├── ReturnWebhookSpec.ts
│   │   │   │   │   ├── Role.ts
│   │   │   │   │   ├── SessionSettings.ts
│   │   │   │   │   ├── SessionSettingsVariablesValue.ts
│   │   │   │   │   ├── SubscribeEvent.ts
│   │   │   │   │   ├── Tool.ts
│   │   │   │   │   ├── ToolCallMessage.ts
│   │   │   │   │   ├── ToolErrorMessage.ts
│   │   │   │   │   ├── ToolResponseMessage.ts
│   │   │   │   │   ├── ToolType.ts
│   │   │   │   │   ├── UserInput.ts
│   │   │   │   │   ├── UserInterruption.ts
│   │   │   │   │   ├── UserMessage.ts
│   │   │   │   │   ├── ValidationError.ts
│   │   │   │   │   ├── ValidationErrorLocItem.ts
│   │   │   │   │   ├── VoiceId.ts
│   │   │   │   │   ├── VoiceName.ts
│   │   │   │   │   ├── VoiceProvider.ts
│   │   │   │   │   ├── VoiceRef.ts
│   │   │   │   │   ├── WebhookEvent.ts
│   │   │   │   │   ├── WebhookEventBase.ts
│   │   │   │   │   ├── WebhookEventChatEnded.ts
│   │   │   │   │   ├── WebhookEventChatStarted.ts
│   │   │   │   │   ├── WebhookEventChatStartType.ts
│   │   │   │   │   ├── WebhookEventChatStatus.ts
│   │   │   │   │   ├── WebhookEventToolCall.ts
│   │   │   │   │   └── WebSocketError.ts
│   │   │   │   └── index.ts
│   │   │   ├── expressionMeasurement
│   │   │   │   ├── client
│   │   │   │   │   ├── Client.ts
│   │   │   │   │   └── index.ts
│   │   │   │   ├── resources
│   │   │   │   │   ├── batch
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── requests
│   │   │   │   │   │   │   │   ├── BatchListJobsRequest.ts
│   │   │   │   │   │   │   │   ├── BatchStartInferenceJobFromLocalFileRequest.ts
│   │   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   │   ├── Client.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   ├── types
│   │   │   │   │   │   │   ├── Alternative.ts
│   │   │   │   │   │   │   ├── Bcp47Tag.ts
│   │   │   │   │   │   │   ├── BoundingBox.ts
│   │   │   │   │   │   │   ├── BurstPrediction.ts
│   │   │   │   │   │   │   ├── Classification.ts
│   │   │   │   │   │   │   ├── CompletedEmbeddingGeneration.ts
│   │   │   │   │   │   │   ├── CompletedInference.ts
│   │   │   │   │   │   │   ├── CompletedState.ts
│   │   │   │   │   │   │   ├── CompletedTlInference.ts
│   │   │   │   │   │   │   ├── CompletedTraining.ts
│   │   │   │   │   │   │   ├── CustomModel.ts
│   │   │   │   │   │   │   ├── CustomModelId.ts
│   │   │   │   │   │   │   ├── CustomModelPrediction.ts
│   │   │   │   │   │   │   ├── CustomModelRequest.ts
│   │   │   │   │   │   │   ├── CustomModelsInferenceJob.ts
│   │   │   │   │   │   │   ├── CustomModelsTrainingJob.ts
│   │   │   │   │   │   │   ├── CustomModelVersionId.ts
│   │   │   │   │   │   │   ├── Dataset.ts
│   │   │   │   │   │   │   ├── DatasetId.ts
│   │   │   │   │   │   │   ├── DatasetVersionId.ts
│   │   │   │   │   │   │   ├── Direction.ts
│   │   │   │   │   │   │   ├── EmbeddingGenerationBaseRequest.ts
│   │   │   │   │   │   │   ├── EmbeddingGenerationJob.ts
│   │   │   │   │   │   │   ├── Error_.ts
│   │   │   │   │   │   │   ├── EvaluationArgs.ts
│   │   │   │   │   │   │   ├── Face.ts
│   │   │   │   │   │   │   ├── FacemeshPrediction.ts
│   │   │   │   │   │   │   ├── FacePrediction.ts
│   │   │   │   │   │   │   ├── Failed.ts
│   │   │   │   │   │   │   ├── FailedState.ts
│   │   │   │   │   │   │   ├── File_.ts
│   │   │   │   │   │   │   ├── Granularity.ts
│   │   │   │   │   │   │   ├── GroupedPredictionsBurstPrediction.ts
│   │   │   │   │   │   │   ├── GroupedPredictionsFacemeshPrediction.ts
│   │   │   │   │   │   │   ├── GroupedPredictionsFacePrediction.ts
│   │   │   │   │   │   │   ├── GroupedPredictionsLanguagePrediction.ts
│   │   │   │   │   │   │   ├── GroupedPredictionsNerPrediction.ts
│   │   │   │   │   │   │   ├── GroupedPredictionsProsodyPrediction.ts
│   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   ├── InferenceBaseRequest.ts
│   │   │   │   │   │   │   ├── InferenceJob.ts
│   │   │   │   │   │   │   ├── InferencePrediction.ts
│   │   │   │   │   │   │   ├── InferenceRequest.ts
│   │   │   │   │   │   │   ├── InferenceResults.ts
│   │   │   │   │   │   │   ├── InferenceSourcePredictResult.ts
│   │   │   │   │   │   │   ├── InProgress.ts
│   │   │   │   │   │   │   ├── InProgressState.ts
│   │   │   │   │   │   │   ├── JobEmbeddingGeneration.ts
│   │   │   │   │   │   │   ├── JobId.ts
│   │   │   │   │   │   │   ├── JobInference.ts
│   │   │   │   │   │   │   ├── JobTlInference.ts
│   │   │   │   │   │   │   ├── JobTraining.ts
│   │   │   │   │   │   │   ├── Language.ts
│   │   │   │   │   │   │   ├── LanguagePrediction.ts
│   │   │   │   │   │   │   ├── Models.ts
│   │   │   │   │   │   │   ├── ModelsPredictions.ts
│   │   │   │   │   │   │   ├── Ner.ts
│   │   │   │   │   │   │   ├── NerPrediction.ts
│   │   │   │   │   │   │   ├── Null.ts
│   │   │   │   │   │   │   ├── PositionInterval.ts
│   │   │   │   │   │   │   ├── PredictionsOptionalNullBurstPrediction.ts
│   │   │   │   │   │   │   ├── PredictionsOptionalNullFacemeshPrediction.ts
│   │   │   │   │   │   │   ├── PredictionsOptionalNullFacePrediction.ts
│   │   │   │   │   │   │   ├── PredictionsOptionalTranscriptionMetadataLanguagePrediction.ts
│   │   │   │   │   │   │   ├── PredictionsOptionalTranscriptionMetadataNerPrediction.ts
│   │   │   │   │   │   │   ├── PredictionsOptionalTranscriptionMetadataProsodyPrediction.ts
│   │   │   │   │   │   │   ├── Prosody.ts
│   │   │   │   │   │   │   ├── ProsodyPrediction.ts
│   │   │   │   │   │   │   ├── Queued.ts
│   │   │   │   │   │   │   ├── QueuedState.ts
│   │   │   │   │   │   │   ├── RegistryFileDetail.ts
│   │   │   │   │   │   │   ├── Regression.ts
│   │   │   │   │   │   │   ├── SortBy.ts
│   │   │   │   │   │   │   ├── Source.ts
│   │   │   │   │   │   │   ├── SourceFile.ts
│   │   │   │   │   │   │   ├── SourceTextSource.ts
│   │   │   │   │   │   │   ├── SourceUrl.ts
│   │   │   │   │   │   │   ├── StateEmbeddingGeneration.ts
│   │   │   │   │   │   │   ├── StateEmbeddingGenerationCompletedEmbeddingGeneration.ts
│   │   │   │   │   │   │   ├── StateEmbeddingGenerationFailed.ts
│   │   │   │   │   │   │   ├── StateEmbeddingGenerationInProgress.ts
│   │   │   │   │   │   │   ├── StateEmbeddingGenerationQueued.ts
│   │   │   │   │   │   │   ├── StateInference.ts
│   │   │   │   │   │   │   ├── StateTlInference.ts
│   │   │   │   │   │   │   ├── StateTlInferenceCompletedTlInference.ts
│   │   │   │   │   │   │   ├── StateTlInferenceFailed.ts
│   │   │   │   │   │   │   ├── StateTlInferenceInProgress.ts
│   │   │   │   │   │   │   ├── StateTlInferenceQueued.ts
│   │   │   │   │   │   │   ├── StateTraining.ts
│   │   │   │   │   │   │   ├── StateTrainingCompletedTraining.ts
│   │   │   │   │   │   │   ├── StateTrainingFailed.ts
│   │   │   │   │   │   │   ├── StateTrainingInProgress.ts
│   │   │   │   │   │   │   ├── StateTrainingQueued.ts
│   │   │   │   │   │   │   ├── Status.ts
│   │   │   │   │   │   │   ├── Tag.ts
│   │   │   │   │   │   │   ├── Target.ts
│   │   │   │   │   │   │   ├── Task.ts
│   │   │   │   │   │   │   ├── TaskClassification.ts
│   │   │   │   │   │   │   ├── TaskRegression.ts
│   │   │   │   │   │   │   ├── TextSource.ts
│   │   │   │   │   │   │   ├── TimeInterval.ts
│   │   │   │   │   │   │   ├── TlInferenceBaseRequest.ts
│   │   │   │   │   │   │   ├── TlInferencePrediction.ts
│   │   │   │   │   │   │   ├── TlInferenceResults.ts
│   │   │   │   │   │   │   ├── TlInferenceSourcePredictResult.ts
│   │   │   │   │   │   │   ├── TrainingBaseRequest.ts
│   │   │   │   │   │   │   ├── TrainingCustomModel.ts
│   │   │   │   │   │   │   ├── Transcription.ts
│   │   │   │   │   │   │   ├── TranscriptionMetadata.ts
│   │   │   │   │   │   │   ├── Type.ts
│   │   │   │   │   │   │   ├── Unconfigurable.ts
│   │   │   │   │   │   │   ├── UnionJob.ts
│   │   │   │   │   │   │   ├── UnionPredictResult.ts
│   │   │   │   │   │   │   ├── Url.ts
│   │   │   │   │   │   │   ├── ValidationArgs.ts
│   │   │   │   │   │   │   ├── When.ts
│   │   │   │   │   │   │   └── Window.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── stream
│   │   │   │   │   │   ├── resources
│   │   │   │   │   │   │   ├── stream
│   │   │   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   │   │   ├── Client.ts
│   │   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   │   └── Socket.ts
│   │   │   │   │   │   │   │   ├── types
│   │   │   │   │   │   │   │   │   ├── Config.ts
│   │   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   │   ├── JobDetails.ts
│   │   │   │   │   │   │   │   │   ├── StreamErrorMessage.ts
│   │   │   │   │   │   │   │   │   ├── StreamFace.ts
│   │   │   │   │   │   │   │   │   ├── StreamLanguage.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictions.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsBurst.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsBurstPredictionsItem.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsFace.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsFacemesh.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsFacemeshPredictionsItem.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsFacePredictionsItem.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsJobDetails.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsLanguage.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsLanguagePredictionsItem.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsProsody.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsProsodyPredictionsItem.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelsEndpointPayload.ts
│   │   │   │   │   │   │   │   │   ├── StreamWarningMessage.ts
│   │   │   │   │   │   │   │   │   ├── StreamWarningMessageJobDetails.ts
│   │   │   │   │   │   │   │   │   └── SubscribeEvent.ts
│   │   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   ├── types
│   │   │   │   │   │   │   ├── EmotionEmbedding.ts
│   │   │   │   │   │   │   ├── EmotionEmbeddingItem.ts
│   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   ├── Sentiment.ts
│   │   │   │   │   │   │   ├── SentimentItem.ts
│   │   │   │   │   │   │   ├── StreamBoundingBox.ts
│   │   │   │   │   │   │   ├── TextPosition.ts
│   │   │   │   │   │   │   ├── TimeRange.ts
│   │   │   │   │   │   │   ├── Toxicity.ts
│   │   │   │   │   │   │   └── ToxicityItem.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   └── index.ts
│   │   │   │   └── index.ts
│   │   │   ├── tts
│   │   │   │   ├── client
│   │   │   │   │   ├── requests
│   │   │   │   │   │   ├── ConvertVoiceFileRequest.ts
│   │   │   │   │   │   ├── ConvertVoiceJsonRequest.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── Client.ts
│   │   │   │   │   └── index.ts
│   │   │   │   ├── errors
│   │   │   │   │   ├── BadRequestError.ts
│   │   │   │   │   ├── index.ts
│   │   │   │   │   └── UnprocessableEntityError.ts
│   │   │   │   ├── resources
│   │   │   │   │   ├── streamInput
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── Client.ts
│   │   │   │   │   │   │   ├── Client.ts.diff
│   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   └── Socket.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── voices
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── requests
│   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   ├── PostedVoice.ts
│   │   │   │   │   │   │   │   ├── VoicesDeleteRequest.ts
│   │   │   │   │   │   │   │   └── VoicesListRequest.ts
│   │   │   │   │   │   │   ├── Client.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   └── index.ts
│   │   │   │   ├── types
│   │   │   │   │   ├── AudioEncoding.ts
│   │   │   │   │   ├── AudioFormatType.ts
│   │   │   │   │   ├── ErrorResponse.ts
│   │   │   │   │   ├── Format.ts
│   │   │   │   │   ├── FormatMp3.ts
│   │   │   │   │   ├── FormatPcm.ts
│   │   │   │   │   ├── FormatWav.ts
│   │   │   │   │   ├── HttpValidationError.ts
│   │   │   │   │   ├── index.ts
│   │   │   │   │   ├── MillisecondInterval.ts
│   │   │   │   │   ├── OctaveVersion.ts
│   │   │   │   │   ├── PostedContext.ts
│   │   │   │   │   ├── PostedContextWithGenerationId.ts
│   │   │   │   │   ├── PostedContextWithUtterances.ts
│   │   │   │   │   ├── PostedTts.ts
│   │   │   │   │   ├── PostedUtterance.ts
│   │   │   │   │   ├── PostedUtteranceVoice.ts
│   │   │   │   │   ├── PostedUtteranceVoiceWithId.ts
│   │   │   │   │   ├── PostedUtteranceVoiceWithName.ts
│   │   │   │   │   ├── PublishTts.ts
│   │   │   │   │   ├── ReturnGeneration.ts
│   │   │   │   │   ├── ReturnPagedVoices.ts
│   │   │   │   │   ├── ReturnTts.ts
│   │   │   │   │   ├── ReturnVoice.ts
│   │   │   │   │   ├── Snippet.ts
│   │   │   │   │   ├── SnippetAudioChunk.ts
│   │   │   │   │   ├── Timestamp.ts
│   │   │   │   │   ├── TimestampMessage.ts
│   │   │   │   │   ├── TimestampType.ts
│   │   │   │   │   ├── TtsOutput.ts
│   │   │   │   │   ├── ValidationError.ts
│   │   │   │   │   ├── ValidationErrorLocItem.ts
│   │   │   │   │   └── VoiceProvider.ts
│   │   │   │   └── index.ts
│   │   │   └── index.ts
│   │   └── index.ts
│   ├── auth
│   │   ├── HeaderAuthProvider.ts
│   │   ├── HeaderAuthProvider.ts.diff
│   │   └── index.ts
│   ├── errors
│   │   ├── handleNonStatusCodeError.ts
│   │   ├── HumeError.ts
│   │   ├── HumeTimeoutError.ts
│   │   └── index.ts
│   ├── serialization
│   │   ├── resources
│   │   │   ├── empathicVoice
│   │   │   │   ├── resources
│   │   │   │   │   ├── chat
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── socket
│   │   │   │   │   │   │   │   ├── ChatSocketResponse.ts
│   │   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   ├── types
│   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   ├── PublishEvent.ts
│   │   │   │   │   │   │   └── SubscribeEvent.ts
│   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   └── index.ts.diff
│   │   │   │   │   ├── configs
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── requests
│   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   ├── PostedConfig.ts
│   │   │   │   │   │   │   │   ├── PostedConfigName.ts
│   │   │   │   │   │   │   │   ├── PostedConfigVersion.ts
│   │   │   │   │   │   │   │   └── PostedConfigVersionDescription.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── controlPlane
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── socket
│   │   │   │   │   │   │   │   ├── ControlPlaneSocketResponse.ts
│   │   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── prompts
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── requests
│   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   ├── PostedPrompt.ts
│   │   │   │   │   │   │   │   ├── PostedPromptName.ts
│   │   │   │   │   │   │   │   ├── PostedPromptVersion.ts
│   │   │   │   │   │   │   │   └── PostedPromptVersionDescription.ts
│   │   │   │   │   │   │   ├── createPrompt.ts
│   │   │   │   │   │   │   ├── createPromptVersion.ts
│   │   │   │   │   │   │   ├── getPromptVersion.ts
│   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   └── updatePromptDescription.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── tools
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── requests
│   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   ├── PostedUserDefinedTool.ts
│   │   │   │   │   │   │   │   ├── PostedUserDefinedToolName.ts
│   │   │   │   │   │   │   │   ├── PostedUserDefinedToolVersion.ts
│   │   │   │   │   │   │   │   └── PostedUserDefinedToolVersionDescription.ts
│   │   │   │   │   │   │   ├── createTool.ts
│   │   │   │   │   │   │   ├── createToolVersion.ts
│   │   │   │   │   │   │   ├── getToolVersion.ts
│   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   └── updateToolDescription.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   └── index.ts
│   │   │   │   ├── types
│   │   │   │   │   ├── AssistantEnd.ts
│   │   │   │   │   ├── AssistantInput.ts
│   │   │   │   │   ├── AssistantMessage.ts
│   │   │   │   │   ├── AssistantProsody.ts
│   │   │   │   │   ├── AudioConfiguration.ts
│   │   │   │   │   ├── AudioInput.ts
│   │   │   │   │   ├── AudioOutput.ts
│   │   │   │   │   ├── BuiltInTool.ts
│   │   │   │   │   ├── BuiltinToolConfig.ts
│   │   │   │   │   ├── ChatMessage.ts
│   │   │   │   │   ├── ChatMessageToolResult.ts
│   │   │   │   │   ├── ChatMetadata.ts
│   │   │   │   │   ├── ConnectSessionSettings.ts
│   │   │   │   │   ├── ConnectSessionSettingsAudio.ts
│   │   │   │   │   ├── ConnectSessionSettingsContext.ts
│   │   │   │   │   ├── ConnectSessionSettingsVariablesValue.ts
│   │   │   │   │   ├── Context.ts
│   │   │   │   │   ├── ContextType.ts
│   │   │   │   │   ├── ControlPlanePublishEvent.ts
│   │   │   │   │   ├── Encoding.ts
│   │   │   │   │   ├── ErrorLevel.ts
│   │   │   │   │   ├── ErrorResponse.ts
│   │   │   │   │   ├── HttpValidationError.ts
│   │   │   │   │   ├── index.ts
│   │   │   │   │   ├── Inference.ts
│   │   │   │   │   ├── JsonMessage.ts
│   │   │   │   │   ├── LanguageModelType.ts
│   │   │   │   │   ├── MillisecondInterval.ts
│   │   │   │   │   ├── ModelProviderEnum.ts
│   │   │   │   │   ├── PauseAssistantMessage.ts
│   │   │   │   │   ├── PostedBuiltinTool.ts
│   │   │   │   │   ├── PostedBuiltinToolName.ts
│   │   │   │   │   ├── PostedConfigPromptSpec.ts
│   │   │   │   │   ├── PostedEllmModel.ts
│   │   │   │   │   ├── PostedEventMessageSpec.ts
│   │   │   │   │   ├── PostedEventMessageSpecs.ts
│   │   │   │   │   ├── PostedLanguageModel.ts
│   │   │   │   │   ├── PostedNudgeSpec.ts
│   │   │   │   │   ├── PostedTimeoutSpec.ts
│   │   │   │   │   ├── PostedTimeoutSpecs.ts
│   │   │   │   │   ├── PostedTimeoutSpecsInactivity.ts
│   │   │   │   │   ├── PostedTimeoutSpecsMaxDuration.ts
│   │   │   │   │   ├── PostedUserDefinedToolSpec.ts
│   │   │   │   │   ├── PostedWebhookEventType.ts
│   │   │   │   │   ├── PostedWebhookSpec.ts
│   │   │   │   │   ├── ProsodyInference.ts
│   │   │   │   │   ├── ResumeAssistantMessage.ts
│   │   │   │   │   ├── ReturnBuiltinTool.ts
│   │   │   │   │   ├── ReturnBuiltinToolToolType.ts
│   │   │   │   │   ├── ReturnChat.ts
│   │   │   │   │   ├── ReturnChatAudioReconstruction.ts
│   │   │   │   │   ├── ReturnChatAudioReconstructionStatus.ts
│   │   │   │   │   ├── ReturnChatEvent.ts
│   │   │   │   │   ├── ReturnChatEventRole.ts
│   │   │   │   │   ├── ReturnChatEventType.ts
│   │   │   │   │   ├── ReturnChatGroup.ts
│   │   │   │   │   ├── ReturnChatGroupPagedAudioReconstructions.ts
│   │   │   │   │   ├── ReturnChatGroupPagedAudioReconstructionsPaginationDirection.ts
│   │   │   │   │   ├── ReturnChatGroupPagedChats.ts
│   │   │   │   │   ├── ReturnChatGroupPagedChatsPaginationDirection.ts
│   │   │   │   │   ├── ReturnChatGroupPagedEvents.ts
│   │   │   │   │   ├── ReturnChatGroupPagedEventsPaginationDirection.ts
│   │   │   │   │   ├── ReturnChatPagedEvents.ts
│   │   │   │   │   ├── ReturnChatPagedEventsPaginationDirection.ts
│   │   │   │   │   ├── ReturnChatPagedEventsStatus.ts
│   │   │   │   │   ├── ReturnChatStatus.ts
│   │   │   │   │   ├── ReturnConfig.ts
│   │   │   │   │   ├── ReturnConfigSpec.ts
│   │   │   │   │   ├── ReturnEllmModel.ts
│   │   │   │   │   ├── ReturnEventMessageSpec.ts
│   │   │   │   │   ├── ReturnEventMessageSpecs.ts
│   │   │   │   │   ├── ReturnLanguageModel.ts
│   │   │   │   │   ├── ReturnNudgeSpec.ts
│   │   │   │   │   ├── ReturnPagedChatGroups.ts
│   │   │   │   │   ├── ReturnPagedChatGroupsPaginationDirection.ts
│   │   │   │   │   ├── ReturnPagedChats.ts
│   │   │   │   │   ├── ReturnPagedChatsPaginationDirection.ts
│   │   │   │   │   ├── ReturnPagedConfigs.ts
│   │   │   │   │   ├── ReturnPagedPrompts.ts
│   │   │   │   │   ├── ReturnPagedUserDefinedTools.ts
│   │   │   │   │   ├── ReturnPrompt.ts
│   │   │   │   │   ├── ReturnPromptVersionType.ts
│   │   │   │   │   ├── ReturnTimeoutSpec.ts
│   │   │   │   │   ├── ReturnTimeoutSpecs.ts
│   │   │   │   │   ├── ReturnUserDefinedTool.ts
│   │   │   │   │   ├── ReturnUserDefinedToolToolType.ts
│   │   │   │   │   ├── ReturnUserDefinedToolVersionType.ts
│   │   │   │   │   ├── ReturnVoice.ts
│   │   │   │   │   ├── ReturnWebhookEventType.ts
│   │   │   │   │   ├── ReturnWebhookSpec.ts
│   │   │   │   │   ├── Role.ts
│   │   │   │   │   ├── SessionSettings.ts
│   │   │   │   │   ├── SessionSettingsVariablesValue.ts
│   │   │   │   │   ├── SubscribeEvent.ts
│   │   │   │   │   ├── Tool.ts
│   │   │   │   │   ├── ToolCallMessage.ts
│   │   │   │   │   ├── ToolErrorMessage.ts
│   │   │   │   │   ├── ToolResponseMessage.ts
│   │   │   │   │   ├── ToolType.ts
│   │   │   │   │   ├── UserInput.ts
│   │   │   │   │   ├── UserInterruption.ts
│   │   │   │   │   ├── UserMessage.ts
│   │   │   │   │   ├── ValidationError.ts
│   │   │   │   │   ├── ValidationErrorLocItem.ts
│   │   │   │   │   ├── VoiceId.ts
│   │   │   │   │   ├── VoiceName.ts
│   │   │   │   │   ├── VoiceProvider.ts
│   │   │   │   │   ├── VoiceRef.ts
│   │   │   │   │   ├── WebhookEvent.ts
│   │   │   │   │   ├── WebhookEventBase.ts
│   │   │   │   │   ├── WebhookEventChatEnded.ts
│   │   │   │   │   ├── WebhookEventChatStarted.ts
│   │   │   │   │   ├── WebhookEventChatStartType.ts
│   │   │   │   │   ├── WebhookEventChatStatus.ts
│   │   │   │   │   ├── WebhookEventToolCall.ts
│   │   │   │   │   └── WebSocketError.ts
│   │   │   │   └── index.ts
│   │   │   ├── expressionMeasurement
│   │   │   │   ├── resources
│   │   │   │   │   ├── batch
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── getJobPredictions.ts
│   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   └── listJobs.ts
│   │   │   │   │   │   ├── types
│   │   │   │   │   │   │   ├── Alternative.ts
│   │   │   │   │   │   │   ├── Bcp47Tag.ts
│   │   │   │   │   │   │   ├── BoundingBox.ts
│   │   │   │   │   │   │   ├── BurstPrediction.ts
│   │   │   │   │   │   │   ├── Classification.ts
│   │   │   │   │   │   │   ├── CompletedEmbeddingGeneration.ts
│   │   │   │   │   │   │   ├── CompletedInference.ts
│   │   │   │   │   │   │   ├── CompletedState.ts
│   │   │   │   │   │   │   ├── CompletedTlInference.ts
│   │   │   │   │   │   │   ├── CompletedTraining.ts
│   │   │   │   │   │   │   ├── CustomModel.ts
│   │   │   │   │   │   │   ├── CustomModelId.ts
│   │   │   │   │   │   │   ├── CustomModelPrediction.ts
│   │   │   │   │   │   │   ├── CustomModelRequest.ts
│   │   │   │   │   │   │   ├── CustomModelsInferenceJob.ts
│   │   │   │   │   │   │   ├── CustomModelsTrainingJob.ts
│   │   │   │   │   │   │   ├── CustomModelVersionId.ts
│   │   │   │   │   │   │   ├── Dataset.ts
│   │   │   │   │   │   │   ├── DatasetId.ts
│   │   │   │   │   │   │   ├── DatasetVersionId.ts
│   │   │   │   │   │   │   ├── Direction.ts
│   │   │   │   │   │   │   ├── EmbeddingGenerationBaseRequest.ts
│   │   │   │   │   │   │   ├── EmbeddingGenerationJob.ts
│   │   │   │   │   │   │   ├── Error_.ts
│   │   │   │   │   │   │   ├── EvaluationArgs.ts
│   │   │   │   │   │   │   ├── Face.ts
│   │   │   │   │   │   │   ├── FacemeshPrediction.ts
│   │   │   │   │   │   │   ├── FacePrediction.ts
│   │   │   │   │   │   │   ├── Failed.ts
│   │   │   │   │   │   │   ├── FailedState.ts
│   │   │   │   │   │   │   ├── File_.ts
│   │   │   │   │   │   │   ├── Granularity.ts
│   │   │   │   │   │   │   ├── GroupedPredictionsBurstPrediction.ts
│   │   │   │   │   │   │   ├── GroupedPredictionsFacemeshPrediction.ts
│   │   │   │   │   │   │   ├── GroupedPredictionsFacePrediction.ts
│   │   │   │   │   │   │   ├── GroupedPredictionsLanguagePrediction.ts
│   │   │   │   │   │   │   ├── GroupedPredictionsNerPrediction.ts
│   │   │   │   │   │   │   ├── GroupedPredictionsProsodyPrediction.ts
│   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   ├── InferenceBaseRequest.ts
│   │   │   │   │   │   │   ├── InferenceJob.ts
│   │   │   │   │   │   │   ├── InferencePrediction.ts
│   │   │   │   │   │   │   ├── InferenceRequest.ts
│   │   │   │   │   │   │   ├── InferenceResults.ts
│   │   │   │   │   │   │   ├── InferenceSourcePredictResult.ts
│   │   │   │   │   │   │   ├── InProgress.ts
│   │   │   │   │   │   │   ├── InProgressState.ts
│   │   │   │   │   │   │   ├── JobEmbeddingGeneration.ts
│   │   │   │   │   │   │   ├── JobId.ts
│   │   │   │   │   │   │   ├── JobInference.ts
│   │   │   │   │   │   │   ├── JobTlInference.ts
│   │   │   │   │   │   │   ├── JobTraining.ts
│   │   │   │   │   │   │   ├── Language.ts
│   │   │   │   │   │   │   ├── LanguagePrediction.ts
│   │   │   │   │   │   │   ├── Models.ts
│   │   │   │   │   │   │   ├── ModelsPredictions.ts
│   │   │   │   │   │   │   ├── Ner.ts
│   │   │   │   │   │   │   ├── NerPrediction.ts
│   │   │   │   │   │   │   ├── Null.ts
│   │   │   │   │   │   │   ├── PositionInterval.ts
│   │   │   │   │   │   │   ├── PredictionsOptionalNullBurstPrediction.ts
│   │   │   │   │   │   │   ├── PredictionsOptionalNullFacemeshPrediction.ts
│   │   │   │   │   │   │   ├── PredictionsOptionalNullFacePrediction.ts
│   │   │   │   │   │   │   ├── PredictionsOptionalTranscriptionMetadataLanguagePrediction.ts
│   │   │   │   │   │   │   ├── PredictionsOptionalTranscriptionMetadataNerPrediction.ts
│   │   │   │   │   │   │   ├── PredictionsOptionalTranscriptionMetadataProsodyPrediction.ts
│   │   │   │   │   │   │   ├── Prosody.ts
│   │   │   │   │   │   │   ├── ProsodyPrediction.ts
│   │   │   │   │   │   │   ├── Queued.ts
│   │   │   │   │   │   │   ├── QueuedState.ts
│   │   │   │   │   │   │   ├── RegistryFileDetail.ts
│   │   │   │   │   │   │   ├── Regression.ts
│   │   │   │   │   │   │   ├── SortBy.ts
│   │   │   │   │   │   │   ├── Source.ts
│   │   │   │   │   │   │   ├── SourceFile.ts
│   │   │   │   │   │   │   ├── SourceTextSource.ts
│   │   │   │   │   │   │   ├── SourceUrl.ts
│   │   │   │   │   │   │   ├── StateEmbeddingGeneration.ts
│   │   │   │   │   │   │   ├── StateEmbeddingGenerationCompletedEmbeddingGeneration.ts
│   │   │   │   │   │   │   ├── StateEmbeddingGenerationFailed.ts
│   │   │   │   │   │   │   ├── StateEmbeddingGenerationInProgress.ts
│   │   │   │   │   │   │   ├── StateEmbeddingGenerationQueued.ts
│   │   │   │   │   │   │   ├── StateInference.ts
│   │   │   │   │   │   │   ├── StateTlInference.ts
│   │   │   │   │   │   │   ├── StateTlInferenceCompletedTlInference.ts
│   │   │   │   │   │   │   ├── StateTlInferenceFailed.ts
│   │   │   │   │   │   │   ├── StateTlInferenceInProgress.ts
│   │   │   │   │   │   │   ├── StateTlInferenceQueued.ts
│   │   │   │   │   │   │   ├── StateTraining.ts
│   │   │   │   │   │   │   ├── StateTrainingCompletedTraining.ts
│   │   │   │   │   │   │   ├── StateTrainingFailed.ts
│   │   │   │   │   │   │   ├── StateTrainingInProgress.ts
│   │   │   │   │   │   │   ├── StateTrainingQueued.ts
│   │   │   │   │   │   │   ├── Status.ts
│   │   │   │   │   │   │   ├── Tag.ts
│   │   │   │   │   │   │   ├── Target.ts
│   │   │   │   │   │   │   ├── Task.ts
│   │   │   │   │   │   │   ├── TaskClassification.ts
│   │   │   │   │   │   │   ├── TaskRegression.ts
│   │   │   │   │   │   │   ├── TextSource.ts
│   │   │   │   │   │   │   ├── TimeInterval.ts
│   │   │   │   │   │   │   ├── TlInferenceBaseRequest.ts
│   │   │   │   │   │   │   ├── TlInferencePrediction.ts
│   │   │   │   │   │   │   ├── TlInferenceResults.ts
│   │   │   │   │   │   │   ├── TlInferenceSourcePredictResult.ts
│   │   │   │   │   │   │   ├── TrainingBaseRequest.ts
│   │   │   │   │   │   │   ├── TrainingCustomModel.ts
│   │   │   │   │   │   │   ├── Transcription.ts
│   │   │   │   │   │   │   ├── TranscriptionMetadata.ts
│   │   │   │   │   │   │   ├── Type.ts
│   │   │   │   │   │   │   ├── Unconfigurable.ts
│   │   │   │   │   │   │   ├── UnionJob.ts
│   │   │   │   │   │   │   ├── UnionPredictResult.ts
│   │   │   │   │   │   │   ├── Url.ts
│   │   │   │   │   │   │   ├── ValidationArgs.ts
│   │   │   │   │   │   │   ├── When.ts
│   │   │   │   │   │   │   └── Window.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── stream
│   │   │   │   │   │   ├── resources
│   │   │   │   │   │   │   ├── stream
│   │   │   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   │   │   ├── socket
│   │   │   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   │   │   └── StreamSocketResponse.ts
│   │   │   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   │   │   ├── types
│   │   │   │   │   │   │   │   │   ├── Config.ts
│   │   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   │   ├── JobDetails.ts
│   │   │   │   │   │   │   │   │   ├── StreamErrorMessage.ts
│   │   │   │   │   │   │   │   │   ├── StreamFace.ts
│   │   │   │   │   │   │   │   │   ├── StreamLanguage.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictions.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsBurst.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsBurstPredictionsItem.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsFace.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsFacemesh.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsFacemeshPredictionsItem.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsFacePredictionsItem.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsJobDetails.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsLanguage.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsLanguagePredictionsItem.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsProsody.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelPredictionsProsodyPredictionsItem.ts
│   │   │   │   │   │   │   │   │   ├── StreamModelsEndpointPayload.ts
│   │   │   │   │   │   │   │   │   ├── StreamWarningMessage.ts
│   │   │   │   │   │   │   │   │   ├── StreamWarningMessageJobDetails.ts
│   │   │   │   │   │   │   │   │   └── SubscribeEvent.ts
│   │   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   ├── types
│   │   │   │   │   │   │   ├── EmotionEmbedding.ts
│   │   │   │   │   │   │   ├── EmotionEmbeddingItem.ts
│   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   ├── Sentiment.ts
│   │   │   │   │   │   │   ├── SentimentItem.ts
│   │   │   │   │   │   │   ├── StreamBoundingBox.ts
│   │   │   │   │   │   │   ├── TextPosition.ts
│   │   │   │   │   │   │   ├── TimeRange.ts
│   │   │   │   │   │   │   ├── Toxicity.ts
│   │   │   │   │   │   │   └── ToxicityItem.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   └── index.ts
│   │   │   │   └── index.ts
│   │   │   ├── tts
│   │   │   │   ├── resources
│   │   │   │   │   ├── streamInput
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── socket
│   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   └── StreamInputSocketResponse.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   ├── voices
│   │   │   │   │   │   ├── client
│   │   │   │   │   │   │   ├── requests
│   │   │   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   │   │   └── PostedVoice.ts
│   │   │   │   │   │   │   └── index.ts
│   │   │   │   │   │   └── index.ts
│   │   │   │   │   └── index.ts
│   │   │   │   ├── types
│   │   │   │   │   ├── AudioEncoding.ts
│   │   │   │   │   ├── AudioFormatType.ts
│   │   │   │   │   ├── ErrorResponse.ts
│   │   │   │   │   ├── Format.ts
│   │   │   │   │   ├── FormatMp3.ts
│   │   │   │   │   ├── FormatPcm.ts
│   │   │   │   │   ├── FormatWav.ts
│   │   │   │   │   ├── HttpValidationError.ts
│   │   │   │   │   ├── index.ts
│   │   │   │   │   ├── MillisecondInterval.ts
│   │   │   │   │   ├── OctaveVersion.ts
│   │   │   │   │   ├── PostedContext.ts
│   │   │   │   │   ├── PostedContextWithGenerationId.ts
│   │   │   │   │   ├── PostedContextWithUtterances.ts
│   │   │   │   │   ├── PostedTts.ts
│   │   │   │   │   ├── PostedUtterance.ts
│   │   │   │   │   ├── PostedUtteranceVoice.ts
│   │   │   │   │   ├── PostedUtteranceVoiceWithId.ts
│   │   │   │   │   ├── PostedUtteranceVoiceWithName.ts
│   │   │   │   │   ├── PublishTts.ts
│   │   │   │   │   ├── ReturnGeneration.ts
│   │   │   │   │   ├── ReturnPagedVoices.ts
│   │   │   │   │   ├── ReturnTts.ts
│   │   │   │   │   ├── ReturnVoice.ts
│   │   │   │   │   ├── Snippet.ts
│   │   │   │   │   ├── SnippetAudioChunk.ts
│   │   │   │   │   ├── Timestamp.ts
│   │   │   │   │   ├── TimestampMessage.ts
│   │   │   │   │   ├── TimestampType.ts
│   │   │   │   │   ├── TtsOutput.ts
│   │   │   │   │   ├── ValidationError.ts
│   │   │   │   │   ├── ValidationErrorLocItem.ts
│   │   │   │   │   └── VoiceProvider.ts
│   │   │   │   └── index.ts
│   │   │   └── index.ts
│   │   └── index.ts
│   ├── wrapper
│   │   ├── expressionMeasurement
│   │   │   ├── batch
│   │   │   │   ├── BatchClient.ts
│   │   │   │   └── Job.ts
│   │   │   ├── streaming
│   │   │   │   ├── StreamingClient.ts
│   │   │   │   └── StreamSocket.ts
│   │   │   └── ExpressionMeasurementClient.ts
│   │   ├── base64Decode.ts
│   │   ├── base64Encode.ts
│   │   ├── checkForAudioTracks.ts
│   │   ├── collate.ts
│   │   ├── convertBase64ToBlob.ts
│   │   ├── convertBlobToBase64.ts
│   │   ├── convertFrequencyScale.ts
│   │   ├── ensureSingleValidAudioTrack.ts
│   │   ├── EVIWebAudioPlayer.ts
│   │   ├── fetchAccessToken.ts
│   │   ├── generateEmptyFft.ts
│   │   ├── getAudioStream.ts
│   │   ├── getBrowserSupportedMimeType.ts
│   │   ├── HumeClient.ts
│   │   ├── index.ts
│   │   └── SilenceFiller.ts
│   ├── BaseClient.ts
│   ├── Client.ts
│   ├── environments.ts
│   ├── exports.ts
│   ├── index.ts
│   ├── index.ts.diff
│   └── version.ts
├── .fernignore
├── .prettierignore
├── biome.json
├── eslint.config.mjs
├── justfile
├── package.json
├── pnpm-workspace.yaml
├── tsconfig.base.json
├── tsconfig.cjs.json
├── tsconfig.dev.json
├── tsconfig.esm.json
└── vitest.config.mts
```

================================================================================
// File: .fern/metadata.json
================================================================================
{
    "cliVersion": "3.4.3",
    "generatorName": "fernapi/fern-typescript-node-sdk",
    "generatorVersion": "3.43.3",
    "generatorConfig": {
        "extraDependencies": {
            "uuid": "9.0.1",
            "zod": "^3.23.8"
        },
        "extraDevDependencies": {
            "@types/uuid": "9.0.7",
            "@types/ws": "^8.5.9"
        },
        "formDataSupport": "Node18",
        "noSerdeLayer": false,
        "enableInlineTypes": false,
        "allowCustomFetcher": true,
        "shouldGenerateWebsocketClients": true,
        "namespaceExport": "Hume"
    },
    "sdkVersion": "0.15.11"
}

================================================================================
// File: .fernignore
================================================================================
# Specify files that shouldn't be modified by Fern

README.md
CITATIONS.md
LICENSE
CONTRIBUTING.md

# Tooling
eslint.config.mjs
#jest.config.mjs
justfile
tsconfig.dev.json
.nvmrc
.github
.prettierignore


# EVI WebSocket
# Supplier.ts - sync version required to keep EVI chat client .connect() method synchronous
src/core/fetcher/Supplier.ts
# src/Client.ts
# src/api/resources/empathicVoice/client/Client.ts
# src/api/resources/empathicVoice/resources/chat/index.ts
# src/api/resources/empathicVoice/resources/chat/client
# src/core/websocket
# src/core/index.ts
# EVI Chat Client - manually maintained to preserve backward compatibility
# Client.ts changes from generated version:
# - ConnectArgs.sessionSettings is optional (was required)
# - ConnectArgs.configVersion accepts string | number (was only number)
# - ConnectArgs.voiceId added back as deprecated parameter
# - ConnectArgs.queryParams added for arbitrary query parameters
# - connect() args parameter is optional with default {}
# - Handles voiceId parameter (maps to voice_id query param)
# - Handles flexible configVersion types (both string and number)
# - Conditional sessionSettings serialization (only if provided)
# - Merges custom queryParams into query parameters
src/api/resources/empathicVoice/resources/chat/client/Client.ts

# The below websocket clients also need a custom _getCustomAuthorizationHeaders
src/api/resources/tts/resources/streamInput/client/Client.ts
src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts

# Socket.ts changes from generated version:
# - Response type includes receivedAt: Date timestamp
# - handleMessage adds receivedAt timestamp to messages
# - Restored 8 convenience methods that wrap sendPublish():
#   - sendAudioInput(), sendSessionSettings(), sendAssistantInput()
#   - pauseAssistant(), resumeAssistant()
#   - sendToolResponseMessage(), sendToolErrorMessage(), sendUserInput()
# - Added tillSocketOpen() as deprecated alias for waitForOpen()
src/api/resources/empathicVoice/resources/chat/client/Socket.ts

# index.ts - manually maintained to export Chat and ChatSocket
# Generated version exports nothing (export {}), but we need to export
# our manually maintained Client and Socket classes
src/api/resources/empathicVoice/resources/chat/client/index.ts

# Manually added tests
tests/unit/url-resolution.test.ts
tests/expressionMeasurement/batch.test.ts
tests/expressionMeasurement/streaming.test.ts

# Required manual edits for Node 18 compatibility
tests/unit/fetcher/Fetcher.test.ts
tests/unit/file/file.test.ts
tests/unit/file/test-file.txt

# Needed because node 18 doesn't actually have a global.File
tests/BrowserTestEnvironment.ts

# Needed to send apiKey on websocket queryParams
# See https://github.com/fern-demo/hume-typescript-sdk/pull/1
src/core/websocket/ws.ts

# Needed to export the utilities under src/wrapper
src/wrapper
src/index.ts

# Deprecated type aliases for backward compatibility
src/api/resources/empathicVoice/resources/chat/types/SubscribeEvent.ts
src/serialization/resources/empathicVoice/resources/chat/types/SubscribeEvent.ts
# Modified index files to support deprecated aliases
src/api/resources/empathicVoice/resources/chat/index.ts
src/serialization/resources/empathicVoice/resources/chat/index.ts

scripts/test-examples-local.sh
justfile

# Custom HeaderAuthProvider to support both apiKey and accessToken authentication
src/auth/HeaderAuthProvider.ts

# Auth tests
tests/unit/auth/auth.test.ts

================================================================================
// File: .github/dependabot.yml
================================================================================
version: 2

updates:
    # check for updated versions of github actions on a weekly basis
    - package-ecosystem: "github-actions"
      directory: "/"
      schedule:
          interval: "weekly"
          day: "monday"
          time: "06:00"
          timezone: "America/New_York"
      commit-message:
          prefix: "[github actions] "
      open-pull-requests-limit: 5

    # commented out for now because dep versions are defined in fern-config,
    # so each Fern generation will overwrite any updates made by Dependabot in this SDK

    # check for updated versions of npm dependencies on a daily basis
    # - package-ecosystem: "npm"
    #   directory: "/"
    #   schedule:
    #       interval: "daily"
    #       time: "06:00"
    #       timezone: "America/New_York"
    #   commit-message:
    #       prefix: "[npm] "
    #   open-pull-requests-limit: 5

================================================================================
// File: .github/workflows/ci.yml
================================================================================
name: ci

on:
  push:
  pull_request:
    types: [synchronize, reopened, ready_for_review]

jobs:
  format:
    runs-on: ubuntu-latest
    # Only run on push events to branches (not tags), and not on main/master
    if: github.event_name == 'push' && !contains(github.ref, 'refs/tags/') && github.ref != 'refs/heads/main' && github.ref != 'refs/heads/master'
    permissions:
      contents: write
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '18.18.0'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Run formatter
        run: pnpm format

      - name: Check for formatting changes
        id: verify_diff
        run: |
          git diff --exit-code || echo "has_changes=true" >> $GITHUB_OUTPUT

      - name: Commit formatting changes
        if: steps.verify_diff.outputs.has_changes == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: 'style: auto-format code'
          commit_options: '--no-verify'

      - name: Fail if formatting was needed
        if: steps.verify_diff.outputs.has_changes == 'true'
        run: |
          echo "::error::Code was not properly formatted. Auto-format commit has been pushed. Please pull the latest changes."
          exit 1

  compile:
    runs-on: ubuntu-latest
    needs: [format]
    # Run if format succeeded or was skipped (on main/tags)
    if: always() && github.event_name == 'push' && (needs.format.result == 'success' || needs.format.result == 'skipped')
    permissions:
      contents: read
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '18.18.0'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Compile
        run: pnpm build

  test:
    runs-on: ubuntu-latest
    needs: [format]
    # Run if format succeeded or was skipped (on main/tags)
    if: always() && github.event_name == 'push' && (needs.format.result == 'success' || needs.format.result == 'skipped')
    permissions:
      contents: read
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '18.18.0'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Check for formatting issues
        run: pnpm format:check

      - name: Run tests
        # --configLoader runner is used to make vitest able to load its config as a ESM module in node 18. We wouldn't need to specify this if we didn't support node 18.
        run: pnpm test --configLoader runner

  test-examples:
    runs-on: ubuntu-latest
    # Run on pull_request events and push events (to test feature branches)
    if: (github.event_name == 'pull_request' || github.event_name == 'push') && github.actor != 'dependabot[bot]'
    permissions:
      contents: read
    steps:
      - name: Checkout SDK repo (PR branch)
        uses: actions/checkout@v4
        with:
          path: sdk
          # checkout the PR branch, not main
          ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}
          fetch-depth: 0

      - name: Checkout examples repo
        uses: actions/checkout@v4
        with:
          repository: humeai/hume-api-examples
          path: examples

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.20.0

      - name: Build SDK
        working-directory: ./sdk
        run: |
          echo "=== SDK Build Info ==="
          echo "Branch: ${{ github.head_ref || github.ref_name || 'unknown' }}"
          echo "Ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}"
          echo "Commit SHA: $(git rev-parse HEAD)"
          echo "Branch name: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'detached')"
          echo "======================"
          pnpm install
          pnpm build
          echo "SDK version from package.json: $(node -p "require('./package.json').version")"

      - name: Link SDK to examples
        run: |
          cd ./sdk
          SDK_VERSION=$(node -p "require('./package.json').version")
          SDK_PATH=$(pwd)
          echo "=== Linking SDK ==="
          echo "SDK version: $SDK_VERSION"
          echo "SDK path: $SDK_PATH"
          pnpm link --global
          cd ../examples/evi/evi-typescript-quickstart
          pnpm install --no-frozen-lockfile
          pnpm remove hume || true
          pnpm link hume
          echo ""
          echo "=== Verifying Linked SDK ==="
          if [ -L node_modules/hume ]; then
            LINK_TARGET=$(readlink -f node_modules/hume)
            echo "✓ node_modules/hume is a symlink"
            echo "  Link target: $LINK_TARGET"
            if [[ "$LINK_TARGET" == *"$SDK_PATH"* ]] || [[ "$LINK_TARGET" == *"global"* ]]; then
              echo "✓ Link points to local SDK (not npm package)"
            else
              echo "✗ WARNING: Link may not point to local SDK"
            fi
          else
            echo "✗ ERROR: node_modules/hume is NOT a symlink - using npm package!"
            exit 1
          fi
          INSTALLED_VERSION=$(node -p "require('hume/package.json').version")
          echo "Installed hume version: $INSTALLED_VERSION"
          if [ "$INSTALLED_VERSION" != "$SDK_VERSION" ]; then
            echo "✗ WARNING: Version mismatch! Expected $SDK_VERSION, got $INSTALLED_VERSION"
          else
            echo "✓ Version matches: $INSTALLED_VERSION"
          fi
          echo "===================="
          cd ../../tts/tts-typescript-quickstart
          pnpm install --no-frozen-lockfile
          pnpm remove hume || true
          pnpm link hume
          echo ""
          echo "=== Verifying Linked SDK ==="
          if [ -L node_modules/hume ]; then
            LINK_TARGET=$(readlink -f node_modules/hume)
            echo "✓ node_modules/hume is a symlink"
            echo "  Link target: $LINK_TARGET"
            if [[ "$LINK_TARGET" == *"$SDK_PATH"* ]] || [[ "$LINK_TARGET" == *"global"* ]]; then
              echo "✓ Link points to local SDK (not npm package)"
            else
              echo "✗ WARNING: Link may not point to local SDK"
            fi
          else
            echo "✗ ERROR: node_modules/hume is NOT a symlink - using npm package!"
            exit 1
          fi
          INSTALLED_VERSION=$(node -p "require('hume/package.json').version")
          echo "Installed hume version: $INSTALLED_VERSION"
          if [ "$INSTALLED_VERSION" != "$SDK_VERSION" ]; then
            echo "✗ WARNING: Version mismatch! Expected $SDK_VERSION, got $INSTALLED_VERSION"
          else
            echo "✓ Version matches: $INSTALLED_VERSION"
          fi
          echo "===================="

      - name: Run example evi-typescript-quickstart
        working-directory: ./examples/evi/evi-typescript-quickstart
        run: pnpm run test
        env:
          TEST_HUME_API_KEY: ${{ secrets.TEST_HUME_API_KEY }}
          TEST_HUME_SECRET_KEY: ${{ secrets.TEST_HUME_SECRET_KEY }}

      - name: Run example tts-typescript-quickstart
        working-directory: ./examples/tts/tts-typescript-quickstart
        run: pnpm run test
        env:
          TEST_HUME_API_KEY: ${{ secrets.TEST_HUME_API_KEY }}
          TEST_HUME_SECRET_KEY: ${{ secrets.TEST_HUME_SECRET_KEY }}

  publish:
    needs: [compile, test]
    if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Required for OIDC publishing to NPM
      contents: read
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '18.18.0'
          registry-url: 'https://registry.npmjs.org'

      - name: Setup pnpm
        run: npm install -g pnpm

      - name: Install dependencies
        run: pnpm install

      - name: Build
        run: pnpm build

      - name: Publish to npm
        run: |

          publish() {
            npx -y npm@latest publish --provenance "$@"
          }
          if [[ ${GITHUB_REF} == *alpha* ]]; then
            publish --access public --tag alpha
          elif [[ ${GITHUB_REF} == *beta* ]]; then
            publish --access public --tag beta
          else
            publish --access public
          fi
      - name: Trigger React SDK bump
        uses: peter-evans/repository-dispatch@v4
        with:
          token: ${{ secrets.REPO_DISPATCH_TOKEN }}
          repository: HumeAI/hume-react-sdk
          event-type: typescript-sdk-published
          client-payload: |
            {
              "version": "${{ github.ref_name }}",
              "tag": "${{ github.ref_name }}",
              "is_prerelease": ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') }}
            }

================================================================================
// File: .github/workflows/publish.yml
================================================================================
name: Manual Publish to npm

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Git tag to publish (e.g., 0.15.12)'
        required: true
        type: string
      npm_tag:
        description: 'npm dist-tag (latest, alpha, beta)'
        required: false
        default: 'latest'
        type: choice
        options:
          - latest
          - alpha
          - beta

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout repo at tag
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.tag }}

      - name: Verify tag exists
        run: |
          if ! git describe --tags --exact-match HEAD 2>/dev/null; then
            echo "Warning: HEAD is not at an exact tag. Proceeding anyway with ref: ${{ inputs.tag }}"
          fi

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '18.18.0'
          registry-url: 'https://registry.npmjs.org'

      - name: Setup pnpm
        run: npm install -g pnpm

      - name: Install dependencies
        run: pnpm install

      - name: Build
        run: pnpm build

      - name: Verify version matches tag
        run: |
          PACKAGE_VERSION=$(node -p "require('./package.json').version")
          echo "Package version: $PACKAGE_VERSION"
          echo "Input tag: ${{ inputs.tag }}"
          if [ "$PACKAGE_VERSION" != "${{ inputs.tag }}" ]; then
            echo "Warning: package.json version ($PACKAGE_VERSION) does not match input tag (${{ inputs.tag }})"
          fi

      - name: Publish to npm
        run: npx -y npm@latest publish --provenance --access public --tag ${{ inputs.npm_tag }}

      - name: Trigger React SDK bump
        if: inputs.npm_tag == 'latest'
        uses: peter-evans/repository-dispatch@v4
        with:
          token: ${{ secrets.REPO_DISPATCH_TOKEN }}
          repository: HumeAI/hume-react-sdk
          event-type: typescript-sdk-published
          client-payload: |
            {
              "version": "${{ inputs.tag }}",
              "tag": "${{ inputs.tag }}",
              "is_prerelease": ${{ inputs.npm_tag != 'latest' }}
            }

================================================================================
// File: .github/workflows/test-examples-dependabot.yml
================================================================================
name: test-examples-dependabot

on:
  pull_request_target:
    types: [opened, synchronize, reopened]

jobs:
  test-examples-dependabot:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request_target' && github.actor == 'dependabot[bot]'
    permissions:
      contents: read
      pull-requests: read

    steps:
      - name: Checkout base SHA (trusted)
        uses: actions/checkout@v4
        with:
          path: sdk
          ref: ${{ github.event.pull_request.base.sha }}
          fetch-depth: 0
          persist-credentials: false

      - name: Verify PR changes are dependency-only
        working-directory: sdk
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          PR: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail

          files="$(curl -fsSL \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO/pulls/$PR/files?per_page=100" \
            | jq -r '.[].filename')"

          echo "Changed files:"
          echo "$files"

          allowed='^(
            package\.json|
            pnpm-lock\.yaml|
            pnpm-workspace\.yaml|
            \.npmrc|
            examples/.*/package\.json|
            examples/.*/pnpm-lock\.yaml
          )$'

          bad="$(echo "$files" | tr -d '\r' | grep -Ev "$allowed" || true)"
          if [ -n "$bad" ]; then
            echo "::error::Disallowed file changes in Dependabot PR:"
            echo "$bad"
            exit 1
          fi

      - name: Apply Dependabot PR patch
        working-directory: sdk
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          PR: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail
          curl -fsSL \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3.patch" \
            "https://api.github.com/repos/$REPO/pulls/$PR" \
            > pr.patch
          git apply --whitespace=nowarn pr.patch

      - name: Checkout examples repo
        uses: actions/checkout@v4
        with:
          repository: humeai/hume-api-examples
          path: examples
          fetch-depth: 0

      - name: Set up node
        uses: actions/setup-node@v4
        with:
          node-version: '18.18.0'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: '10.20.0'

      - name: Build SDK
        working-directory: ./sdk
        run: |
          echo "=== SDK Build Info ==="
          echo "Branch: ${{ github.head_ref || github.ref_name || 'unknown' }}"
          echo "Ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}"
          echo "Commit SHA: $(git rev-parse HEAD)"
          echo "Branch name: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'detached')"
          echo "======================"
          pnpm install
          pnpm build
          echo "SDK version from package.json: $(node -p "require('./package.json').version")"

      - name: Link SDK to examples
        run: |
          cd ./sdk
          SDK_VERSION=$(node -p "require('./package.json').version")
          SDK_PATH=$(pwd)
          echo "=== Linking SDK ==="
          echo "SDK version: $SDK_VERSION"
          echo "SDK path: $SDK_PATH"
          pnpm link --global

          cd ../examples/evi/evi-typescript-quickstart
          pnpm install --no-frozen-lockfile
          pnpm remove hume || true
          pnpm link hume

          echo ""
          echo "=== Verifying Linked SDK ==="
          if [ -L node_modules/hume ]; then
            LINK_TARGET=$(readlink -f node_modules/hume)
            echo "✓ node_modules/hume is a symlink"
            echo "  Link target: $LINK_TARGET"
            if [[ "$LINK_TARGET" == *"$SDK_PATH"* ]] || [[ "$LINK_TARGET" == *"global"* ]]; then
              echo "✓ Link points to local SDK (not npm package)"
            else
              echo "✗ WARNING: Link may not point to local SDK"
            fi
          else
            echo "✗ ERROR: node_modules/hume is NOT a symlink - using npm package!"
            exit 1
          fi

          INSTALLED_VERSION=$(node -p "require('hume/package.json').version")
          echo "Installed hume version: $INSTALLED_VERSION"
          if [ "$INSTALLED_VERSION" != "$SDK_VERSION" ]; then
            echo "✗ WARNING: Version mismatch! Expected $SDK_VERSION, got $INSTALLED_VERSION"
          else
            echo "✓ Version matches: $INSTALLED_VERSION"
          fi
          echo "===================="

          cd ../../tts/tts-typescript-quickstart
          pnpm install --no-frozen-lockfile
          pnpm remove hume || true
          pnpm link hume

          echo ""
          echo "=== Verifying Linked SDK ==="
          if [ -L node_modules/hume ]; then
            LINK_TARGET=$(readlink -f node_modules/hume)
            echo "✓ node_modules/hume is a symlink"
            echo "  Link target: $LINK_TARGET"
            if [[ "$LINK_TARGET" == *"$SDK_PATH"* ]] || [[ "$LINK_TARGET" == *"global"* ]]; then
              echo "✓ Link points to local SDK (not npm package)"
            else
              echo "✗ WARNING: Link may not point to local SDK"
            fi
          else
            echo "✗ ERROR: node_modules/hume is NOT a symlink - using npm package!"
            exit 1
          fi

          INSTALLED_VERSION=$(node -p "require('hume/package.json').version")
          echo "Installed hume version: $INSTALLED_VERSION"
          if [ "$INSTALLED_VERSION" != "$SDK_VERSION" ]; then
            echo "✗ WARNING: Version mismatch! Expected $SDK_VERSION, got $INSTALLED_VERSION"
          else
            echo "✓ Version matches: $INSTALLED_VERSION"
          fi
          echo "===================="

      - name: Run example evi-typescript-quickstart
        working-directory: ./examples/evi/evi-typescript-quickstart
        env:
          TEST_HUME_API_KEY: ${{ secrets.TEST_HUME_API_KEY }}
          TEST_HUME_SECRET_KEY: ${{ secrets.TEST_HUME_SECRET_KEY }}
        run: pnpm run test

      - name: Run example tts-typescript-quickstart
        working-directory: ./examples/tts/tts-typescript-quickstart
        env:
          TEST_HUME_API_KEY: ${{ secrets.TEST_HUME_API_KEY }}
          TEST_HUME_SECRET_KEY: ${{ secrets.TEST_HUME_SECRET_KEY }}
        run: pnpm run test

================================================================================
// File: .prettierignore
================================================================================
.mock

================================================================================
// File: biome.json
================================================================================
{
    "$schema": "https://biomejs.dev/schemas/2.3.1/schema.json",
    "root": true,
    "vcs": {
        "enabled": false
    },
    "files": {
        "ignoreUnknown": true,
        "includes": [
            "**",
            "!!dist",
            "!!**/dist",
            "!!lib",
            "!!**/lib",
            "!!_tmp_*",
            "!!**/_tmp_*",
            "!!*.tmp",
            "!!**/*.tmp",
            "!!.tmp/",
            "!!**/.tmp/",
            "!!*.log",
            "!!**/*.log",
            "!!**/.DS_Store",
            "!!**/Thumbs.db"
        ]
    },
    "formatter": {
        "enabled": true,
        "indentStyle": "space",
        "indentWidth": 4,
        "lineWidth": 120
    },
    "javascript": {
        "formatter": {
            "quoteStyle": "double"
        }
    },
    "assist": {
        "enabled": true,
        "actions": {
            "source": {
                "organizeImports": "on"
            }
        }
    },
    "linter": {
        "rules": {
            "style": {
                "useNodejsImportProtocol": "off"
            },
            "suspicious": {
                "noAssignInExpressions": "warn",
                "noUselessEscapeInString": {
                    "level": "warn",
                    "fix": "none",
                    "options": {}
                },
                "noThenProperty": "warn",
                "useIterableCallbackReturn": "warn",
                "noShadowRestrictedNames": "warn",
                "noTsIgnore": {
                    "level": "warn",
                    "fix": "none",
                    "options": {}
                },
                "noConfusingVoidType": {
                    "level": "warn",
                    "fix": "none",
                    "options": {}
                }
            }
        }
    }
}

================================================================================
// File: eslint.config.mjs
================================================================================
import js from "@eslint/js";
import tseslint from "typescript-eslint";

const fernRules = {
    files: ["src/**/*.ts"],
    rules: {
        "@typescript-eslint/no-unused-vars": "off",
        "@typescript-eslint/no-unnecessary-type-assertion": "warn",
        "@typescript-eslint/no-explicit-any": "warn",
        "@typescript-eslint/ban-ts-comment": "warn",
        "prefer-const": "warn",
    },
};

const humeRules = {
    files: ["src/wrapper/**/*.ts"],
    rules: {
        "@typescript-eslint/no-unused-vars": "error",
        "@typescript-eslint/no-unnecessary-type-assertion": "error",
        "@typescript-eslint/no-explicit-any": "error",
        "@typescript-eslint/ban-ts-comment": "error",
        "prefer-const": "error",
    },
};

export default [
    js.configs.recommended,
    ...tseslint.configs.recommended,
    {
        ignores: ["dist", "src/core/**/*.ts", "jest.config.js"],
    },
    {
        languageOptions: {
            parserOptions: {
                project: "./tsconfig.dev.json",
            },
        },
    },
    {
        rules: {
            "@typescript-eslint/no-namespace": "off",
        },
    },
    fernRules,
    humeRules,
];

================================================================================
// File: justfile
================================================================================
# run the CI workflow locally
local-ci:
    act -W '.github/workflows/ci.yml' --container-architecture linux/amd64 -s GITHUB_TOKEN="$(gh auth token)"

================================================================================
// File: package.json
================================================================================
{
    "name": "hume",
    "version": "0.15.12",
    "private": false,
    "repository": {
        "type": "git",
        "url": "git+https://github.com/HumeAI/hume-typescript-sdk.git"
    },
    "type": "commonjs",
    "main": "./dist/cjs/index.js",
    "module": "./dist/esm/index.mjs",
    "types": "./dist/cjs/index.d.ts",
    "exports": {
        ".": {
            "types": "./dist/cjs/index.d.ts",
            "import": {
                "types": "./dist/esm/index.d.mts",
                "default": "./dist/esm/index.mjs"
            },
            "require": {
                "types": "./dist/cjs/index.d.ts",
                "default": "./dist/cjs/index.js"
            },
            "default": "./dist/cjs/index.js"
        },
        "./serialization": {
            "types": "./dist/cjs/serialization/index.d.ts",
            "import": {
                "types": "./dist/esm/serialization/index.d.mts",
                "default": "./dist/esm/serialization/index.mjs"
            },
            "require": {
                "types": "./dist/cjs/serialization/index.d.ts",
                "default": "./dist/cjs/serialization/index.js"
            },
            "default": "./dist/cjs/serialization/index.js"
        },
        "./package.json": "./package.json"
    },
    "files": [
        "dist",
        "reference.md",
        "README.md",
        "LICENSE"
    ],
    "scripts": {
        "format": "biome format --write --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
        "format:check": "biome format --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
        "lint": "biome lint --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
        "lint:fix": "biome lint --fix --unsafe --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
        "check": "biome check --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
        "check:fix": "biome check --fix --unsafe --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
        "build": "pnpm build:cjs && pnpm build:esm",
        "build:cjs": "tsc --project ./tsconfig.cjs.json",
        "build:esm": "tsc --project ./tsconfig.esm.json && node scripts/rename-to-esm-files.js dist/esm",
        "test": "vitest",
        "test:unit": "vitest --project unit",
        "test:wire": "vitest --project wire"
    },
    "dependencies": {
        "ws": "^8.16.0",
        "uuid": "9.0.1",
        "zod": "^3.23.8"
    },
    "devDependencies": {
        "webpack": "^5.97.1",
        "ts-loader": "^9.5.1",
        "@types/ws": "^8.5.9",
        "vitest": "^3.2.4",
        "msw": "2.11.2",
        "@types/node": "^18.19.70",
        "typescript": "~5.7.2",
        "@biomejs/biome": "2.3.1",
        "@types/uuid": "9.0.7"
    },
    "browser": {
        "fs": false,
        "os": false,
        "path": false,
        "stream": false
    },
    "packageManager": "pnpm@10.20.0",
    "engines": {
        "node": ">=18.0.0"
    },
    "sideEffects": false
}

================================================================================
// File: pnpm-workspace.yaml
================================================================================
packages: ['.']

================================================================================
// File: scripts/rename-to-esm-files.js
================================================================================
#!/usr/bin/env node

const fs = require("fs").promises;
const path = require("path");

const extensionMap = {
    ".js": ".mjs",
    ".d.ts": ".d.mts",
};
const oldExtensions = Object.keys(extensionMap);

async function findFiles(rootPath) {
    const files = [];

    async function scan(directory) {
        const entries = await fs.readdir(directory, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(directory, entry.name);

            if (entry.isDirectory()) {
                if (entry.name !== "node_modules" && !entry.name.startsWith(".")) {
                    await scan(fullPath);
                }
            } else if (entry.isFile()) {
                if (oldExtensions.some((ext) => entry.name.endsWith(ext))) {
                    files.push(fullPath);
                }
            }
        }
    }

    await scan(rootPath);
    return files;
}

async function updateFiles(files) {
    const updatedFiles = [];
    for (const file of files) {
        const updated = await updateFileContents(file);
        updatedFiles.push(updated);
    }

    console.log(`Updated imports in ${updatedFiles.length} files.`);
}

async function updateFileContents(file) {
    const content = await fs.readFile(file, "utf8");

    let newContent = content;
    // Update each extension type defined in the map
    for (const [oldExt, newExt] of Object.entries(extensionMap)) {
        // Handle static imports/exports
        const staticRegex = new RegExp(`(import|export)(.+from\\s+['"])(\\.\\.?\\/[^'"]+)(\\${oldExt})(['"])`, "g");
        newContent = newContent.replace(staticRegex, `$1$2$3${newExt}$5`);

        // Handle dynamic imports (yield import, await import, regular import())
        const dynamicRegex = new RegExp(
            `(yield\\s+import|await\\s+import|import)\\s*\\(\\s*['"](\\.\\.\?\\/[^'"]+)(\\${oldExt})['"]\\s*\\)`,
            "g",
        );
        newContent = newContent.replace(dynamicRegex, `$1("$2${newExt}")`);
    }

    if (content !== newContent) {
        await fs.writeFile(file, newContent, "utf8");
        return true;
    }
    return false;
}

async function renameFiles(files) {
    let counter = 0;
    for (const file of files) {
        const ext = oldExtensions.find((ext) => file.endsWith(ext));
        const newExt = extensionMap[ext];

        if (newExt) {
            const newPath = file.slice(0, -ext.length) + newExt;
            await fs.rename(file, newPath);
            counter++;
        }
    }

    console.log(`Renamed ${counter} files.`);
}

async function main() {
    try {
        const targetDir = process.argv[2];
        if (!targetDir) {
            console.error("Please provide a target directory");
            process.exit(1);
        }

        const targetPath = path.resolve(targetDir);
        const targetStats = await fs.stat(targetPath);

        if (!targetStats.isDirectory()) {
            console.error("The provided path is not a directory");
            process.exit(1);
        }

        console.log(`Scanning directory: ${targetDir}`);

        const files = await findFiles(targetDir);

        if (files.length === 0) {
            console.log("No matching files found.");
            process.exit(0);
        }

        console.log(`Found ${files.length} files.`);
        await updateFiles(files);
        await renameFiles(files);
        console.log("\nDone!");
    } catch (error) {
        console.error("An error occurred:", error.message);
        process.exit(1);
    }
}

main();

================================================================================
// File: src/BaseClient.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import { HeaderAuthProvider } from "./auth/HeaderAuthProvider.js";
import { mergeHeaders } from "./core/headers.js";
import * as core from "./core/index.js";
import type * as environments from "./environments.js";

export type BaseClientOptions = {
    environment?: core.Supplier<environments.HumeEnvironment | environments.HumeEnvironmentUrls>;
    /** Specify a custom URL to connect the client to. */
    baseUrl?: core.Supplier<string>;
    /** Additional headers to include in requests. */
    headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    /** The default maximum time to wait for a response in seconds. */
    timeoutInSeconds?: number;
    /** The default number of times to retry the request. Defaults to 2. */
    maxRetries?: number;
    /** Provide a custom fetch implementation. Useful for platforms that don't have a built-in fetch or need a custom implementation. */
    fetch?: typeof fetch;
    fetcher?: core.FetchFunction;
    /** Configure logging for the client. */
    logging?: core.logging.LogConfig | core.logging.Logger;
} & HeaderAuthProvider.AuthOptions;

export interface BaseRequestOptions {
    /** The maximum time to wait for a response in seconds. */
    timeoutInSeconds?: number;
    /** The number of times to retry the request. Defaults to 2. */
    maxRetries?: number;
    /** A hook to abort the request. */
    abortSignal?: AbortSignal;
    /** Additional query string parameters to include in the request. */
    queryParams?: Record<string, unknown>;
    /** Additional headers to include in the request. */
    headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
}

export type NormalizedClientOptions<T extends BaseClientOptions = BaseClientOptions> = T & {
    logging: core.logging.Logger;
    authProvider?: core.AuthProvider;
};

export type NormalizedClientOptionsWithAuth<T extends BaseClientOptions = BaseClientOptions> =
    NormalizedClientOptions<T> & {
        authProvider: core.AuthProvider;
    };

export function normalizeClientOptions<T extends BaseClientOptions = BaseClientOptions>(
    options: T,
): NormalizedClientOptions<T> {
    const headers = mergeHeaders(
        {
            "X-Fern-Language": "JavaScript",
            "X-Fern-SDK-Name": "hume",
            "X-Fern-SDK-Version": "0.15.11",
            "User-Agent": "hume/0.15.11",
            "X-Fern-Runtime": core.RUNTIME.type,
            "X-Fern-Runtime-Version": core.RUNTIME.version,
        },
        options?.headers,
    );

    return {
        ...options,
        logging: core.logging.createLogger(options?.logging),
        headers,
    } as NormalizedClientOptions<T>;
}

export function normalizeClientOptionsWithAuth<T extends BaseClientOptions = BaseClientOptions>(
    options: T,
): NormalizedClientOptionsWithAuth<T> {
    const normalized = normalizeClientOptions(options) as NormalizedClientOptionsWithAuth<T>;
    const normalizedWithNoOpAuthProvider = withNoOpAuthProvider(normalized);
    normalized.authProvider ??= new HeaderAuthProvider(normalizedWithNoOpAuthProvider);
    return normalized;
}

function withNoOpAuthProvider<T extends BaseClientOptions = BaseClientOptions>(
    options: NormalizedClientOptions<T>,
): NormalizedClientOptionsWithAuth<T> {
    return {
        ...options,
        authProvider: new core.NoOpAuthProvider(),
    };
}

================================================================================
// File: src/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import { EmpathicVoiceClient } from "./api/resources/empathicVoice/client/Client.js";
import { ExpressionMeasurementClient } from "./api/resources/expressionMeasurement/client/Client.js";
import { TtsClient } from "./api/resources/tts/client/Client.js";
import type { BaseClientOptions, BaseRequestOptions } from "./BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "./BaseClient.js";

export declare namespace HumeClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class HumeClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<HumeClient.Options>;
    protected _tts: TtsClient | undefined;
    protected _empathicVoice: EmpathicVoiceClient | undefined;
    protected _expressionMeasurement: ExpressionMeasurementClient | undefined;

    constructor(options: HumeClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    public get tts(): TtsClient {
        return (this._tts ??= new TtsClient(this._options));
    }

    public get empathicVoice(): EmpathicVoiceClient {
        return (this._empathicVoice ??= new EmpathicVoiceClient(this._options));
    }

    public get expressionMeasurement(): ExpressionMeasurementClient {
        return (this._expressionMeasurement ??= new ExpressionMeasurementClient(this._options));
    }
}

================================================================================
// File: src/api/index.ts
================================================================================
export * from "./resources/index.js";

================================================================================
// File: src/api/resources/empathicVoice/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { ChatClient } from "../resources/chat/client/Client.js";
import { ChatGroupsClient } from "../resources/chatGroups/client/Client.js";
import { ChatsClient } from "../resources/chats/client/Client.js";
import { ConfigsClient } from "../resources/configs/client/Client.js";
import { ControlPlaneClient } from "../resources/controlPlane/client/Client.js";
import { PromptsClient } from "../resources/prompts/client/Client.js";
import { ToolsClient } from "../resources/tools/client/Client.js";

export declare namespace EmpathicVoiceClient {
    export type Options = BaseClientOptions;
}

export class EmpathicVoiceClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<EmpathicVoiceClient.Options>;
    protected _controlPlane: ControlPlaneClient | undefined;
    protected _chatGroups: ChatGroupsClient | undefined;
    protected _chats: ChatsClient | undefined;
    protected _configs: ConfigsClient | undefined;
    protected _prompts: PromptsClient | undefined;
    protected _tools: ToolsClient | undefined;
    protected _chat: ChatClient | undefined;

    constructor(options: EmpathicVoiceClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    public get controlPlane(): ControlPlaneClient {
        return (this._controlPlane ??= new ControlPlaneClient(this._options));
    }

    public get chatGroups(): ChatGroupsClient {
        return (this._chatGroups ??= new ChatGroupsClient(this._options));
    }

    public get chats(): ChatsClient {
        return (this._chats ??= new ChatsClient(this._options));
    }

    public get configs(): ConfigsClient {
        return (this._configs ??= new ConfigsClient(this._options));
    }

    public get prompts(): PromptsClient {
        return (this._prompts ??= new PromptsClient(this._options));
    }

    public get tools(): ToolsClient {
        return (this._tools ??= new ToolsClient(this._options));
    }

    public get chat(): ChatClient {
        return (this._chat ??= new ChatClient(this._options));
    }
}

================================================================================
// File: src/api/resources/empathicVoice/client/index.ts
================================================================================
export {};

================================================================================
// File: src/api/resources/empathicVoice/errors/BadRequestError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../core/index.js";
import * as errors from "../../../../errors/index.js";
import type * as Hume from "../../../index.js";

export class BadRequestError extends errors.HumeError {
    constructor(body: Hume.empathicVoice.ErrorResponse, rawResponse?: core.RawResponse) {
        super({
            message: "BadRequestError",
            statusCode: 400,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }

        this.name = this.constructor.name;
    }
}

================================================================================
// File: src/api/resources/empathicVoice/errors/UnprocessableEntityError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../core/index.js";
import * as errors from "../../../../errors/index.js";
import type * as Hume from "../../../index.js";

export class UnprocessableEntityError extends errors.HumeError {
    constructor(body: Hume.empathicVoice.HttpValidationError, rawResponse?: core.RawResponse) {
        super({
            message: "UnprocessableEntityError",
            statusCode: 422,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }

        this.name = this.constructor.name;
    }
}

================================================================================
// File: src/api/resources/empathicVoice/errors/index.ts
================================================================================
export * from "./BadRequestError.js";
export * from "./UnprocessableEntityError.js";

================================================================================
// File: src/api/resources/empathicVoice/index.ts
================================================================================
export * from "./client/index.js";
export * from "./errors/index.js";
export * from "./resources/index.js";
export * from "./types/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/chat/client/Client.ts
================================================================================
/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
import type { BaseClientOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import * as serializers from "../../../../../../serialization/index.js";
import type * as Hume from "../../../../../index.js";
import { mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import { ChatSocket } from "./Socket.js";

export declare namespace ChatClient {
    export type Options = BaseClientOptions;

    export interface ConnectArgs {
        accessToken?: string;
        allowConnection?: boolean;
        configId?: string;
        /** Accepts both string and number for backward compatibility */
        configVersion?: string | number;
        eventLimit?: number;
        resumedChatGroupId?: string;
        verboseTranscription?: boolean;
        /** @deprecated Use sessionSettings.voiceId instead */
        voiceId?: string;
        apiKey?: string;
        sessionSettings?: Hume.empathicVoice.ConnectSessionSettings;
        /** Extra query parameters sent at WebSocket connection  for backward compatibility */
        queryParams?: Record<string, string | string[] | object | object[]>;
        /** Arbitrary headers to send with the websocket connect request. */
        headers?: Record<string, string>;
        debug?: boolean;
        reconnectAttempts?: number;
    }
}

export class ChatClient {
    protected readonly _options: NormalizedClientOptions<ChatClient.Options>;

    constructor(options: ChatClient.Options = {}) {
        this._options = normalizeClientOptions(options);
    }

    public connect(args: ChatClient.ConnectArgs = {}): ChatSocket {
        const {
            accessToken,
            allowConnection,
            configId,
            configVersion,
            eventLimit,
            resumedChatGroupId,
            verboseTranscription,
            voiceId,
            apiKey,
            sessionSettings,
            queryParams,
            headers,
            debug,
            reconnectAttempts,
        } = args;

        const _queryParams: Record<string, string | string[] | object | object[] | null | undefined> = {
            access_token: accessToken,
            allow_connection: allowConnection != null ? (allowConnection ? "true" : "false") : undefined,
            config_id: configId,
            config_version:
                configVersion != null
                    ? typeof configVersion === "number"
                        ? configVersion.toString()
                        : configVersion
                    : undefined,
            event_limit: eventLimit != null ? eventLimit.toString() : undefined,
            resumed_chat_group_id: resumedChatGroupId,
            verbose_transcription: verboseTranscription != null ? verboseTranscription.toString() : undefined,
            voice_id: voiceId,
            api_key: apiKey,
            session_settings:
                sessionSettings != null
                    ? serializers.empathicVoice.ConnectSessionSettings.jsonOrThrow(sessionSettings, {
                          unrecognizedObjectKeys: "passthrough",
                          allowUnrecognizedUnionMembers: true,
                          allowUnrecognizedEnumValues: true,
                          omitUndefined: true,
                          breadcrumbsPrefix: ["request", "sessionSettings"],
                      })
                    : undefined,
        };

        // Merge in any additional query parameters
        if (queryParams != null) {
            for (const [name, value] of Object.entries(queryParams)) {
                _queryParams[name] = value;
            }
        }

        const _headers: Record<string, unknown> = mergeOnlyDefinedHeaders({
            ...this._getCustomAuthorizationHeaders(),
            ...headers,
        });
        const socket = new core.ReconnectingWebSocket({
            url: core.url.join(
                core.Supplier.get(this._options.baseUrl) ??
                    (core.Supplier.get(this._options.environment) ?? environments.HumeEnvironment.Prod).evi,
                "/chat",
            ),
            protocols: [],
            queryParameters: _queryParams,
            headers: _headers,
            options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
        });

        return new ChatSocket({ socket });
    }

    protected _getCustomAuthorizationHeaders(): Record<string, string | null | undefined> {
        const apiKeyValue = core.Supplier.get(this._options.apiKey);
        // This `authHeaderValue` is manually added as if you don't provide it it will
        // be omitted from the headers which means it won't reach the logic in ws.ts that
        // extracts values from the headers and adds them to query parameters.
        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
    }
}

================================================================================
// File: src/api/resources/empathicVoice/resources/chat/client/Client.ts.diff
================================================================================
diff --git a/src/api/resources/empathicVoice/resources/chat/client/Client.ts b/src/api/resources/empathicVoice/resources/chat/client/Client.ts
index b67a3a3..6a5e46a 100644
--- a/src/api/resources/empathicVoice/resources/chat/client/Client.ts
+++ b/src/api/resources/empathicVoice/resources/chat/client/Client.ts
@@ -1,36 +1,26 @@
-/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
+// This file was auto-generated by Fern from our API Definition.
 
-import * as environments from "../../../../../../environments.js";
+import type { BaseClientOptions } from "../../../../../../BaseClient.js";
+import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
 import * as core from "../../../../../../core/index.js";
-import * as Hume from "../../../../../index.js";
-import { mergeOnlyDefinedHeaders, mergeHeaders } from "../../../../../../core/headers.js";
+import * as environments from "../../../../../../environments.js";
 import * as serializers from "../../../../../../serialization/index.js";
+import type * as Hume from "../../../../../index.js";
 import { ChatSocket } from "./Socket.js";
 
 export declare namespace ChatClient {
-    export interface Options {
-        environment?: core.Supplier<environments.HumeEnvironment | environments.HumeEnvironmentUrls>;
-        /** Specify a custom URL to connect the client to. */
-        baseUrl?: core.Supplier<string>;
-        apiKey?: core.Supplier<string | undefined>;
-        /** Additional headers to include in requests. */
-        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
-    }
+    export type Options = BaseClientOptions;
 
     export interface ConnectArgs {
-        accessToken?: string | undefined;
-        configId?: string | undefined;
-        configVersion?: string | number | undefined;
-        eventLimit?: number | undefined;
-        resumedChatGroupId?: string | undefined;
-        verboseTranscription?: boolean | undefined;
-        allowConnection?: boolean | undefined;
-        /** @deprecated Use sessionSettings.voiceId instead */
-        voiceId?: string | undefined;
-        apiKey?: string | undefined;
-        sessionSettings?: Hume.empathicVoice.ConnectSessionSettings;
-        /** Extra query parameters sent at WebSocket connection */
-        queryParams?: Record<string, string | string[] | object | object[]>;
+        accessToken?: string;
+        allowConnection?: boolean;
+        configId?: string;
+        configVersion?: number;
+        eventLimit?: number;
+        resumedChatGroupId?: string;
+        verboseTranscription?: boolean;
+        apiKey?: string;
+        sessionSettings: Hume.empathicVoice.ConnectSessionSettings;
         /** Arbitrary headers to send with the websocket connect request. */
         headers?: Record<string, string>;
         /** Enable debug mode on the websocket. Defaults to false. */
@@ -41,97 +31,49 @@ export declare namespace ChatClient {
 }
 
 export class ChatClient {
-    protected readonly _options: ChatClient.Options;
+    protected readonly _options: NormalizedClientOptions<ChatClient.Options>;
 
-    constructor(_options: ChatClient.Options = {}) {
-        this._options = _options;
+    constructor(options: ChatClient.Options = {}) {
+        this._options = normalizeClientOptions(options);
     }
 
-    public connect(args: ChatClient.ConnectArgs = {}): ChatSocket {
+    public async connect(args: ChatClient.ConnectArgs): Promise<ChatSocket> {
         const {
             accessToken,
+            allowConnection,
             configId,
             configVersion,
             eventLimit,
             resumedChatGroupId,
             verboseTranscription,
-            voiceId,
             apiKey,
             sessionSettings,
-            queryParams,
             headers,
             debug,
             reconnectAttempts,
-            allowConnection,
         } = args;
-        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
-
-        if (accessToken != null) {
-            _queryParams["access_token"] = accessToken;
-        }
-
-        if (configId != null) {
-            _queryParams["config_id"] = configId;
-        }
-
-        if (configVersion != null) {
-            _queryParams["config_version"] =
-                typeof configVersion === "number" ? configVersion.toString() : configVersion;
-        }
-
-        if (eventLimit != null) {
-            _queryParams["event_limit"] = eventLimit.toString();
-        }
-
-        if (resumedChatGroupId != null) {
-            _queryParams["resumed_chat_group_id"] = resumedChatGroupId;
-        }
-
-        if (verboseTranscription != null) {
-            _queryParams["verbose_transcription"] = verboseTranscription.toString();
-        }
-
-        if (voiceId != null) {
-            _queryParams["voice_id"] = voiceId;
-        }
-
-        if (apiKey != null) {
-            _queryParams["api_key"] = apiKey;
-        }
-
-        if (allowConnection != null) {
-            _queryParams["allow_connection"] = allowConnection === true ? "true" : "false";
-        }
-
-        if (sessionSettings != null) {
-            _queryParams["session_settings"] = serializers.empathicVoice.ConnectSessionSettings.jsonOrThrow(
-                sessionSettings,
-                {
-                    unrecognizedObjectKeys: "passthrough",
-                    allowUnrecognizedUnionMembers: true,
-                    allowUnrecognizedEnumValues: true,
-                    omitUndefined: true,
-                    breadcrumbsPrefix: ["request", "sessionSettings"],
-                },
-            );
-        }
-
-        // Merge in any additional query parameters
-        if (queryParams != null) {
-            for (const [name, value] of Object.entries(queryParams)) {
-                _queryParams[name] = value;
-            }
-        }
-
-        let _headers: Record<string, unknown> = mergeHeaders(
-            mergeOnlyDefinedHeaders({ ...this._getCustomAuthorizationHeaders() }),
-            headers,
-        );
-
+        const _queryParams: Record<string, unknown> = {
+            access_token: accessToken,
+            allow_connection: allowConnection,
+            config_id: configId,
+            config_version: configVersion,
+            event_limit: eventLimit,
+            resumed_chat_group_id: resumedChatGroupId,
+            verbose_transcription: verboseTranscription,
+            api_key: apiKey,
+            session_settings: serializers.empathicVoice.ConnectSessionSettings.jsonOrThrow(sessionSettings, {
+                unrecognizedObjectKeys: "passthrough",
+                allowUnrecognizedUnionMembers: true,
+                allowUnrecognizedEnumValues: true,
+                omitUndefined: true,
+                breadcrumbsPrefix: ["request", "sessionSettings"],
+            }),
+        };
+        const _headers: Record<string, unknown> = { ...headers };
         const socket = new core.ReconnectingWebSocket({
             url: core.url.join(
-                core.Supplier.get(this._options["baseUrl"]) ??
-                    (core.Supplier.get(this._options["environment"]) ?? environments.HumeEnvironment.Prod).evi,
+                (await core.Supplier.get(this._options.baseUrl)) ??
+                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).evi,
                 "/chat",
             ),
             protocols: [],
@@ -141,13 +83,4 @@ export class ChatClient {
         });
         return new ChatSocket({ socket });
     }
-
-    protected _getCustomAuthorizationHeaders(): Record<string, string | null | undefined> {
-        const apiKeyValue = core.Supplier.get(this._options.apiKey);
-        // This `authHeaderValue` is manually added as if you don't provide it it will
-        // be omitted from the headers which means it won't reach the logic in ws.ts that
-        // extracts values from the headers and adds them to query parameters.
-        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
-        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
-    }
 }

================================================================================
// File: src/api/resources/empathicVoice/resources/chat/client/Socket.ts
================================================================================
/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */

import * as core from "../../../../../../core/index.js";
import * as Hume from "../../../../../index.js";
import { PublishEvent } from "../../../../../../serialization/resources/empathicVoice/resources/chat/types/PublishEvent.js";
import { fromJson } from "../../../../../../core/json.js";
import * as serializers from "../../../../../../serialization/index.js";

export declare namespace ChatSocket {
    export interface Args {
        socket: core.ReconnectingWebSocket;
    }

    export type Response = Hume.empathicVoice.SubscribeEvent & { receivedAt: Date };
    type EventHandlers = {
        open?: () => void;
        message?: (message: Response) => void;
        close?: (event: core.CloseEvent) => void;
        error?: (error: Error) => void;
    };
}

export class ChatSocket {
    public readonly socket: core.ReconnectingWebSocket;
    protected readonly eventHandlers: ChatSocket.EventHandlers = {};
    private handleOpen: () => void = () => {
        this.eventHandlers.open?.();
    };
    private handleMessage: (event: { data: string }) => void = (event) => {
        const data = fromJson(event.data);

        const parsedResponse = serializers.empathicVoice.ChatSocketResponse.parse(data, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        if (parsedResponse.ok) {
            this.eventHandlers.message?.({
                ...parsedResponse.value,
                receivedAt: new Date(),
            });
        } else {
            this.eventHandlers.error?.(new Error("Received unknown message type"));
        }
    };
    private handleClose: (event: core.CloseEvent) => void = (event) => {
        this.eventHandlers.close?.(event);
    };
    private handleError: (event: core.ErrorEvent) => void = (event) => {
        const message = event.message;
        this.eventHandlers.error?.(new Error(message));
    };

    constructor(args: ChatSocket.Args) {
        this.socket = args.socket;
        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);
    }

    /** The current state of the connection; this is one of the readyState constants. */
    get readyState(): number {
        return this.socket.readyState;
    }

    /**
     * @param event - The event to attach to.
     * @param callback - The callback to run when the event is triggered.
     * Usage:
     * ```typescript
     * this.on('open', () => {
     *     console.log('The websocket is open');
     * });
     * ```
     */
    public on<T extends keyof ChatSocket.EventHandlers>(event: T, callback: ChatSocket.EventHandlers[T]): void {
        this.eventHandlers[event] = callback;
    }

    public sendPublish(message: Hume.empathicVoice.PublishEvent): void {
        this.assertSocketIsOpen();
        const jsonPayload = PublishEvent.jsonOrThrow(message, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        this.socket.send(JSON.stringify(jsonPayload));
    }

    /**
     * Send audio input
     */
    public sendAudioInput(message: Omit<Hume.empathicVoice.AudioInput, "type">): void {
        this.sendPublish({
            type: "audio_input",
            ...message,
        });
    }

    /**
     * Send session settings
     */
    public sendSessionSettings(message: Omit<Hume.empathicVoice.SessionSettings, "type"> = {}): void {
        this.sendPublish({
            type: "session_settings",
            ...message,
        });
    }

    /**
     * Send assistant input
     */
    public sendAssistantInput(message: Omit<Hume.empathicVoice.AssistantInput, "type">): void {
        this.sendPublish({
            type: "assistant_input",
            ...message,
        });
    }

    /**
     * Send pause assistant message
     */
    public pauseAssistant(message: Omit<Hume.empathicVoice.PauseAssistantMessage, "type"> = {}): void {
        this.sendPublish({
            type: "pause_assistant_message",
            ...message,
        });
    }

    /**
     * Send resume assistant message
     */
    public resumeAssistant(message: Omit<Hume.empathicVoice.ResumeAssistantMessage, "type"> = {}): void {
        this.sendPublish({
            type: "resume_assistant_message",
            ...message,
        });
    }

    /**
     * Send tool response message
     */
    public sendToolResponseMessage(message: Omit<Hume.empathicVoice.ToolResponseMessage, "type">): void {
        this.sendPublish({
            type: "tool_response",
            ...message,
        });
    }

    /**
     * Send tool error message
     */
    public sendToolErrorMessage(message: Omit<Hume.empathicVoice.ToolErrorMessage, "type">): void {
        this.sendPublish({
            type: "tool_error",
            ...message,
        });
    }

    /**
     * Send text input
     */
    public sendUserInput(text: string): void {
        this.sendPublish({
            type: "user_input",
            text,
        });
    }

    /** Connect to the websocket and register event handlers. */
    public connect(): ChatSocket {
        this.socket.reconnect();

        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);

        return this;
    }

    /** Close the websocket and unregister event handlers. */
    public close(): void {
        this.socket.close();

        this.handleClose({ code: 1000 } as CloseEvent);

        this.socket.removeEventListener("open", this.handleOpen);
        this.socket.removeEventListener("message", this.handleMessage);
        this.socket.removeEventListener("close", this.handleClose);
        this.socket.removeEventListener("error", this.handleError);
    }

    /** Returns a promise that resolves when the websocket is open. */
    public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
        if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
            return this.socket;
        }

        return new Promise((resolve, reject) => {
            this.socket.addEventListener("open", () => {
                resolve(this.socket);
            });

            this.socket.addEventListener("error", (event: unknown) => {
                reject(event);
            });
        });
    }

    /**
     * @deprecated Use waitForOpen() instead
     */
    public async tillSocketOpen(): Promise<core.ReconnectingWebSocket> {
        return this.waitForOpen();
    }

    /** Asserts that the websocket is open. */
    private assertSocketIsOpen(): void {
        if (!this.socket) {
            throw new Error("Socket is not connected.");
        }

        if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
            throw new Error("Socket is not open.");
        }
    }

    /** Send a binary payload to the websocket. */
    protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
        this.socket.send(payload);
    }
}

================================================================================
// File: src/api/resources/empathicVoice/resources/chat/client/Socket.ts.diff
================================================================================
diff --git a/src/api/resources/empathicVoice/resources/chat/client/Socket.ts b/src/api/resources/empathicVoice/resources/chat/client/Socket.ts
index a55c7b5..0f2f2a5 100644
--- a/src/api/resources/empathicVoice/resources/chat/client/Socket.ts
+++ b/src/api/resources/empathicVoice/resources/chat/client/Socket.ts
@@ -1,17 +1,17 @@
-/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
+// This file was auto-generated by Fern from our API Definition.
 
 import * as core from "../../../../../../core/index.js";
-import * as Hume from "../../../../../index.js";
-import { PublishEvent } from "../../../../../../serialization/resources/empathicVoice/resources/chat/types/PublishEvent.js";
 import { fromJson } from "../../../../../../core/json.js";
 import * as serializers from "../../../../../../serialization/index.js";
+import { PublishEvent } from "../../../../../../serialization/resources/empathicVoice/resources/chat/types/PublishEvent.js";
+import type * as Hume from "../../../../../index.js";
 
 export declare namespace ChatSocket {
     export interface Args {
         socket: core.ReconnectingWebSocket;
     }
 
-    export type Response = Hume.empathicVoice.SubscribeEvent & { receivedAt: Date };
+    export type Response = Hume.empathicVoice.SubscribeEvent;
     type EventHandlers = {
         open?: () => void;
         message?: (message: Response) => void;
@@ -37,10 +37,7 @@ export class ChatSocket {
             omitUndefined: true,
         });
         if (parsedResponse.ok) {
-            this.eventHandlers.message?.({
-                ...parsedResponse.value,
-                receivedAt: new Date(),
-            });
+            this.eventHandlers.message?.(parsedResponse.value);
         } else {
             this.eventHandlers.error?.(new Error("Received unknown message type"));
         }
@@ -92,86 +89,6 @@ export class ChatSocket {
         this.socket.send(JSON.stringify(jsonPayload));
     }
 
-    /**
-     * Send audio input
-     */
-    public sendAudioInput(message: Omit<Hume.empathicVoice.AudioInput, "type">): void {
-        this.sendPublish({
-            type: "audio_input",
-            ...message,
-        });
-    }
-
-    /**
-     * Send session settings
-     */
-    public sendSessionSettings(message: Omit<Hume.empathicVoice.SessionSettings, "type"> = {}): void {
-        this.sendPublish({
-            type: "session_settings",
-            ...message,
-        });
-    }
-
-    /**
-     * Send assistant input
-     */
-    public sendAssistantInput(message: Omit<Hume.empathicVoice.AssistantInput, "type">): void {
-        this.sendPublish({
-            type: "assistant_input",
-            ...message,
-        });
-    }
-
-    /**
-     * Send pause assistant message
-     */
-    public pauseAssistant(message: Omit<Hume.empathicVoice.PauseAssistantMessage, "type"> = {}): void {
-        this.sendPublish({
-            type: "pause_assistant_message",
-            ...message,
-        });
-    }
-
-    /**
-     * Send resume assistant message
-     */
-    public resumeAssistant(message: Omit<Hume.empathicVoice.ResumeAssistantMessage, "type"> = {}): void {
-        this.sendPublish({
-            type: "resume_assistant_message",
-            ...message,
-        });
-    }
-
-    /**
-     * Send tool response message
-     */
-    public sendToolResponseMessage(message: Omit<Hume.empathicVoice.ToolResponseMessage, "type">): void {
-        this.sendPublish({
-            type: "tool_response",
-            ...message,
-        });
-    }
-
-    /**
-     * Send tool error message
-     */
-    public sendToolErrorMessage(message: Omit<Hume.empathicVoice.ToolErrorMessage, "type">): void {
-        this.sendPublish({
-            type: "tool_error",
-            ...message,
-        });
-    }
-
-    /**
-     * Send text input
-     */
-    public sendUserInput(text: string): void {
-        this.sendPublish({
-            type: "user_input",
-            text,
-        });
-    }
-
     /** Connect to the websocket and register event handlers. */
     public connect(): ChatSocket {
         this.socket.reconnect();
@@ -213,13 +130,6 @@ export class ChatSocket {
         });
     }
 
-    /**
-     * @deprecated Use waitForOpen() instead
-     */
-    public async tillSocketOpen(): Promise<core.ReconnectingWebSocket> {
-        return this.waitForOpen();
-    }
-
     /** Asserts that the websocket is open. */
     private assertSocketIsOpen(): void {
         if (!this.socket) {

================================================================================
// File: src/api/resources/empathicVoice/resources/chat/client/index.ts
================================================================================
/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
export { ChatSocket } from "./Socket.js";
export { ChatClient as Chat } from "./Client.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/chat/client/index.ts.diff
================================================================================
diff --git a/src/api/resources/empathicVoice/resources/chat/client/index.ts b/src/api/resources/empathicVoice/resources/chat/client/index.ts
index ff59f82..cb0ff5c 100644
--- a/src/api/resources/empathicVoice/resources/chat/client/index.ts
+++ b/src/api/resources/empathicVoice/resources/chat/client/index.ts
@@ -1,3 +1 @@
-/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
-export { ChatSocket } from "./Socket.js";
-export { ChatClient as Chat } from "./Client.js";
+export {};

================================================================================
// File: src/api/resources/empathicVoice/resources/chat/index.ts
================================================================================
export * from "./types/index.js";
export * from "./client/index.js";
/**
 * @deprecated Use `Hume.empathicVoice.SubscribeEvent` instead.
 * This type alias will be removed in a future version.
 */
export type { SubscribeEvent } from "./types/SubscribeEvent.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/chat/index.ts.diff
================================================================================
diff --git a/src/api/resources/empathicVoice/resources/chat/index.ts b/src/api/resources/empathicVoice/resources/chat/index.ts
index a2f33dc..d9adb1a 100644
--- a/src/api/resources/empathicVoice/resources/chat/index.ts
+++ b/src/api/resources/empathicVoice/resources/chat/index.ts
@@ -1,7 +1,2 @@
-export * from "./types/index.js";
 export * from "./client/index.js";
-/**
- * @deprecated Use `Hume.empathicVoice.SubscribeEvent` instead.
- * This type alias will be removed in a future version.
- */
-export type { SubscribeEvent } from "./types/SubscribeEvent.js";
+export * from "./types/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/chat/types/PublishEvent.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type PublishEvent =
    | Hume.empathicVoice.AudioInput
    | Hume.empathicVoice.SessionSettings
    | Hume.empathicVoice.UserInput
    | Hume.empathicVoice.AssistantInput
    | Hume.empathicVoice.ToolResponseMessage
    | Hume.empathicVoice.ToolErrorMessage
    | Hume.empathicVoice.PauseAssistantMessage
    | Hume.empathicVoice.ResumeAssistantMessage;

================================================================================
// File: src/api/resources/empathicVoice/resources/chat/types/SubscribeEvent.ts
================================================================================
/**
 * This file was manually added to provide backward compatibility.
 *
 * @deprecated Use `Hume.empathicVoice.SubscribeEvent` instead.
 * This type alias will be removed in a future version.
 */

import type { SubscribeEvent as NewSubscribeEvent } from "../../../types/SubscribeEvent.js";

/**
 * @deprecated Use `Hume.empathicVoice.SubscribeEvent` instead.
 * This type alias will be removed in a future version.
 */
export type SubscribeEvent = NewSubscribeEvent;

================================================================================
// File: src/api/resources/empathicVoice/resources/chat/types/index.ts
================================================================================
export * from "./PublishEvent.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/chatGroups/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace ChatGroupsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class ChatGroupsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ChatGroupsClient.Options>;

    constructor(options: ChatGroupsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * @param {Hume.empathicVoice.ChatGroupsListChatGroupsRequest} request
     * @param {ChatGroupsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chatGroups.listChatGroups({
     *         pageNumber: 0,
     *         pageSize: 1,
     *         ascendingOrder: true,
     *         configId: "1b60e1a0-cc59-424a-8d2c-189d354db3f3"
     *     })
     */
    public async listChatGroups(
        request: Hume.empathicVoice.ChatGroupsListChatGroupsRequest = {},
        requestOptions?: ChatGroupsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnChatGroup, Hume.empathicVoice.ReturnPagedChatGroups>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ChatGroupsListChatGroupsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedChatGroups>> => {
                const { pageNumber, pageSize, ascendingOrder, configId } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    ascending_order: ascendingOrder,
                    config_id: configId,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/evi/chat_groups",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedChatGroups.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chat_groups");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnChatGroup, Hume.empathicVoice.ReturnPagedChatGroups>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.chatGroupsPage ?? []).length > 0,
            getItems: (response) => response?.chatGroupsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {string} id - Identifier for a chat. Formatted as a UUID.
     * @param {Hume.empathicVoice.ChatGroupsGetChatGroupRequest} request
     * @param {ChatGroupsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chatGroups.getChatGroup("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
     *         pageNumber: 0,
     *         pageSize: 1,
     *         ascendingOrder: true
     *     })
     */
    public getChatGroup(
        id: string,
        request: Hume.empathicVoice.ChatGroupsGetChatGroupRequest = {},
        requestOptions?: ChatGroupsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnChatGroupPagedChats> {
        return core.HttpResponsePromise.fromPromise(this.__getChatGroup(id, request, requestOptions));
    }

    private async __getChatGroup(
        id: string,
        request: Hume.empathicVoice.ChatGroupsGetChatGroupRequest = {},
        requestOptions?: ChatGroupsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatGroupPagedChats>> {
        const { status, pageSize, pageNumber, ascendingOrder } = request;
        const _queryParams: Record<string, unknown> = {
            status,
            page_size: pageSize,
            page_number: pageNumber,
            ascending_order: ascendingOrder,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/chat_groups/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnChatGroupPagedChats.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chat_groups/{id}");
    }

    /**
     * @param {string} id - Identifier for a chat. Formatted as a UUID.
     * @param {Hume.empathicVoice.ChatGroupsGetAudioRequest} request
     * @param {ChatGroupsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chatGroups.getAudio("369846cf-6ad5-404d-905e-a8acb5cdfc78", {
     *         pageNumber: 0,
     *         pageSize: 10,
     *         ascendingOrder: true
     *     })
     */
    public getAudio(
        id: string,
        request: Hume.empathicVoice.ChatGroupsGetAudioRequest = {},
        requestOptions?: ChatGroupsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructions> {
        return core.HttpResponsePromise.fromPromise(this.__getAudio(id, request, requestOptions));
    }

    private async __getAudio(
        id: string,
        request: Hume.empathicVoice.ChatGroupsGetAudioRequest = {},
        requestOptions?: ChatGroupsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructions>> {
        const { pageNumber, pageSize, ascendingOrder } = request;
        const _queryParams: Record<string, unknown> = {
            page_number: pageNumber,
            page_size: pageSize,
            ascending_order: ascendingOrder,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/chat_groups/${core.url.encodePathParam(id)}/audio`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnChatGroupPagedAudioReconstructions.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v0/evi/chat_groups/{id}/audio",
        );
    }

    /**
     * @param {string} id - Identifier for a chat. Formatted as a UUID.
     * @param {Hume.empathicVoice.ChatGroupsListChatGroupEventsRequest} request
     * @param {ChatGroupsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chatGroups.listChatGroupEvents("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
     *         pageNumber: 0,
     *         pageSize: 3,
     *         ascendingOrder: true
     *     })
     */
    public async listChatGroupEvents(
        id: string,
        request: Hume.empathicVoice.ChatGroupsListChatGroupEventsRequest = {},
        requestOptions?: ChatGroupsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnChatEvent, Hume.empathicVoice.ReturnChatGroupPagedEvents>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ChatGroupsListChatGroupEventsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatGroupPagedEvents>> => {
                const { pageSize, pageNumber, ascendingOrder } = request;
                const _queryParams: Record<string, unknown> = {
                    page_size: pageSize,
                    page_number: pageNumber,
                    ascending_order: ascendingOrder,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        `v0/evi/chat_groups/${core.url.encodePathParam(id)}/events`,
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnChatGroupPagedEvents.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(
                    _response.error,
                    _response.rawResponse,
                    "GET",
                    "/v0/evi/chat_groups/{id}/events",
                );
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnChatEvent, Hume.empathicVoice.ReturnChatGroupPagedEvents>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.eventsPage ?? []).length > 0,
            getItems: (response) => response?.eventsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }
}

================================================================================
// File: src/api/resources/empathicVoice/resources/chatGroups/client/index.ts
================================================================================
export * from "./requests/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/chatGroups/client/requests/ChatGroupsGetAudioRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 10,
 *         ascendingOrder: true
 *     }
 */
export interface ChatGroupsGetAudioRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
    ascendingOrder?: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/chatGroups/client/requests/ChatGroupsGetChatGroupRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 1,
 *         ascendingOrder: true
 *     }
 */
export interface ChatGroupsGetChatGroupRequest {
    /** Chat status to apply to the chat. String from the ChatStatus enum. */
    status?: string;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
    ascendingOrder?: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/chatGroups/client/requests/ChatGroupsListChatGroupEventsRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 3,
 *         ascendingOrder: true
 *     }
 */
export interface ChatGroupsListChatGroupEventsRequest {
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
    ascendingOrder?: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/chatGroups/client/requests/ChatGroupsListChatGroupsRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 1,
 *         ascendingOrder: true,
 *         configId: "1b60e1a0-cc59-424a-8d2c-189d354db3f3"
 *     }
 */
export interface ChatGroupsListChatGroupsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
    ascendingOrder?: boolean;
    /** Filter chatgroups to only include chats that used this config in their most recent chat. */
    configId?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/chatGroups/client/requests/index.ts
================================================================================
export type { ChatGroupsGetAudioRequest } from "./ChatGroupsGetAudioRequest.js";
export type { ChatGroupsGetChatGroupRequest } from "./ChatGroupsGetChatGroupRequest.js";
export type { ChatGroupsListChatGroupEventsRequest } from "./ChatGroupsListChatGroupEventsRequest.js";
export type { ChatGroupsListChatGroupsRequest } from "./ChatGroupsListChatGroupsRequest.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/chatGroups/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/chats/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace ChatsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class ChatsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ChatsClient.Options>;

    constructor(options: ChatsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * @param {Hume.empathicVoice.ChatsListChatsRequest} request
     * @param {ChatsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chats.listChats({
     *         pageNumber: 0,
     *         pageSize: 1,
     *         ascendingOrder: true
     *     })
     */
    public async listChats(
        request: Hume.empathicVoice.ChatsListChatsRequest = {},
        requestOptions?: ChatsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnChat, Hume.empathicVoice.ReturnPagedChats>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ChatsListChatsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedChats>> => {
                const { pageNumber, pageSize, ascendingOrder, configId, status } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    ascending_order: ascendingOrder,
                    config_id: configId,
                    status,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/evi/chats",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedChats.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chats");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnChat, Hume.empathicVoice.ReturnPagedChats>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.chatsPage ?? []).length > 0,
            getItems: (response) => response?.chatsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {string} id - Identifier for a chat. Formatted as a UUID.
     * @param {Hume.empathicVoice.ChatsListChatEventsRequest} request
     * @param {ChatsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chats.listChatEvents("470a49f6-1dec-4afe-8b61-035d3b2d63b0", {
     *         pageNumber: 0,
     *         pageSize: 3,
     *         ascendingOrder: true
     *     })
     */
    public async listChatEvents(
        id: string,
        request: Hume.empathicVoice.ChatsListChatEventsRequest = {},
        requestOptions?: ChatsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnChatEvent, Hume.empathicVoice.ReturnChatPagedEvents>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ChatsListChatEventsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatPagedEvents>> => {
                const { pageSize, pageNumber, ascendingOrder } = request;
                const _queryParams: Record<string, unknown> = {
                    page_size: pageSize,
                    page_number: pageNumber,
                    ascending_order: ascendingOrder,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        `v0/evi/chats/${core.url.encodePathParam(id)}`,
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnChatPagedEvents.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chats/{id}");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnChatEvent, Hume.empathicVoice.ReturnChatPagedEvents>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.eventsPage ?? []).length > 0,
            getItems: (response) => response?.eventsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {string} id - Identifier for a chat. Formatted as a UUID.
     * @param {ChatsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.chats.getAudio("470a49f6-1dec-4afe-8b61-035d3b2d63b0")
     */
    public getAudio(
        id: string,
        requestOptions?: ChatsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnChatAudioReconstruction> {
        return core.HttpResponsePromise.fromPromise(this.__getAudio(id, requestOptions));
    }

    private async __getAudio(
        id: string,
        requestOptions?: ChatsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatAudioReconstruction>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/chats/${core.url.encodePathParam(id)}/audio`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnChatAudioReconstruction.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chats/{id}/audio");
    }
}

================================================================================
// File: src/api/resources/empathicVoice/resources/chats/client/index.ts
================================================================================
export * from "./requests/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/chats/client/requests/ChatsListChatEventsRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 3,
 *         ascendingOrder: true
 *     }
 */
export interface ChatsListChatEventsRequest {
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
    ascendingOrder?: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/chats/client/requests/ChatsListChatsRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 1,
 *         ascendingOrder: true
 *     }
 */
export interface ChatsListChatsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
    ascendingOrder?: boolean;
    /** Filter to only include chats that used this config. */
    configId?: string;
    /** Chat status to apply to the chat. String from the ChatStatus enum. */
    status?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/chats/client/requests/index.ts
================================================================================
export type { ChatsListChatEventsRequest } from "./ChatsListChatEventsRequest.js";
export type { ChatsListChatsRequest } from "./ChatsListChatsRequest.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/chats/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/configs/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace ConfigsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class ConfigsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ConfigsClient.Options>;

    constructor(options: ConfigsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * @param {Hume.empathicVoice.ConfigsListConfigsRequest} request
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.listConfigs({
     *         pageNumber: 0,
     *         pageSize: 1
     *     })
     */
    public async listConfigs(
        request: Hume.empathicVoice.ConfigsListConfigsRequest = {},
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnConfig, Hume.empathicVoice.ReturnPagedConfigs>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ConfigsListConfigsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedConfigs>> => {
                const { pageNumber, pageSize, restrictToMostRecent, name } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    restrict_to_most_recent: restrictToMostRecent,
                    name,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/evi/configs",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedConfigs.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/configs");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnConfig, Hume.empathicVoice.ReturnPagedConfigs>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.configsPage ?? []).length > 0,
            getItems: (response) => response?.configsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {Hume.empathicVoice.PostedConfig} request
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.createConfig({
     *         name: "Weather Assistant Config",
     *         prompt: {
     *             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
     *             version: 0
     *         },
     *         eviVersion: "3",
     *         voice: {
     *             provider: "HUME_AI",
     *             name: "Ava Song"
     *         },
     *         languageModel: {
     *             modelProvider: "ANTHROPIC",
     *             modelResource: "claude-3-7-sonnet-latest",
     *             temperature: 1
     *         },
     *         eventMessages: {
     *             onNewChat: {
     *                 enabled: false,
     *                 text: ""
     *             },
     *             onInactivityTimeout: {
     *                 enabled: false,
     *                 text: ""
     *             },
     *             onMaxDurationTimeout: {
     *                 enabled: false,
     *                 text: ""
     *             }
     *         }
     *     })
     */
    public createConfig(
        request: Hume.empathicVoice.PostedConfig,
        requestOptions?: ConfigsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnConfig> {
        return core.HttpResponsePromise.fromPromise(this.__createConfig(request, requestOptions));
    }

    private async __createConfig(
        request: Hume.empathicVoice.PostedConfig,
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnConfig>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/evi/configs",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedConfig.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnConfig.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/configs");
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {Hume.empathicVoice.ConfigsListConfigVersionsRequest} request
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.listConfigVersions("1b60e1a0-cc59-424a-8d2c-189d354db3f3")
     */
    public async listConfigVersions(
        id: string,
        request: Hume.empathicVoice.ConfigsListConfigVersionsRequest = {},
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnConfig, Hume.empathicVoice.ReturnPagedConfigs>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ConfigsListConfigVersionsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedConfigs>> => {
                const { pageNumber, pageSize, restrictToMostRecent } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    restrict_to_most_recent: restrictToMostRecent,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        `v0/evi/configs/${core.url.encodePathParam(id)}`,
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedConfigs.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/configs/{id}");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnConfig, Hume.empathicVoice.ReturnPagedConfigs>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.configsPage ?? []).length > 0,
            getItems: (response) => response?.configsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {Hume.empathicVoice.PostedConfigVersion} request
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.createConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", {
     *         versionDescription: "This is an updated version of the Weather Assistant Config.",
     *         eviVersion: "3",
     *         prompt: {
     *             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
     *             version: 0
     *         },
     *         voice: {
     *             provider: "HUME_AI",
     *             name: "Ava Song"
     *         },
     *         languageModel: {
     *             modelProvider: "ANTHROPIC",
     *             modelResource: "claude-3-7-sonnet-latest",
     *             temperature: 1
     *         },
     *         ellmModel: {
     *             allowShortResponses: true
     *         },
     *         eventMessages: {
     *             onNewChat: {
     *                 enabled: false,
     *                 text: ""
     *             },
     *             onInactivityTimeout: {
     *                 enabled: false,
     *                 text: ""
     *             },
     *             onMaxDurationTimeout: {
     *                 enabled: false,
     *                 text: ""
     *             }
     *         }
     *     })
     */
    public createConfigVersion(
        id: string,
        request: Hume.empathicVoice.PostedConfigVersion,
        requestOptions?: ConfigsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnConfig> {
        return core.HttpResponsePromise.fromPromise(this.__createConfigVersion(id, request, requestOptions));
    }

    private async __createConfigVersion(
        id: string,
        request: Hume.empathicVoice.PostedConfigVersion,
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnConfig>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/configs/${core.url.encodePathParam(id)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedConfigVersion.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnConfig.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/configs/{id}");
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.deleteConfig("1b60e1a0-cc59-424a-8d2c-189d354db3f3")
     */
    public deleteConfig(id: string, requestOptions?: ConfigsClient.RequestOptions): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteConfig(id, requestOptions));
    }

    private async __deleteConfig(
        id: string,
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/configs/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v0/evi/configs/{id}");
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {Hume.empathicVoice.PostedConfigName} request
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.updateConfigName("1b60e1a0-cc59-424a-8d2c-189d354db3f3", {
     *         name: "Updated Weather Assistant Config Name"
     *     })
     */
    public updateConfigName(
        id: string,
        request: Hume.empathicVoice.PostedConfigName,
        requestOptions?: ConfigsClient.RequestOptions,
    ): core.HttpResponsePromise<string> {
        return core.HttpResponsePromise.fromPromise(this.__updateConfigName(id, request, requestOptions));
    }

    private async __updateConfigName(
        id: string,
        request: Hume.empathicVoice.PostedConfigName,
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<string>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/configs/${core.url.encodePathParam(id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedConfigName.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "text",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as string, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/v0/evi/configs/{id}");
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {number} version - Version number for a config. Version numbers should be integers.
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.getConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1)
     */
    public getConfigVersion(
        id: string,
        version: number,
        requestOptions?: ConfigsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnConfig> {
        return core.HttpResponsePromise.fromPromise(this.__getConfigVersion(id, version, requestOptions));
    }

    private async __getConfigVersion(
        id: string,
        version: number,
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnConfig>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/configs/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnConfig.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v0/evi/configs/{id}/version/{version}",
        );
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {number} version - Version number for a config. Version numbers should be integers.
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.deleteConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1)
     */
    public deleteConfigVersion(
        id: string,
        version: number,
        requestOptions?: ConfigsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteConfigVersion(id, version, requestOptions));
    }

    private async __deleteConfigVersion(
        id: string,
        version: number,
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/configs/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/v0/evi/configs/{id}/version/{version}",
        );
    }

    /**
     * @param {string} id - Identifier for a config. Formatted as a UUID.
     * @param {number} version - Version number for a config. Version numbers should be integers.
     * @param {Hume.empathicVoice.PostedConfigVersionDescription} request
     * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.configs.updateConfigDescription("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1, {
     *         versionDescription: "This is an updated version_description."
     *     })
     */
    public updateConfigDescription(
        id: string,
        version: number,
        request: Hume.empathicVoice.PostedConfigVersionDescription = {},
        requestOptions?: ConfigsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnConfig> {
        return core.HttpResponsePromise.fromPromise(
            this.__updateConfigDescription(id, version, request, requestOptions),
        );
    }

    private async __updateConfigDescription(
        id: string,
        version: number,
        request: Hume.empathicVoice.PostedConfigVersionDescription = {},
        requestOptions?: ConfigsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnConfig>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/configs/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedConfigVersionDescription.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnConfig.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v0/evi/configs/{id}/version/{version}",
        );
    }
}

================================================================================
// File: src/api/resources/empathicVoice/resources/configs/client/index.ts
================================================================================
export * from "./requests/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/configs/client/requests/ConfigsListConfigVersionsRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {}
 */
export interface ConfigsListConfigVersionsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** By default, `restrict_to_most_recent` is set to true, returning only the latest version of each tool. To include all versions of each tool in the list, set `restrict_to_most_recent` to false. */
    restrictToMostRecent?: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/configs/client/requests/ConfigsListConfigsRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 1
 *     }
 */
export interface ConfigsListConfigsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** By default, `restrict_to_most_recent` is set to true, returning only the latest version of each tool. To include all versions of each tool in the list, set `restrict_to_most_recent` to false. */
    restrictToMostRecent?: boolean;
    /** Filter to only include configs with this name. */
    name?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/configs/client/requests/PostedConfig.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../index.js";

/**
 * @example
 *     {
 *         name: "Weather Assistant Config",
 *         prompt: {
 *             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 *             version: 0
 *         },
 *         eviVersion: "3",
 *         voice: {
 *             provider: "HUME_AI",
 *             name: "Ava Song"
 *         },
 *         languageModel: {
 *             modelProvider: "ANTHROPIC",
 *             modelResource: "claude-3-7-sonnet-latest",
 *             temperature: 1
 *         },
 *         eventMessages: {
 *             onNewChat: {
 *                 enabled: false,
 *                 text: ""
 *             },
 *             onInactivityTimeout: {
 *                 enabled: false,
 *                 text: ""
 *             },
 *             onMaxDurationTimeout: {
 *                 enabled: false,
 *                 text: ""
 *             }
 *         }
 *     }
 */
export interface PostedConfig {
    /** Built-in tool specification for a Config. */
    builtinTools?: (Hume.empathicVoice.PostedBuiltinTool | undefined)[];
    ellmModel?: Hume.empathicVoice.PostedEllmModel;
    eventMessages?: Hume.empathicVoice.PostedEventMessageSpecs;
    /** The version of the EVI used with this config. */
    eviVersion: string;
    languageModel?: Hume.empathicVoice.PostedLanguageModel;
    /** Name applied to all versions of a particular Config. */
    name: string;
    nudges?: Hume.empathicVoice.PostedNudgeSpec;
    prompt?: Hume.empathicVoice.PostedConfigPromptSpec;
    timeouts?: Hume.empathicVoice.PostedTimeoutSpecs;
    /** Tool specification for a Config. */
    tools?: (Hume.empathicVoice.PostedUserDefinedToolSpec | undefined)[];
    /** Description that is appended to a specific version of a Config. */
    versionDescription?: string;
    voice?: Hume.empathicVoice.VoiceRef;
    /** Webhook config specifications for each subscriber. */
    webhooks?: (Hume.empathicVoice.PostedWebhookSpec | undefined)[];
}

================================================================================
// File: src/api/resources/empathicVoice/resources/configs/client/requests/PostedConfigName.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         name: "Updated Weather Assistant Config Name"
 *     }
 */
export interface PostedConfigName {
    /** Name applied to all versions of a particular Config. */
    name: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/configs/client/requests/PostedConfigVersion.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../index.js";

/**
 * @example
 *     {
 *         versionDescription: "This is an updated version of the Weather Assistant Config.",
 *         eviVersion: "3",
 *         prompt: {
 *             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 *             version: 0
 *         },
 *         voice: {
 *             provider: "HUME_AI",
 *             name: "Ava Song"
 *         },
 *         languageModel: {
 *             modelProvider: "ANTHROPIC",
 *             modelResource: "claude-3-7-sonnet-latest",
 *             temperature: 1
 *         },
 *         ellmModel: {
 *             allowShortResponses: true
 *         },
 *         eventMessages: {
 *             onNewChat: {
 *                 enabled: false,
 *                 text: ""
 *             },
 *             onInactivityTimeout: {
 *                 enabled: false,
 *                 text: ""
 *             },
 *             onMaxDurationTimeout: {
 *                 enabled: false,
 *                 text: ""
 *             }
 *         }
 *     }
 */
export interface PostedConfigVersion {
    /** Built-in tool specification for a Config. */
    builtinTools?: (Hume.empathicVoice.PostedBuiltinTool | undefined)[];
    ellmModel?: Hume.empathicVoice.PostedEllmModel;
    eventMessages?: Hume.empathicVoice.PostedEventMessageSpecs;
    /** The version of the EVI used with this config. */
    eviVersion: string;
    languageModel?: Hume.empathicVoice.PostedLanguageModel;
    nudges?: Hume.empathicVoice.PostedNudgeSpec;
    prompt?: Hume.empathicVoice.PostedConfigPromptSpec;
    timeouts?: Hume.empathicVoice.PostedTimeoutSpecs;
    /** Tool specification for a Config. */
    tools?: (Hume.empathicVoice.PostedUserDefinedToolSpec | undefined)[];
    /** Description that is appended to a specific version of a Config. */
    versionDescription?: string;
    voice?: Hume.empathicVoice.VoiceRef;
    /** Webhook config specifications for each subscriber. */
    webhooks?: (Hume.empathicVoice.PostedWebhookSpec | undefined)[];
}

================================================================================
// File: src/api/resources/empathicVoice/resources/configs/client/requests/PostedConfigVersionDescription.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         versionDescription: "This is an updated version_description."
 *     }
 */
export interface PostedConfigVersionDescription {
    /** Description that is appended to a specific version of a Config. */
    versionDescription?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/configs/client/requests/index.ts
================================================================================
export type { ConfigsListConfigsRequest } from "./ConfigsListConfigsRequest.js";
export type { ConfigsListConfigVersionsRequest } from "./ConfigsListConfigVersionsRequest.js";
export type { PostedConfig } from "./PostedConfig.js";
export type { PostedConfigName } from "./PostedConfigName.js";
export type { PostedConfigVersion } from "./PostedConfigVersion.js";
export type { PostedConfigVersionDescription } from "./PostedConfigVersionDescription.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/configs/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";
import { ControlPlaneSocket } from "./Socket.js";

export declare namespace ControlPlaneClient {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}

    export interface ConnectArgs {
        chat_id: string;
        accessToken?: string | undefined;
        /** Arbitrary headers to send with the websocket connect request. */
        headers?: Record<string, string>;
        /** Enable debug mode on the websocket. Defaults to false. */
        debug?: boolean;
        /** Number of reconnect attempts. Defaults to 30. */
        reconnectAttempts?: number;
    }
}

export class ControlPlaneClient {
    protected readonly _options: ControlPlaneClient.Options;

    constructor(_options: ControlPlaneClient.Options = {}) {
        this._options = _options;
    }

    /**
     * Send a message to a specific chat.
     *
     * @param {string} chatId
     * @param {Hume.empathicVoice.ControlPlanePublishEvent} request
     * @param {ControlPlaneClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.UnprocessableEntityError}
     *
     * @example
     *     await client.empathicVoice.controlPlane.send("chat_id", {
     *         type: "session_settings"
     *     })
     */
    public send(
        chatId: string,
        request: Hume.empathicVoice.ControlPlanePublishEvent,
        requestOptions?: ControlPlaneClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__send(chatId, request, requestOptions));
    }

    private async __send(
        chatId: string,
        request: Hume.empathicVoice.ControlPlanePublishEvent,
        requestOptions?: ControlPlaneClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/chat/${core.url.encodePathParam(chatId)}/send`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.ControlPlanePublishEvent.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.empathicVoice.UnprocessableEntityError(
                        serializers.empathicVoice.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/chat/{chat_id}/send");
    }

    public async connect(args: ControlPlaneClient.ConnectArgs): Promise<ControlPlaneSocket> {
        const { chat_id, accessToken, headers, debug, reconnectAttempts } = args;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (accessToken != null) {
            _queryParams.access_token = accessToken;
        }

        const _headers: Record<string, unknown> = mergeHeaders(
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            headers,
        );
        const socket = new core.ReconnectingWebSocket({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).evi,
                `/chat/${core.url.encodePathParam(chat_id)}/connect`,
            ),
            protocols: [],
            queryParameters: _queryParams,
            headers: _headers,
            options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
        });
        return new ControlPlaneSocket({ socket });
    }
    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
        const apiKeyValue = core.Supplier.get(this._options.apiKey);
        // This `authHeaderValue` is manually added as if you don't provide it it will
        // be omitted from the headers which means it won't reach the logic in ws.ts that
        // extracts values from the headers and adds them to query parameters.
        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
    }
}

================================================================================
// File: src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts.diff
================================================================================
diff --git a/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts b/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
index 0eec869..b5d6ea0 100644
--- a/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
+++ b/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
@@ -1,7 +1,8 @@
 // This file was auto-generated by Fern from our API Definition.
 
 import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
-import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
+import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
+import { mergeHeaders } from "../../../../../../core/headers.js";
 import * as core from "../../../../../../core/index.js";
 import * as environments from "../../../../../../environments.js";
 import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
@@ -11,13 +12,13 @@ import * as Hume from "../../../../../index.js";
 import { ControlPlaneSocket } from "./Socket.js";
 
 export declare namespace ControlPlaneClient {
-    export interface Options extends BaseClientOptions {}
+    export type Options = BaseClientOptions;
 
     export interface RequestOptions extends BaseRequestOptions {}
 
     export interface ConnectArgs {
-        chat_id: string;
-        accessToken?: string | undefined;
+        chatId: string;
+        accessToken?: string;
         /** Arbitrary headers to send with the websocket connect request. */
         headers?: Record<string, string>;
         /** Enable debug mode on the websocket. Defaults to false. */
@@ -28,16 +29,16 @@ export declare namespace ControlPlaneClient {
 }
 
 export class ControlPlaneClient {
-    protected readonly _options: ControlPlaneClient.Options;
+    protected readonly _options: NormalizedClientOptionsWithAuth<ControlPlaneClient.Options>;
 
-    constructor(_options: ControlPlaneClient.Options = {}) {
-        this._options = _options;
+    constructor(options: ControlPlaneClient.Options = {}) {
+        this._options = normalizeClientOptionsWithAuth(options);
     }
 
     /**
      * Send a message to a specific chat.
      *
-     * @param {string} chatId
+     * @param {string} chat_id
      * @param {Hume.empathicVoice.ControlPlanePublishEvent} request
      * @param {ControlPlaneClient.RequestOptions} requestOptions - Request-specific configuration.
      *
@@ -49,28 +50,29 @@ export class ControlPlaneClient {
      *     })
      */
     public send(
-        chatId: string,
+        chat_id: string,
         request: Hume.empathicVoice.ControlPlanePublishEvent,
         requestOptions?: ControlPlaneClient.RequestOptions,
     ): core.HttpResponsePromise<void> {
-        return core.HttpResponsePromise.fromPromise(this.__send(chatId, request, requestOptions));
+        return core.HttpResponsePromise.fromPromise(this.__send(chat_id, request, requestOptions));
     }
 
     private async __send(
-        chatId: string,
+        chat_id: string,
         request: Hume.empathicVoice.ControlPlanePublishEvent,
         requestOptions?: ControlPlaneClient.RequestOptions,
     ): Promise<core.WithRawResponse<void>> {
+        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
+            _authRequest.headers,
             this._options?.headers,
-            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
             requestOptions?.headers,
         );
         const _response = await (this._options.fetcher ?? core.fetcher)({
             url: core.url.join(
                 (await core.Supplier.get(this._options.baseUrl)) ??
                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
-                `v0/evi/chat/${core.url.encodePathParam(chatId)}/send`,
+                `v0/evi/chat/${core.url.encodePathParam(chat_id)}/send`,
             ),
             method: "POST",
             headers: _headers,
@@ -117,21 +119,16 @@ export class ControlPlaneClient {
     }
 
     public async connect(args: ControlPlaneClient.ConnectArgs): Promise<ControlPlaneSocket> {
-        const { chat_id, accessToken, headers, debug, reconnectAttempts } = args;
-        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
-        if (accessToken != null) {
-            _queryParams.access_token = accessToken;
-        }
-
-        const _headers: Record<string, unknown> = mergeHeaders(
-            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
-            headers,
-        );
+        const { chatId, accessToken, headers, debug, reconnectAttempts } = args;
+        const _queryParams: Record<string, unknown> = {
+            access_token: accessToken,
+        };
+        const _headers: Record<string, unknown> = { ...headers };
         const socket = new core.ReconnectingWebSocket({
             url: core.url.join(
                 (await core.Supplier.get(this._options.baseUrl)) ??
                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).evi,
-                `/chat/${core.url.encodePathParam(chat_id)}/connect`,
+                `/chat/${core.url.encodePathParam(chatId)}/connect`,
             ),
             protocols: [],
             queryParameters: _queryParams,
@@ -140,12 +137,4 @@ export class ControlPlaneClient {
         });
         return new ControlPlaneSocket({ socket });
     }
-    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
-        const apiKeyValue = core.Supplier.get(this._options.apiKey);
-        // This `authHeaderValue` is manually added as if you don't provide it it will
-        // be omitted from the headers which means it won't reach the logic in ws.ts that
-        // extracts values from the headers and adds them to query parameters.
-        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
-        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
-    }
 }

================================================================================
// File: src/api/resources/empathicVoice/resources/controlPlane/client/Socket.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import * as core from "../../../../../../core/index.js";
import { fromJson } from "../../../../../../core/json.js";
import * as serializers from "../../../../../../serialization/index.js";
import { ControlPlanePublishEvent } from "../../../../../../serialization/resources/empathicVoice/types/ControlPlanePublishEvent.js";
import type * as Hume from "../../../../../index.js";

export declare namespace ControlPlaneSocket {
    export interface Args {
        socket: core.ReconnectingWebSocket;
    }

    export type Response = Hume.empathicVoice.SubscribeEvent;
    type EventHandlers = {
        open?: () => void;
        message?: (message: Response) => void;
        close?: (event: core.CloseEvent) => void;
        error?: (error: Error) => void;
    };
}

export class ControlPlaneSocket {
    public readonly socket: core.ReconnectingWebSocket;
    protected readonly eventHandlers: ControlPlaneSocket.EventHandlers = {};
    private handleOpen: () => void = () => {
        this.eventHandlers.open?.();
    };
    private handleMessage: (event: { data: string }) => void = (event) => {
        const data = fromJson(event.data);

        const parsedResponse = serializers.empathicVoice.ControlPlaneSocketResponse.parse(data, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        if (parsedResponse.ok) {
            this.eventHandlers.message?.(parsedResponse.value);
        } else {
            this.eventHandlers.error?.(new Error("Received unknown message type"));
        }
    };
    private handleClose: (event: core.CloseEvent) => void = (event) => {
        this.eventHandlers.close?.(event);
    };
    private handleError: (event: core.ErrorEvent) => void = (event) => {
        const message = event.message;
        this.eventHandlers.error?.(new Error(message));
    };

    constructor(args: ControlPlaneSocket.Args) {
        this.socket = args.socket;
        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);
    }

    /** The current state of the connection; this is one of the readyState constants. */
    get readyState(): number {
        return this.socket.readyState;
    }

    /**
     * @param event - The event to attach to.
     * @param callback - The callback to run when the event is triggered.
     * Usage:
     * ```typescript
     * this.on('open', () => {
     *     console.log('The websocket is open');
     * });
     * ```
     */
    public on<T extends keyof ControlPlaneSocket.EventHandlers>(
        event: T,
        callback: ControlPlaneSocket.EventHandlers[T],
    ): void {
        this.eventHandlers[event] = callback;
    }

    public sendPublish(message: Hume.empathicVoice.ControlPlanePublishEvent): void {
        this.assertSocketIsOpen();
        const jsonPayload = ControlPlanePublishEvent.jsonOrThrow(message, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        this.socket.send(JSON.stringify(jsonPayload));
    }

    /** Connect to the websocket and register event handlers. */
    public connect(): ControlPlaneSocket {
        this.socket.reconnect();

        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);

        return this;
    }

    /** Close the websocket and unregister event handlers. */
    public close(): void {
        this.socket.close();

        this.handleClose({ code: 1000 } as CloseEvent);

        this.socket.removeEventListener("open", this.handleOpen);
        this.socket.removeEventListener("message", this.handleMessage);
        this.socket.removeEventListener("close", this.handleClose);
        this.socket.removeEventListener("error", this.handleError);
    }

    /** Returns a promise that resolves when the websocket is open. */
    public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
        if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
            return this.socket;
        }

        return new Promise((resolve, reject) => {
            this.socket.addEventListener("open", () => {
                resolve(this.socket);
            });

            this.socket.addEventListener("error", (event: unknown) => {
                reject(event);
            });
        });
    }

    /** Asserts that the websocket is open. */
    private assertSocketIsOpen(): void {
        if (!this.socket) {
            throw new Error("Socket is not connected.");
        }

        if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
            throw new Error("Socket is not open.");
        }
    }

    /** Send a binary payload to the websocket. */
    protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
        this.socket.send(payload);
    }
}

================================================================================
// File: src/api/resources/empathicVoice/resources/controlPlane/client/index.ts
================================================================================
export {};

================================================================================
// File: src/api/resources/empathicVoice/resources/controlPlane/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/index.ts
================================================================================
export * as chat from "./chat/index.js";
export * from "./chat/types/index.js";
export * from "./chatGroups/client/requests/index.js";
export * as chatGroups from "./chatGroups/index.js";
export * from "./chats/client/requests/index.js";
export * as chats from "./chats/index.js";
export * from "./configs/client/requests/index.js";
export * as configs from "./configs/index.js";
export * as controlPlane from "./controlPlane/index.js";
export * from "./prompts/client/requests/index.js";
export * as prompts from "./prompts/index.js";
export * from "./tools/client/requests/index.js";
export * as tools from "./tools/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/prompts/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace PromptsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class PromptsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<PromptsClient.Options>;

    constructor(options: PromptsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * @param {Hume.empathicVoice.PromptsListPromptsRequest} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.listPrompts({
     *         pageNumber: 0,
     *         pageSize: 2
     *     })
     */
    public async listPrompts(
        request: Hume.empathicVoice.PromptsListPromptsRequest = {},
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnPrompt | undefined, Hume.empathicVoice.ReturnPagedPrompts>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.PromptsListPromptsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedPrompts>> => {
                const { pageNumber, pageSize, restrictToMostRecent, name } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    restrict_to_most_recent: restrictToMostRecent,
                    name,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/evi/prompts",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedPrompts.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/prompts");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnPrompt | undefined, Hume.empathicVoice.ReturnPagedPrompts>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.promptsPage ?? []).length > 0,
            getItems: (response) => response?.promptsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {Hume.empathicVoice.PostedPrompt} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.createPrompt({
     *         name: "Weather Assistant Prompt",
     *         text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>"
     *     })
     */
    public createPrompt(
        request: Hume.empathicVoice.PostedPrompt,
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__createPrompt(request, requestOptions));
    }

    private async __createPrompt(
        request: Hume.empathicVoice.PostedPrompt,
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/evi/prompts",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedPrompt.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.prompts.createPrompt.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/prompts");
    }

    /**
     * @param {string} id
     * @param {Hume.empathicVoice.PromptsListPromptVersionsRequest} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.listPromptVersions("af699d45-2985-42cc-91b9-af9e5da3bac5")
     */
    public listPromptVersions(
        id: string,
        request: Hume.empathicVoice.PromptsListPromptVersionsRequest = {},
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPagedPrompts> {
        return core.HttpResponsePromise.fromPromise(this.__listPromptVersions(id, request, requestOptions));
    }

    private async __listPromptVersions(
        id: string,
        request: Hume.empathicVoice.PromptsListPromptVersionsRequest = {},
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedPrompts>> {
        const { pageNumber, pageSize, restrictToMostRecent } = request;
        const _queryParams: Record<string, unknown> = {
            page_number: pageNumber,
            page_size: pageSize,
            restrict_to_most_recent: restrictToMostRecent,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnPagedPrompts.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/prompts/{id}");
    }

    /**
     * @param {string} id - Identifier for a prompt. Formatted as a UUID.
     * @param {Hume.empathicVoice.PostedPromptVersion} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.createPromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", {
     *         text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
     *         versionDescription: "This is an updated version of the Weather Assistant Prompt."
     *     })
     */
    public createPromptVersion(
        id: string,
        request: Hume.empathicVoice.PostedPromptVersion,
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__createPromptVersion(id, request, requestOptions));
    }

    private async __createPromptVersion(
        id: string,
        request: Hume.empathicVoice.PostedPromptVersion,
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedPromptVersion.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.prompts.createPromptVersion.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/prompts/{id}");
    }

    /**
     * @param {string} id - Identifier for a prompt. Formatted as a UUID.
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.deletePrompt("af699d45-2985-42cc-91b9-af9e5da3bac5")
     */
    public deletePrompt(id: string, requestOptions?: PromptsClient.RequestOptions): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deletePrompt(id, requestOptions));
    }

    private async __deletePrompt(
        id: string,
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v0/evi/prompts/{id}");
    }

    /**
     * @param {string} id - Identifier for a prompt. Formatted as a UUID.
     * @param {Hume.empathicVoice.PostedPromptName} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.updatePromptName("af699d45-2985-42cc-91b9-af9e5da3bac5", {
     *         name: "Updated Weather Assistant Prompt Name"
     *     })
     */
    public updatePromptName(
        id: string,
        request: Hume.empathicVoice.PostedPromptName,
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<string> {
        return core.HttpResponsePromise.fromPromise(this.__updatePromptName(id, request, requestOptions));
    }

    private async __updatePromptName(
        id: string,
        request: Hume.empathicVoice.PostedPromptName,
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<string>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedPromptName.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "text",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as string, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/v0/evi/prompts/{id}");
    }

    /**
     * @param {string} id - Identifier for a prompt. Formatted as a UUID.
     * @param {number} version - Version number for a prompt. Version numbers should be integers.
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.getPromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", 0)
     */
    public getPromptVersion(
        id: string,
        version: number,
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__getPromptVersion(id, version, requestOptions));
    }

    private async __getPromptVersion(
        id: string,
        version: number,
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.prompts.getPromptVersion.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v0/evi/prompts/{id}/version/{version}",
        );
    }

    /**
     * @param {string} id - Identifier for a prompt. Formatted as a UUID.
     * @param {number} version - Version number for a prompt. Version numbers should be integers.
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.deletePromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", 1)
     */
    public deletePromptVersion(
        id: string,
        version: number,
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deletePromptVersion(id, version, requestOptions));
    }

    private async __deletePromptVersion(
        id: string,
        version: number,
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/v0/evi/prompts/{id}/version/{version}",
        );
    }

    /**
     * @param {string} id - Identifier for a prompt. Formatted as a UUID.
     * @param {number} version - Version number for a prompt. Version numbers should be integers.
     * @param {Hume.empathicVoice.PostedPromptVersionDescription} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.updatePromptDescription("af699d45-2985-42cc-91b9-af9e5da3bac5", 1, {
     *         versionDescription: "This is an updated version_description."
     *     })
     */
    public updatePromptDescription(
        id: string,
        version: number,
        request: Hume.empathicVoice.PostedPromptVersionDescription = {},
        requestOptions?: PromptsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | undefined> {
        return core.HttpResponsePromise.fromPromise(
            this.__updatePromptDescription(id, version, request, requestOptions),
        );
    }

    private async __updatePromptDescription(
        id: string,
        version: number,
        request: Hume.empathicVoice.PostedPromptVersionDescription = {},
        requestOptions?: PromptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedPromptVersionDescription.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.prompts.updatePromptDescription.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v0/evi/prompts/{id}/version/{version}",
        );
    }
}

================================================================================
// File: src/api/resources/empathicVoice/resources/prompts/client/index.ts
================================================================================
export * from "./requests/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/prompts/client/requests/PostedPrompt.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         name: "Weather Assistant Prompt",
 *         text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>"
 *     }
 */
export interface PostedPrompt {
    /** Name applied to all versions of a particular Prompt. */
    name: string;
    /** Text used for this version of the Prompt. */
    text: string;
    /** Description that is appended to a specific version of a Prompt. */
    versionDescription?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/prompts/client/requests/PostedPromptName.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         name: "Updated Weather Assistant Prompt Name"
 *     }
 */
export interface PostedPromptName {
    /** Name applied to all versions of a particular Prompt. */
    name: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/prompts/client/requests/PostedPromptVersion.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 *         versionDescription: "This is an updated version of the Weather Assistant Prompt."
 *     }
 */
export interface PostedPromptVersion {
    /** Text used for this version of the Prompt. */
    text: string;
    /** Description that is appended to a specific version of a Prompt. */
    versionDescription?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/prompts/client/requests/PostedPromptVersionDescription.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         versionDescription: "This is an updated version_description."
 *     }
 */
export interface PostedPromptVersionDescription {
    /** Description that is appended to a specific version of a Prompt. */
    versionDescription?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/prompts/client/requests/PromptsListPromptVersionsRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {}
 */
export interface PromptsListPromptVersionsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** Only include the most recent version of each prompt in the list. */
    restrictToMostRecent?: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/prompts/client/requests/PromptsListPromptsRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 2
 *     }
 */
export interface PromptsListPromptsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** Only include the most recent version of each prompt in the list. */
    restrictToMostRecent?: boolean;
    /** Filter to only include prompts with name. */
    name?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/prompts/client/requests/index.ts
================================================================================
export type { PostedPrompt } from "./PostedPrompt.js";
export type { PostedPromptName } from "./PostedPromptName.js";
export type { PostedPromptVersion } from "./PostedPromptVersion.js";
export type { PostedPromptVersionDescription } from "./PostedPromptVersionDescription.js";
export type { PromptsListPromptsRequest } from "./PromptsListPromptsRequest.js";
export type { PromptsListPromptVersionsRequest } from "./PromptsListPromptVersionsRequest.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/prompts/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/tools/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace ToolsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class ToolsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ToolsClient.Options>;

    constructor(options: ToolsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * @param {Hume.empathicVoice.ToolsListToolsRequest} request
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.listTools({
     *         pageNumber: 0,
     *         pageSize: 2
     *     })
     */
    public async listTools(
        request: Hume.empathicVoice.ToolsListToolsRequest = {},
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<
        core.Page<Hume.empathicVoice.ReturnUserDefinedTool | undefined, Hume.empathicVoice.ReturnPagedUserDefinedTools>
    > {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ToolsListToolsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedUserDefinedTools>> => {
                const { pageNumber, pageSize, restrictToMostRecent, name } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    restrict_to_most_recent: restrictToMostRecent,
                    name,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/evi/tools",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedUserDefinedTools.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/tools");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<
            Hume.empathicVoice.ReturnUserDefinedTool | undefined,
            Hume.empathicVoice.ReturnPagedUserDefinedTools
        >({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.toolsPage ?? []).length > 0,
            getItems: (response) => response?.toolsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {Hume.empathicVoice.PostedUserDefinedTool} request
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.createTool({
     *         name: "get_current_weather",
     *         parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
     *         versionDescription: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
     *         description: "This tool is for getting the current weather.",
     *         fallbackContent: "Unable to fetch current weather."
     *     })
     */
    public createTool(
        request: Hume.empathicVoice.PostedUserDefinedTool,
        requestOptions?: ToolsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnUserDefinedTool | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__createTool(request, requestOptions));
    }

    private async __createTool(
        request: Hume.empathicVoice.PostedUserDefinedTool,
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnUserDefinedTool | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/evi/tools",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedUserDefinedTool.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.tools.createTool.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/tools");
    }

    /**
     * @param {string} id
     * @param {Hume.empathicVoice.ToolsListToolVersionsRequest} request
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.listToolVersions("00183a3f-79ba-413d-9f3b-609864268bea")
     */
    public async listToolVersions(
        id: string,
        request: Hume.empathicVoice.ToolsListToolVersionsRequest = {},
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<
        core.Page<Hume.empathicVoice.ReturnUserDefinedTool | undefined, Hume.empathicVoice.ReturnPagedUserDefinedTools>
    > {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ToolsListToolVersionsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedUserDefinedTools>> => {
                const { pageNumber, pageSize, restrictToMostRecent } = request;
                const _queryParams: Record<string, unknown> = {
                    page_number: pageNumber,
                    page_size: pageSize,
                    restrict_to_most_recent: restrictToMostRecent,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        `v0/evi/tools/${core.url.encodePathParam(id)}`,
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedUserDefinedTools.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/tools/{id}");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<
            Hume.empathicVoice.ReturnUserDefinedTool | undefined,
            Hume.empathicVoice.ReturnPagedUserDefinedTools
        >({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.toolsPage ?? []).length > 0,
            getItems: (response) => response?.toolsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * @param {string} id - Identifier for a tool. Formatted as a UUID.
     * @param {Hume.empathicVoice.PostedUserDefinedToolVersion} request
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.createToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", {
     *         parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\", \"kelvin\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
     *         versionDescription: "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
     *         fallbackContent: "Unable to fetch current weather.",
     *         description: "This tool is for getting the current weather."
     *     })
     */
    public createToolVersion(
        id: string,
        request: Hume.empathicVoice.PostedUserDefinedToolVersion,
        requestOptions?: ToolsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnUserDefinedTool | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__createToolVersion(id, request, requestOptions));
    }

    private async __createToolVersion(
        id: string,
        request: Hume.empathicVoice.PostedUserDefinedToolVersion,
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnUserDefinedTool | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/tools/${core.url.encodePathParam(id)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedUserDefinedToolVersion.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.tools.createToolVersion.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/tools/{id}");
    }

    /**
     * @param {string} id - Identifier for a tool. Formatted as a UUID.
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.deleteTool("00183a3f-79ba-413d-9f3b-609864268bea")
     */
    public deleteTool(id: string, requestOptions?: ToolsClient.RequestOptions): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteTool(id, requestOptions));
    }

    private async __deleteTool(
        id: string,
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/tools/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v0/evi/tools/{id}");
    }

    /**
     * @param {string} id - Identifier for a tool. Formatted as a UUID.
     * @param {Hume.empathicVoice.PostedUserDefinedToolName} request
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.updateToolName("00183a3f-79ba-413d-9f3b-609864268bea", {
     *         name: "get_current_temperature"
     *     })
     */
    public updateToolName(
        id: string,
        request: Hume.empathicVoice.PostedUserDefinedToolName,
        requestOptions?: ToolsClient.RequestOptions,
    ): core.HttpResponsePromise<string> {
        return core.HttpResponsePromise.fromPromise(this.__updateToolName(id, request, requestOptions));
    }

    private async __updateToolName(
        id: string,
        request: Hume.empathicVoice.PostedUserDefinedToolName,
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<string>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/tools/${core.url.encodePathParam(id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedUserDefinedToolName.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "text",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as string, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/v0/evi/tools/{id}");
    }

    /**
     * @param {string} id - Identifier for a tool. Formatted as a UUID.
     * @param {number} version - Version number for a tool. Version numbers should be integers.
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.getToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1)
     */
    public getToolVersion(
        id: string,
        version: number,
        requestOptions?: ToolsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnUserDefinedTool | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__getToolVersion(id, version, requestOptions));
    }

    private async __getToolVersion(
        id: string,
        version: number,
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnUserDefinedTool | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/tools/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.tools.getToolVersion.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v0/evi/tools/{id}/version/{version}",
        );
    }

    /**
     * @param {string} id - Identifier for a tool. Formatted as a UUID.
     * @param {number} version - Version number for a tool. Version numbers should be integers.
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.deleteToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1)
     */
    public deleteToolVersion(
        id: string,
        version: number,
        requestOptions?: ToolsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteToolVersion(id, version, requestOptions));
    }

    private async __deleteToolVersion(
        id: string,
        version: number,
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/tools/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/v0/evi/tools/{id}/version/{version}",
        );
    }

    /**
     * @param {string} id - Identifier for a tool. Formatted as a UUID.
     * @param {number} version - Version number for a tool. Version numbers should be integers.
     * @param {Hume.empathicVoice.PostedUserDefinedToolVersionDescription} request
     * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.tools.updateToolDescription("00183a3f-79ba-413d-9f3b-609864268bea", 1, {
     *         versionDescription: "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region."
     *     })
     */
    public updateToolDescription(
        id: string,
        version: number,
        request: Hume.empathicVoice.PostedUserDefinedToolVersionDescription = {},
        requestOptions?: ToolsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnUserDefinedTool | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__updateToolDescription(id, version, request, requestOptions));
    }

    private async __updateToolDescription(
        id: string,
        version: number,
        request: Hume.empathicVoice.PostedUserDefinedToolVersionDescription = {},
        requestOptions?: ToolsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnUserDefinedTool | undefined>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/tools/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedUserDefinedToolVersionDescription.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.tools.updateToolDescription.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v0/evi/tools/{id}/version/{version}",
        );
    }
}

================================================================================
// File: src/api/resources/empathicVoice/resources/tools/client/index.ts
================================================================================
export * from "./requests/index.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedTool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         name: "get_current_weather",
 *         parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
 *         versionDescription: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
 *         description: "This tool is for getting the current weather.",
 *         fallbackContent: "Unable to fetch current weather."
 *     }
 */
export interface PostedUserDefinedTool {
    /** Text describing what the tool does. */
    description?: string;
    /** Text to use if the tool fails to generate content. */
    fallbackContent?: string;
    /** Name applied to all versions of a particular Tool. */
    name: string;
    /** Stringified JSON defining the parameters used by this version of the Tool. */
    parameters: string;
    /** Description that is appended to a specific version of a Tool. */
    versionDescription?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolName.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         name: "get_current_temperature"
 *     }
 */
export interface PostedUserDefinedToolName {
    /** Name applied to all versions of a particular Tool. */
    name: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolVersion.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\", \"kelvin\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
 *         versionDescription: "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
 *         fallbackContent: "Unable to fetch current weather.",
 *         description: "This tool is for getting the current weather."
 *     }
 */
export interface PostedUserDefinedToolVersion {
    /** Text describing what the tool does. */
    description?: string;
    /** Text to use if the tool fails to generate content. */
    fallbackContent?: string;
    /** Stringified JSON defining the parameters used by this version of the Tool. */
    parameters: string;
    /** Description that is appended to a specific version of a Tool. */
    versionDescription?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolVersionDescription.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         versionDescription: "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region."
 *     }
 */
export interface PostedUserDefinedToolVersionDescription {
    /** Description that is appended to a specific version of a Tool. */
    versionDescription?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/tools/client/requests/ToolsListToolVersionsRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {}
 */
export interface ToolsListToolVersionsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** By default, `restrict_to_most_recent` is set to true, returning only the latest version of each tool. To include all versions of each tool in the list, set `restrict_to_most_recent` to false. */
    restrictToMostRecent?: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/tools/client/requests/ToolsListToolsRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         pageNumber: 0,
 *         pageSize: 2
 *     }
 */
export interface ToolsListToolsRequest {
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    /** By default, `restrict_to_most_recent` is set to true, returning only the latest version of each tool. To include all versions of each tool in the list, set `restrict_to_most_recent` to false. */
    restrictToMostRecent?: boolean;
    /** Filter to only include tools with name. */
    name?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/resources/tools/client/requests/index.ts
================================================================================
export type { PostedUserDefinedTool } from "./PostedUserDefinedTool.js";
export type { PostedUserDefinedToolName } from "./PostedUserDefinedToolName.js";
export type { PostedUserDefinedToolVersion } from "./PostedUserDefinedToolVersion.js";
export type { PostedUserDefinedToolVersionDescription } from "./PostedUserDefinedToolVersionDescription.js";
export type { ToolsListToolsRequest } from "./ToolsListToolsRequest.js";
export type { ToolsListToolVersionsRequest } from "./ToolsListToolVersionsRequest.js";

================================================================================
// File: src/api/resources/empathicVoice/resources/tools/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/api/resources/empathicVoice/types/AssistantEnd.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * When provided, the output is an assistant end message.
 */
export interface AssistantEnd {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /**
     * The type of message sent through the socket; for an Assistant End message, this must be `assistant_end`.
     *
     * This message indicates the conclusion of the assistant's response, signaling that the assistant has finished speaking for the current conversational turn.
     */
    type: "assistant_end";
}

================================================================================
// File: src/api/resources/empathicVoice/types/AssistantInput.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * When provided, the input is spoken by EVI.
 */
export interface AssistantInput {
    customSessionId?: string;
    /**
     * Assistant text to synthesize into spoken audio and insert into the conversation.
     *
     * EVI uses this text to generate spoken audio using our proprietary expressive text-to-speech model. Our model adds appropriate emotional inflections and tones to the text based on the user's expressions and the context of the conversation. The synthesized audio is streamed back to the user as an [Assistant Message](/reference/empathic-voice-interface-evi/chat/chat#receive.Assistant%20Message.type).
     */
    text: string;
    /** The type of message sent through the socket; must be `assistant_input` for our server to correctly identify and process it as an Assistant Input message. */
    type: "assistant_input";
}

================================================================================
// File: src/api/resources/empathicVoice/types/AssistantMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * When provided, the output is an assistant message.
 */
export interface AssistantMessage {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Indicates if this message was inserted into the conversation as text from an [Assistant Input message](/reference/empathic-voice-interface-evi/chat/chat#send.Assistant%20Input.text). */
    fromText: boolean;
    /** ID of the assistant message. Allows the Assistant Message to be tracked and referenced. */
    id?: string;
    /** Indicates if this message is a quick response or not. */
    isQuickResponse: boolean;
    /** Detected language of the message text. */
    language?: string;
    /** Transcript of the message. */
    message: Hume.empathicVoice.ChatMessage;
    /** Inference model results. */
    models: Hume.empathicVoice.Inference;
    /**
     * The type of message sent through the socket; for an Assistant Message, this must be `assistant_message`.
     *
     * This message contains both a transcript of the assistant's response and the expression measurement predictions of the assistant's audio output.
     */
    type: "assistant_message";
}

================================================================================
// File: src/api/resources/empathicVoice/types/AssistantProsody.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * When provided, the output is an Assistant Prosody message.
 */
export interface AssistantProsody {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Unique identifier for the segment. */
    id?: string;
    /** Inference model results. */
    models: Hume.empathicVoice.Inference;
    /**
     * The type of message sent through the socket; for an Assistant Prosody message, this must be `assistant_PROSODY`.
     *
     * This message the expression measurement predictions of the assistant's audio output.
     */
    type: "assistant_prosody";
}

================================================================================
// File: src/api/resources/empathicVoice/types/AudioConfiguration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface AudioConfiguration {
    /** Number of audio channels. */
    channels: number;
    /** Optional codec information. */
    codec?: string;
    /** Encoding format of the audio input, such as `linear16`. */
    encoding: Hume.empathicVoice.Encoding;
    /** Audio sample rate. Number of samples per second in the audio input, measured in Hertz. */
    sampleRate: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/AudioInput.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * When provided, the input is audio.
 */
export interface AudioInput {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /**
     * Base64 encoded audio input to insert into the conversation.
     *
     * The content of an Audio Input message is treated as the user's speech to EVI and must be streamed continuously. Pre-recorded audio files are not supported.
     *
     * For optimal transcription quality, the audio data should be transmitted in small chunks.
     *
     * Hume recommends streaming audio with a buffer window of 20 milliseconds (ms), or 100 milliseconds (ms) for web applications.
     */
    data: string;
    /**
     * The type of message sent through the socket; must be `audio_input` for our server to correctly identify and process it as an Audio Input message.
     *
     * This message is used for sending audio input data to EVI for processing and expression measurement. Audio data should be sent as a continuous stream, encoded in Base64.
     */
    type: "audio_input";
}

================================================================================
// File: src/api/resources/empathicVoice/types/AudioOutput.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * The type of message sent through the socket; for an Audio Output message, this must be `audio_output`.
 */
export interface AudioOutput {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Base64 encoded audio output. This encoded audio is transmitted to the client, where it can be decoded and played back as part of the user interaction. */
    data: string;
    /** ID of the audio output. Allows the Audio Output message to be tracked and referenced. */
    id: string;
    /** Index of the chunk of audio relative to the whole audio segment. */
    index: number;
    type: "audio_output";
}

================================================================================
// File: src/api/resources/empathicVoice/types/BuiltInTool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const BuiltInTool = {
    WebSearch: "web_search",
    HangUp: "hang_up",
} as const;
export type BuiltInTool = (typeof BuiltInTool)[keyof typeof BuiltInTool];

================================================================================
// File: src/api/resources/empathicVoice/types/BuiltinToolConfig.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface BuiltinToolConfig {
    /** Optional text passed to the supplemental LLM if the tool call fails. The LLM then uses this text to generate a response back to the user, ensuring continuity in the conversation. */
    fallbackContent?: string;
    name: Hume.empathicVoice.BuiltInTool;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ChatMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ChatMessage {
    /** Transcript of the message. */
    content?: string;
    /** Role of who is providing the message. */
    role: Hume.empathicVoice.Role;
    /** Function call name and arguments. */
    toolCall?: Hume.empathicVoice.ToolCallMessage;
    /** Function call response from client. */
    toolResult?: Hume.empathicVoice.ChatMessageToolResult;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ChatMessageToolResult.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Function call response from client.
 */
export type ChatMessageToolResult = Hume.empathicVoice.ToolResponseMessage | Hume.empathicVoice.ToolErrorMessage;

================================================================================
// File: src/api/resources/empathicVoice/types/ChatMetadata.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * When provided, the output is a chat metadata message.
 */
export interface ChatMetadata {
    /**
     * ID of the Chat Group.
     *
     * Used to resume a Chat when passed in the [resumed_chat_group_id](/reference/empathic-voice-interface-evi/chat/chat#request.query.resumed_chat_group_id) query parameter of a subsequent connection request. This allows EVI to continue the conversation from where it left off within the Chat Group.
     *
     * Learn more about [supporting chat resumability](/docs/empathic-voice-interface-evi/faq#does-evi-support-chat-resumability) from the EVI FAQ.
     */
    chatGroupId: string;
    /** ID of the Chat session. Allows the Chat session to be tracked and referenced. */
    chatId: string;
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** ID of the initiating request. */
    requestId?: string;
    /**
     * The type of message sent through the socket; for a Chat Metadata message, this must be `chat_metadata`.
     *
     * The Chat Metadata message is the first message you receive after establishing a connection with EVI and contains important identifiers for the current Chat session.
     */
    type: "chat_metadata";
}

================================================================================
// File: src/api/resources/empathicVoice/types/ConnectSessionSettings.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ConnectSessionSettings {
    /**
     * Configuration details for the audio input used during the session. Ensures the audio is being correctly set up for processing.
     *
     * This optional field is only required when the audio input is encoded in PCM Linear 16 (16-bit, little-endian, signed PCM WAV data). For detailed instructions on how to configure session settings for PCM Linear 16 audio, please refer to the [Session Settings section](/docs/empathic-voice-interface-evi/configuration#session-settings) on the EVI Configuration page.
     */
    audio?: Hume.empathicVoice.ConnectSessionSettingsAudio;
    /**
     * Allows developers to inject additional context into the conversation, which is appended to the end of user messages for the session.
     *
     * When included in a Session Settings message, the provided context can be used to remind the LLM of its role in every user message, prevent it from forgetting important details, or add new relevant information to the conversation.
     *
     * Set to `null` to disable context injection.
     */
    context?: Hume.empathicVoice.ConnectSessionSettingsContext;
    /**
     * Unique identifier for the session. Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions.
     *
     * If included, the response sent from Hume to your backend will include this ID. This allows you to correlate frontend users with their incoming messages.
     *
     * It is recommended to pass a `custom_session_id` if you are using a Custom Language Model. Please see our guide to [using a custom language model](/docs/empathic-voice-interface-evi/custom-language-model) with EVI to learn more.
     */
    customSessionId?: string;
    eventLimit?: number;
    /**
     * Third party API key for the supplemental language model.
     *
     * When provided, EVI will use this key instead of Hume's API key for the supplemental LLM. This allows you to bypass rate limits and utilize your own API key as needed.
     */
    languageModelApiKey?: string;
    /**
     * Instructions used to shape EVI's behavior, responses, and style for the session.
     *
     * When included in a Session Settings message, the provided Prompt overrides the existing one specified in the EVI configuration. If no Prompt was defined in the configuration, this Prompt will be the one used for the session.
     *
     * You can use the Prompt to define a specific goal or role for EVI, specifying how it should act or what it should focus on during the conversation. For example, EVI can be instructed to act as a customer support representative, a fitness coach, or a travel advisor, each with its own set of behaviors and response styles.
     *
     * For help writing a system prompt, see our [Prompting Guide](/docs/empathic-voice-interface-evi/prompting).
     */
    systemPrompt?: string;
    voiceId?: string;
    /**
     * This field allows you to assign values to dynamic variables referenced in your system prompt.
     *
     * Each key represents the variable name, and the corresponding value is the specific content you wish to assign to that variable within the session. While the values for variables can be strings, numbers, or booleans, the value will ultimately be converted to a string when injected into your system prompt.
     *
     * When used in query parameters, specify each variable using bracket notation: `session_settings[variables][key]=value`. For example: `session_settings[variables][name]=John&session_settings[variables][age]=30`.
     *
     * Using this field, you can personalize responses based on session-specific details. For more guidance, see our [guide on using dynamic variables](/docs/speech-to-speech-evi/features/dynamic-variables).
     */
    variables?: Record<string, Hume.empathicVoice.ConnectSessionSettingsVariablesValue>;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ConnectSessionSettingsAudio.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Configuration details for the audio input used during the session. Ensures the audio is being correctly set up for processing.
 *
 * This optional field is only required when the audio input is encoded in PCM Linear 16 (16-bit, little-endian, signed PCM WAV data). For detailed instructions on how to configure session settings for PCM Linear 16 audio, please refer to the [Session Settings section](/docs/empathic-voice-interface-evi/configuration#session-settings) on the EVI Configuration page.
 */
export interface ConnectSessionSettingsAudio {
    /** Number of audio channels. */
    channels?: number;
    /** Encoding format of the audio input, such as `linear16`. */
    encoding?: Hume.empathicVoice.Encoding;
    /** Audio sample rate. Number of samples per second in the audio input, measured in Hertz. */
    sampleRate?: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ConnectSessionSettingsContext.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Allows developers to inject additional context into the conversation, which is appended to the end of user messages for the session.
 *
 * When included in a Session Settings message, the provided context can be used to remind the LLM of its role in every user message, prevent it from forgetting important details, or add new relevant information to the conversation.
 *
 * Set to `null` to disable context injection.
 */
export interface ConnectSessionSettingsContext {
    /**
     * The context to be injected into the conversation. Helps inform the LLM's response by providing relevant information about the ongoing conversation.
     *
     * This text will be appended to the end of user messages based on the chosen persistence level. For example, if you want to remind EVI of its role as a helpful weather assistant, the context you insert will be appended to the end of user messages as `{Context: You are a helpful weather assistant}`.
     */
    text?: string;
    /**
     * The persistence level of the injected context. Specifies how long the injected context will remain active in the session.
     *
     * There are three possible context types:
     *
     * - **Persistent**: The context is appended to all user messages for the duration of the session.
     *
     * - **Temporary**: The context is appended only to the next user message.
     *
     *  - **Editable**: The original context is updated to reflect the new context.
     *
     *  If the type is not specified, it will default to `temporary`.
     */
    type?: Hume.empathicVoice.ContextType;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ConnectSessionSettingsVariablesValue.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type ConnectSessionSettingsVariablesValue = string | number | boolean;

================================================================================
// File: src/api/resources/empathicVoice/types/Context.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface Context {
    /**
     * The context to be injected into the conversation. Helps inform the LLM's response by providing relevant information about the ongoing conversation.
     *
     * This text will be appended to the end of user messages based on the chosen persistence level. For example, if you want to remind EVI of its role as a helpful weather assistant, the context you insert will be appended to the end of user messages as `{Context: You are a helpful weather assistant}`.
     */
    text: string;
    /**
     * The persistence level of the injected context. Specifies how long the injected context will remain active in the session.
     *
     * There are three possible context types:
     *
     * - **Persistent**: The context is appended to all user messages for the duration of the session.
     *
     * - **Temporary**: The context is appended only to the next user message.
     *
     *  - **Editable**: The original context is updated to reflect the new context.
     *
     *  If the type is not specified, it will default to `temporary`.
     */
    type?: Hume.empathicVoice.ContextType;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ContextType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ContextType = {
    Persistent: "persistent",
    Temporary: "temporary",
} as const;
export type ContextType = (typeof ContextType)[keyof typeof ContextType];

================================================================================
// File: src/api/resources/empathicVoice/types/ControlPlanePublishEvent.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type ControlPlanePublishEvent =
    | Hume.empathicVoice.SessionSettings
    | Hume.empathicVoice.UserInput
    | Hume.empathicVoice.AssistantInput
    | Hume.empathicVoice.ToolResponseMessage
    | Hume.empathicVoice.ToolErrorMessage
    | Hume.empathicVoice.PauseAssistantMessage
    | Hume.empathicVoice.ResumeAssistantMessage;

================================================================================
// File: src/api/resources/empathicVoice/types/Encoding.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type Encoding = "linear16";

================================================================================
// File: src/api/resources/empathicVoice/types/ErrorLevel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type ErrorLevel = "warn";

================================================================================
// File: src/api/resources/empathicVoice/types/ErrorResponse.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface ErrorResponse {
    code?: string;
    error?: string;
    message?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/types/HttpValidationError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface HttpValidationError {
    detail?: Hume.empathicVoice.ValidationError[];
}

================================================================================
// File: src/api/resources/empathicVoice/types/Inference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface Inference {
    /**
     * Prosody model inference results.
     *
     * EVI uses the prosody model to measure 48 emotions related to speech and vocal characteristics within a given expression.
     */
    prosody?: Hume.empathicVoice.ProsodyInference;
}

================================================================================
// File: src/api/resources/empathicVoice/types/JsonMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type JsonMessage =
    | Hume.empathicVoice.AssistantEnd
    | Hume.empathicVoice.AssistantMessage
    | Hume.empathicVoice.AssistantProsody
    | Hume.empathicVoice.ChatMetadata
    | Hume.empathicVoice.WebSocketError
    | Hume.empathicVoice.UserInterruption
    | Hume.empathicVoice.UserMessage
    | Hume.empathicVoice.ToolCallMessage
    | Hume.empathicVoice.ToolResponseMessage
    | Hume.empathicVoice.ToolErrorMessage
    | Hume.empathicVoice.SessionSettings;

================================================================================
// File: src/api/resources/empathicVoice/types/LanguageModelType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const LanguageModelType = {
    Claude37SonnetLatest: "claude-3-7-sonnet-latest",
    Claude35SonnetLatest: "claude-3-5-sonnet-latest",
    Claude35HaikuLatest: "claude-3-5-haiku-latest",
    Claude35Sonnet20240620: "claude-3-5-sonnet-20240620",
    Claude3Opus20240229: "claude-3-opus-20240229",
    Claude3Sonnet20240229: "claude-3-sonnet-20240229",
    Claude3Haiku20240307: "claude-3-haiku-20240307",
    ClaudeSonnet420250514: "claude-sonnet-4-20250514",
    ClaudeSonnet4520250929: "claude-sonnet-4-5-20250929",
    ClaudeHaiku4520251001: "claude-haiku-4-5-20251001",
    UsAnthropicClaude35Haiku20241022V10: "us.anthropic.claude-3-5-haiku-20241022-v1:0",
    UsAnthropicClaude35Sonnet20240620V10: "us.anthropic.claude-3-5-sonnet-20240620-v1:0",
    UsAnthropicClaude3Haiku20240307V10: "us.anthropic.claude-3-haiku-20240307-v1:0",
    GptOss120B: "gpt-oss-120b",
    Qwen3235Ba22B: "qwen-3-235b-a22b",
    Qwen3235Ba22BInstruct2507: "qwen-3-235b-a22b-instruct-2507",
    Qwen3235Ba22BThinking2507: "qwen-3-235b-a22b-thinking-2507",
    Gemini15Pro: "gemini-1.5-pro",
    Gemini15Flash: "gemini-1.5-flash",
    Gemini15Pro002: "gemini-1.5-pro-002",
    Gemini15Flash002: "gemini-1.5-flash-002",
    Gemini20Flash: "gemini-2.0-flash",
    Gemini25Flash: "gemini-2.5-flash",
    Gemini25FlashPreview0417: "gemini-2.5-flash-preview-04-17",
    Gpt4Turbo: "gpt-4-turbo",
    Gpt4TurboPreview: "gpt-4-turbo-preview",
    Gpt35Turbo0125: "gpt-3.5-turbo-0125",
    Gpt35Turbo: "gpt-3.5-turbo",
    Gpt4O: "gpt-4o",
    Gpt4OMini: "gpt-4o-mini",
    Gpt41: "gpt-4.1",
    Gpt5: "gpt-5",
    Gpt5Mini: "gpt-5-mini",
    Gpt5Nano: "gpt-5-nano",
    Gpt4OPriority: "gpt-4o-priority",
    Gpt4OMiniPriority: "gpt-4o-mini-priority",
    Gpt41Priority: "gpt-4.1-priority",
    Gpt5Priority: "gpt-5-priority",
    Gpt5MiniPriority: "gpt-5-mini-priority",
    Gpt5NanoPriority: "gpt-5-nano-priority",
    Gemma7BIt: "gemma-7b-it",
    Llama38B8192: "llama3-8b-8192",
    Llama370B8192: "llama3-70b-8192",
    Llama3170BVersatile: "llama-3.1-70b-versatile",
    Llama3370BVersatile: "llama-3.3-70b-versatile",
    Llama318BInstant: "llama-3.1-8b-instant",
    MoonshotaiKimiK2Instruct: "moonshotai/kimi-k2-instruct",
    AccountsFireworksModelsMixtral8X7BInstruct: "accounts/fireworks/models/mixtral-8x7b-instruct",
    AccountsFireworksModelsLlamaV3P1405BInstruct: "accounts/fireworks/models/llama-v3p1-405b-instruct",
    AccountsFireworksModelsLlamaV3P170BInstruct: "accounts/fireworks/models/llama-v3p1-70b-instruct",
    AccountsFireworksModelsLlamaV3P18BInstruct: "accounts/fireworks/models/llama-v3p1-8b-instruct",
    Sonar: "sonar",
    SonarPro: "sonar-pro",
    Sambanova: "sambanova",
    DeepSeekR1DistillLlama70B: "DeepSeek-R1-Distill-Llama-70B",
    Llama4Maverick17B128EInstruct: "Llama-4-Maverick-17B-128E-Instruct",
    Qwen332B: "Qwen3-32B",
    Grok4FastNonReasoningLatest: "grok-4-fast-non-reasoning-latest",
    Ellm: "ellm",
    CustomLanguageModel: "custom-language-model",
    HumeEvi3WebSearch: "hume-evi-3-web-search",
} as const;
export type LanguageModelType = (typeof LanguageModelType)[keyof typeof LanguageModelType];

================================================================================
// File: src/api/resources/empathicVoice/types/MillisecondInterval.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface MillisecondInterval {
    /** Start time of the interval in milliseconds. */
    begin: number;
    /** End time of the interval in milliseconds. */
    end: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ModelProviderEnum.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ModelProviderEnum = {
    Groq: "GROQ",
    OpenAi: "OPEN_AI",
    Fireworks: "FIREWORKS",
    Anthropic: "ANTHROPIC",
    CustomLanguageModel: "CUSTOM_LANGUAGE_MODEL",
    Google: "GOOGLE",
    HumeAi: "HUME_AI",
    AmazonBedrock: "AMAZON_BEDROCK",
    Perplexity: "PERPLEXITY",
    Sambanova: "SAMBANOVA",
    Cerebras: "CEREBRAS",
} as const;
export type ModelProviderEnum = (typeof ModelProviderEnum)[keyof typeof ModelProviderEnum];

================================================================================
// File: src/api/resources/empathicVoice/types/PauseAssistantMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * Pause responses from EVI. Chat history is still saved and sent after resuming.
 */
export interface PauseAssistantMessage {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /**
     * The type of message sent through the socket; must be `pause_assistant_message` for our server to correctly identify and process it as a Pause Assistant message.
     *
     * Once this message is sent, EVI will not respond until a [Resume Assistant message](/reference/empathic-voice-interface-evi/chat/chat#send.Resume%20Assistant%20Message.type) is sent. When paused, EVI won't respond, but transcriptions of your audio inputs will still be recorded.
     */
    type: "pause_assistant_message";
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedBuiltinTool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A configuration of a built-in tool to be posted to the server
 */
export interface PostedBuiltinTool {
    /** Text to use if the tool fails to generate content. */
    fallbackContent?: string;
    name: Hume.empathicVoice.PostedBuiltinToolName;
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedBuiltinToolName.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const PostedBuiltinToolName = {
    WebSearch: "web_search",
    HangUp: "hang_up",
} as const;
export type PostedBuiltinToolName = (typeof PostedBuiltinToolName)[keyof typeof PostedBuiltinToolName];

================================================================================
// File: src/api/resources/empathicVoice/types/PostedConfigPromptSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * Identifies which prompt to use in a a config OR how to create a new prompt to use in the config
 */
export interface PostedConfigPromptSpec {
    /** Identifier for a Prompt. Formatted as a UUID. */
    id?: string;
    /** Text used to create a new prompt for a particular config. */
    text?: string;
    /** Version number for a Prompt. Version numbers should be integers. The combination of configId and version number is unique. */
    version?: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedEllmModel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * A eLLM model configuration to be posted to the server
 */
export interface PostedEllmModel {
    /** Boolean indicating if the model is allowed to generate short responses. */
    allowShortResponses?: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedEventMessageSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * Settings for a specific event_message to be posted to the server
 */
export interface PostedEventMessageSpec {
    /** Boolean indicating if this event message is enabled. */
    enabled: boolean;
    /** Optional text that will be used as a verbatim event message. If the text is null and the event message is enabled, the system will generate a message based using the language model. */
    text?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedEventMessageSpecs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Collection of event_message specs to be posted to the server
 */
export interface PostedEventMessageSpecs {
    onInactivityTimeout?: Hume.empathicVoice.PostedEventMessageSpec;
    onMaxDurationTimeout?: Hume.empathicVoice.PostedEventMessageSpec;
    onNewChat?: Hume.empathicVoice.PostedEventMessageSpec;
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedLanguageModel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A LanguageModel to be posted to the server
 */
export interface PostedLanguageModel {
    modelProvider?: Hume.empathicVoice.ModelProviderEnum;
    modelResource?: Hume.empathicVoice.LanguageModelType;
    /** Model temperature. */
    temperature?: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedNudgeSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * A nudge specification posted to the server
 */
export interface PostedNudgeSpec {
    /** EVI will nudge user after inactivity */
    enabled?: boolean;
    /** Time interval in seconds after which the nudge will be sent. */
    intervalSecs?: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedTimeoutSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * Settings for a specific timeout to be posted to the server
 */
export interface PostedTimeoutSpec {
    /** Duration in seconds for the timeout. */
    durationSecs?: number;
    /** Boolean indicating if this event message is enabled. */
    enabled: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedTimeoutSpecs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Collection of timeout specs to be posted to the server
 */
export interface PostedTimeoutSpecs {
    inactivity?: Hume.empathicVoice.PostedTimeoutSpecsInactivity;
    maxDuration?: Hume.empathicVoice.PostedTimeoutSpecsMaxDuration;
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedTimeoutSpecsInactivity.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface PostedTimeoutSpecsInactivity {
    durationSecs?: number;
    enabled: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedTimeoutSpecsMaxDuration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface PostedTimeoutSpecsMaxDuration {
    durationSecs?: number;
    enabled: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedUserDefinedToolSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * A specific tool identifier to be posted to the server
 */
export interface PostedUserDefinedToolSpec {
    /** Identifier for a Tool. Formatted as a UUID. */
    id: string;
    /** Version number for a Tool. Version numbers should be integers. The combination of configId and version number is unique. */
    version?: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/PostedWebhookEventType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/** Events this URL is subscribed to */
export const PostedWebhookEventType = {
    ChatStarted: "chat_started",
    ChatEnded: "chat_ended",
    ToolCall: "tool_call",
} as const;
export type PostedWebhookEventType = (typeof PostedWebhookEventType)[keyof typeof PostedWebhookEventType];

================================================================================
// File: src/api/resources/empathicVoice/types/PostedWebhookSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * URL and settings for a specific webhook to be posted to the server
 */
export interface PostedWebhookSpec {
    /** Events this URL is subscribed to */
    events: Hume.empathicVoice.PostedWebhookEventType[];
    /** URL to send the webhook to */
    url: string;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ProsodyInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ProsodyInference {
    /**
     * The confidence scores for 48 emotions within the detected expression of an audio sample.
     *
     * Scores typically range from 0 to 1, with higher values indicating a stronger confidence level in the measured attribute.
     *
     * See our guide on [interpreting expression measurement results](/docs/expression-measurement/faq#how-do-i-interpret-my-results) to learn more.
     */
    scores: Hume.empathicVoice.EmotionScores;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ResumeAssistantMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * Resume responses from EVI. Chat history sent while paused will now be sent.
 */
export interface ResumeAssistantMessage {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /**
     * The type of message sent through the socket; must be `resume_assistant_message` for our server to correctly identify and process it as a Resume Assistant message.
     *
     * Upon resuming, if any audio input was sent during the pause, EVI will retain context from all messages sent but only respond to the last user message. (e.g., If you ask EVI two questions while paused and then send a `resume_assistant_message`, EVI will respond to the second question and have added the first question to its conversation context.)
     */
    type: "resume_assistant_message";
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnBuiltinTool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A specific builtin tool version returned from the server
 */
export interface ReturnBuiltinTool {
    /** Text to use if the tool fails to generate content. */
    fallbackContent?: string;
    /** Name applied to all versions of a particular Tool. */
    name: string;
    toolType: Hume.empathicVoice.ReturnBuiltinToolToolType;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnBuiltinToolToolType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnBuiltinToolToolType = {
    Builtin: "BUILTIN",
    Function: "FUNCTION",
} as const;
export type ReturnBuiltinToolToolType = (typeof ReturnBuiltinToolToolType)[keyof typeof ReturnBuiltinToolToolType];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChat.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A description of chat and its status
 */
export interface ReturnChat {
    /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
    chatGroupId: string;
    config?: Hume.empathicVoice.ReturnConfigSpec;
    /** The timestamp when the chat ended, formatted as a Unix epoch milliseconds. */
    endTimestamp?: number;
    /** The total number of events currently in this chat. */
    eventCount?: number;
    /** Identifier for a chat. Formatted as a UUID. */
    id: string;
    /** Stringified JSON with additional metadata about the chat. */
    metadata?: string;
    /** The timestamp when the chat started, formatted as a Unix epoch milliseconds. */
    startTimestamp: number;
    status: Hume.empathicVoice.ReturnChatStatus;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatAudioReconstruction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * List of chat audio reconstructions returned for the specified page number and page size.
 */
export interface ReturnChatAudioReconstruction {
    /** Name of the chat audio reconstruction file. */
    filename?: string;
    /** Identifier for the chat. Formatted as a UUID. */
    id: string;
    /** The timestamp of the most recent status change for this audio reconstruction, formatted milliseconds since the Unix epoch. */
    modifiedAt?: number;
    /** Signed URL used to download the chat audio reconstruction file. */
    signedAudioUrl?: string;
    /** The timestamp when the signed URL will expire, formatted as a Unix epoch milliseconds. */
    signedUrlExpirationTimestampMillis?: number;
    status: Hume.empathicVoice.ReturnChatAudioReconstructionStatus;
    /** Identifier for the user that owns this chat. Formatted as a UUID. */
    userId: string;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatAudioReconstructionStatus.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatAudioReconstructionStatus = {
    Queued: "QUEUED",
    InProgress: "IN_PROGRESS",
    Complete: "COMPLETE",
    Error: "ERROR",
    Cancelled: "CANCELLED",
} as const;
export type ReturnChatAudioReconstructionStatus =
    (typeof ReturnChatAudioReconstructionStatus)[keyof typeof ReturnChatAudioReconstructionStatus];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatEvent.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A description of a single event in a chat returned from the server
 */
export interface ReturnChatEvent {
    /** Identifier for the chat this event occurred in. Formatted as a UUID. */
    chatId: string;
    /** Stringified JSON with data about emotional content/prosody of the event. */
    emotionFeatures?: string;
    /** Identifier for a chat event. Formatted as a UUID. */
    id: string;
    /** The text of the chat message, either transcribed from speaker audio or generated by the agent. */
    messageText?: string;
    /** Stringified JSON with additional metadata about the chat event. */
    metadata?: string;
    /** Identifier for a related chat event. Currently only seen on ASSISTANT_PROSODY events, to point back to the ASSISTANT_MESSAGE that generated these prosody scores */
    relatedEventId?: string;
    role: Hume.empathicVoice.ReturnChatEventRole;
    /** The timestamp when the chat event occurred, formatted as a Unix epoch milliseconds. */
    timestamp: number;
    type: Hume.empathicVoice.ReturnChatEventType;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatEventRole.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatEventRole = {
    User: "USER",
    Agent: "AGENT",
    System: "SYSTEM",
    Tool: "TOOL",
} as const;
export type ReturnChatEventRole = (typeof ReturnChatEventRole)[keyof typeof ReturnChatEventRole];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatEventType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatEventType = {
    FunctionCall: "FUNCTION_CALL",
    FunctionCallResponse: "FUNCTION_CALL_RESPONSE",
    ChatEndMessage: "CHAT_END_MESSAGE",
    AgentMessage: "AGENT_MESSAGE",
    SystemPrompt: "SYSTEM_PROMPT",
    UserRecordingStartMessage: "USER_RECORDING_START_MESSAGE",
    ResumeOnset: "RESUME_ONSET",
    UserInterruption: "USER_INTERRUPTION",
    ChatStartMessage: "CHAT_START_MESSAGE",
    PauseOnset: "PAUSE_ONSET",
    UserMessage: "USER_MESSAGE",
} as const;
export type ReturnChatEventType = (typeof ReturnChatEventType)[keyof typeof ReturnChatEventType];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatGroup.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A description of chat_group and its status
 */
export interface ReturnChatGroup {
    active?: boolean;
    /** The timestamp when the first chat in this chat group started, formatted as a Unix epoch milliseconds. */
    firstStartTimestamp: number;
    /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
    id: string;
    /** The chat_id of the most recent chat in this chat group. Formatted as a UUID. */
    mostRecentChatId?: string;
    mostRecentConfig?: Hume.empathicVoice.ReturnConfigSpec;
    /** The timestamp when the most recent chat in this chat group started, formatted as a Unix epoch milliseconds. */
    mostRecentStartTimestamp: number;
    /** The total number of chats in this chat group. */
    numChats: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatGroupPagedAudioReconstructions.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of chat reconstructions for a particular chatgroup
 */
export interface ReturnChatGroupPagedAudioReconstructions {
    /** List of chat audio reconstructions returned for the specified page number and page size. */
    audioReconstructionsPage: Hume.empathicVoice.ReturnChatAudioReconstruction[];
    /** Identifier for the chat group. Formatted as a UUID. */
    id: string;
    /** Total number of chats in this chatgroup */
    numChats: number;
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    paginationDirection: Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructionsPaginationDirection;
    /** The total number of pages in the collection. */
    totalPages: number;
    /** Identifier for the user that owns this chat. Formatted as a UUID. */
    userId: string;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatGroupPagedAudioReconstructionsPaginationDirection.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatGroupPagedAudioReconstructionsPaginationDirection = {
    Asc: "ASC",
    Desc: "DESC",
} as const;
export type ReturnChatGroupPagedAudioReconstructionsPaginationDirection =
    (typeof ReturnChatGroupPagedAudioReconstructionsPaginationDirection)[keyof typeof ReturnChatGroupPagedAudioReconstructionsPaginationDirection];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatGroupPagedChats.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A description of chat_group and its status with a paginated list of each chat in the chat_group
 */
export interface ReturnChatGroupPagedChats {
    active?: boolean;
    /** List of chats and their metadata returned for the specified page number and page size. */
    chatsPage: Hume.empathicVoice.ReturnChat[];
    /** The timestamp when the first chat in this chat group started, formatted as a Unix epoch milliseconds. */
    firstStartTimestamp: number;
    /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
    id: string;
    /** The timestamp when the most recent chat in this chat group started, formatted as a Unix epoch milliseconds. */
    mostRecentStartTimestamp: number;
    /** The total number of chats in this chat group. */
    numChats: number;
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    paginationDirection: Hume.empathicVoice.ReturnChatGroupPagedChatsPaginationDirection;
    /** The total number of pages in the collection. */
    totalPages: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatGroupPagedChatsPaginationDirection.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatGroupPagedChatsPaginationDirection = {
    Asc: "ASC",
    Desc: "DESC",
} as const;
export type ReturnChatGroupPagedChatsPaginationDirection =
    (typeof ReturnChatGroupPagedChatsPaginationDirection)[keyof typeof ReturnChatGroupPagedChatsPaginationDirection];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatGroupPagedEvents.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of chat events that occurred across chats in this chat_group from the server
 */
export interface ReturnChatGroupPagedEvents {
    /** List of chat_events returned for the specified page number and page size. */
    eventsPage: Hume.empathicVoice.ReturnChatEvent[];
    /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
    id: string;
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    paginationDirection: Hume.empathicVoice.ReturnChatGroupPagedEventsPaginationDirection;
    /** The total number of pages in the collection. */
    totalPages: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatGroupPagedEventsPaginationDirection.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatGroupPagedEventsPaginationDirection = {
    Asc: "ASC",
    Desc: "DESC",
} as const;
export type ReturnChatGroupPagedEventsPaginationDirection =
    (typeof ReturnChatGroupPagedEventsPaginationDirection)[keyof typeof ReturnChatGroupPagedEventsPaginationDirection];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatPagedEvents.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A description of chat status with a paginated list of chat events returned from the server
 */
export interface ReturnChatPagedEvents {
    /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
    chatGroupId: string;
    config?: Hume.empathicVoice.ReturnConfigSpec;
    /** The timestamp when the chat ended, formatted as a Unix epoch milliseconds. */
    endTimestamp?: number;
    /** List of chat events with the specified page number and page size. */
    eventsPage: Hume.empathicVoice.ReturnChatEvent[];
    /** Identifier for a chat. Formatted as a UUID. */
    id: string;
    /** Stringified JSON with additional metadata about the chat. */
    metadata?: string;
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    paginationDirection: Hume.empathicVoice.ReturnChatPagedEventsPaginationDirection;
    /** The timestamp when the chat started, formatted as a Unix epoch milliseconds. */
    startTimestamp: number;
    status: Hume.empathicVoice.ReturnChatPagedEventsStatus;
    /** The total number of pages in the collection. */
    totalPages: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatPagedEventsPaginationDirection.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatPagedEventsPaginationDirection = {
    Asc: "ASC",
    Desc: "DESC",
} as const;
export type ReturnChatPagedEventsPaginationDirection =
    (typeof ReturnChatPagedEventsPaginationDirection)[keyof typeof ReturnChatPagedEventsPaginationDirection];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatPagedEventsStatus.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatPagedEventsStatus = {
    Active: "ACTIVE",
    UserEnded: "USER_ENDED",
    UserTimeout: "USER_TIMEOUT",
    MaxDurationTimeout: "MAX_DURATION_TIMEOUT",
    InactivityTimeout: "INACTIVITY_TIMEOUT",
    Error: "ERROR",
} as const;
export type ReturnChatPagedEventsStatus =
    (typeof ReturnChatPagedEventsStatus)[keyof typeof ReturnChatPagedEventsStatus];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnChatStatus.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnChatStatus = {
    Active: "ACTIVE",
    UserEnded: "USER_ENDED",
    UserTimeout: "USER_TIMEOUT",
    MaxDurationTimeout: "MAX_DURATION_TIMEOUT",
    InactivityTimeout: "INACTIVITY_TIMEOUT",
    Error: "ERROR",
} as const;
export type ReturnChatStatus = (typeof ReturnChatStatus)[keyof typeof ReturnChatStatus];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnConfig.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A specific config version returned from the server
 */
export interface ReturnConfig {
    /** List of built-in tools associated with this config */
    builtinTools?: (Hume.empathicVoice.ReturnBuiltinTool | undefined)[];
    /** The timestamp when the first version of this config was created. */
    createdOn?: number;
    ellmModel?: Hume.empathicVoice.ReturnEllmModel;
    eventMessages?: Hume.empathicVoice.ReturnEventMessageSpecs;
    /** The version of the EVI used with this config. */
    eviVersion?: string;
    /** Identifier for a Config. Formatted as a UUID. */
    id?: string;
    languageModel?: Hume.empathicVoice.ReturnLanguageModel;
    /** The timestamp when this version of the config was created. */
    modifiedOn?: number;
    /** Name applied to all versions of a particular Config. */
    name?: string;
    nudges?: Hume.empathicVoice.ReturnNudgeSpec;
    prompt?: Hume.empathicVoice.ReturnPrompt;
    timeouts?: Hume.empathicVoice.ReturnTimeoutSpecs;
    /** List of user-defined tools associated with this config. */
    tools?: (Hume.empathicVoice.ReturnUserDefinedTool | undefined)[];
    /** Version number for a Config. Version numbers should be integers. The combination of configId and version number is unique. */
    version?: number;
    /** Description that is appended to a specific version of a Config. */
    versionDescription?: string;
    voice?: Hume.empathicVoice.ReturnVoice;
    /** Map of webhooks associated with this config. */
    webhooks?: (Hume.empathicVoice.ReturnWebhookSpec | undefined)[];
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnConfigSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * An id/version number for a specific config version
 */
export interface ReturnConfigSpec {
    /** Identifier for a Config. Formatted as a UUID. */
    id: string;
    /** Version number for a Config. Version numbers should be integers. The combination of configId and version number is unique. */
    version?: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnEllmModel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * A specific eLLM Model configuration
 */
export interface ReturnEllmModel {
    /** Boolean indicating if the model is allowed to generate short responses. */
    allowShortResponses: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnEventMessageSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * A specific event message configuration to be returned from the server
 */
export interface ReturnEventMessageSpec {
    /** Boolean indicating if this event message is enabled. */
    enabled: boolean;
    /** Optional text that will be used as a verbatim event message. If the text is null and the event message is enabled, the system will generate a message based using the language model. */
    text?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnEventMessageSpecs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Collection of event_message specs to be returned from the server
 */
export interface ReturnEventMessageSpecs {
    onInactivityTimeout?: Hume.empathicVoice.ReturnEventMessageSpec;
    onMaxDurationTimeout?: Hume.empathicVoice.ReturnEventMessageSpec;
    onNewChat?: Hume.empathicVoice.ReturnEventMessageSpec;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnLanguageModel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A specific LanguageModel
 */
export interface ReturnLanguageModel {
    modelProvider?: Hume.empathicVoice.ModelProviderEnum;
    modelResource?: Hume.empathicVoice.LanguageModelType;
    /** Model temperature. */
    temperature?: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnNudgeSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * A specific nudge configuration returned from the server
 */
export interface ReturnNudgeSpec {
    /** EVI will nudge user after inactivity */
    enabled: boolean;
    /** Time interval in seconds after which the nudge will be sent. */
    intervalSecs?: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnPagedChatGroups.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of chat_groups returned from the server
 */
export interface ReturnPagedChatGroups {
    /** List of chat_groups and their metadata returned for the specified page number and page size. */
    chatGroupsPage: Hume.empathicVoice.ReturnChatGroup[];
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    paginationDirection: Hume.empathicVoice.ReturnPagedChatGroupsPaginationDirection;
    /** The total number of pages in the collection. */
    totalPages: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnPagedChatGroupsPaginationDirection.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnPagedChatGroupsPaginationDirection = {
    Asc: "ASC",
    Desc: "DESC",
} as const;
export type ReturnPagedChatGroupsPaginationDirection =
    (typeof ReturnPagedChatGroupsPaginationDirection)[keyof typeof ReturnPagedChatGroupsPaginationDirection];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnPagedChats.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of chats returned from the server
 */
export interface ReturnPagedChats {
    /** List of chats and their metadata returned for the specified page number and page size. */
    chatsPage: Hume.empathicVoice.ReturnChat[];
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    paginationDirection: Hume.empathicVoice.ReturnPagedChatsPaginationDirection;
    /** The total number of pages in the collection. */
    totalPages: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnPagedChatsPaginationDirection.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnPagedChatsPaginationDirection = {
    Asc: "ASC",
    Desc: "DESC",
} as const;
export type ReturnPagedChatsPaginationDirection =
    (typeof ReturnPagedChatsPaginationDirection)[keyof typeof ReturnPagedChatsPaginationDirection];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnPagedConfigs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of config versions returned from the server
 */
export interface ReturnPagedConfigs {
    /** List of prompts returned for the specified page number and page size. */
    configsPage?: Hume.empathicVoice.ReturnConfig[];
    /** The page number of the returned results. */
    pageNumber?: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize?: number;
    /** The total number of pages in the collection. */
    totalPages: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnPagedPrompts.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of prompt versions returned from the server
 */
export interface ReturnPagedPrompts {
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    /** List of prompts returned for the specified page number and page size. */
    promptsPage: (Hume.empathicVoice.ReturnPrompt | undefined)[];
    /** The total number of pages in the collection. */
    totalPages: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnPagedUserDefinedTools.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list of user defined tool versions returned from the server
 */
export interface ReturnPagedUserDefinedTools {
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    /** List of tools returned for the specified page number and page size. */
    toolsPage: (Hume.empathicVoice.ReturnUserDefinedTool | undefined)[];
    /** The total number of pages in the collection. */
    totalPages: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnPrompt.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * A specific prompt version returned from the server
 */
export interface ReturnPrompt {
    /** The timestamp when the first version of this prompt was created. */
    createdOn: number;
    /** Identifier for a Prompt. Formatted as a UUID. */
    id: string;
    /** The timestamp when this version of the prompt was created. */
    modifiedOn: number;
    /** Name applied to all versions of a particular Prompt. */
    name: string;
    /** Text used for this version of the Prompt. */
    text: string;
    /** Version number for a Prompt. Version numbers should be integers. The combination of configId and version number is unique. */
    version: number;
    /** Description that is appended to a specific version of a Prompt. */
    versionDescription?: string;
    /** Indicates whether this prompt is using a fixed version number or auto-updating to the latest version. Values from the VersionType enum. */
    versionType: string;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnPromptVersionType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnPromptVersionType = {
    Fixed: "FIXED",
    Latest: "LATEST",
} as const;
export type ReturnPromptVersionType = (typeof ReturnPromptVersionType)[keyof typeof ReturnPromptVersionType];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnTimeoutSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * A specific timeout configuration to be returned from the server
 */
export interface ReturnTimeoutSpec {
    /** Duration in seconds for the timeout. */
    durationSecs?: number;
    /** Boolean indicating if this event message is enabled. */
    enabled: boolean;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnTimeoutSpecs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Collection of timeout specs to be returned from the server
 */
export interface ReturnTimeoutSpecs {
    inactivity: Hume.empathicVoice.ReturnTimeoutSpec;
    maxDuration: Hume.empathicVoice.ReturnTimeoutSpec;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnUserDefinedTool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A specific tool version returned from the server
 */
export interface ReturnUserDefinedTool {
    /** The timestamp when the first version of this tool was created. */
    createdOn: number;
    /** Text describing what the tool does. */
    description?: string;
    /** Text to use if the tool fails to generate content. */
    fallbackContent?: string;
    /** Identifier for a Tool. Formatted as a UUID. */
    id: string;
    /** The timestamp when this version of the tool was created. */
    modifiedOn: number;
    /** Name applied to all versions of a particular Tool. */
    name: string;
    /** Stringified JSON defining the parameters used by this version of the Tool. */
    parameters: string;
    toolType: Hume.empathicVoice.ReturnUserDefinedToolToolType;
    /** Version number for a Tool. Version numbers should be integers. The combination of configId and version number is unique. */
    version: number;
    /** Description that is appended to a specific version of a Tool. */
    versionDescription?: string;
    versionType: Hume.empathicVoice.ReturnUserDefinedToolVersionType;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnUserDefinedToolToolType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnUserDefinedToolToolType = {
    Builtin: "BUILTIN",
    Function: "FUNCTION",
} as const;
export type ReturnUserDefinedToolToolType =
    (typeof ReturnUserDefinedToolToolType)[keyof typeof ReturnUserDefinedToolToolType];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnUserDefinedToolVersionType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ReturnUserDefinedToolVersionType = {
    Fixed: "FIXED",
    Latest: "LATEST",
} as const;
export type ReturnUserDefinedToolVersionType =
    (typeof ReturnUserDefinedToolVersionType)[keyof typeof ReturnUserDefinedToolVersionType];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnVoice.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * An Octave voice available for text-to-speech
 */
export interface ReturnVoice {
    compatibleOctaveModels?: string[];
    /** ID of the voice in the `Voice Library`. */
    id: string;
    /** Name of the voice in the `Voice Library`. */
    name: string;
    provider: Hume.empathicVoice.VoiceProvider;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnWebhookEventType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/** Events this URL is subscribed to */
export const ReturnWebhookEventType = {
    ChatStarted: "chat_started",
    ChatEnded: "chat_ended",
    ToolCall: "tool_call",
} as const;
export type ReturnWebhookEventType = (typeof ReturnWebhookEventType)[keyof typeof ReturnWebhookEventType];

================================================================================
// File: src/api/resources/empathicVoice/types/ReturnWebhookSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Collection of webhook URL endpoints to be returned from the server
 */
export interface ReturnWebhookSpec {
    /** Events this URL is subscribed to */
    events: Hume.empathicVoice.ReturnWebhookEventType[];
    /** Webhook URL to send the event updates to */
    url: string;
}

================================================================================
// File: src/api/resources/empathicVoice/types/Role.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const Role = {
    Assistant: "assistant",
    System: "system",
    User: "user",
    All: "all",
    Tool: "tool",
    Context: "context",
} as const;
export type Role = (typeof Role)[keyof typeof Role];

================================================================================
// File: src/api/resources/empathicVoice/types/SessionSettings.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Settings for this chat session.
 */
export interface SessionSettings {
    /**
     * Configuration details for the audio input used during the session. Ensures the audio is being correctly set up for processing.
     *
     * This optional field is only required when the audio input is encoded in PCM Linear 16 (16-bit, little-endian, signed PCM WAV data). For detailed instructions on how to configure session settings for PCM Linear 16 audio, please refer to the [Session Settings section](/docs/empathic-voice-interface-evi/configuration#session-settings) on the EVI Configuration page.
     */
    audio?: Hume.empathicVoice.AudioConfiguration;
    /**
     * List of built-in tools to enable for the session.
     *
     * Tools are resources used by EVI to perform various tasks, such as searching the web or calling external APIs. Built-in tools, like web search, are natively integrated, while user-defined tools are created and invoked by the user. To learn more, see our [Tool Use Guide](/docs/empathic-voice-interface-evi/tool-use).
     *
     * Currently, the only built-in tool Hume provides is **Web Search**. When enabled, Web Search equips EVI with the ability to search the web for up-to-date information.
     */
    builtinTools?: Hume.empathicVoice.BuiltinToolConfig[];
    /**
     * Allows developers to inject additional context into the conversation, which is appended to the end of user messages for the session.
     *
     * When included in a Session Settings message, the provided context can be used to remind the LLM of its role in every user message, prevent it from forgetting important details, or add new relevant information to the conversation.
     *
     * Set to `null` to disable context injection.
     */
    context?: Hume.empathicVoice.Context;
    /**
     * Unique identifier for the session. Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions.
     *
     * If included, the response sent from Hume to your backend will include this ID. This allows you to correlate frontend users with their incoming messages.
     *
     * It is recommended to pass a `custom_session_id` if you are using a Custom Language Model. Please see our guide to [using a custom language model](/docs/empathic-voice-interface-evi/custom-language-model) with EVI to learn more.
     */
    customSessionId?: string;
    /**
     * Third party API key for the supplemental language model.
     *
     * When provided, EVI will use this key instead of Hume's API key for the supplemental LLM. This allows you to bypass rate limits and utilize your own API key as needed.
     */
    languageModelApiKey?: string;
    metadata?: Record<string, unknown>;
    /**
     * Instructions used to shape EVI's behavior, responses, and style for the session.
     *
     * When included in a Session Settings message, the provided Prompt overrides the existing one specified in the EVI configuration. If no Prompt was defined in the configuration, this Prompt will be the one used for the session.
     *
     * You can use the Prompt to define a specific goal or role for EVI, specifying how it should act or what it should focus on during the conversation. For example, EVI can be instructed to act as a customer support representative, a fitness coach, or a travel advisor, each with its own set of behaviors and response styles.
     *
     * For help writing a system prompt, see our [Prompting Guide](/docs/empathic-voice-interface-evi/prompting).
     */
    systemPrompt?: string;
    /**
     * List of user-defined tools to enable for the session.
     *
     * Tools are resources used by EVI to perform various tasks, such as searching the web or calling external APIs. Built-in tools, like web search, are natively integrated, while user-defined tools are created and invoked by the user. To learn more, see our [Tool Use Guide](/docs/empathic-voice-interface-evi/tool-use).
     */
    tools?: Hume.empathicVoice.Tool[];
    /**
     * The type of message sent through the socket; must be `session_settings` for our server to correctly identify and process it as a Session Settings message.
     *
     * Session settings are temporary and apply only to the current Chat session. These settings can be adjusted dynamically based on the requirements of each session to ensure optimal performance and user experience.
     *
     * For more information, please refer to the [Session Settings section](/docs/empathic-voice-interface-evi/configuration#session-settings) on the EVI Configuration page.
     */
    type: "session_settings";
    /** Dynamic values that can be used to populate EVI prompts. */
    variables?: Record<string, Hume.empathicVoice.SessionSettingsVariablesValue>;
    voiceId?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/types/SessionSettingsVariablesValue.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type SessionSettingsVariablesValue = string | number | boolean;

================================================================================
// File: src/api/resources/empathicVoice/types/SubscribeEvent.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type SubscribeEvent =
    | Hume.empathicVoice.AssistantEnd
    | Hume.empathicVoice.AssistantMessage
    | Hume.empathicVoice.AssistantProsody
    | Hume.empathicVoice.AudioOutput
    | Hume.empathicVoice.ChatMetadata
    | Hume.empathicVoice.WebSocketError
    | Hume.empathicVoice.UserInterruption
    | Hume.empathicVoice.UserMessage
    | Hume.empathicVoice.ToolCallMessage
    | Hume.empathicVoice.ToolResponseMessage
    | Hume.empathicVoice.ToolErrorMessage
    | Hume.empathicVoice.SessionSettings;

================================================================================
// File: src/api/resources/empathicVoice/types/Tool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface Tool {
    /** An optional description of what the tool does, used by the supplemental LLM to choose when and how to call the function. */
    description?: string;
    /** Optional text passed to the supplemental LLM if the tool call fails. The LLM then uses this text to generate a response back to the user, ensuring continuity in the conversation. */
    fallbackContent?: string;
    /** Name of the user-defined tool to be enabled. */
    name: string;
    /**
     * Parameters of the tool. Is a stringified JSON schema.
     *
     * These parameters define the inputs needed for the tool's execution, including the expected data type and description for each input field. Structured as a JSON schema, this format ensures the tool receives data in the expected format.
     */
    parameters: string;
    /** Type of tool. Set to `function` for user-defined tools. */
    type: Hume.empathicVoice.ToolType;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ToolCallMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * When provided, the output is a tool call.
 */
export interface ToolCallMessage {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Name of the tool called. */
    name: string;
    /** Parameters of the tool call. Is a stringified JSON schema. */
    parameters: string;
    /** Indicates whether a response to the tool call is required from the developer, either in the form of a [Tool Response message](/reference/empathic-voice-interface-evi/chat/chat#send.Tool%20Response%20Message.type) or a [Tool Error message](/reference/empathic-voice-interface-evi/chat/chat#send.Tool%20Error%20Message.type). */
    responseRequired: boolean;
    /**
     * The unique identifier for a specific tool call instance.
     *
     * This ID is used to track the request and response of a particular tool invocation, ensuring that the correct response is linked to the appropriate request.
     */
    toolCallId: string;
    /** Type of tool called. Either `builtin` for natively implemented tools, like web search, or `function` for user-defined tools. */
    toolType: Hume.empathicVoice.ToolType;
    /**
     * The type of message sent through the socket; for a Tool Call message, this must be `tool_call`.
     *
     * This message indicates that the supplemental LLM has detected a need to invoke the specified tool.
     */
    type: "tool_call";
}

================================================================================
// File: src/api/resources/empathicVoice/types/ToolErrorMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * When provided, the output is a function call error.
 */
export interface ToolErrorMessage {
    /** Error code. Identifies the type of error encountered. */
    code?: string;
    /** Optional text passed to the supplemental LLM in place of the tool call result. The LLM then uses this text to generate a response back to the user, ensuring continuity in the conversation if the tool errors. */
    content?: string;
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Error message from the tool call, not exposed to the LLM or user. */
    error: string;
    /** Indicates the severity of an error; for a Tool Error message, this must be `warn` to signal an unexpected event. */
    level?: Hume.empathicVoice.ErrorLevel;
    /**
     * The unique identifier for a specific tool call instance.
     *
     * This ID is used to track the request and response of a particular tool invocation, ensuring that the Tool Error message is linked to the appropriate tool call request. The specified `tool_call_id` must match the one received in the [Tool Call message](/reference/empathic-voice-interface-evi/chat/chat#receive.Tool%20Call%20Message.type).
     */
    toolCallId: string;
    /** Type of tool called. Either `builtin` for natively implemented tools, like web search, or `function` for user-defined tools. */
    toolType?: Hume.empathicVoice.ToolType;
    /**
     * The type of message sent through the socket; for a Tool Error message, this must be `tool_error`.
     *
     * Upon receiving a [Tool Call message](/reference/empathic-voice-interface-evi/chat/chat#receive.Tool%20Call%20Message.type) and failing to invoke the function, this message is sent to notify EVI of the tool's failure.
     */
    type: "tool_error";
}

================================================================================
// File: src/api/resources/empathicVoice/types/ToolResponseMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * When provided, the output is a function call response.
 */
export interface ToolResponseMessage {
    /** Return value of the tool call. Contains the output generated by the tool to pass back to EVI. */
    content: string;
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /**
     * The unique identifier for a specific tool call instance.
     *
     * This ID is used to track the request and response of a particular tool invocation, ensuring that the correct response is linked to the appropriate request. The specified `tool_call_id` must match the one received in the [Tool Call message](/reference/empathic-voice-interface-evi/chat/chat#receive.Tool%20Call%20Message.tool_call_id).
     */
    toolCallId: string;
    toolName?: string;
    toolType?: Hume.empathicVoice.ToolType;
    /**
     * The type of message sent through the socket; for a Tool Response message, this must be `tool_response`.
     *
     * Upon receiving a [Tool Call message](/reference/empathic-voice-interface-evi/chat/chat#receive.Tool%20Call%20Message.type) and successfully invoking the function, this message is sent to convey the result of the function call back to EVI.
     */
    type: "tool_response";
}

================================================================================
// File: src/api/resources/empathicVoice/types/ToolType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const ToolType = {
    Builtin: "builtin",
    Function: "function",
} as const;
export type ToolType = (typeof ToolType)[keyof typeof ToolType];

================================================================================
// File: src/api/resources/empathicVoice/types/UserInput.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * User text to insert into the conversation. Text sent through a User Input message is treated as the user's speech to EVI. EVI processes this input and provides a corresponding response.
 *
 * Expression measurement results are not available for User Input messages, as the prosody model relies on audio input and cannot process text alone.
 */
export interface UserInput {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /**
     * User text to insert into the conversation. Text sent through a User Input message is treated as the user's speech to EVI. EVI processes this input and provides a corresponding response.
     *
     * Expression measurement results are not available for User Input messages, as the prosody model relies on audio input and cannot process text alone.
     */
    text: string;
    /** The type of message sent through the socket; must be `user_input` for our server to correctly identify and process it as a User Input message. */
    type: "user_input";
}

================================================================================
// File: src/api/resources/empathicVoice/types/UserInterruption.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * When provided, the output is an interruption.
 */
export interface UserInterruption {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Unix timestamp of the detected user interruption. */
    time: number;
    /**
     * The type of message sent through the socket; for a User Interruption message, this must be `user_interruption`.
     *
     * This message indicates the user has interrupted the assistant's response. EVI detects the interruption in real-time and sends this message to signal the interruption event. This message allows the system to stop the current audio playback, clear the audio queue, and prepare to handle new user input.
     */
    type: "user_interruption";
}

================================================================================
// File: src/api/resources/empathicVoice/types/UserMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * When provided, the output is a user message.
 */
export interface UserMessage {
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Indicates if this message was inserted into the conversation as text from a [User Input](/reference/empathic-voice-interface-evi/chat/chat#send.User%20Input.text) message. */
    fromText: boolean;
    /** Indicates if this message contains an immediate and unfinalized transcript of the user's audio input. If it does, words may be repeated across successive UserMessage messages as our transcription model becomes more confident about what was said with additional context. Interim messages are useful to detect if the user is interrupting during audio playback on the client. Even without a finalized transcription, along with `UserInterrupt` messages, interim `UserMessages` are useful for detecting if the user is interrupting during audio playback on the client, signaling to stop playback in your application. */
    interim: boolean;
    /** Detected language of the message text. */
    language?: string;
    /** Transcript of the message. */
    message: Hume.empathicVoice.ChatMessage;
    /** Inference model results. */
    models: Hume.empathicVoice.Inference;
    /** Start and End time of user message. */
    time: Hume.empathicVoice.MillisecondInterval;
    type: "user_message";
}

================================================================================
// File: src/api/resources/empathicVoice/types/ValidationError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ValidationError {
    loc: Hume.empathicVoice.ValidationErrorLocItem[];
    msg: string;
    type: string;
}

================================================================================
// File: src/api/resources/empathicVoice/types/ValidationErrorLocItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type ValidationErrorLocItem = string | number;

================================================================================
// File: src/api/resources/empathicVoice/types/VoiceId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface VoiceId {
    /** The unique ID associated with the **Voice**. */
    id: string;
    /**
     * Specifies the source provider associated with the chosen voice.
     *
     * - **`HUME_AI`**: Select voices from Hume's [Voice Library](https://app.hume.ai/voices), containing a variety of preset, shared voices.
     * - **`CUSTOM_VOICE`**: Select from voices you've personally generated and saved in your account.
     *
     * If no provider is explicitly set, the default provider is `CUSTOM_VOICE`. When using voices from Hume's **Voice Library**, you must explicitly set the provider to `HUME_AI`.
     *
     * Preset voices from Hume's **Voice Library** are accessible by all users. In contrast, your custom voices are private and accessible only via requests authenticated with your API key.
     */
    provider?: Hume.empathicVoice.VoiceProvider;
}

================================================================================
// File: src/api/resources/empathicVoice/types/VoiceName.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface VoiceName {
    /** The name of a **Voice**. */
    name: string;
    /**
     * Specifies the source provider associated with the chosen voice.
     *
     * - **`HUME_AI`**: Select voices from Hume's [Voice Library](https://app.hume.ai/voices), containing a variety of preset, shared voices.
     * - **`CUSTOM_VOICE`**: Select from voices you've personally generated and saved in your account.
     *
     * If no provider is explicitly set, the default provider is `CUSTOM_VOICE`. When using voices from Hume's **Voice Library**, you must explicitly set the provider to `HUME_AI`.
     *
     * Preset voices from Hume's **Voice Library** are accessible by all users. In contrast, your custom voices are private and accessible only via requests authenticated with your API key.
     */
    provider?: Hume.empathicVoice.VoiceProvider;
}

================================================================================
// File: src/api/resources/empathicVoice/types/VoiceProvider.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const VoiceProvider = {
    HumeAi: "HUME_AI",
    CustomVoice: "CUSTOM_VOICE",
} as const;
export type VoiceProvider = (typeof VoiceProvider)[keyof typeof VoiceProvider];

================================================================================
// File: src/api/resources/empathicVoice/types/VoiceRef.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type VoiceRef = Hume.empathicVoice.VoiceId | Hume.empathicVoice.VoiceName;

================================================================================
// File: src/api/resources/empathicVoice/types/WebSocketError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * When provided, the output is an error message.
 */
export interface WebSocketError {
    /** Error code. Identifies the type of error encountered. */
    code: string;
    /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
    customSessionId?: string;
    /** Detailed description of the error. */
    message: string;
    /** ID of the initiating request. */
    requestId?: string;
    /** Short, human-readable identifier and description for the error. See a complete list of error slugs on the [Errors page](/docs/resources/errors). */
    slug: string;
    /**
     * The type of message sent through the socket; for a Web Socket Error message, this must be `error`.
     *
     * This message indicates a disruption in the WebSocket connection, such as an unexpected disconnection, protocol error, or data transmission issue.
     */
    type: "error";
}

================================================================================
// File: src/api/resources/empathicVoice/types/WebhookEvent.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type WebhookEvent =
    | Hume.empathicVoice.WebhookEventChatStarted
    | Hume.empathicVoice.WebhookEventChatEnded
    | Hume.empathicVoice.WebhookEventToolCall;

================================================================================
// File: src/api/resources/empathicVoice/types/WebhookEventBase.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * Represents the fields common to all webhook events.
 */
export interface WebhookEventBase {
    /** Unique ID of the **Chat Group** associated with the **Chat** session. */
    chatGroupId: string;
    /** Unique ID of the **Chat** session. */
    chatId: string;
    /** Unique ID of the EVI **Config** used for the session. */
    configId?: string;
}

================================================================================
// File: src/api/resources/empathicVoice/types/WebhookEventChatEnded.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface WebhookEventChatEnded extends Hume.empathicVoice.WebhookEventBase {
    /** Phone number of the caller in E.164 format (e.g., `+12223333333`). This field is included only if the Chat was created via the [Twilio phone calling](/docs/empathic-voice-interface-evi/phone-calling) integration. */
    callerNumber?: string;
    /** User-defined session ID. Relevant only when employing a [custom language model](/docs/empathic-voice-interface-evi/custom-language-model) in the EVI Config. */
    customSessionId?: string;
    /** Total duration of the session in seconds. */
    durationSeconds: number;
    /** Reason for the session's termination. */
    endReason: Hume.empathicVoice.WebhookEventChatStatus;
    /** Unix timestamp (in milliseconds) indicating when the session ended. */
    endTime: number;
    /** Always `chat_ended`. */
    eventName?: "chat_ended";
}

================================================================================
// File: src/api/resources/empathicVoice/types/WebhookEventChatStartType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const WebhookEventChatStartType = {
    NewChatGroup: "new_chat_group",
    ResumedChatGroup: "resumed_chat_group",
} as const;
export type WebhookEventChatStartType = (typeof WebhookEventChatStartType)[keyof typeof WebhookEventChatStartType];

================================================================================
// File: src/api/resources/empathicVoice/types/WebhookEventChatStarted.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface WebhookEventChatStarted extends Hume.empathicVoice.WebhookEventBase {
    /** Phone number of the caller in E.164 format (e.g., `+12223333333`). This field is included only if the Chat was created via the [Twilio phone calling](/docs/empathic-voice-interface-evi/phone-calling) integration. */
    callerNumber?: string;
    /** Indicates whether the chat is the first in a new Chat Group (`new_chat_group`) or the continuation of an existing chat group (`resumed_chat_group`). */
    chatStartType: Hume.empathicVoice.WebhookEventChatStartType;
    /** User-defined session ID. Relevant only when employing a [custom language model](/docs/empathic-voice-interface-evi/custom-language-model) in the EVI Config. */
    customSessionId?: string;
    /** Always `chat_started`. */
    eventName?: "chat_started";
    /** Unix timestamp (in milliseconds) indicating when the session started. */
    startTime: number;
}

================================================================================
// File: src/api/resources/empathicVoice/types/WebhookEventChatStatus.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const WebhookEventChatStatus = {
    Active: "ACTIVE",
    UserEnded: "USER_ENDED",
    UserTimeout: "USER_TIMEOUT",
    InactivityTimeout: "INACTIVITY_TIMEOUT",
    MaxDurationTimeout: "MAX_DURATION_TIMEOUT",
    SilenceTimeout: "SILENCE_TIMEOUT",
    Error: "ERROR",
} as const;
export type WebhookEventChatStatus = (typeof WebhookEventChatStatus)[keyof typeof WebhookEventChatStatus];

================================================================================
// File: src/api/resources/empathicVoice/types/WebhookEventToolCall.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface WebhookEventToolCall extends Hume.empathicVoice.WebhookEventBase {
    /** Phone number of the caller in E.164 format (e.g., `+12223333333`). This field is included only if the Chat was created via the [Twilio phone calling](/docs/empathic-voice-interface-evi/phone-calling) integration. */
    callerNumber?: string;
    /** User-defined session ID. Relevant only when employing a [custom language model](/docs/empathic-voice-interface-evi/custom-language-model) in the EVI Config. */
    customSessionId?: string;
    /** Always `tool_call`. */
    eventName?: "tool_call";
    /** Unix timestamp (in milliseconds) indicating when the tool call was triggered. */
    timestamp: number;
    /** The tool call. */
    toolCallMessage: Hume.empathicVoice.ToolCallMessage;
}

================================================================================
// File: src/api/resources/empathicVoice/types/index.ts
================================================================================
export * from "./AssistantEnd.js";
export * from "./AssistantInput.js";
export * from "./AssistantMessage.js";
export * from "./AssistantProsody.js";
export * from "./AudioConfiguration.js";
export * from "./AudioInput.js";
export * from "./AudioOutput.js";
export * from "./BuiltInTool.js";
export * from "./BuiltinToolConfig.js";
export * from "./ChatMessage.js";
export * from "./ChatMessageToolResult.js";
export * from "./ChatMetadata.js";
export * from "./ConnectSessionSettings.js";
export * from "./ConnectSessionSettingsAudio.js";
export * from "./ConnectSessionSettingsContext.js";
export * from "./ConnectSessionSettingsVariablesValue.js";
export * from "./Context.js";
export * from "./ContextType.js";
export * from "./ControlPlanePublishEvent.js";
export * from "./EmotionScores.js";
export * from "./Encoding.js";
export * from "./ErrorLevel.js";
export * from "./ErrorResponse.js";
export * from "./HttpValidationError.js";
export * from "./Inference.js";
export * from "./JsonMessage.js";
export * from "./LanguageModelType.js";
export * from "./MillisecondInterval.js";
export * from "./ModelProviderEnum.js";
export * from "./PauseAssistantMessage.js";
export * from "./PostedBuiltinTool.js";
export * from "./PostedBuiltinToolName.js";
export * from "./PostedConfigPromptSpec.js";
export * from "./PostedEllmModel.js";
export * from "./PostedEventMessageSpec.js";
export * from "./PostedEventMessageSpecs.js";
export * from "./PostedLanguageModel.js";
export * from "./PostedNudgeSpec.js";
export * from "./PostedTimeoutSpec.js";
export * from "./PostedTimeoutSpecs.js";
export * from "./PostedTimeoutSpecsInactivity.js";
export * from "./PostedTimeoutSpecsMaxDuration.js";
export * from "./PostedUserDefinedToolSpec.js";
export * from "./PostedWebhookEventType.js";
export * from "./PostedWebhookSpec.js";
export * from "./ProsodyInference.js";
export * from "./ResumeAssistantMessage.js";
export * from "./ReturnBuiltinTool.js";
export * from "./ReturnBuiltinToolToolType.js";
export * from "./ReturnChat.js";
export * from "./ReturnChatAudioReconstruction.js";
export * from "./ReturnChatAudioReconstructionStatus.js";
export * from "./ReturnChatEvent.js";
export * from "./ReturnChatEventRole.js";
export * from "./ReturnChatEventType.js";
export * from "./ReturnChatGroup.js";
export * from "./ReturnChatGroupPagedAudioReconstructions.js";
export * from "./ReturnChatGroupPagedAudioReconstructionsPaginationDirection.js";
export * from "./ReturnChatGroupPagedChats.js";
export * from "./ReturnChatGroupPagedChatsPaginationDirection.js";
export * from "./ReturnChatGroupPagedEvents.js";
export * from "./ReturnChatGroupPagedEventsPaginationDirection.js";
export * from "./ReturnChatPagedEvents.js";
export * from "./ReturnChatPagedEventsPaginationDirection.js";
export * from "./ReturnChatPagedEventsStatus.js";
export * from "./ReturnChatStatus.js";
export * from "./ReturnConfig.js";
export * from "./ReturnConfigSpec.js";
export * from "./ReturnEllmModel.js";
export * from "./ReturnEventMessageSpec.js";
export * from "./ReturnEventMessageSpecs.js";
export * from "./ReturnLanguageModel.js";
export * from "./ReturnNudgeSpec.js";
export * from "./ReturnPagedChatGroups.js";
export * from "./ReturnPagedChatGroupsPaginationDirection.js";
export * from "./ReturnPagedChats.js";
export * from "./ReturnPagedChatsPaginationDirection.js";
export * from "./ReturnPagedConfigs.js";
export * from "./ReturnPagedPrompts.js";
export * from "./ReturnPagedUserDefinedTools.js";
export * from "./ReturnPrompt.js";
export * from "./ReturnPromptVersionType.js";
export * from "./ReturnTimeoutSpec.js";
export * from "./ReturnTimeoutSpecs.js";
export * from "./ReturnUserDefinedTool.js";
export * from "./ReturnUserDefinedToolToolType.js";
export * from "./ReturnUserDefinedToolVersionType.js";
export * from "./ReturnVoice.js";
export * from "./ReturnWebhookEventType.js";
export * from "./ReturnWebhookSpec.js";
export * from "./Role.js";
export * from "./SessionSettings.js";
export * from "./SessionSettingsVariablesValue.js";
export * from "./SubscribeEvent.js";
export * from "./Tool.js";
export * from "./ToolCallMessage.js";
export * from "./ToolErrorMessage.js";
export * from "./ToolResponseMessage.js";
export * from "./ToolType.js";
export * from "./UserInput.js";
export * from "./UserInterruption.js";
export * from "./UserMessage.js";
export * from "./ValidationError.js";
export * from "./ValidationErrorLocItem.js";
export * from "./VoiceId.js";
export * from "./VoiceName.js";
export * from "./VoiceProvider.js";
export * from "./VoiceRef.js";
export * from "./WebhookEvent.js";
export * from "./WebhookEventBase.js";
export * from "./WebhookEventChatEnded.js";
export * from "./WebhookEventChatStarted.js";
export * from "./WebhookEventChatStartType.js";
export * from "./WebhookEventChatStatus.js";
export * from "./WebhookEventToolCall.js";
export * from "./WebSocketError.js";

================================================================================
// File: src/api/resources/expressionMeasurement/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { BatchClient } from "../resources/batch/client/Client.js";

export declare namespace ExpressionMeasurementClient {
    export type Options = BaseClientOptions;
}

export class ExpressionMeasurementClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ExpressionMeasurementClient.Options>;
    protected _batch: BatchClient | undefined;

    constructor(options: ExpressionMeasurementClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    public get batch(): BatchClient {
        return (this._batch ??= new BatchClient(this._options));
    }
}

================================================================================
// File: src/api/resources/expressionMeasurement/client/index.ts
================================================================================
export {};

================================================================================
// File: src/api/resources/expressionMeasurement/index.ts
================================================================================
export * from "./client/index.js";
export * from "./resources/index.js";

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import { toJson } from "../../../../../../core/json.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import type * as Hume from "../../../../../index.js";

export declare namespace BatchClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class BatchClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<BatchClient.Options>;

    constructor(options: BatchClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Sort and filter jobs.
     *
     * @param {Hume.expressionMeasurement.batch.BatchListJobsRequest} request
     * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.listJobs()
     */
    public listJobs(
        request: Hume.expressionMeasurement.batch.BatchListJobsRequest = {},
        requestOptions?: BatchClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.UnionJob[]> {
        return core.HttpResponsePromise.fromPromise(this.__listJobs(request, requestOptions));
    }

    private async __listJobs(
        request: Hume.expressionMeasurement.batch.BatchListJobsRequest = {},
        requestOptions?: BatchClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.UnionJob[]>> {
        const { limit, status, when, timestampMs, sortBy, direction } = request;
        const _queryParams: Record<string, unknown> = {
            limit,
            status: Array.isArray(status)
                ? status.map((item) =>
                      serializers.expressionMeasurement.batch.Status.jsonOrThrow(item, {
                          unrecognizedObjectKeys: "strip",
                          omitUndefined: true,
                      }),
                  )
                : status != null
                  ? serializers.expressionMeasurement.batch.Status.jsonOrThrow(status, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    })
                  : undefined,
            when:
                when != null
                    ? serializers.expressionMeasurement.batch.When.jsonOrThrow(when, {
                          unrecognizedObjectKeys: "strip",
                          omitUndefined: true,
                      })
                    : undefined,
            timestamp_ms: timestampMs,
            sort_by:
                sortBy != null
                    ? serializers.expressionMeasurement.batch.SortBy.jsonOrThrow(sortBy, {
                          unrecognizedObjectKeys: "strip",
                          omitUndefined: true,
                      })
                    : undefined,
            direction:
                direction != null
                    ? serializers.expressionMeasurement.batch.Direction.jsonOrThrow(direction, {
                          unrecognizedObjectKeys: "strip",
                          omitUndefined: true,
                      })
                    : undefined,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/batch/jobs",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.expressionMeasurement.batch.listJobs.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/batch/jobs");
    }

    /**
     * Start a new measurement inference job.
     *
     * @param {Hume.expressionMeasurement.batch.InferenceBaseRequest} request
     * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.startInferenceJob({
     *         urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
     *         notify: true
     *     })
     */
    public startInferenceJob(
        request: Hume.expressionMeasurement.batch.InferenceBaseRequest,
        requestOptions?: BatchClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.JobId> {
        return core.HttpResponsePromise.fromPromise(this.__startInferenceJob(request, requestOptions));
    }

    private async __startInferenceJob(
        request: Hume.expressionMeasurement.batch.InferenceBaseRequest,
        requestOptions?: BatchClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.JobId>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/batch/jobs",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.expressionMeasurement.batch.InferenceBaseRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.expressionMeasurement.batch.JobId.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/batch/jobs");
    }

    /**
     * Get the request details and state of a given job.
     *
     * @param {string} id - The unique identifier for the job.
     * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.getJobDetails("job_id")
     */
    public getJobDetails(
        id: string,
        requestOptions?: BatchClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.UnionJob> {
        return core.HttpResponsePromise.fromPromise(this.__getJobDetails(id, requestOptions));
    }

    private async __getJobDetails(
        id: string,
        requestOptions?: BatchClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.UnionJob>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/batch/jobs/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.expressionMeasurement.batch.UnionJob.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/batch/jobs/{id}");
    }

    /**
     * Get the JSON predictions of a completed inference job.
     *
     * @param {string} id - The unique identifier for the job.
     * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.getJobPredictions("job_id")
     */
    public getJobPredictions(
        id: string,
        requestOptions?: BatchClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.UnionPredictResult[]> {
        return core.HttpResponsePromise.fromPromise(this.__getJobPredictions(id, requestOptions));
    }

    private async __getJobPredictions(
        id: string,
        requestOptions?: BatchClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.UnionPredictResult[]>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/batch/jobs/${core.url.encodePathParam(id)}/predictions`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.expressionMeasurement.batch.getJobPredictions.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v0/batch/jobs/{id}/predictions",
        );
    }

    /**
     * Get the artifacts ZIP of a completed inference job.
     */
    public getJobArtifacts(
        id: string,
        requestOptions?: BatchClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getJobArtifacts(id, requestOptions));
    }

    private async __getJobArtifacts(
        id: string,
        requestOptions?: BatchClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/batch/jobs/${core.url.encodePathParam(id)}/artifacts`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/batch/jobs/{id}/artifacts");
    }

    /**
     * Start a new batch inference job.
     *
     * @param {Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest} request
     * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.expressionMeasurement.batch.startInferenceJobFromLocalFile({
     *         file: [fs.createReadStream("/path/to/your/file")]
     *     })
     */
    public startInferenceJobFromLocalFile(
        request: Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest,
        requestOptions?: BatchClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.JobId> {
        return core.HttpResponsePromise.fromPromise(this.__startInferenceJobFromLocalFile(request, requestOptions));
    }

    private async __startInferenceJobFromLocalFile(
        request: Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest,
        requestOptions?: BatchClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.JobId>> {
        const _body = await core.newFormData();
        if (request.json != null) {
            _body.append(
                "json",
                toJson(
                    serializers.expressionMeasurement.batch.InferenceBaseRequest.jsonOrThrow(request.json, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    }),
                ),
            );
        }

        for (const _file of request.file) {
            await _body.appendFile("file", _file);
        }

        const _maybeEncodedRequest = await _body.getRequest();
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ..._maybeEncodedRequest.headers }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/batch/jobs",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.expressionMeasurement.batch.JobId.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/batch/jobs");
    }
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/client/index.ts
================================================================================
export * from "./requests/index.js";

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/client/requests/BatchListJobsRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../index.js";

/**
 * @example
 *     {}
 */
export interface BatchListJobsRequest {
    /** The maximum number of jobs to include in the response. */
    limit?: number;
    /**
     * Include only jobs of this status in the response. There are four possible statuses:
     *
     * - `QUEUED`: The job has been received and is waiting to be processed.
     *
     * - `IN_PROGRESS`: The job is currently being processed.
     *
     * - `COMPLETED`: The job has finished processing.
     *
     * - `FAILED`: The job encountered an error and could not be completed successfully.
     */
    status?: Hume.expressionMeasurement.batch.Status | Hume.expressionMeasurement.batch.Status[];
    /** Specify whether to include jobs created before or after a given `timestamp_ms`. */
    when?: Hume.expressionMeasurement.batch.When;
    /**
     * Provide a timestamp in milliseconds to filter jobs.
     *
     *  When combined with the `when` parameter, you can filter jobs before or after the given timestamp. Defaults to the current Unix timestamp if one is not provided.
     */
    timestampMs?: number;
    /**
     * Specify which timestamp to sort the jobs by.
     *
     * - `created`: Sort jobs by the time of creation, indicated by `created_timestamp_ms`.
     *
     * - `started`: Sort jobs by the time processing started, indicated by `started_timestamp_ms`.
     *
     * - `ended`: Sort jobs by the time processing ended, indicated by `ended_timestamp_ms`.
     */
    sortBy?: Hume.expressionMeasurement.batch.SortBy;
    /**
     * Specify the order in which to sort the jobs. Defaults to descending order.
     *
     * - `asc`: Sort in ascending order (chronological, with the oldest records first).
     *
     * - `desc`: Sort in descending order (reverse-chronological, with the newest records first).
     */
    direction?: Hume.expressionMeasurement.batch.Direction;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/client/requests/BatchStartInferenceJobFromLocalFileRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../../../../core/index.js";
import type * as Hume from "../../../../../../index.js";

/**
 * @example
 *     {
 *         file: [fs.createReadStream("/path/to/your/file")]
 *     }
 */
export interface BatchStartInferenceJobFromLocalFileRequest {
    /** Stringified JSON object containing the inference job configuration. */
    json?: Hume.expressionMeasurement.batch.InferenceBaseRequest;
    /**
     * Local media files (see recommended input filetypes) to be processed.
     *
     * If you wish to supply more than 100 files, consider providing them as an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`).
     */
    file: core.file.Uploadable[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/client/requests/index.ts
================================================================================
export type { BatchListJobsRequest } from "./BatchListJobsRequest.js";
export type { BatchStartInferenceJobFromLocalFileRequest } from "./BatchStartInferenceJobFromLocalFileRequest.js";

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/index.ts
================================================================================
export * from "./client/index.js";
export * from "./types/index.js";

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Alternative.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type Alternative = "language_only";

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Bcp47Tag.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const Bcp47Tag = {
    Zh: "zh",
    Da: "da",
    Nl: "nl",
    En: "en",
    EnAu: "en-AU",
    EnIn: "en-IN",
    EnNz: "en-NZ",
    EnGb: "en-GB",
    Fr: "fr",
    FrCa: "fr-CA",
    De: "de",
    Hi: "hi",
    HiLatn: "hi-Latn",
    Id: "id",
    It: "it",
    Ja: "ja",
    Ko: "ko",
    No: "no",
    Pl: "pl",
    Pt: "pt",
    PtBr: "pt-BR",
    PtPt: "pt-PT",
    Ru: "ru",
    Es: "es",
    Es419: "es-419",
    Sv: "sv",
    Ta: "ta",
    Tr: "tr",
    Uk: "uk",
} as const;
export type Bcp47Tag = (typeof Bcp47Tag)[keyof typeof Bcp47Tag];

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/BoundingBox.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * A bounding box around a face.
 */
export interface BoundingBox {
    /** x-coordinate of bounding box top left corner. */
    x: number;
    /** y-coordinate of bounding box top left corner. */
    y: number;
    /** Bounding box width. */
    w: number;
    /** Bounding box height. */
    h: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/BurstPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface BurstPrediction {
    time: Hume.expressionMeasurement.batch.TimeInterval;
    /** A high-dimensional embedding in emotion space. */
    emotions: Hume.expressionMeasurement.batch.EmotionScore[];
    /** Modality-specific descriptive features and their scores. */
    descriptions: Hume.expressionMeasurement.batch.DescriptionsScore[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Classification.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type Classification = Record<string, unknown>;

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/CompletedEmbeddingGeneration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface CompletedEmbeddingGeneration {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
    /** When this job started (Unix timestamp in milliseconds). */
    startedTimestampMs: number;
    /** When this job ended (Unix timestamp in milliseconds). */
    endedTimestampMs: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/CompletedInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface CompletedInference {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
    /** When this job started (Unix timestamp in milliseconds). */
    startedTimestampMs: number;
    /** When this job ended (Unix timestamp in milliseconds). */
    endedTimestampMs: number;
    /** The number of predictions that were generated by this job. */
    numPredictions: number;
    /** The number of errors that occurred while running this job. */
    numErrors: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/CompletedState.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface CompletedState extends Hume.expressionMeasurement.batch.CompletedInference {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/CompletedTlInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface CompletedTlInference {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
    /** When this job started (Unix timestamp in milliseconds). */
    startedTimestampMs: number;
    /** When this job ended (Unix timestamp in milliseconds). */
    endedTimestampMs: number;
    /** The number of predictions that were generated by this job. */
    numPredictions: number;
    /** The number of errors that occurred while running this job. */
    numErrors: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/CompletedTraining.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface CompletedTraining {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
    /** When this job started (Unix timestamp in milliseconds). */
    startedTimestampMs: number;
    /** When this job ended (Unix timestamp in milliseconds). */
    endedTimestampMs: number;
    customModel: Hume.expressionMeasurement.batch.TrainingCustomModel;
    alternatives?: Record<string, Hume.expressionMeasurement.batch.TrainingCustomModel>;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type CustomModel =
    | Hume.expressionMeasurement.batch.CustomModelId
    | Hume.expressionMeasurement.batch.CustomModelVersionId;

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModelId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface CustomModelId {
    id: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModelPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface CustomModelPrediction {
    output: Record<string, number>;
    error: string;
    taskType: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModelRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface CustomModelRequest {
    name: string;
    description?: string;
    tags?: Hume.expressionMeasurement.batch.Tag[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModelVersionId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface CustomModelVersionId {
    versionId: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModelsInferenceJob.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface CustomModelsInferenceJob extends Hume.expressionMeasurement.batch.JobTlInference {
    type: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModelsTrainingJob.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface CustomModelsTrainingJob extends Hume.expressionMeasurement.batch.JobTraining {
    type: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Dataset.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type Dataset = Hume.expressionMeasurement.batch.DatasetId | Hume.expressionMeasurement.batch.DatasetVersionId;

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/DatasetId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface DatasetId {
    id: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/DatasetVersionId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface DatasetVersionId {
    versionId: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Direction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const Direction = {
    Asc: "asc",
    Desc: "desc",
} as const;
export type Direction = (typeof Direction)[keyof typeof Direction];

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/EmbeddingGenerationBaseRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface EmbeddingGenerationBaseRequest {
    /** File ID and File URL pairs for an asset registry file */
    registryFileDetails?: Hume.expressionMeasurement.batch.RegistryFileDetail[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/EmbeddingGenerationJob.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface EmbeddingGenerationJob extends Hume.expressionMeasurement.batch.JobEmbeddingGeneration {
    type: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Error_.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface Error_ {
    /** An error message. */
    message: string;
    /** A file path relative to the top level source URL or file. */
    file: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/EvaluationArgs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface EvaluationArgs {
    validation?: Hume.expressionMeasurement.batch.ValidationArgs;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Face.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * The Facial Emotional Expression model analyzes human facial expressions in images and videos. Results will be provided per frame for video files.
 *
 * Recommended input file types: `.png`, `.jpeg`, `.mp4`
 */
export interface Face {
    /** Number of frames per second to process. Other frames will be omitted from the response. Set to `0` to process every frame. */
    fpsPred?: number;
    /** Face detection probability threshold. Faces detected with a probability less than this threshold will be omitted from the response. */
    probThreshold?: number;
    /** Whether to return identifiers for faces across frames. If `true`, unique identifiers will be assigned to face bounding boxes to differentiate different faces. If `false`, all faces will be tagged with an `unknown` ID. */
    identifyFaces?: boolean;
    /** Minimum bounding box side length in pixels to treat as a face. Faces detected with a bounding box side length in pixels less than this threshold will be omitted from the response. */
    minFaceSize?: number;
    facs?: Hume.expressionMeasurement.batch.Unconfigurable;
    descriptions?: Hume.expressionMeasurement.batch.Unconfigurable;
    /** Whether to extract and save the detected faces in the artifacts zip created by each job. */
    saveFaces?: boolean;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/FacePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface FacePrediction {
    /** Frame number */
    frame: number;
    /** Time in seconds when face detection occurred. */
    time: number;
    /** The predicted probability that a detected face was actually a face. */
    prob: number;
    box: Hume.expressionMeasurement.batch.BoundingBox;
    /** A high-dimensional embedding in emotion space. */
    emotions: Hume.expressionMeasurement.batch.EmotionScore[];
    /** FACS 2.0 features and their scores. */
    facs?: Hume.expressionMeasurement.batch.FacsScore[];
    /** Modality-specific descriptive features and their scores. */
    descriptions?: Hume.expressionMeasurement.batch.DescriptionsScore[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/FacemeshPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface FacemeshPrediction {
    /** A high-dimensional embedding in emotion space. */
    emotions: Hume.expressionMeasurement.batch.EmotionScore[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Failed.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface Failed {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
    /** When this job started (Unix timestamp in milliseconds). */
    startedTimestampMs: number;
    /** When this job ended (Unix timestamp in milliseconds). */
    endedTimestampMs: number;
    /** An error message. */
    message: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/FailedState.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface FailedState extends Hume.expressionMeasurement.batch.Failed {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/File_.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * The list of files submitted for analysis.
 */
export interface File_ {
    /** The name of the file. */
    filename?: string;
    /** The content type of the file. */
    contentType?: string;
    /** The MD5 checksum of the file. */
    md5Sum: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Granularity.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * The granularity at which to generate predictions. The `granularity` field is ignored if transcription is not enabled or if the `window` field has been set.
 *
 * - `word`: At the word level, our model provides a separate output for each word, offering the most granular insight into emotional expression during speech.
 *
 * - `sentence`: At the sentence level of granularity, we annotate the emotional tone of each spoken sentence with our Prosody and Emotional Language models.
 *
 * - `utterance`: Utterance-level granularity is between word- and sentence-level. It takes into account natural pauses or breaks in speech, providing more rapidly updated measures of emotional expression within a flowing conversation. For text inputs, utterance-level granularity will produce results identical to sentence-level granularity.
 *
 * - `conversational_turn`: Conversational turn-level granularity provides a distinct output for each change in speaker. It captures the full sequence of words and sentences spoken uninterrupted by each person. This approach provides a higher-level view of the emotional dynamics in a multi-participant dialogue. For text inputs, specifying conversational turn-level granularity for our Emotional Language model will produce results for the entire passage.
 */
export const Granularity = {
    Word: "word",
    Sentence: "sentence",
    Utterance: "utterance",
    ConversationalTurn: "conversational_turn",
} as const;
export type Granularity = (typeof Granularity)[keyof typeof Granularity];

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsBurstPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface GroupedPredictionsBurstPrediction {
    /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
    id: string;
    predictions: Hume.expressionMeasurement.batch.BurstPrediction[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsFacePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface GroupedPredictionsFacePrediction {
    /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
    id: string;
    predictions: Hume.expressionMeasurement.batch.FacePrediction[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsFacemeshPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface GroupedPredictionsFacemeshPrediction {
    /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
    id: string;
    predictions: Hume.expressionMeasurement.batch.FacemeshPrediction[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsLanguagePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface GroupedPredictionsLanguagePrediction {
    /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
    id: string;
    predictions: Hume.expressionMeasurement.batch.LanguagePrediction[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsNerPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface GroupedPredictionsNerPrediction {
    /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
    id: string;
    predictions: Hume.expressionMeasurement.batch.NerPrediction[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsProsodyPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface GroupedPredictionsProsodyPrediction {
    /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
    id: string;
    predictions: Hume.expressionMeasurement.batch.ProsodyPrediction[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/InProgress.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface InProgress {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
    /** When this job started (Unix timestamp in milliseconds). */
    startedTimestampMs: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/InProgressState.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InProgressState extends Hume.expressionMeasurement.batch.InProgress {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/InferenceBaseRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InferenceBaseRequest {
    /**
     * Specify the models to use for inference.
     *
     * If this field is not explicitly set, then all models will run by default.
     */
    models?: Hume.expressionMeasurement.batch.Models;
    transcription?: Hume.expressionMeasurement.batch.Transcription;
    /**
     * URLs to the media files to be processed. Each must be a valid public URL to a media file (see recommended input filetypes) or an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`) of media files.
     *
     * If you wish to supply more than 100 URLs, consider providing them as an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`).
     */
    urls?: string[];
    /** Text supplied directly to our Emotional Language and NER models for analysis. */
    text?: string[];
    /** If provided, a `POST` request will be made to the URL with the generated predictions on completion or the error message on failure. */
    callbackUrl?: string;
    /** Whether to send an email notification to the user upon job completion/failure. */
    notify?: boolean;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/InferenceJob.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InferenceJob extends Hume.expressionMeasurement.batch.JobInference {
    /**
     * Denotes the job type.
     *
     * Jobs created with the Expression Measurement API will have this field set to `INFERENCE`.
     */
    type: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/InferencePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InferencePrediction {
    /** A file path relative to the top level source URL or file. */
    file: string;
    models: Hume.expressionMeasurement.batch.ModelsPredictions;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/InferenceRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InferenceRequest {
    models?: Hume.expressionMeasurement.batch.Models;
    transcription?: Hume.expressionMeasurement.batch.Transcription;
    /**
     * URLs to the media files to be processed. Each must be a valid public URL to a media file (see recommended input filetypes) or an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`) of media files.
     *
     * If you wish to supply more than 100 URLs, consider providing them as an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`).
     */
    urls?: string[];
    /** Text to supply directly to our language and NER models. */
    text?: string[];
    /** If provided, a `POST` request will be made to the URL with the generated predictions on completion or the error message on failure. */
    callbackUrl?: string;
    /** Whether to send an email notification to the user upon job completion/failure. */
    notify?: boolean;
    files: Hume.expressionMeasurement.batch.File_[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/InferenceResults.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InferenceResults {
    predictions: Hume.expressionMeasurement.batch.InferencePrediction[];
    errors: Hume.expressionMeasurement.batch.Error_[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/InferenceSourcePredictResult.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface InferenceSourcePredictResult {
    source: Hume.expressionMeasurement.batch.Source;
    results?: Hume.expressionMeasurement.batch.InferenceResults;
    /** An error message. */
    error?: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/JobEmbeddingGeneration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface JobEmbeddingGeneration {
    /** The ID associated with this job. */
    jobId: string;
    userId: string;
    request: Hume.expressionMeasurement.batch.EmbeddingGenerationBaseRequest;
    state: Hume.expressionMeasurement.batch.StateEmbeddingGeneration;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/JobId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface JobId {
    /** The ID of the started job. */
    jobId: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/JobInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface JobInference {
    /** The ID associated with this job. */
    jobId: string;
    /** The request that initiated the job. */
    request: Hume.expressionMeasurement.batch.InferenceRequest;
    /** The current state of the job. */
    state: Hume.expressionMeasurement.batch.StateInference;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/JobTlInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface JobTlInference {
    /** The ID associated with this job. */
    jobId: string;
    userId: string;
    request: Hume.expressionMeasurement.batch.TlInferenceBaseRequest;
    state: Hume.expressionMeasurement.batch.StateTlInference;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/JobTraining.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface JobTraining {
    /** The ID associated with this job. */
    jobId: string;
    userId: string;
    request: Hume.expressionMeasurement.batch.TrainingBaseRequest;
    state: Hume.expressionMeasurement.batch.StateTraining;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Language.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * The Emotional Language model analyzes passages of text. This also supports audio and video files by transcribing and then directly analyzing the transcribed text.
 *
 * Recommended input filetypes: `.txt`, `.mp3`, `.wav`, `.mp4`
 */
export interface Language {
    granularity?: Hume.expressionMeasurement.batch.Granularity;
    sentiment?: Hume.expressionMeasurement.batch.Unconfigurable;
    toxicity?: Hume.expressionMeasurement.batch.Unconfigurable;
    /** Whether to return identifiers for speakers over time. If `true`, unique identifiers will be assigned to spoken words to differentiate different speakers. If `false`, all speakers will be tagged with an `unknown` ID. */
    identifySpeakers?: boolean;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/LanguagePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface LanguagePrediction {
    /** A segment of text (like a word or a sentence). */
    text: string;
    position: Hume.expressionMeasurement.batch.PositionInterval;
    time?: Hume.expressionMeasurement.batch.TimeInterval;
    /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence in this text. */
    confidence?: number;
    /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence that this text was spoken by this speaker. */
    speakerConfidence?: number;
    /** A high-dimensional embedding in emotion space. */
    emotions: Hume.expressionMeasurement.batch.EmotionScore[];
    /**
     * Sentiment predictions returned as a distribution. This model predicts the probability that a given text could be interpreted as having each sentiment level from `1` (negative) to `9` (positive).
     *
     * Compared to returning one estimate of sentiment, this enables a more nuanced analysis of a text's meaning. For example, a text with very neutral sentiment would have an average rating of `5`. But also a text that could be interpreted as having very positive sentiment or very negative sentiment would also have an average rating of `5`. The average sentiment is less informative than the distribution over sentiment, so this API returns a value for each sentiment level.
     */
    sentiment?: Hume.expressionMeasurement.batch.SentimentScore[];
    /** Toxicity predictions returned as probabilities that the text can be classified into the following categories: `toxic`, `severe_toxic`, `obscene`, `threat`, `insult`, and `identity_hate`. */
    toxicity?: Hume.expressionMeasurement.batch.ToxicityScore[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Models.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * The models used for inference.
 */
export interface Models {
    face?: Hume.expressionMeasurement.batch.Face;
    burst?: Hume.expressionMeasurement.batch.Unconfigurable;
    prosody?: Hume.expressionMeasurement.batch.Prosody;
    language?: Hume.expressionMeasurement.batch.Language;
    ner?: Hume.expressionMeasurement.batch.Ner;
    facemesh?: Hume.expressionMeasurement.batch.Unconfigurable;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/ModelsPredictions.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface ModelsPredictions {
    face?: Hume.expressionMeasurement.batch.PredictionsOptionalNullFacePrediction;
    burst?: Hume.expressionMeasurement.batch.PredictionsOptionalNullBurstPrediction;
    prosody?: Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataProsodyPrediction;
    language?: Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataLanguagePrediction;
    ner?: Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataNerPrediction;
    facemesh?: Hume.expressionMeasurement.batch.PredictionsOptionalNullFacemeshPrediction;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Ner.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * The NER (Named-entity Recognition) model identifies real-world objects and concepts in passages of text. This also supports audio and video files by transcribing and then directly analyzing the transcribed text.
 *
 * Recommended input filetypes: `.txt`, `.mp3`, `.wav`, `.mp4`
 */
export interface Ner {
    /** Whether to return identifiers for speakers over time. If `true`, unique identifiers will be assigned to spoken words to differentiate different speakers. If `false`, all speakers will be tagged with an `unknown` ID. */
    identifySpeakers?: boolean;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/NerPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface NerPrediction {
    /** The recognized topic or entity. */
    entity: string;
    position: Hume.expressionMeasurement.batch.PositionInterval;
    /** Our NER model's relative confidence in the recognized topic or entity. */
    entityConfidence: number;
    /** A measure of how often the entity is linked to by other entities. */
    support: number;
    /** A URL which provides more information about the recognized topic or entity. */
    uri: string;
    /** The specific word to which the emotion predictions are linked. */
    linkWord: string;
    time?: Hume.expressionMeasurement.batch.TimeInterval;
    /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence in this text. */
    confidence?: number;
    /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence that this text was spoken by this speaker. */
    speakerConfidence?: number;
    /** A high-dimensional embedding in emotion space. */
    emotions: Hume.expressionMeasurement.batch.EmotionScore[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Null.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * No associated metadata for this model. Value will be `null`.
 */
export type Null = Record<string, unknown>;

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/PositionInterval.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * Position of a segment of text within a larger document, measured in characters. Uses zero-based indexing. The beginning index is inclusive and the end index is exclusive.
 */
export interface PositionInterval {
    /** The index of the first character in the text segment, inclusive. */
    begin: number;
    /** The index of the last character in the text segment, exclusive. */
    end: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullBurstPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface PredictionsOptionalNullBurstPrediction {
    metadata?: Hume.expressionMeasurement.batch.Null;
    groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsBurstPrediction[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullFacePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface PredictionsOptionalNullFacePrediction {
    metadata?: Hume.expressionMeasurement.batch.Null;
    groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsFacePrediction[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullFacemeshPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface PredictionsOptionalNullFacemeshPrediction {
    metadata?: Hume.expressionMeasurement.batch.Null;
    groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsFacemeshPrediction[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataLanguagePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface PredictionsOptionalTranscriptionMetadataLanguagePrediction {
    metadata?: Hume.expressionMeasurement.batch.TranscriptionMetadata;
    groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsLanguagePrediction[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataNerPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface PredictionsOptionalTranscriptionMetadataNerPrediction {
    metadata?: Hume.expressionMeasurement.batch.TranscriptionMetadata;
    groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsNerPrediction[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataProsodyPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface PredictionsOptionalTranscriptionMetadataProsodyPrediction {
    metadata?: Hume.expressionMeasurement.batch.TranscriptionMetadata;
    groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsProsodyPrediction[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Prosody.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * The Speech Prosody model analyzes the intonation, stress, and rhythm of spoken word.
 *
 * Recommended input file types: `.wav`, `.mp3`, `.mp4`
 */
export interface Prosody {
    granularity?: Hume.expressionMeasurement.batch.Granularity;
    window?: Hume.expressionMeasurement.batch.Window;
    /** Whether to return identifiers for speakers over time. If `true`, unique identifiers will be assigned to spoken words to differentiate different speakers. If `false`, all speakers will be tagged with an `unknown` ID. */
    identifySpeakers?: boolean;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/ProsodyPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface ProsodyPrediction {
    /** A segment of text (like a word or a sentence). */
    text?: string;
    time: Hume.expressionMeasurement.batch.TimeInterval;
    /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence in this text. */
    confidence?: number;
    /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence that this text was spoken by this speaker. */
    speakerConfidence?: number;
    /** A high-dimensional embedding in emotion space. */
    emotions: Hume.expressionMeasurement.batch.EmotionScore[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Queued.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface Queued {
    /** When this job was created (Unix timestamp in milliseconds). */
    createdTimestampMs: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/QueuedState.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface QueuedState extends Hume.expressionMeasurement.batch.Queued {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/RegistryFileDetail.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface RegistryFileDetail {
    /** File ID in the Asset Registry */
    fileId: string;
    /** URL to the file in the Asset Registry */
    fileUrl: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Regression.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type Regression = Record<string, unknown>;

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/SortBy.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const SortBy = {
    Created: "created",
    Started: "started",
    Ended: "ended",
} as const;
export type SortBy = (typeof SortBy)[keyof typeof SortBy];

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Source.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type Source =
    | Hume.expressionMeasurement.batch.Source.Url
    | Hume.expressionMeasurement.batch.Source.File_
    | Hume.expressionMeasurement.batch.Source.Text;

export namespace Source {
    export interface Url extends Hume.expressionMeasurement.batch.SourceUrl {
        type: "url";
    }

    export interface File_ extends Hume.expressionMeasurement.batch.SourceFile {
        type: "file";
    }

    export interface Text extends Hume.expressionMeasurement.batch.SourceTextSource {
        type: "text";
    }
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/SourceFile.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface SourceFile extends Hume.expressionMeasurement.batch.File_ {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/SourceTextSource.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type SourceTextSource = {};

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/SourceUrl.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface SourceUrl extends Hume.expressionMeasurement.batch.Url {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGeneration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type StateEmbeddingGeneration =
    | Hume.expressionMeasurement.batch.StateEmbeddingGeneration.Queued
    | Hume.expressionMeasurement.batch.StateEmbeddingGeneration.InProgress
    | Hume.expressionMeasurement.batch.StateEmbeddingGeneration.Completed
    | Hume.expressionMeasurement.batch.StateEmbeddingGeneration.Failed;

export namespace StateEmbeddingGeneration {
    export interface Queued extends Hume.expressionMeasurement.batch.StateEmbeddingGenerationQueued {
        status: "QUEUED";
    }

    export interface InProgress extends Hume.expressionMeasurement.batch.StateEmbeddingGenerationInProgress {
        status: "IN_PROGRESS";
    }

    export interface Completed
        extends Hume.expressionMeasurement.batch.StateEmbeddingGenerationCompletedEmbeddingGeneration {
        status: "COMPLETED";
    }

    export interface Failed extends Hume.expressionMeasurement.batch.StateEmbeddingGenerationFailed {
        status: "FAILED";
    }
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationCompletedEmbeddingGeneration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateEmbeddingGenerationCompletedEmbeddingGeneration
    extends Hume.expressionMeasurement.batch.CompletedEmbeddingGeneration {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationFailed.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateEmbeddingGenerationFailed extends Hume.expressionMeasurement.batch.Failed {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationInProgress.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateEmbeddingGenerationInProgress extends Hume.expressionMeasurement.batch.InProgress {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationQueued.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateEmbeddingGenerationQueued extends Hume.expressionMeasurement.batch.Queued {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type StateInference =
    | Hume.expressionMeasurement.batch.StateInference.Queued
    | Hume.expressionMeasurement.batch.StateInference.InProgress
    | Hume.expressionMeasurement.batch.StateInference.Completed
    | Hume.expressionMeasurement.batch.StateInference.Failed;

export namespace StateInference {
    export interface Queued extends Hume.expressionMeasurement.batch.QueuedState {
        status: "QUEUED";
    }

    export interface InProgress extends Hume.expressionMeasurement.batch.InProgressState {
        status: "IN_PROGRESS";
    }

    export interface Completed extends Hume.expressionMeasurement.batch.CompletedState {
        status: "COMPLETED";
    }

    export interface Failed extends Hume.expressionMeasurement.batch.FailedState {
        status: "FAILED";
    }
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateTlInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type StateTlInference =
    | Hume.expressionMeasurement.batch.StateTlInference.Queued
    | Hume.expressionMeasurement.batch.StateTlInference.InProgress
    | Hume.expressionMeasurement.batch.StateTlInference.Completed
    | Hume.expressionMeasurement.batch.StateTlInference.Failed;

export namespace StateTlInference {
    export interface Queued extends Hume.expressionMeasurement.batch.StateTlInferenceQueued {
        status: "QUEUED";
    }

    export interface InProgress extends Hume.expressionMeasurement.batch.StateTlInferenceInProgress {
        status: "IN_PROGRESS";
    }

    export interface Completed extends Hume.expressionMeasurement.batch.StateTlInferenceCompletedTlInference {
        status: "COMPLETED";
    }

    export interface Failed extends Hume.expressionMeasurement.batch.StateTlInferenceFailed {
        status: "FAILED";
    }
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateTlInferenceCompletedTlInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTlInferenceCompletedTlInference extends Hume.expressionMeasurement.batch.CompletedTlInference {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateTlInferenceFailed.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTlInferenceFailed extends Hume.expressionMeasurement.batch.Failed {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateTlInferenceInProgress.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTlInferenceInProgress extends Hume.expressionMeasurement.batch.InProgress {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateTlInferenceQueued.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTlInferenceQueued extends Hume.expressionMeasurement.batch.Queued {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateTraining.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type StateTraining =
    | Hume.expressionMeasurement.batch.StateTraining.Queued
    | Hume.expressionMeasurement.batch.StateTraining.InProgress
    | Hume.expressionMeasurement.batch.StateTraining.Completed
    | Hume.expressionMeasurement.batch.StateTraining.Failed;

export namespace StateTraining {
    export interface Queued extends Hume.expressionMeasurement.batch.StateTrainingQueued {
        status: "QUEUED";
    }

    export interface InProgress extends Hume.expressionMeasurement.batch.StateTrainingInProgress {
        status: "IN_PROGRESS";
    }

    export interface Completed extends Hume.expressionMeasurement.batch.StateTrainingCompletedTraining {
        status: "COMPLETED";
    }

    export interface Failed extends Hume.expressionMeasurement.batch.StateTrainingFailed {
        status: "FAILED";
    }
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateTrainingCompletedTraining.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTrainingCompletedTraining extends Hume.expressionMeasurement.batch.CompletedTraining {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateTrainingFailed.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTrainingFailed extends Hume.expressionMeasurement.batch.Failed {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateTrainingInProgress.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTrainingInProgress extends Hume.expressionMeasurement.batch.InProgress {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/StateTrainingQueued.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface StateTrainingQueued extends Hume.expressionMeasurement.batch.Queued {}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Status.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const Status = {
    Queued: "QUEUED",
    InProgress: "IN_PROGRESS",
    Completed: "COMPLETED",
    Failed: "FAILED",
} as const;
export type Status = (typeof Status)[keyof typeof Status];

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Tag.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface Tag {
    key: string;
    value: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Target.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type Target = number | number | string;

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Task.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type Task =
    | Hume.expressionMeasurement.batch.Task.Classification
    | Hume.expressionMeasurement.batch.Task.Regression;

export namespace Task {
    export interface Classification extends Hume.expressionMeasurement.batch.TaskClassification {
        type: "classification";
    }

    export interface Regression extends Hume.expressionMeasurement.batch.TaskRegression {
        type: "regression";
    }
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/TaskClassification.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type TaskClassification = {};

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/TaskRegression.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type TaskRegression = {};

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/TextSource.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type TextSource = Record<string, unknown>;

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/TimeInterval.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * A time range with a beginning and end, measured in seconds.
 */
export interface TimeInterval {
    /** Beginning of time range in seconds. */
    begin: number;
    /** End of time range in seconds. */
    end: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/TlInferenceBaseRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface TlInferenceBaseRequest {
    customModel: Hume.expressionMeasurement.batch.CustomModel;
    /**
     * URLs to the media files to be processed. Each must be a valid public URL to a media file (see recommended input filetypes) or an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`) of media files.
     *
     * If you wish to supply more than 100 URLs, consider providing them as an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`).
     */
    urls?: string[];
    /** If provided, a `POST` request will be made to the URL with the generated predictions on completion or the error message on failure. */
    callbackUrl?: string;
    /** Whether to send an email notification to the user upon job completion/failure. */
    notify?: boolean;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/TlInferencePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface TlInferencePrediction {
    /** A file path relative to the top level source URL or file. */
    file: string;
    fileType: string;
    customModels: Record<string, Hume.expressionMeasurement.batch.CustomModelPrediction>;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/TlInferenceResults.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface TlInferenceResults {
    predictions: Hume.expressionMeasurement.batch.TlInferencePrediction[];
    errors: Hume.expressionMeasurement.batch.Error_[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/TlInferenceSourcePredictResult.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface TlInferenceSourcePredictResult {
    source: Hume.expressionMeasurement.batch.Source;
    results?: Hume.expressionMeasurement.batch.TlInferenceResults;
    /** An error message. */
    error?: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/TrainingBaseRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface TrainingBaseRequest {
    customModel: Hume.expressionMeasurement.batch.CustomModelRequest;
    dataset: Hume.expressionMeasurement.batch.Dataset;
    targetFeature?: string;
    task?: Hume.expressionMeasurement.batch.Task;
    evaluation?: Hume.expressionMeasurement.batch.EvaluationArgs;
    alternatives?: Hume.expressionMeasurement.batch.Alternative[];
    callbackUrl?: string;
    notify?: boolean;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/TrainingCustomModel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface TrainingCustomModel {
    id: string;
    versionId?: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Transcription.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * Transcription-related configuration options.
 *
 * To disable transcription, explicitly set this field to `null`.
 */
export interface Transcription {
    /**
     * By default, we use an automated language detection method for our Speech Prosody, Language, and NER models. However, if you know what language is being spoken in your media samples, you can specify it via its BCP-47 tag and potentially obtain more accurate results.
     *
     * You can specify any of the following languages:
     * - Chinese: `zh`
     * - Danish: `da`
     * - Dutch: `nl`
     * - English: `en`
     * - English (Australia): `en-AU`
     * - English (India): `en-IN`
     * - English (New Zealand): `en-NZ`
     * - English (United Kingdom): `en-GB`
     * - French: `fr`
     * - French (Canada): `fr-CA`
     * - German: `de`
     * - Hindi: `hi`
     * - Hindi (Roman Script): `hi-Latn`
     * - Indonesian: `id`
     * - Italian: `it`
     * - Japanese: `ja`
     * - Korean: `ko`
     * - Norwegian: `no`
     * - Polish: `pl`
     * - Portuguese: `pt`
     * - Portuguese (Brazil): `pt-BR`
     * - Portuguese (Portugal): `pt-PT`
     * - Russian: `ru`
     * - Spanish: `es`
     * - Spanish (Latin America): `es-419`
     * - Swedish: `sv`
     * - Tamil: `ta`
     * - Turkish: `tr`
     * - Ukrainian: `uk`
     */
    language?: Hume.expressionMeasurement.batch.Bcp47Tag;
    /** Whether to return identifiers for speakers over time. If `true`, unique identifiers will be assigned to spoken words to differentiate different speakers. If `false`, all speakers will be tagged with an `unknown` ID. */
    identifySpeakers?: boolean;
    /** Transcript confidence threshold. Transcripts generated with a confidence less than this threshold will be considered invalid and not used as an input for model inference. */
    confidenceThreshold?: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/TranscriptionMetadata.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * Transcription metadata for your media file.
 */
export interface TranscriptionMetadata {
    /** Value between `0.0` and `1.0` indicating our transcription model's relative confidence in the transcription of your media file. */
    confidence: number;
    detectedLanguage?: Hume.expressionMeasurement.batch.Bcp47Tag;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Type.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const Type = {
    EmbeddingGeneration: "EMBEDDING_GENERATION",
    Inference: "INFERENCE",
    TlInference: "TL_INFERENCE",
    Training: "TRAINING",
} as const;
export type Type = (typeof Type)[keyof typeof Type];

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Unconfigurable.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * To include predictions for this model type, set this field to `{}`. It is currently not configurable further.
 */
export type Unconfigurable = Record<string, unknown>;

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/UnionJob.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type UnionJob = Hume.expressionMeasurement.batch.InferenceJob;

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/UnionPredictResult.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export type UnionPredictResult = Hume.expressionMeasurement.batch.InferenceSourcePredictResult;

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Url.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface Url {
    /** The URL of the source media file. */
    url: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/ValidationArgs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

export interface ValidationArgs {
    positiveLabel?: Hume.expressionMeasurement.batch.Target;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/When.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const When = {
    CreatedBefore: "created_before",
    CreatedAfter: "created_after",
} as const;
export type When = (typeof When)[keyof typeof When];

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/Window.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * Generate predictions based on time.
 *
 * Setting the `window` field allows for a 'sliding window' approach, where a fixed-size window moves across the audio or video file in defined steps. This enables continuous analysis of prosody within subsets of the file, providing dynamic and localized insights into emotional expression.
 */
export interface Window {
    /** The length of the sliding window. */
    length?: number;
    /** The step size of the sliding window. */
    step?: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/batch/types/index.ts
================================================================================
export * from "./Alternative.js";
export * from "./Bcp47Tag.js";
export * from "./BoundingBox.js";
export * from "./BurstPrediction.js";
export * from "./Classification.js";
export * from "./CompletedEmbeddingGeneration.js";
export * from "./CompletedInference.js";
export * from "./CompletedState.js";
export * from "./CompletedTlInference.js";
export * from "./CompletedTraining.js";
export * from "./CustomModel.js";
export * from "./CustomModelId.js";
export * from "./CustomModelPrediction.js";
export * from "./CustomModelRequest.js";
export * from "./CustomModelsInferenceJob.js";
export * from "./CustomModelsTrainingJob.js";
export * from "./CustomModelVersionId.js";
export * from "./Dataset.js";
export * from "./DatasetId.js";
export * from "./DatasetVersionId.js";
export * from "./DescriptionsScore.js";
export * from "./Direction.js";
export * from "./EmbeddingGenerationBaseRequest.js";
export * from "./EmbeddingGenerationJob.js";
export * from "./EmotionScore.js";
export * from "./Error_.js";
export * from "./EvaluationArgs.js";
export * from "./Face.js";
export * from "./FacemeshPrediction.js";
export * from "./FacePrediction.js";
export * from "./FacsScore.js";
export * from "./Failed.js";
export * from "./FailedState.js";
export * from "./File_.js";
export * from "./Granularity.js";
export * from "./GroupedPredictionsBurstPrediction.js";
export * from "./GroupedPredictionsFacemeshPrediction.js";
export * from "./GroupedPredictionsFacePrediction.js";
export * from "./GroupedPredictionsLanguagePrediction.js";
export * from "./GroupedPredictionsNerPrediction.js";
export * from "./GroupedPredictionsProsodyPrediction.js";
export * from "./InferenceBaseRequest.js";
export * from "./InferenceJob.js";
export * from "./InferencePrediction.js";
export * from "./InferenceRequest.js";
export * from "./InferenceResults.js";
export * from "./InferenceSourcePredictResult.js";
export * from "./InProgress.js";
export * from "./InProgressState.js";
export * from "./JobEmbeddingGeneration.js";
export * from "./JobId.js";
export * from "./JobInference.js";
export * from "./JobTlInference.js";
export * from "./JobTraining.js";
export * from "./Language.js";
export * from "./LanguagePrediction.js";
export * from "./Models.js";
export * from "./ModelsPredictions.js";
export * from "./Ner.js";
export * from "./NerPrediction.js";
export * from "./Null.js";
export * from "./PositionInterval.js";
export * from "./PredictionsOptionalNullBurstPrediction.js";
export * from "./PredictionsOptionalNullFacemeshPrediction.js";
export * from "./PredictionsOptionalNullFacePrediction.js";
export * from "./PredictionsOptionalTranscriptionMetadataLanguagePrediction.js";
export * from "./PredictionsOptionalTranscriptionMetadataNerPrediction.js";
export * from "./PredictionsOptionalTranscriptionMetadataProsodyPrediction.js";
export * from "./Prosody.js";
export * from "./ProsodyPrediction.js";
export * from "./Queued.js";
export * from "./QueuedState.js";
export * from "./RegistryFileDetail.js";
export * from "./Regression.js";
export * from "./SentimentScore.js";
export * from "./SortBy.js";
export * from "./Source.js";
export * from "./SourceFile.js";
export * from "./SourceTextSource.js";
export * from "./SourceUrl.js";
export * from "./StateEmbeddingGeneration.js";
export * from "./StateEmbeddingGenerationCompletedEmbeddingGeneration.js";
export * from "./StateEmbeddingGenerationFailed.js";
export * from "./StateEmbeddingGenerationInProgress.js";
export * from "./StateEmbeddingGenerationQueued.js";
export * from "./StateInference.js";
export * from "./StateTlInference.js";
export * from "./StateTlInferenceCompletedTlInference.js";
export * from "./StateTlInferenceFailed.js";
export * from "./StateTlInferenceInProgress.js";
export * from "./StateTlInferenceQueued.js";
export * from "./StateTraining.js";
export * from "./StateTrainingCompletedTraining.js";
export * from "./StateTrainingFailed.js";
export * from "./StateTrainingInProgress.js";
export * from "./StateTrainingQueued.js";
export * from "./Status.js";
export * from "./Tag.js";
export * from "./Target.js";
export * from "./Task.js";
export * from "./TaskClassification.js";
export * from "./TaskRegression.js";
export * from "./TextSource.js";
export * from "./TimeInterval.js";
export * from "./TlInferenceBaseRequest.js";
export * from "./TlInferencePrediction.js";
export * from "./TlInferenceResults.js";
export * from "./TlInferenceSourcePredictResult.js";
export * from "./ToxicityScore.js";
export * from "./TrainingBaseRequest.js";
export * from "./TrainingCustomModel.js";
export * from "./Transcription.js";
export * from "./TranscriptionMetadata.js";
export * from "./Type.js";
export * from "./Unconfigurable.js";
export * from "./UnionJob.js";
export * from "./UnionPredictResult.js";
export * from "./Url.js";
export * from "./ValidationArgs.js";
export * from "./When.js";
export * from "./Window.js";

================================================================================
// File: src/api/resources/expressionMeasurement/resources/index.ts
================================================================================
export * as batch from "./batch/index.js";
export * as stream from "./stream/index.js";

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/index.ts
================================================================================
export * from "./resources/index.js";
export * from "./types/index.js";

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/index.ts
================================================================================
export * as stream from "./stream/index.js";
export * from "./stream/types/index.js";

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions } from "../../../../../../../../BaseClient.js";
import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../../../core/headers.js";
import * as core from "../../../../../../../../core/index.js";
import * as environments from "../../../../../../../../environments.js";
import { StreamSocket } from "./Socket.js";

export declare namespace StreamClient {
    export type Options = BaseClientOptions;

    export interface ConnectArgs {
        "X-Hume-Api-Key": string;
        /** Arbitrary headers to send with the websocket connect request. */
        headers?: Record<string, string>;
        /** Enable debug mode on the websocket. Defaults to false. */
        debug?: boolean;
        /** Number of reconnect attempts. Defaults to 30. */
        reconnectAttempts?: number;
    }
}

export class StreamClient {
    protected readonly _options: NormalizedClientOptions<StreamClient.Options>;

    constructor(options: StreamClient.Options = {}) {
        this._options = normalizeClientOptions(options);
    }

    public async connect(args: StreamClient.ConnectArgs): Promise<StreamSocket> {
        const { headers, debug, reconnectAttempts } = args;
        const _headers: Record<string, unknown> = mergeHeaders(
            mergeOnlyDefinedHeaders({ "X-Hume-Api-Key": args["X-Hume-Api-Key"] }),
            headers,
        );
        const socket = new core.ReconnectingWebSocket({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).stream,
                "/models",
            ),
            protocols: [],
            queryParameters: {},
            headers: _headers,
            options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
        });
        return new StreamSocket({ socket });
    }
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/client/Socket.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import * as core from "../../../../../../../../core/index.js";
import { fromJson } from "../../../../../../../../core/json.js";
import * as serializers from "../../../../../../../../serialization/index.js";
import { StreamModelsEndpointPayload } from "../../../../../../../../serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelsEndpointPayload.js";
import type * as Hume from "../../../../../../../index.js";

export declare namespace StreamSocket {
    export interface Args {
        socket: core.ReconnectingWebSocket;
    }

    export type Response = Hume.expressionMeasurement.stream.SubscribeEvent;
    type EventHandlers = {
        open?: () => void;
        message?: (message: Response) => void;
        close?: (event: core.CloseEvent) => void;
        error?: (error: Error) => void;
    };
}

export class StreamSocket {
    public readonly socket: core.ReconnectingWebSocket;
    protected readonly eventHandlers: StreamSocket.EventHandlers = {};
    private handleOpen: () => void = () => {
        this.eventHandlers.open?.();
    };
    private handleMessage: (event: { data: string }) => void = (event) => {
        const data = fromJson(event.data);

        const parsedResponse = serializers.expressionMeasurement.stream.StreamSocketResponse.parse(data, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        if (parsedResponse.ok) {
            this.eventHandlers.message?.(parsedResponse.value);
        } else {
            this.eventHandlers.error?.(new Error("Received unknown message type"));
        }
    };
    private handleClose: (event: core.CloseEvent) => void = (event) => {
        this.eventHandlers.close?.(event);
    };
    private handleError: (event: core.ErrorEvent) => void = (event) => {
        const message = event.message;
        this.eventHandlers.error?.(new Error(message));
    };

    constructor(args: StreamSocket.Args) {
        this.socket = args.socket;
        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);
    }

    /** The current state of the connection; this is one of the readyState constants. */
    get readyState(): number {
        return this.socket.readyState;
    }

    /**
     * @param event - The event to attach to.
     * @param callback - The callback to run when the event is triggered.
     * Usage:
     * ```typescript
     * this.on('open', () => {
     *     console.log('The websocket is open');
     * });
     * ```
     */
    public on<T extends keyof StreamSocket.EventHandlers>(event: T, callback: StreamSocket.EventHandlers[T]): void {
        this.eventHandlers[event] = callback;
    }

    public sendPublish(message: Hume.expressionMeasurement.stream.StreamModelsEndpointPayload): void {
        this.assertSocketIsOpen();
        const jsonPayload = StreamModelsEndpointPayload.jsonOrThrow(message, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        this.socket.send(JSON.stringify(jsonPayload));
    }

    /** Connect to the websocket and register event handlers. */
    public connect(): StreamSocket {
        this.socket.reconnect();

        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);

        return this;
    }

    /** Close the websocket and unregister event handlers. */
    public close(): void {
        this.socket.close();

        this.handleClose({ code: 1000 } as CloseEvent);

        this.socket.removeEventListener("open", this.handleOpen);
        this.socket.removeEventListener("message", this.handleMessage);
        this.socket.removeEventListener("close", this.handleClose);
        this.socket.removeEventListener("error", this.handleError);
    }

    /** Returns a promise that resolves when the websocket is open. */
    public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
        if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
            return this.socket;
        }

        return new Promise((resolve, reject) => {
            this.socket.addEventListener("open", () => {
                resolve(this.socket);
            });

            this.socket.addEventListener("error", (event: unknown) => {
                reject(event);
            });
        });
    }

    /** Asserts that the websocket is open. */
    private assertSocketIsOpen(): void {
        if (!this.socket) {
            throw new Error("Socket is not connected.");
        }

        if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
            throw new Error("Socket is not open.");
        }
    }

    /** Send a binary payload to the websocket. */
    protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
        this.socket.send(payload);
    }
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/client/index.ts
================================================================================
export {};

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/index.ts
================================================================================
export * from "./client/index.js";
export * from "./types/index.js";

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/Config.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Configuration used to specify which models should be used and with what settings.
 */
export interface Config {
    /**
     * Configuration for the vocal burst emotion model.
     *
     * Note: Model configuration is not currently available in streaming.
     *
     * Please use the default configuration by passing an empty object `{}`.
     */
    burst?: Record<string, unknown>;
    /**
     * Configuration for the facial expression emotion model.
     *
     * Note: Using the `reset_stream` parameter does not have any effect on face identification. A single face identifier cache is maintained over a full session whether `reset_stream` is used or not.
     */
    face?: Hume.expressionMeasurement.stream.StreamFace;
    /**
     * Configuration for the facemesh emotion model.
     *
     * Note: Model configuration is not currently available in streaming.
     *
     * Please use the default configuration by passing an empty object `{}`.
     */
    facemesh?: Record<string, unknown>;
    /** Configuration for the language emotion model. */
    language?: Hume.expressionMeasurement.stream.StreamLanguage;
    /**
     * Configuration for the speech prosody emotion model.
     *
     * Note: Model configuration is not currently available in streaming.
     *
     * Please use the default configuration by passing an empty object `{}`.
     */
    prosody?: Record<string, unknown>;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/JobDetails.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * If the job_details flag was set in the request, details about the current streaming job will be returned in the response body.
 */
export interface JobDetails {
    /** ID of the current streaming job. */
    jobId?: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamErrorMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Error message
 */
export interface StreamErrorMessage {
    /** Error message text. */
    error?: string;
    /** Unique identifier for the error. */
    code?: string;
    /** If a payload ID was passed in the request, the same payload ID will be sent back in the response body. */
    payloadId?: string;
    /** If the job_details flag was set in the request, details about the current streaming job will be returned in the response body. */
    jobDetails?: Hume.expressionMeasurement.stream.JobDetails;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamFace.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * Configuration for the facial expression emotion model.
 *
 * Note: Using the `reset_stream` parameter does not have any effect on face identification. A single face identifier cache is maintained over a full session whether `reset_stream` is used or not.
 */
export interface StreamFace {
    /** Configuration for FACS predictions. If missing or null, no FACS predictions will be generated. */
    facs?: Record<string, unknown>;
    /** Configuration for Descriptions predictions. If missing or null, no Descriptions predictions will be generated. */
    descriptions?: Record<string, unknown>;
    /** Whether to return identifiers for faces across frames. If true, unique identifiers will be assigned to face bounding boxes to differentiate different faces. If false, all faces will be tagged with an "unknown" ID. */
    identifyFaces?: boolean;
    /** Number of frames per second to process. Other frames will be omitted from the response. */
    fpsPred?: number;
    /** Face detection probability threshold. Faces detected with a probability less than this threshold will be omitted from the response. */
    probThreshold?: number;
    /** Minimum bounding box side length in pixels to treat as a face. Faces detected with a bounding box side length in pixels less than this threshold will be omitted from the response. */
    minFaceSize?: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamLanguage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * Configuration for the language emotion model.
 */
export interface StreamLanguage {
    /** Configuration for sentiment predictions. If missing or null, no sentiment predictions will be generated. */
    sentiment?: Record<string, unknown>;
    /** Configuration for toxicity predictions. If missing or null, no toxicity predictions will be generated. */
    toxicity?: Record<string, unknown>;
    /** The granularity at which to generate predictions. Values are `word`, `sentence`, `utterance`, or `passage`. To get a single prediction for the entire text of your streaming payload use `passage`. Default value is `word`. */
    granularity?: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictions.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Model predictions
 */
export interface StreamModelPredictions {
    /** If a payload ID was passed in the request, the same payload ID will be sent back in the response body. */
    payloadId?: string;
    /** If the job_details flag was set in the request, details about the current streaming job will be returned in the response body. */
    jobDetails?: Hume.expressionMeasurement.stream.StreamModelPredictionsJobDetails;
    /** Response for the vocal burst emotion model. */
    burst?: Hume.expressionMeasurement.stream.StreamModelPredictionsBurst;
    /** Response for the facial expression emotion model. */
    face?: Hume.expressionMeasurement.stream.StreamModelPredictionsFace;
    /** Response for the facemesh emotion model. */
    facemesh?: Hume.expressionMeasurement.stream.StreamModelPredictionsFacemesh;
    /** Response for the language emotion model. */
    language?: Hume.expressionMeasurement.stream.StreamModelPredictionsLanguage;
    /** Response for the speech prosody emotion model. */
    prosody?: Hume.expressionMeasurement.stream.StreamModelPredictionsProsody;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsBurst.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Response for the vocal burst emotion model.
 */
export interface StreamModelPredictionsBurst {
    predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsBurstPredictionsItem[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsBurstPredictionsItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

export interface StreamModelPredictionsBurstPredictionsItem {
    time?: Hume.expressionMeasurement.stream.TimeRange;
    emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFace.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Response for the facial expression emotion model.
 */
export interface StreamModelPredictionsFace {
    predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsFacePredictionsItem[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacePredictionsItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

export interface StreamModelPredictionsFacePredictionsItem {
    /** Frame number */
    frame?: number;
    /** Time in seconds when face detection occurred. */
    time?: number;
    bbox?: Hume.expressionMeasurement.stream.StreamBoundingBox;
    /** The predicted probability that a detected face was actually a face. */
    prob?: number;
    /** Identifier for a face. Not that this defaults to `unknown` unless face identification is enabled in the face model configuration. */
    faceId?: string;
    emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
    facs?: Hume.expressionMeasurement.stream.EmotionEmbedding;
    descriptions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacemesh.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Response for the facemesh emotion model.
 */
export interface StreamModelPredictionsFacemesh {
    predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsFacemeshPredictionsItem[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacemeshPredictionsItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

export interface StreamModelPredictionsFacemeshPredictionsItem {
    emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsJobDetails.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * If the job_details flag was set in the request, details about the current streaming job will be returned in the response body.
 */
export interface StreamModelPredictionsJobDetails {
    /** ID of the current streaming job. */
    jobId?: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsLanguage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Response for the language emotion model.
 */
export interface StreamModelPredictionsLanguage {
    predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsLanguagePredictionsItem[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsLanguagePredictionsItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

export interface StreamModelPredictionsLanguagePredictionsItem {
    /** A segment of text (like a word or a sentence). */
    text?: string;
    position?: Hume.expressionMeasurement.stream.TextPosition;
    emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
    sentiment?: Hume.expressionMeasurement.stream.Sentiment;
    toxicity?: Hume.expressionMeasurement.stream.Toxicity;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsProsody.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Response for the speech prosody emotion model.
 */
export interface StreamModelPredictionsProsody {
    predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsProsodyPredictionsItem[];
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsProsodyPredictionsItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

export interface StreamModelPredictionsProsodyPredictionsItem {
    time?: Hume.expressionMeasurement.stream.TimeRange;
    emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelsEndpointPayload.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Models endpoint payload
 */
export interface StreamModelsEndpointPayload {
    data?: string;
    /** Configuration used to specify which models should be used and with what settings. */
    models?: Hume.expressionMeasurement.stream.Config;
    /**
     * Length in milliseconds of streaming sliding window.
     *
     * Extending the length of this window will prepend media context from past payloads into the current payload.
     *
     * For example, if on the first payload you send 500ms of data and on the second payload you send an additional 500ms of data, a window of at least 1000ms will allow the model to process all 1000ms of stream data.
     *
     * A window of 600ms would append the full 500ms of the second payload to the last 100ms of the first payload.
     *
     * Note: This feature is currently only supported for audio data and audio models. For other file types and models this parameter will be ignored.
     */
    streamWindowMs?: number;
    /**
     * Whether to reset the streaming sliding window before processing the current payload.
     *
     * If this parameter is set to `true` then past context will be deleted before processing the current payload.
     *
     * Use reset_stream when one audio file is done being processed and you do not want context to leak across files.
     */
    resetStream?: boolean;
    /**
     * Set to `true` to enable the data parameter to be parsed as raw text rather than base64 encoded bytes.
     * This parameter is useful if you want to send text to be processed by the language model, but it cannot be used with other file types like audio, image, or video.
     */
    rawText?: boolean;
    /**
     * Set to `true` to get details about the job.
     *
     * This parameter can be set in the same payload as data or it can be set without data and models configuration to get the job details between payloads.
     *
     * This parameter is useful to get the unique job ID.
     */
    jobDetails?: boolean;
    /**
     * Pass an arbitrary string as the payload ID and get it back at the top level of the socket response.
     *
     * This can be useful if you have multiple requests running asynchronously and want to disambiguate responses as they are received.
     */
    payloadId?: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamWarningMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

/**
 * Warning message
 */
export interface StreamWarningMessage {
    /** Warning message text. */
    warning?: string;
    /** Unique identifier for the error. */
    code?: string;
    /** If a payload ID was passed in the request, the same payload ID will be sent back in the response body. */
    payloadId?: string;
    /** If the job_details flag was set in the request, details about the current streaming job will be returned in the response body. */
    jobDetails?: Hume.expressionMeasurement.stream.StreamWarningMessageJobDetails;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamWarningMessageJobDetails.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * If the job_details flag was set in the request, details about the current streaming job will be returned in the response body.
 */
export interface StreamWarningMessageJobDetails {
    /** ID of the current streaming job. */
    jobId?: string;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/SubscribeEvent.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../index.js";

export type SubscribeEvent =
    /**
     * Model predictions */
    | Hume.expressionMeasurement.stream.StreamModelPredictions
    /**
     * Error message */
    | Hume.expressionMeasurement.stream.StreamErrorMessage
    /**
     * Warning message */
    | Hume.expressionMeasurement.stream.StreamWarningMessage;

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/index.ts
================================================================================
export * from "./Config.js";
export * from "./JobDetails.js";
export * from "./StreamErrorMessage.js";
export * from "./StreamFace.js";
export * from "./StreamLanguage.js";
export * from "./StreamModelPredictions.js";
export * from "./StreamModelPredictionsBurst.js";
export * from "./StreamModelPredictionsBurstPredictionsItem.js";
export * from "./StreamModelPredictionsFace.js";
export * from "./StreamModelPredictionsFacemesh.js";
export * from "./StreamModelPredictionsFacemeshPredictionsItem.js";
export * from "./StreamModelPredictionsFacePredictionsItem.js";
export * from "./StreamModelPredictionsJobDetails.js";
export * from "./StreamModelPredictionsLanguage.js";
export * from "./StreamModelPredictionsLanguagePredictionsItem.js";
export * from "./StreamModelPredictionsProsody.js";
export * from "./StreamModelPredictionsProsodyPredictionsItem.js";
export * from "./StreamModelsEndpointPayload.js";
export * from "./StreamWarningMessage.js";
export * from "./StreamWarningMessageJobDetails.js";
export * from "./SubscribeEvent.js";

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/types/EmotionEmbedding.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * A high-dimensional embedding in emotion space.
 */
export type EmotionEmbedding = Hume.expressionMeasurement.stream.EmotionEmbeddingItem[];

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/types/EmotionEmbeddingItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface EmotionEmbeddingItem {
    /** Name of the emotion being expressed. */
    name?: string;
    /** Embedding value for the emotion being expressed. */
    score?: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/types/Sentiment.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * Sentiment predictions returned as a distribution. This model predicts the probability that a given text could be interpreted as having each sentiment level from 1 (negative) to 9 (positive).
 *
 * Compared to returning one estimate of sentiment, this enables a more nuanced analysis of a text's meaning. For example, a text with very neutral sentiment would have an average rating of 5. But also a text that could be interpreted as having very positive sentiment or very negative sentiment would also have an average rating of 5. The average sentiment is less informative than the distribution over sentiment, so this API returns a value for each sentiment level.
 */
export type Sentiment = Hume.expressionMeasurement.stream.SentimentItem[];

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/types/SentimentItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface SentimentItem {
    /** Level of sentiment, ranging from 1 (negative) to 9 (positive) */
    name?: string;
    /** Prediction for this level of sentiment */
    score?: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/types/StreamBoundingBox.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * A bounding box around a face.
 */
export interface StreamBoundingBox {
    /** x-coordinate of bounding box top left corner. */
    x?: number;
    /** y-coordinate of bounding box top left corner. */
    y?: number;
    /** Bounding box width. */
    w?: number;
    /** Bounding box height. */
    h?: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/types/TextPosition.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * Position of a segment of text within a larger document, measured in characters. Uses zero-based indexing. The beginning index is inclusive and the end index is exclusive.
 */
export interface TextPosition {
    /** The index of the first character in the text segment, inclusive. */
    begin?: number;
    /** The index of the last character in the text segment, exclusive. */
    end?: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/types/TimeRange.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * A time range with a beginning and end, measured in seconds.
 */
export interface TimeRange {
    /** Beginning of time range in seconds. */
    begin?: number;
    /** End of time range in seconds. */
    end?: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/types/Toxicity.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../index.js";

/**
 * Toxicity predictions returned as probabilities that the text can be classified into the following categories: toxic, severe_toxic, obscene, threat, insult, and identity_hate.
 */
export type Toxicity = Hume.expressionMeasurement.stream.ToxicityItem[];

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/types/ToxicityItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface ToxicityItem {
    /** Category of toxicity. */
    name?: string;
    /** Prediction for this category of toxicity */
    score?: number;
}

================================================================================
// File: src/api/resources/expressionMeasurement/resources/stream/types/index.ts
================================================================================
export * from "./EmotionEmbedding.js";
export * from "./EmotionEmbeddingItem.js";
export * from "./Sentiment.js";
export * from "./SentimentItem.js";
export * from "./StreamBoundingBox.js";
export * from "./TextPosition.js";
export * from "./TimeRange.js";
export * from "./Toxicity.js";
export * from "./ToxicityItem.js";

================================================================================
// File: src/api/resources/index.ts
================================================================================
export * as empathicVoice from "./empathicVoice/index.js";
export * as expressionMeasurement from "./expressionMeasurement/index.js";
export * as tts from "./tts/index.js";

================================================================================
// File: src/api/resources/tts/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import { toJson } from "../../../../core/json.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as serializers from "../../../../serialization/index.js";
import * as Hume from "../../../index.js";
import { StreamInputClient } from "../resources/streamInput/client/Client.js";
import { VoicesClient } from "../resources/voices/client/Client.js";

export declare namespace TtsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class TtsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<TtsClient.Options>;
    protected _voices: VoicesClient | undefined;
    protected _streamInput: StreamInputClient | undefined;

    constructor(options: TtsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    public get voices(): VoicesClient {
        return (this._voices ??= new VoicesClient(this._options));
    }

    public get streamInput(): StreamInputClient {
        return (this._streamInput ??= new StreamInputClient(this._options));
    }

    /**
     * Synthesizes one or more input texts into speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
     *
     * The response includes the base64-encoded audio and metadata in JSON format.
     *
     * @param {Hume.tts.PostedTts} request
     * @param {TtsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.tts.UnprocessableEntityError}
     *
     * @example
     *     await client.tts.synthesizeJson({
     *         context: {
     *             utterances: [{
     *                     text: "How can people see beauty so differently?",
     *                     description: "A curious student with a clear and respectful tone, seeking clarification on Hume's ideas with a straightforward question."
     *                 }]
     *         },
     *         format: {
     *             type: "mp3"
     *         },
     *         numGenerations: 1,
     *         utterances: [{
     *                 text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
     *                 description: "Middle-aged masculine voice with a clear, rhythmic Scots lilt, rounded vowels, and a warm, steady tone with an articulate, academic quality."
     *             }]
     *     })
     */
    public synthesizeJson(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.tts.ReturnTts> {
        return core.HttpResponsePromise.fromPromise(this.__synthesizeJson(request, requestOptions));
    }

    private async __synthesizeJson(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.tts.ReturnTts>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.tts.PostedTts.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.tts.ReturnTts.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts");
    }

    /**
     * Synthesizes one or more input texts into speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
     *
     * The response contains the generated audio file in the requested format.
     * @throws {@link Hume.tts.UnprocessableEntityError}
     */
    public synthesizeFile(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__synthesizeFile(request, requestOptions));
    }

    private async __synthesizeFile(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/file",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.tts.PostedTts.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts/file");
    }

    /**
     * Streams synthesized speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
     * @throws {@link Hume.tts.UnprocessableEntityError}
     */
    public synthesizeFileStreaming(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__synthesizeFileStreaming(request, requestOptions));
    }

    private async __synthesizeFileStreaming(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/stream/file",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.tts.PostedTts.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts/stream/file");
    }

    /**
     * Streams synthesized speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
     *
     * The response is a stream of JSON objects including audio encoded in base64.
     */
    public synthesizeJsonStreaming(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): core.HttpResponsePromise<core.Stream<Hume.tts.TtsOutput>> {
        return core.HttpResponsePromise.fromPromise(this.__synthesizeJsonStreaming(request, requestOptions));
    }

    private async __synthesizeJsonStreaming(
        request: Hume.tts.PostedTts,
        requestOptions?: TtsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.Stream<Hume.tts.TtsOutput>>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<ReadableStream>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/stream/json",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.tts.PostedTts.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "sse",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: new core.Stream({
                    stream: _response.body,
                    parse: async (data) => {
                        return serializers.tts.TtsOutput.parseOrThrow(data, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        });
                    },
                    signal: requestOptions?.abortSignal,
                    eventShape: {
                        type: "json",
                        messageTerminator: "\n",
                    },
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts/stream/json");
    }

    /**
     * @throws {@link Hume.tts.UnprocessableEntityError}
     */
    public convertVoiceFile(
        request: Hume.tts.ConvertVoiceFileRequest,
        requestOptions?: TtsClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__convertVoiceFile(request, requestOptions));
    }

    private async __convertVoiceFile(
        request: Hume.tts.ConvertVoiceFileRequest,
        requestOptions?: TtsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _body = await core.newFormData();
        if (request.stripHeaders != null) {
            _body.append("strip_headers", request.stripHeaders?.toString());
        }

        await _body.appendFile("audio", request.audio);
        if (request.context != null) {
            _body.append(
                "context",
                (() => {
                    const mapped = serializers.tts.PostedContext.jsonOrThrow(request.context, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    });
                    return typeof mapped === "string" ? mapped : toJson(mapped);
                })(),
            );
        }

        if (request.voice != null) {
            _body.append(
                "voice",
                (() => {
                    const mapped = serializers.tts.PostedUtteranceVoice.jsonOrThrow(request.voice, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    });
                    return typeof mapped === "string" ? mapped : toJson(mapped);
                })(),
            );
        }

        if (request.format != null) {
            _body.append(
                "format",
                (() => {
                    const mapped = serializers.tts.Format.jsonOrThrow(request.format, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    });
                    return typeof mapped === "string" ? mapped : toJson(mapped);
                })(),
            );
        }

        if (request.includeTimestampTypes != null) {
            for (const _item of request.includeTimestampTypes) {
                _body.append(
                    "include_timestamp_types",
                    serializers.tts.TimestampType.jsonOrThrow(_item, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    }),
                );
            }
        }

        const _maybeEncodedRequest = await _body.getRequest();
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ..._maybeEncodedRequest.headers }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/voice_conversion/file",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v0/tts/voice_conversion/file",
        );
    }

    public convertVoiceJson(
        request: Hume.tts.ConvertVoiceJsonRequest,
        requestOptions?: TtsClient.RequestOptions,
    ): core.HttpResponsePromise<core.Stream<Hume.tts.TtsOutput>> {
        return core.HttpResponsePromise.fromPromise(this.__convertVoiceJson(request, requestOptions));
    }

    private async __convertVoiceJson(
        request: Hume.tts.ConvertVoiceJsonRequest,
        requestOptions?: TtsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.Stream<Hume.tts.TtsOutput>>> {
        const _body = await core.newFormData();
        if (request.stripHeaders != null) {
            _body.append("strip_headers", request.stripHeaders?.toString());
        }

        if (request.audio != null) {
            await _body.appendFile("audio", request.audio);
        }

        if (request.context != null) {
            _body.append(
                "context",
                (() => {
                    const mapped = serializers.tts.PostedContext.jsonOrThrow(request.context, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    });
                    return typeof mapped === "string" ? mapped : toJson(mapped);
                })(),
            );
        }

        if (request.voice != null) {
            _body.append(
                "voice",
                (() => {
                    const mapped = serializers.tts.PostedUtteranceVoice.jsonOrThrow(request.voice, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    });
                    return typeof mapped === "string" ? mapped : toJson(mapped);
                })(),
            );
        }

        if (request.format != null) {
            _body.append(
                "format",
                (() => {
                    const mapped = serializers.tts.Format.jsonOrThrow(request.format, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    });
                    return typeof mapped === "string" ? mapped : toJson(mapped);
                })(),
            );
        }

        if (request.includeTimestampTypes != null) {
            for (const _item of request.includeTimestampTypes) {
                _body.append(
                    "include_timestamp_types",
                    serializers.tts.TimestampType.jsonOrThrow(_item, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    }),
                );
            }
        }

        const _maybeEncodedRequest = await _body.getRequest();
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ..._maybeEncodedRequest.headers }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<ReadableStream>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/voice_conversion/json",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            responseType: "sse",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: new core.Stream({
                    stream: _response.body,
                    parse: async (data) => {
                        return serializers.tts.TtsOutput.parseOrThrow(data, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        });
                    },
                    signal: requestOptions?.abortSignal,
                    eventShape: {
                        type: "json",
                        messageTerminator: "\n",
                    },
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v0/tts/voice_conversion/json",
        );
    }
}

================================================================================
// File: src/api/resources/tts/client/index.ts
================================================================================
export * from "./requests/index.js";

================================================================================
// File: src/api/resources/tts/client/requests/ConvertVoiceFileRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../../core/index.js";
import type * as Hume from "../../../../index.js";

export interface ConvertVoiceFileRequest {
    /** If enabled, the audio for all the chunks of a generation, once concatenated together, will constitute a single audio file. Otherwise, if disabled, each chunk's audio will be its own audio file, each with its own headers (if applicable). */
    stripHeaders?: boolean;
    audio: core.file.Uploadable;
    /** Utterances to use as context for generating consistent speech style and prosody across multiple requests. These will not be converted to speech output. */
    context?: Hume.tts.PostedContext;
    voice?: Hume.tts.PostedUtteranceVoice;
    /** Specifies the output audio file format. */
    format?: Hume.tts.Format;
    /** The set of timestamp types to include in the response. When used in multipart/form-data, specify each value using bracket notation: `include_timestamp_types[0]=word&include_timestamp_types[1]=phoneme`. Only supported for Octave 2 requests. */
    includeTimestampTypes?: Hume.tts.TimestampType[];
}

================================================================================
// File: src/api/resources/tts/client/requests/ConvertVoiceJsonRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../../core/index.js";
import type * as Hume from "../../../../index.js";

/**
 * @example
 *     {}
 */
export interface ConvertVoiceJsonRequest {
    /** If enabled, the audio for all the chunks of a generation, once concatenated together, will constitute a single audio file. Otherwise, if disabled, each chunk's audio will be its own audio file, each with its own headers (if applicable). */
    stripHeaders?: boolean;
    audio?: core.file.Uploadable | undefined;
    /** Utterances to use as context for generating consistent speech style and prosody across multiple requests. These will not be converted to speech output. */
    context?: Hume.tts.PostedContext;
    voice?: Hume.tts.PostedUtteranceVoice;
    /** Specifies the output audio file format. */
    format?: Hume.tts.Format;
    /** The set of timestamp types to include in the response. When used in multipart/form-data, specify each value using bracket notation: `include_timestamp_types[0]=word&include_timestamp_types[1]=phoneme`. Only supported for Octave 2 requests. */
    includeTimestampTypes?: Hume.tts.TimestampType[];
}

================================================================================
// File: src/api/resources/tts/client/requests/index.ts
================================================================================
export type { ConvertVoiceFileRequest } from "./ConvertVoiceFileRequest.js";
export type { ConvertVoiceJsonRequest } from "./ConvertVoiceJsonRequest.js";

================================================================================
// File: src/api/resources/tts/errors/BadRequestError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../core/index.js";
import * as errors from "../../../../errors/index.js";
import type * as Hume from "../../../index.js";

export class BadRequestError extends errors.HumeError {
    constructor(body: Hume.tts.ErrorResponse, rawResponse?: core.RawResponse) {
        super({
            message: "BadRequestError",
            statusCode: 400,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }

        this.name = this.constructor.name;
    }
}

================================================================================
// File: src/api/resources/tts/errors/UnprocessableEntityError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../../../../core/index.js";
import * as errors from "../../../../errors/index.js";
import type * as Hume from "../../../index.js";

export class UnprocessableEntityError extends errors.HumeError {
    constructor(body: Hume.tts.HttpValidationError, rawResponse?: core.RawResponse) {
        super({
            message: "UnprocessableEntityError",
            statusCode: 422,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }

        this.name = this.constructor.name;
    }
}

================================================================================
// File: src/api/resources/tts/errors/index.ts
================================================================================
export * from "./BadRequestError.js";
export * from "./UnprocessableEntityError.js";

================================================================================
// File: src/api/resources/tts/index.ts
================================================================================
export * from "./client/index.js";
export * from "./errors/index.js";
export * from "./resources/index.js";
export * from "./types/index.js";

================================================================================
// File: src/api/resources/tts/resources/index.ts
================================================================================
export * as streamInput from "./streamInput/index.js";
export * from "./voices/client/requests/index.js";
export * as voices from "./voices/index.js";

================================================================================
// File: src/api/resources/tts/resources/streamInput/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import * as serializers from "../../../../../../serialization/index.js";
import type * as Hume from "../../../../../index.js";
import { StreamInputSocket } from "./Socket.js";

export declare namespace StreamInputClient {
    export interface Options extends BaseClientOptions {}

    export interface ConnectArgs {
        accessToken?: string;
        contextGenerationId?: string;
        formatType?: Hume.tts.AudioFormatType;
        includeTimestampTypes?: Hume.tts.TimestampType | Hume.tts.TimestampType[];
        instantMode?: boolean;
        noBinary?: boolean;
        stripHeaders?: boolean;
        version?: Hume.tts.OctaveVersion;
        apiKey?: string;
        /** Arbitrary headers to send with the websocket connect request. */
        headers?: Record<string, string>;
        /** Enable debug mode on the websocket. Defaults to false. */
        debug?: boolean;
        /** Number of reconnect attempts. Defaults to 30. */
        reconnectAttempts?: number;
    }
}

export class StreamInputClient {
    protected readonly _options: NormalizedClientOptions<StreamInputClient.Options>;

    constructor(options: StreamInputClient.Options = {}) {
        this._options = normalizeClientOptions(options);
    }

    public async connect(args: StreamInputClient.ConnectArgs = {}): Promise<StreamInputSocket> {
        const {
            accessToken,
            contextGenerationId,
            formatType,
            includeTimestampTypes,
            instantMode,
            noBinary,
            stripHeaders,
            version,
            apiKey,
            headers,
            debug,
            reconnectAttempts,
        } = args;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (accessToken != null) {
            _queryParams.access_token = accessToken;
        }

        if (contextGenerationId != null) {
            _queryParams.context_generation_id = contextGenerationId;
        }

        if (formatType != null) {
            _queryParams.format_type = serializers.tts.AudioFormatType.jsonOrThrow(formatType, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            });
        }

        if (includeTimestampTypes != null) {
            if (Array.isArray(includeTimestampTypes)) {
                _queryParams.include_timestamp_types = includeTimestampTypes.map((item) =>
                    serializers.tts.TimestampType.jsonOrThrow(item, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    }),
                );
            } else {
                _queryParams.include_timestamp_types = serializers.tts.TimestampType.jsonOrThrow(
                    includeTimestampTypes,
                    {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    },
                );
            }
        }

        if (instantMode != null) {
            _queryParams.instant_mode = instantMode.toString();
        }

        if (noBinary != null) {
            _queryParams.no_binary = noBinary.toString();
        }

        if (stripHeaders != null) {
            _queryParams.strip_headers = stripHeaders.toString();
        }

        if (version != null) {
            _queryParams.version = serializers.tts.OctaveVersion.jsonOrThrow(version, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            });
        }

        if (apiKey != null) {
            _queryParams.api_key = apiKey;
        }

        const _headers: Record<string, unknown> = mergeHeaders(
            mergeOnlyDefinedHeaders({
                ...(await this._getCustomAuthorizationHeaders()),
            }),
            headers,
        );
        const socket = new core.ReconnectingWebSocket({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).tts,
                "/stream/input",
            ),
            protocols: [],
            queryParameters: _queryParams,
            headers: _headers,
            options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
        });
        return new StreamInputSocket({ socket });
    }

    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
        const apiKeyValue = core.Supplier.get(this._options.apiKey);
        // This `authHeaderValue` is manually added as if you don't provide it it will
        // be omitted from the headers which means it won't reach the logic in ws.ts that
        // extracts values from the headers and adds them to query parameters.
        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
    }
}

================================================================================
// File: src/api/resources/tts/resources/streamInput/client/Client.ts.diff
================================================================================
diff --git a/src/api/resources/tts/resources/streamInput/client/Client.ts b/src/api/resources/tts/resources/streamInput/client/Client.ts
index e8477c1..4e3ef08 100644
--- a/src/api/resources/tts/resources/streamInput/client/Client.ts
+++ b/src/api/resources/tts/resources/streamInput/client/Client.ts
@@ -2,7 +2,6 @@
 
 import type { BaseClientOptions } from "../../../../../../BaseClient.js";
 import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
-import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
 import * as core from "../../../../../../core/index.js";
 import * as environments from "../../../../../../environments.js";
 import * as serializers from "../../../../../../serialization/index.js";
@@ -10,7 +9,7 @@ import type * as Hume from "../../../../../index.js";
 import { StreamInputSocket } from "./Socket.js";
 
 export declare namespace StreamInputClient {
-    export interface Options extends BaseClientOptions {}
+    export type Options = BaseClientOptions;
 
     export interface ConnectArgs {
         accessToken?: string;
@@ -53,70 +52,42 @@ export class StreamInputClient {
             debug,
             reconnectAttempts,
         } = args;
-        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
-        if (accessToken != null) {
-            _queryParams.access_token = accessToken;
-        }
-
-        if (contextGenerationId != null) {
-            _queryParams.context_generation_id = contextGenerationId;
-        }
-
-        if (formatType != null) {
-            _queryParams.format_type = serializers.tts.AudioFormatType.jsonOrThrow(formatType, {
-                unrecognizedObjectKeys: "strip",
-                omitUndefined: true,
-            });
-        }
-
-        if (includeTimestampTypes != null) {
-            if (Array.isArray(includeTimestampTypes)) {
-                _queryParams.include_timestamp_types = includeTimestampTypes.map((item) =>
-                    serializers.tts.TimestampType.jsonOrThrow(item, {
+        const _queryParams: Record<string, unknown> = {
+            access_token: accessToken,
+            context_generation_id: contextGenerationId,
+            format_type:
+                formatType != null
+                    ? serializers.tts.AudioFormatType.jsonOrThrow(formatType, {
+                          unrecognizedObjectKeys: "strip",
+                          omitUndefined: true,
+                      })
+                    : undefined,
+            include_timestamp_types: Array.isArray(includeTimestampTypes)
+                ? includeTimestampTypes.map((item) =>
+                      serializers.tts.TimestampType.jsonOrThrow(item, {
+                          unrecognizedObjectKeys: "strip",
+                          omitUndefined: true,
+                      }),
+                  )
+                : includeTimestampTypes != null
+                  ? serializers.tts.TimestampType.jsonOrThrow(includeTimestampTypes, {
                         unrecognizedObjectKeys: "strip",
                         omitUndefined: true,
-                    }),
-                );
-            } else {
-                _queryParams.include_timestamp_types = serializers.tts.TimestampType.jsonOrThrow(
-                    includeTimestampTypes,
-                    {
-                        unrecognizedObjectKeys: "strip",
-                        omitUndefined: true,
-                    },
-                );
-            }
-        }
-
-        if (instantMode != null) {
-            _queryParams.instant_mode = instantMode.toString();
-        }
-
-        if (noBinary != null) {
-            _queryParams.no_binary = noBinary.toString();
-        }
-
-        if (stripHeaders != null) {
-            _queryParams.strip_headers = stripHeaders.toString();
-        }
-
-        if (version != null) {
-            _queryParams.version = serializers.tts.OctaveVersion.jsonOrThrow(version, {
-                unrecognizedObjectKeys: "strip",
-                omitUndefined: true,
-            });
-        }
-
-        if (apiKey != null) {
-            _queryParams.api_key = apiKey;
-        }
-
-        const _headers: Record<string, unknown> = mergeHeaders(
-            mergeOnlyDefinedHeaders({
-                ...(await this._getCustomAuthorizationHeaders()),
-            }),
-            headers,
-        );
+                    })
+                  : undefined,
+            instant_mode: instantMode,
+            no_binary: noBinary,
+            strip_headers: stripHeaders,
+            version:
+                version != null
+                    ? serializers.tts.OctaveVersion.jsonOrThrow(version, {
+                          unrecognizedObjectKeys: "strip",
+                          omitUndefined: true,
+                      })
+                    : undefined,
+            api_key: apiKey,
+        };
+        const _headers: Record<string, unknown> = { ...headers };
         const socket = new core.ReconnectingWebSocket({
             url: core.url.join(
                 (await core.Supplier.get(this._options.baseUrl)) ??
@@ -130,13 +101,4 @@ export class StreamInputClient {
         });
         return new StreamInputSocket({ socket });
     }
-
-    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
-        const apiKeyValue = core.Supplier.get(this._options.apiKey);
-        // This `authHeaderValue` is manually added as if you don't provide it it will
-        // be omitted from the headers which means it won't reach the logic in ws.ts that
-        // extracts values from the headers and adds them to query parameters.
-        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
-        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
-    }
 }

================================================================================
// File: src/api/resources/tts/resources/streamInput/client/Socket.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import * as core from "../../../../../../core/index.js";
import { fromJson } from "../../../../../../core/json.js";
import * as serializers from "../../../../../../serialization/index.js";
import { PublishTts } from "../../../../../../serialization/resources/tts/types/PublishTts.js";
import type * as Hume from "../../../../../index.js";

export declare namespace StreamInputSocket {
    export interface Args {
        socket: core.ReconnectingWebSocket;
    }

    export type Response = Hume.tts.TtsOutput;
    type EventHandlers = {
        open?: () => void;
        message?: (message: Response) => void;
        close?: (event: core.CloseEvent) => void;
        error?: (error: Error) => void;
    };
}

export class StreamInputSocket {
    public readonly socket: core.ReconnectingWebSocket;
    protected readonly eventHandlers: StreamInputSocket.EventHandlers = {};
    private handleOpen: () => void = () => {
        this.eventHandlers.open?.();
    };
    private handleMessage: (event: { data: string }) => void = (event) => {
        const data = fromJson(event.data);

        const parsedResponse = serializers.tts.StreamInputSocketResponse.parse(data, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        if (parsedResponse.ok) {
            this.eventHandlers.message?.(parsedResponse.value);
        } else {
            this.eventHandlers.error?.(new Error("Received unknown message type"));
        }
    };
    private handleClose: (event: core.CloseEvent) => void = (event) => {
        this.eventHandlers.close?.(event);
    };
    private handleError: (event: core.ErrorEvent) => void = (event) => {
        const message = event.message;
        this.eventHandlers.error?.(new Error(message));
    };

    constructor(args: StreamInputSocket.Args) {
        this.socket = args.socket;
        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);
    }

    /** The current state of the connection; this is one of the readyState constants. */
    get readyState(): number {
        return this.socket.readyState;
    }

    /**
     * @param event - The event to attach to.
     * @param callback - The callback to run when the event is triggered.
     * Usage:
     * ```typescript
     * this.on('open', () => {
     *     console.log('The websocket is open');
     * });
     * ```
     */
    public on<T extends keyof StreamInputSocket.EventHandlers>(
        event: T,
        callback: StreamInputSocket.EventHandlers[T],
    ): void {
        this.eventHandlers[event] = callback;
    }

    public sendPublish(message: Hume.tts.PublishTts): void {
        this.assertSocketIsOpen();
        const jsonPayload = PublishTts.jsonOrThrow(message, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            omitUndefined: true,
        });
        this.socket.send(JSON.stringify(jsonPayload));
    }

    /** Connect to the websocket and register event handlers. */
    public connect(): StreamInputSocket {
        this.socket.reconnect();

        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);

        return this;
    }

    /** Close the websocket and unregister event handlers. */
    public close(): void {
        this.socket.close();

        this.handleClose({ code: 1000 } as CloseEvent);

        this.socket.removeEventListener("open", this.handleOpen);
        this.socket.removeEventListener("message", this.handleMessage);
        this.socket.removeEventListener("close", this.handleClose);
        this.socket.removeEventListener("error", this.handleError);
    }

    /** Returns a promise that resolves when the websocket is open. */
    public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
        if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
            return this.socket;
        }

        return new Promise((resolve, reject) => {
            this.socket.addEventListener("open", () => {
                resolve(this.socket);
            });

            this.socket.addEventListener("error", (event: unknown) => {
                reject(event);
            });
        });
    }

    /** Asserts that the websocket is open. */
    private assertSocketIsOpen(): void {
        if (!this.socket) {
            throw new Error("Socket is not connected.");
        }

        if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
            throw new Error("Socket is not open.");
        }
    }

    /** Send a binary payload to the websocket. */
    protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
        this.socket.send(payload);
    }
}

================================================================================
// File: src/api/resources/tts/resources/streamInput/client/index.ts
================================================================================
export {};

================================================================================
// File: src/api/resources/tts/resources/streamInput/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/api/resources/tts/resources/voices/client/Client.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace VoicesClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class VoicesClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<VoicesClient.Options>;

    constructor(options: VoicesClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Lists voices you have saved in your account, or voices from the [Voice Library](https://app.hume.ai/voices).
     *
     * @param {Hume.tts.VoicesListRequest} request
     * @param {VoicesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.tts.BadRequestError}
     *
     * @example
     *     await client.tts.voices.list({
     *         provider: "CUSTOM_VOICE"
     *     })
     */
    public async list(
        request: Hume.tts.VoicesListRequest,
        requestOptions?: VoicesClient.RequestOptions,
    ): Promise<core.Page<Hume.tts.ReturnVoice, Hume.tts.ReturnPagedVoices>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (request: Hume.tts.VoicesListRequest): Promise<core.WithRawResponse<Hume.tts.ReturnPagedVoices>> => {
                const { provider, pageNumber, pageSize, ascendingOrder, filterTag } = request;
                const _queryParams: Record<string, unknown> = {
                    provider: serializers.tts.VoiceProvider.jsonOrThrow(provider, {
                        unrecognizedObjectKeys: "strip",
                        omitUndefined: true,
                    }),
                    page_number: pageNumber,
                    page_size: pageSize,
                    ascending_order: ascendingOrder,
                    filter_tag: filterTag,
                };
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/tts/voices",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.tts.ReturnPagedVoices.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.tts.BadRequestError(
                                serializers.tts.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/tts/voices");
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.tts.ReturnVoice, Hume.tts.ReturnPagedVoices>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.voicesPage ?? []).length > 0,
            getItems: (response) => response?.voicesPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * Saves a new custom voice to your account using the specified TTS generation ID.
     *
     * Once saved, this voice can be reused in subsequent TTS requests, ensuring consistent speech style and prosody. For more details on voice creation, see the [Voices Guide](/docs/text-to-speech-tts/voices).
     *
     * @param {Hume.tts.PostedVoice} request
     * @param {VoicesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.tts.UnprocessableEntityError}
     *
     * @example
     *     await client.tts.voices.create({
     *         generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
     *         name: "David Hume"
     *     })
     */
    public create(
        request: Hume.tts.PostedVoice,
        requestOptions?: VoicesClient.RequestOptions,
    ): core.HttpResponsePromise<Hume.tts.ReturnVoice> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: Hume.tts.PostedVoice,
        requestOptions?: VoicesClient.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.tts.ReturnVoice>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/voices",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.tts.PostedVoice.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.tts.ReturnVoice.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Hume.tts.UnprocessableEntityError(
                        serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts/voices");
    }

    /**
     * Deletes a previously generated custom voice.
     *
     * @param {Hume.tts.VoicesDeleteRequest} request
     * @param {VoicesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.tts.BadRequestError}
     *
     * @example
     *     await client.tts.voices.delete({
     *         name: "David Hume"
     *     })
     */
    public delete(
        request: Hume.tts.VoicesDeleteRequest,
        requestOptions?: VoicesClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: Hume.tts.VoicesDeleteRequest,
        requestOptions?: VoicesClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const { name } = request;
        const _queryParams: Record<string, unknown> = {
            name,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/tts/voices",
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.tts.BadRequestError(
                        serializers.tts.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v0/tts/voices");
    }
}

================================================================================
// File: src/api/resources/tts/resources/voices/client/index.ts
================================================================================
export * from "./requests/index.js";

================================================================================
// File: src/api/resources/tts/resources/voices/client/requests/PostedVoice.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
 *         name: "David Hume"
 *     }
 */
export interface PostedVoice {
    /** A unique ID associated with this TTS generation that can be used as context for generating consistent speech style and prosody across multiple requests. */
    generationId: string;
    /** The name of a **Voice**. */
    name: string;
}

================================================================================
// File: src/api/resources/tts/resources/voices/client/requests/VoicesDeleteRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         name: "David Hume"
 *     }
 */
export interface VoicesDeleteRequest {
    /** Name of the voice to delete */
    name: string;
}

================================================================================
// File: src/api/resources/tts/resources/voices/client/requests/VoicesListRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../index.js";

/**
 * @example
 *     {
 *         provider: "CUSTOM_VOICE"
 *     }
 */
export interface VoicesListRequest {
    /**
     * Specify the voice provider to filter voices returned by the endpoint:
     *
     * - **`HUME_AI`**: Lists preset, shared voices from Hume's [Voice Library](https://app.hume.ai/voices).
     * - **`CUSTOM_VOICE`**: Lists custom voices created and saved to your account.
     */
    provider: Hume.tts.VoiceProvider;
    /**
     * Specifies the page number to retrieve, enabling pagination.
     *
     * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
     */
    pageNumber?: number;
    /**
     * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
     *
     * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
     */
    pageSize?: number;
    ascendingOrder?: boolean;
    filterTag?: string | string[];
}

================================================================================
// File: src/api/resources/tts/resources/voices/client/requests/index.ts
================================================================================
export type { PostedVoice } from "./PostedVoice.js";
export type { VoicesDeleteRequest } from "./VoicesDeleteRequest.js";
export type { VoicesListRequest } from "./VoicesListRequest.js";

================================================================================
// File: src/api/resources/tts/resources/voices/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/api/resources/tts/types/AudioEncoding.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Encoding information about the generated audio, including the `format` and `sample_rate`.
 */
export interface AudioEncoding {
    /** Format for the output audio. */
    format: Hume.tts.AudioFormatType;
    /** The sample rate (`Hz`) of the generated audio. The default sample rate is `48000 Hz`. */
    sampleRate: number;
}

================================================================================
// File: src/api/resources/tts/types/AudioFormatType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const AudioFormatType = {
    Mp3: "mp3",
    Pcm: "pcm",
    Wav: "wav",
} as const;
export type AudioFormatType = (typeof AudioFormatType)[keyof typeof AudioFormatType];

================================================================================
// File: src/api/resources/tts/types/ErrorResponse.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface ErrorResponse {
    code?: string;
    error?: string;
    message?: string;
}

================================================================================
// File: src/api/resources/tts/types/Format.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Specifies the output audio file format.
 */
export type Format = Hume.tts.FormatMp3 | Hume.tts.FormatPcm | Hume.tts.FormatWav;

================================================================================
// File: src/api/resources/tts/types/FormatMp3.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface FormatMp3 {
    type: "mp3";
}

================================================================================
// File: src/api/resources/tts/types/FormatPcm.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface FormatPcm {
    type: "pcm";
}

================================================================================
// File: src/api/resources/tts/types/FormatWav.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface FormatWav {
    type: "wav";
}

================================================================================
// File: src/api/resources/tts/types/HttpValidationError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface HttpValidationError {
    detail?: Hume.tts.ValidationError[];
}

================================================================================
// File: src/api/resources/tts/types/MillisecondInterval.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface MillisecondInterval {
    /** Start time of the interval in milliseconds. */
    begin: number;
    /** End time of the interval in milliseconds. */
    end: number;
}

================================================================================
// File: src/api/resources/tts/types/OctaveVersion.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

/**
 * Selects the Octave model version used to synthesize speech for this request. If you omit this field, Hume
 * automatically routes the request to the most appropriate model. Setting a specific version ensures stable and
 * repeatable behavior across requests.
 *
 * Use `2` to opt into the latest Octave capabilities. When you specify version `2`, you must also provide a
 * `voice`. Requests that set `version: 2` without a voice will be rejected.
 *
 * For a comparison of Octave versions, see the
 * [Octave versions](/docs/text-to-speech-tts/overview#octave-versions) section in the TTS overview.
 */
export const OctaveVersion = {
    One: "1",
    Two: "2",
} as const;
export type OctaveVersion = (typeof OctaveVersion)[keyof typeof OctaveVersion];

================================================================================
// File: src/api/resources/tts/types/PostedContext.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Utterances to use as context for generating consistent speech style and prosody across multiple requests. These will not be converted to speech output.
 */
export type PostedContext = Hume.tts.PostedContextWithGenerationId | Hume.tts.PostedContextWithUtterances;

================================================================================
// File: src/api/resources/tts/types/PostedContextWithGenerationId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface PostedContextWithGenerationId {
    /** The ID of a prior TTS generation to use as context for generating consistent speech style and prosody across multiple requests. Including context may increase audio generation times. */
    generationId: string;
}

================================================================================
// File: src/api/resources/tts/types/PostedContextWithUtterances.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface PostedContextWithUtterances {
    utterances: Hume.tts.PostedUtterance[];
}

================================================================================
// File: src/api/resources/tts/types/PostedTts.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface PostedTts {
    /** Utterances to use as context for generating consistent speech style and prosody across multiple requests. These will not be converted to speech output. */
    context?: Hume.tts.PostedContext;
    /** Specifies the output audio file format. */
    format?: Hume.tts.Format;
    /** The set of timestamp types to include in the response. Only supported for Octave 2 requests. */
    includeTimestampTypes?: Hume.tts.TimestampType[];
    /**
     * Number of audio generations to produce from the input utterances.
     *
     * Using `num_generations` enables faster processing than issuing multiple sequential requests. Additionally, specifying `num_generations` allows prosody continuation across all generations without repeating context, ensuring each generation sounds slightly different while maintaining contextual consistency.
     */
    numGenerations?: number;
    /**
     * Controls how audio output is segmented in the response.
     *
     * - When **enabled** (`true`), input utterances are automatically split into natural-sounding speech segments.
     *
     * - When **disabled** (`false`), the response maintains a strict one-to-one mapping between input utterances and output snippets.
     *
     * This setting affects how the `snippets` array is structured in the response, which may be important for applications that need to track the relationship between input text and generated audio segments. When setting to `false`, avoid including utterances with long `text`, as this can result in distorted output.
     */
    splitUtterances?: boolean;
    /** If enabled, the audio for all the chunks of a generation, once concatenated together, will constitute a single audio file. Otherwise, if disabled, each chunk's audio will be its own audio file, each with its own headers (if applicable). */
    stripHeaders?: boolean;
    /**
     * A list of **Utterances** to be converted to speech output.
     *
     * An **Utterance** is a unit of input for [Octave](/docs/text-to-speech-tts/overview), and includes input `text`, an optional `description` to serve as the prompt for how the speech should be delivered, an optional `voice` specification, and additional controls to guide delivery for `speed` and `trailing_silence`.
     */
    utterances: Hume.tts.PostedUtterance[];
    /**
     * Selects the Octave model version used to synthesize speech for this request. If you omit this field, Hume automatically routes the request to the most appropriate model. Setting a specific version ensures stable and repeatable behavior across requests.
     *
     * Use `2` to opt into the latest Octave capabilities. When you specify version `2`, you must also provide a `voice`. Requests that set `version: 2` without a voice will be rejected.
     *
     * For a comparison of Octave versions, see the [Octave versions](/docs/text-to-speech-tts/overview#octave-versions) section in the TTS overview.
     */
    version?: Hume.tts.OctaveVersion;
    instantMode?: boolean;
}

================================================================================
// File: src/api/resources/tts/types/PostedUtterance.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface PostedUtterance {
    /**
     * Natural language instructions describing how the synthesized speech should sound, including but not limited to tone, intonation, pacing, and accent.
     *
     * **This field behaves differently depending on whether a voice is specified**:
     * - **Voice specified**: the description will serve as acting directions for delivery. Keep directions concise—100 characters or fewer—for best results. See our guide on [acting instructions](/docs/text-to-speech-tts/acting-instructions).
     * - **Voice not specified**: the description will serve as a voice prompt for generating a voice. See our [prompting guide](/docs/text-to-speech-tts/prompting) for design tips.
     */
    description?: string;
    /** Speed multiplier for the synthesized speech. Extreme values below 0.75 and above 1.5 may sometimes cause instability to the generated output. */
    speed?: number;
    /** The input text to be synthesized into speech. */
    text: string;
    /** Duration of trailing silence (in seconds) to add to this utterance */
    trailingSilence?: number;
    /**
     * The `name` or `id` associated with a **Voice** from the **Voice Library** to be used as the speaker for this and all subsequent `utterances`, until the `voice` field is updated again.
     *
     *  See our [voices guide](/docs/text-to-speech-tts/voices) for more details on generating and specifying **Voices**.
     */
    voice?: Hume.tts.PostedUtteranceVoice;
}

================================================================================
// File: src/api/resources/tts/types/PostedUtteranceVoice.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type PostedUtteranceVoice = Hume.tts.PostedUtteranceVoiceWithId | Hume.tts.PostedUtteranceVoiceWithName;

================================================================================
// File: src/api/resources/tts/types/PostedUtteranceVoiceWithId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface PostedUtteranceVoiceWithId {
    /** The unique ID associated with the **Voice**. */
    id: string;
    /**
     * Specifies the source provider associated with the chosen voice.
     *
     * - **`HUME_AI`**: Select voices from Hume's [Voice Library](https://app.hume.ai/voices), containing a variety of preset, shared voices.
     * - **`CUSTOM_VOICE`**: Select from voices you've personally generated and saved in your account.
     *
     * If no provider is explicitly set, the default provider is `CUSTOM_VOICE`. When using voices from Hume's **Voice Library**, you must explicitly set the provider to `HUME_AI`.
     *
     * Preset voices from Hume's **Voice Library** are accessible by all users. In contrast, your custom voices are private and accessible only via requests authenticated with your API key.
     */
    provider?: Hume.tts.VoiceProvider;
}

================================================================================
// File: src/api/resources/tts/types/PostedUtteranceVoiceWithName.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface PostedUtteranceVoiceWithName {
    /** The name of a **Voice**. */
    name: string;
    /**
     * Specifies the source provider associated with the chosen voice.
     *
     * - **`HUME_AI`**: Select voices from Hume's [Voice Library](https://app.hume.ai/voices), containing a variety of preset, shared voices.
     * - **`CUSTOM_VOICE`**: Select from voices you've personally generated and saved in your account.
     *
     * If no provider is explicitly set, the default provider is `CUSTOM_VOICE`. When using voices from Hume's **Voice Library**, you must explicitly set the provider to `HUME_AI`.
     *
     * Preset voices from Hume's **Voice Library** are accessible by all users. In contrast, your custom voices are private and accessible only via requests authenticated with your API key.
     */
    provider?: Hume.tts.VoiceProvider;
}

================================================================================
// File: src/api/resources/tts/types/PublishTts.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Input message type for the TTS stream.
 */
export interface PublishTts {
    /** Force the generation of audio and close the stream. */
    close?: boolean;
    /**
     * Natural language instructions describing how the synthesized speech should sound, including but not limited to tone, intonation, pacing, and accent.
     *
     * **This field behaves differently depending on whether a voice is specified**:
     * - **Voice specified**: the description will serve as acting directions for delivery. Keep directions concise—100 characters or fewer—for best results. See our guide on [acting instructions](/docs/text-to-speech-tts/acting-instructions).
     * - **Voice not specified**: the description will serve as a voice prompt for generating a voice. See our [prompting guide](/docs/text-to-speech-tts/prompting) for design tips.
     */
    description?: string;
    /** Force the generation of audio regardless of how much text has been supplied. */
    flush?: boolean;
    /** Speed multiplier for the synthesized speech. Extreme values below 0.75 and above 1.5 may sometimes cause instability to the generated output. */
    speed?: number;
    /** The input text to be synthesized into speech. */
    text?: string;
    /** Duration of trailing silence (in seconds) to add to this utterance */
    trailingSilence?: number;
    /**
     * The `name` or `id` associated with a **Voice** from the **Voice Library** to be used as the speaker for this and all subsequent `utterances`, until the `voice` field is updated again.
     *
     *  See our [voices guide](/docs/text-to-speech-tts/voices) for more details on generating and specifying **Voices**.
     */
    voice?: Hume.tts.PostedUtteranceVoice;
}

================================================================================
// File: src/api/resources/tts/types/ReturnGeneration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ReturnGeneration {
    /** The generated audio output in the requested format, encoded as a base64 string. */
    audio: string;
    /** Duration of the generated audio in seconds. */
    duration: number;
    encoding: Hume.tts.AudioEncoding;
    /** Size of the generated audio in bytes. */
    fileSize: number;
    /** A unique ID associated with this TTS generation that can be used as context for generating consistent speech style and prosody across multiple requests. */
    generationId: string;
    /** A list of snippet groups where each group corresponds to an utterance in the request. Each group contains segmented snippets that represent the original utterance divided into more natural-sounding units optimized for speech delivery. */
    snippets: Hume.tts.Snippet[][];
}

================================================================================
// File: src/api/resources/tts/types/ReturnPagedVoices.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A paginated list Octave voices available for text-to-speech
 */
export interface ReturnPagedVoices {
    /** The page number of the returned results. */
    pageNumber: number;
    /**
     * The maximum number of items returned per page.
     *
     * This value corresponds to the `page_size` parameter specified in the request.
     */
    pageSize: number;
    /** The total number of pages in the collection. */
    totalPages: number;
    /** List of voices returned for the specified `page_number` and `page_size`. */
    voicesPage: Hume.tts.ReturnVoice[];
}

================================================================================
// File: src/api/resources/tts/types/ReturnTts.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ReturnTts {
    generations: Hume.tts.ReturnGeneration[];
    /** A unique ID associated with this request for tracking and troubleshooting. Use this ID when contacting [support](/support) for troubleshooting assistance. */
    requestId?: string;
}

================================================================================
// File: src/api/resources/tts/types/ReturnVoice.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * An Octave voice available for text-to-speech
 */
export interface ReturnVoice {
    compatibleOctaveModels?: string[];
    /** ID of the voice in the `Voice Library`. */
    id: string;
    /** Name of the voice in the `Voice Library`. */
    name: string;
    /**
     * The provider associated with the created voice.
     *
     * Voices created through this endpoint will always have the provider set to `CUSTOM_VOICE`, indicating a custom voice stored in your account.
     */
    provider: Hume.tts.VoiceProvider;
}

================================================================================
// File: src/api/resources/tts/types/Snippet.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface Snippet {
    /** The segmented audio output in the requested format, encoded as a base64 string. */
    audio: string;
    /** The generation ID this snippet corresponds to. */
    generationId: string;
    /** A unique ID associated with this **Snippet**. */
    id: string;
    /** The text for this **Snippet**. */
    text: string;
    /** A list of word or phoneme level timestamps for the generated audio. Timestamps are only returned for Octave 2 requests. */
    timestamps: Hume.tts.Timestamp[];
    /** The transcribed text of the generated audio. It is only present if `instant_mode` is set to `false`. */
    transcribedText?: string;
    /** The index of the utterance in the request this snippet corresponds to. */
    utteranceIndex?: number;
}

================================================================================
// File: src/api/resources/tts/types/SnippetAudioChunk.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * Metadata for a chunk of generated audio.
 */
export interface SnippetAudioChunk {
    /** The generated audio output chunk in the requested format. */
    audio: string;
    /** The generated audio output format. */
    audioFormat: Hume.tts.AudioFormatType;
    /** The index of the audio chunk in the snippet. */
    chunkIndex: number;
    /** The generation ID of the parent snippet that this chunk corresponds to. */
    generationId: string;
    /** Whether or not this is the last chunk streamed back from the decoder for one input snippet. */
    isLastChunk: boolean;
    /** ID of the initiating request. */
    requestId: string;
    snippet?: Hume.tts.Snippet;
    /** The ID of the parent snippet that this chunk corresponds to. */
    snippetId: string;
    /** The text of the parent snippet that this chunk corresponds to. */
    text: string;
    /** The transcribed text of the generated audio of the parent snippet that this chunk corresponds to. It is only present if `instant_mode` is set to `false`. */
    transcribedText?: string;
    type: "audio";
    /** The index of the utterance in the request that the parent snippet of this chunk corresponds to. */
    utteranceIndex?: number;
}

================================================================================
// File: src/api/resources/tts/types/Timestamp.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface Timestamp {
    /** The word or phoneme text that the timestamp corresponds to. */
    text: string;
    /** The start and end timestamps for the word or phoneme in milliseconds. */
    time: Hume.tts.MillisecondInterval;
    type: Hume.tts.TimestampType;
}

================================================================================
// File: src/api/resources/tts/types/TimestampMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

/**
 * A word or phoneme level timestamp for the generated audio.
 */
export interface TimestampMessage {
    /** The generation ID of the parent snippet that this chunk corresponds to. */
    generationId: string;
    /** ID of the initiating request. */
    requestId: string;
    /** The ID of the parent snippet that this chunk corresponds to. */
    snippetId: string;
    /** A word or phoneme level timestamp for the generated audio. */
    timestamp: Hume.tts.Timestamp;
    type: "timestamp";
}

================================================================================
// File: src/api/resources/tts/types/TimestampType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const TimestampType = {
    Word: "word",
    Phoneme: "phoneme",
} as const;
export type TimestampType = (typeof TimestampType)[keyof typeof TimestampType];

================================================================================
// File: src/api/resources/tts/types/TtsOutput.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export type TtsOutput = Hume.tts.SnippetAudioChunk | Hume.tts.TimestampMessage;

================================================================================
// File: src/api/resources/tts/types/ValidationError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../index.js";

export interface ValidationError {
    loc: Hume.tts.ValidationErrorLocItem[];
    msg: string;
    type: string;
}

================================================================================
// File: src/api/resources/tts/types/ValidationErrorLocItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export type ValidationErrorLocItem = string | number;

================================================================================
// File: src/api/resources/tts/types/VoiceProvider.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export const VoiceProvider = {
    HumeAi: "HUME_AI",
    CustomVoice: "CUSTOM_VOICE",
} as const;
export type VoiceProvider = (typeof VoiceProvider)[keyof typeof VoiceProvider];

================================================================================
// File: src/api/resources/tts/types/index.ts
================================================================================
export * from "./AudioEncoding.js";
export * from "./AudioFormatType.js";
export * from "./ErrorResponse.js";
export * from "./Format.js";
export * from "./FormatMp3.js";
export * from "./FormatPcm.js";
export * from "./FormatWav.js";
export * from "./HttpValidationError.js";
export * from "./MillisecondInterval.js";
export * from "./OctaveVersion.js";
export * from "./PostedContext.js";
export * from "./PostedContextWithGenerationId.js";
export * from "./PostedContextWithUtterances.js";
export * from "./PostedTts.js";
export * from "./PostedUtterance.js";
export * from "./PostedUtteranceVoice.js";
export * from "./PostedUtteranceVoiceWithId.js";
export * from "./PostedUtteranceVoiceWithName.js";
export * from "./PublishTts.js";
export * from "./ReturnGeneration.js";
export * from "./ReturnPagedVoices.js";
export * from "./ReturnTts.js";
export * from "./ReturnVoice.js";
export * from "./Snippet.js";
export * from "./SnippetAudioChunk.js";
export * from "./Timestamp.js";
export * from "./TimestampMessage.js";
export * from "./TimestampType.js";
export * from "./TtsOutput.js";
export * from "./ValidationError.js";
export * from "./ValidationErrorLocItem.js";
export * from "./VoiceProvider.js";

================================================================================
// File: src/auth/HeaderAuthProvider.ts
================================================================================
/**
 * THIS FILE IS MANUALLY MAINTAINED: see .fernignore
 *
 * Custom HeaderAuthProvider that supports both apiKey and accessToken authentication.
 * When accessToken is provided to HumeClient, the wrapper converts it to an
 * Authorization: Bearer header. This provider checks for both apiKey and the
 * Authorization header to support both auth methods.
 */

import * as core from "../core/index.js";
import * as errors from "../errors/index.js";

export namespace HeaderAuthProvider {
    export type AuthOptions = {
        apiKey?: core.Supplier<string | undefined>;
    };

    export type Options = {
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    } & AuthOptions;
}

export class HeaderAuthProvider implements core.AuthProvider {
    private readonly options: HeaderAuthProvider.Options;

    constructor(options: HeaderAuthProvider.Options) {
        this.options = options;
    }

    public static canCreate(options: HeaderAuthProvider.Options): boolean {
        return options.apiKey != null || HeaderAuthProvider.hasAuthorizationHeader(options.headers);
    }

    private static hasAuthorizationHeader(
        headers: Record<string, string | core.Supplier<string | null | undefined> | null | undefined> | undefined,
    ): boolean {
        if (!headers) return false;
        return Object.keys(headers).some((key) => key.toLowerCase() === "authorization");
    }

    public async getAuthRequest(_arg?: { endpointMetadata?: core.EndpointMetadata }): Promise<core.AuthRequest> {
        // Check apiKey first (preferred method)
        const apiKey = await core.Supplier.get(this.options.apiKey);
        if (apiKey != null) {
            return { headers: { "X-Hume-Api-Key": apiKey } };
        }

        // Check for Authorization header (from accessToken)
        if (this.options.headers) {
            const authKey = Object.keys(this.options.headers).find((key) => key.toLowerCase() === "authorization");
            if (authKey) {
                const authValue = await core.Supplier.get(this.options.headers[authKey]);
                if (authValue != null) {
                    return { headers: { Authorization: authValue } };
                }
            }
        }

        throw new errors.HumeError({
            message: "Please provide either 'apiKey' or 'accessToken' when initializing the client",
        });
    }
}

================================================================================
// File: src/auth/HeaderAuthProvider.ts.diff
================================================================================
diff --git a/src/auth/HeaderAuthProvider.ts b/src/auth/HeaderAuthProvider.ts
index 8089bcc..83c2e42 100644
--- a/src/auth/HeaderAuthProvider.ts
+++ b/src/auth/HeaderAuthProvider.ts
@@ -1,24 +1,10 @@
-/**
- * THIS FILE IS MANUALLY MAINTAINED: see .fernignore
- *
- * Custom HeaderAuthProvider that supports both apiKey and accessToken authentication.
- * When accessToken is provided to HumeClient, the wrapper converts it to an
- * Authorization: Bearer header. This provider checks for both apiKey and the
- * Authorization header to support both auth methods.
- */
+// This file was auto-generated by Fern from our API Definition.
 
 import * as core from "../core/index.js";
 import * as errors from "../errors/index.js";
 
-export namespace HeaderAuthProvider {
-    export type AuthOptions = {
-        apiKey?: core.Supplier<string | undefined>;
-    };
-
-    export type Options = {
-        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
-    } & AuthOptions;
-}
+const PARAM_KEY = "apiKey" as const;
+const HEADER_NAME = "X-Hume-Api-Key" as const;
 
 export class HeaderAuthProvider implements core.AuthProvider {
     private readonly options: HeaderAuthProvider.Options;
@@ -27,37 +13,36 @@ export class HeaderAuthProvider implements core.AuthProvider {
         this.options = options;
     }
 
-    public static canCreate(options: HeaderAuthProvider.Options): boolean {
-        return options.apiKey != null || HeaderAuthProvider.hasAuthorizationHeader(options.headers);
-    }
-
-    private static hasAuthorizationHeader(
-        headers: Record<string, string | core.Supplier<string | null | undefined> | null | undefined> | undefined,
-    ): boolean {
-        if (!headers) return false;
-        return Object.keys(headers).some((key) => key.toLowerCase() === "authorization");
+    public static canCreate(options: Partial<HeaderAuthProvider.Options>): boolean {
+        return options?.[PARAM_KEY] != null;
     }
 
-    public async getAuthRequest(_arg?: { endpointMetadata?: core.EndpointMetadata }): Promise<core.AuthRequest> {
-        // Check apiKey first (preferred method)
-        const apiKey = await core.Supplier.get(this.options.apiKey);
-        if (apiKey != null) {
-            return { headers: { "X-Hume-Api-Key": apiKey } };
+    public async getAuthRequest({
+        endpointMetadata,
+    }: {
+        endpointMetadata?: core.EndpointMetadata;
+    } = {}): Promise<core.AuthRequest> {
+        const headerValue = await core.Supplier.get(this.options[PARAM_KEY]);
+        if (headerValue == null) {
+            throw new errors.HumeError({
+                message: HeaderAuthProvider.AUTH_CONFIG_ERROR_MESSAGE,
+            });
         }
 
-        // Check for Authorization header (from accessToken)
-        if (this.options.headers) {
-            const authKey = Object.keys(this.options.headers).find((key) => key.toLowerCase() === "authorization");
-            if (authKey) {
-                const authValue = await core.Supplier.get(this.options.headers[authKey]);
-                if (authValue != null) {
-                    return { headers: { Authorization: authValue } };
-                }
-            }
-        }
+        return {
+            headers: { [HEADER_NAME]: headerValue },
+        };
+    }
+}
 
-        throw new errors.HumeError({
-            message: "Please provide either 'apiKey' or 'accessToken' when initializing the client",
-        });
+export namespace HeaderAuthProvider {
+    export const AUTH_SCHEME = "HeaderAuthScheme" as const;
+    export const AUTH_CONFIG_ERROR_MESSAGE: string =
+        `Please provide '${PARAM_KEY}' when initializing the client` as const;
+    export type Options = AuthOptions;
+    export type AuthOptions = { [PARAM_KEY]: core.Supplier<string> };
+
+    export function createInstance(options: Options): core.AuthProvider {
+        return new HeaderAuthProvider(options);
     }
 }

================================================================================
// File: src/auth/index.ts
================================================================================
export { HeaderAuthProvider } from "./HeaderAuthProvider.js";

================================================================================
// File: src/environments.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export interface HumeEnvironmentUrls {
    base: string;
    evi: string;
    tts: string;
    stream: string;
}

export const HumeEnvironment = {
    Prod: {
        base: "https://api.hume.ai",
        evi: "wss://api.hume.ai/v0/evi",
        tts: "wss://api.hume.ai/v0/tts",
        stream: "wss://api.hume.ai/v0/stream",
    },
} as const;

export type HumeEnvironment = typeof HumeEnvironment.Prod;

================================================================================
// File: src/errors/HumeError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../core/index.js";
import { toJson } from "../core/json.js";

export class HumeError extends Error {
    public readonly statusCode?: number;
    public readonly body?: unknown;
    public readonly rawResponse?: core.RawResponse;

    constructor({
        message,
        statusCode,
        body,
        rawResponse,
    }: {
        message?: string;
        statusCode?: number;
        body?: unknown;
        rawResponse?: core.RawResponse;
    }) {
        super(buildMessage({ message, statusCode, body }));
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }

        this.name = this.constructor.name;
        this.statusCode = statusCode;
        this.body = body;
        this.rawResponse = rawResponse;
    }
}

function buildMessage({
    message,
    statusCode,
    body,
}: {
    message: string | undefined;
    statusCode: number | undefined;
    body: unknown | undefined;
}): string {
    const lines: string[] = [];
    if (message != null) {
        lines.push(message);
    }

    if (statusCode != null) {
        lines.push(`Status code: ${statusCode.toString()}`);
    }

    if (body != null) {
        lines.push(`Body: ${toJson(body, undefined, 2)}`);
    }

    return lines.join("\n");
}

================================================================================
// File: src/errors/HumeTimeoutError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

export class HumeTimeoutError extends Error {
    constructor(message: string) {
        super(message);
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }

        this.name = this.constructor.name;
    }
}

================================================================================
// File: src/errors/handleNonStatusCodeError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as core from "../core/index.js";
import * as errors from "./index.js";

export function handleNonStatusCodeError(
    error: core.Fetcher.Error,
    rawResponse: core.RawResponse,
    method: string,
    path: string,
): never {
    switch (error.reason) {
        case "non-json":
            throw new errors.HumeError({
                statusCode: error.statusCode,
                body: error.rawBody,
                rawResponse: rawResponse,
            });
        case "body-is-null":
            throw new errors.HumeError({
                statusCode: error.statusCode,
                rawResponse: rawResponse,
            });
        case "timeout":
            throw new errors.HumeTimeoutError(`Timeout exceeded when calling ${method} ${path}.`);
        case "unknown":
            throw new errors.HumeError({
                message: error.errorMessage,
                rawResponse: rawResponse,
            });
        default:
            throw new errors.HumeError({
                message: "Unknown error",
                rawResponse: rawResponse,
            });
    }
}

================================================================================
// File: src/errors/index.ts
================================================================================
export { HumeError } from "./HumeError.js";
export { HumeTimeoutError } from "./HumeTimeoutError.js";

================================================================================
// File: src/exports.ts
================================================================================
export * from "./core/exports.js";

================================================================================
// File: src/index.ts
================================================================================
export * as Hume from "./api/index.js";
export * as serialization from "./serialization/index.js";
export { HumeError, HumeTimeoutError } from "./errors/index.js";
export { HumeEnvironment } from "./environments.js";
export type { HumeEnvironmentUrls } from "./environments.js";
export * from "./exports.js";

export * from "./wrapper/index.js";

================================================================================
// File: src/index.ts.diff
================================================================================
diff --git a/src/index.ts b/src/index.ts
index 4d19902..c814670 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -1,8 +1,7 @@
 export * as Hume from "./api/index.js";
-export * as serialization from "./serialization/index.js";
+export type { BaseClientOptions, BaseRequestOptions } from "./BaseClient.js";
+export { HumeClient } from "./Client.js";
+export { HumeEnvironment, type HumeEnvironmentUrls } from "./environments.js";
 export { HumeError, HumeTimeoutError } from "./errors/index.js";
-export { HumeEnvironment } from "./environments.js";
-export type { HumeEnvironmentUrls } from "./environments.js";
 export * from "./exports.js";
-
-export * from "./wrapper/index.js";
+export * as serialization from "./serialization/index.js";

================================================================================
// File: src/serialization/index.ts
================================================================================
export * from "./resources/index.js";

================================================================================
// File: src/serialization/resources/empathicVoice/index.ts
================================================================================
export * from "./resources/index.js";
export * from "./types/index.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/chat/client/index.ts
================================================================================
export * from "./socket/index.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/chat/client/socket/ChatSocketResponse.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";
import { SubscribeEvent } from "../../../../types/SubscribeEvent.js";

export const ChatSocketResponse: core.serialization.Schema<
    serializers.empathicVoice.ChatSocketResponse.Raw,
    Hume.empathicVoice.SubscribeEvent
> = core.serialization.undiscriminatedUnion([SubscribeEvent]);

export declare namespace ChatSocketResponse {
    export type Raw = SubscribeEvent.Raw;
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/chat/client/socket/index.ts
================================================================================
export { ChatSocketResponse } from "./ChatSocketResponse.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/chat/index.ts
================================================================================
export * from "./client/index.js";
export * from "./types/index.js";
/**
 * @deprecated Use `serialization.empathicVoice.SubscribeEvent` instead.
 * This serializer alias will be removed in a future version.
 */
export { SubscribeEvent } from "./types/SubscribeEvent.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/chat/index.ts.diff
================================================================================
diff --git a/src/serialization/resources/empathicVoice/resources/chat/index.ts b/src/serialization/resources/empathicVoice/resources/chat/index.ts
index f5ca113..d9adb1a 100644
--- a/src/serialization/resources/empathicVoice/resources/chat/index.ts
+++ b/src/serialization/resources/empathicVoice/resources/chat/index.ts
@@ -1,7 +1,2 @@
 export * from "./client/index.js";
 export * from "./types/index.js";
-/**
- * @deprecated Use `serialization.empathicVoice.SubscribeEvent` instead.
- * This serializer alias will be removed in a future version.
- */
-export { SubscribeEvent } from "./types/SubscribeEvent.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/chat/types/PublishEvent.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { AssistantInput } from "../../../types/AssistantInput.js";
import { AudioInput } from "../../../types/AudioInput.js";
import { PauseAssistantMessage } from "../../../types/PauseAssistantMessage.js";
import { ResumeAssistantMessage } from "../../../types/ResumeAssistantMessage.js";
import { SessionSettings } from "../../../types/SessionSettings.js";
import { ToolErrorMessage } from "../../../types/ToolErrorMessage.js";
import { ToolResponseMessage } from "../../../types/ToolResponseMessage.js";
import { UserInput } from "../../../types/UserInput.js";

export const PublishEvent: core.serialization.Schema<
    serializers.empathicVoice.PublishEvent.Raw,
    Hume.empathicVoice.PublishEvent
> = core.serialization.undiscriminatedUnion([
    AudioInput,
    SessionSettings,
    UserInput,
    AssistantInput,
    ToolResponseMessage,
    ToolErrorMessage,
    PauseAssistantMessage,
    ResumeAssistantMessage,
]);

export declare namespace PublishEvent {
    export type Raw =
        | AudioInput.Raw
        | SessionSettings.Raw
        | UserInput.Raw
        | AssistantInput.Raw
        | ToolResponseMessage.Raw
        | ToolErrorMessage.Raw
        | PauseAssistantMessage.Raw
        | ResumeAssistantMessage.Raw;
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/chat/types/SubscribeEvent.ts
================================================================================
/**
 * This file was manually added to provide backward compatibility.
 *
 * @deprecated Use `serialization.empathicVoice.SubscribeEvent` instead.
 * This serializer alias will be removed in a future version.
 */

import { SubscribeEvent as NewSubscribeEvent } from "../../../types/SubscribeEvent.js";

/**
 * @deprecated Use `serialization.empathicVoice.SubscribeEvent` instead.
 * This serializer alias will be removed in a future version.
 */
export const SubscribeEvent: typeof NewSubscribeEvent = NewSubscribeEvent;

export declare namespace SubscribeEvent {
    /**
     * @deprecated Use `serialization.empathicVoice.SubscribeEvent.Raw` instead.
     * This type alias will be removed in a future version.
     */
    export type Raw = NewSubscribeEvent.Raw;
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/chat/types/index.ts
================================================================================
export * from "./PublishEvent.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/configs/client/index.ts
================================================================================
export * from "./requests/index.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/configs/client/requests/PostedConfig.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";
import { PostedBuiltinTool } from "../../../../types/PostedBuiltinTool.js";
import { PostedConfigPromptSpec } from "../../../../types/PostedConfigPromptSpec.js";
import { PostedEllmModel } from "../../../../types/PostedEllmModel.js";
import { PostedEventMessageSpecs } from "../../../../types/PostedEventMessageSpecs.js";
import { PostedLanguageModel } from "../../../../types/PostedLanguageModel.js";
import { PostedNudgeSpec } from "../../../../types/PostedNudgeSpec.js";
import { PostedTimeoutSpecs } from "../../../../types/PostedTimeoutSpecs.js";
import { PostedUserDefinedToolSpec } from "../../../../types/PostedUserDefinedToolSpec.js";
import { PostedWebhookSpec } from "../../../../types/PostedWebhookSpec.js";
import { VoiceRef } from "../../../../types/VoiceRef.js";

export const PostedConfig: core.serialization.Schema<
    serializers.empathicVoice.PostedConfig.Raw,
    Hume.empathicVoice.PostedConfig
> = core.serialization.object({
    builtinTools: core.serialization.property(
        "builtin_tools",
        core.serialization.list(PostedBuiltinTool.optional()).optional(),
    ),
    ellmModel: core.serialization.property("ellm_model", PostedEllmModel.optional()),
    eventMessages: core.serialization.property("event_messages", PostedEventMessageSpecs.optional()),
    eviVersion: core.serialization.property("evi_version", core.serialization.string()),
    languageModel: core.serialization.property("language_model", PostedLanguageModel.optional()),
    name: core.serialization.string(),
    nudges: PostedNudgeSpec.optional(),
    prompt: PostedConfigPromptSpec.optional(),
    timeouts: PostedTimeoutSpecs.optional(),
    tools: core.serialization.list(PostedUserDefinedToolSpec.optional()).optional(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
    voice: VoiceRef.optional(),
    webhooks: core.serialization.list(PostedWebhookSpec.optional()).optional(),
});

export declare namespace PostedConfig {
    export interface Raw {
        builtin_tools?: (PostedBuiltinTool.Raw | null | undefined)[] | null;
        ellm_model?: PostedEllmModel.Raw | null;
        event_messages?: PostedEventMessageSpecs.Raw | null;
        evi_version: string;
        language_model?: PostedLanguageModel.Raw | null;
        name: string;
        nudges?: PostedNudgeSpec.Raw | null;
        prompt?: PostedConfigPromptSpec.Raw | null;
        timeouts?: PostedTimeoutSpecs.Raw | null;
        tools?: (PostedUserDefinedToolSpec.Raw | null | undefined)[] | null;
        version_description?: string | null;
        voice?: VoiceRef.Raw | null;
        webhooks?: (PostedWebhookSpec.Raw | null | undefined)[] | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/configs/client/requests/PostedConfigName.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedConfigName: core.serialization.Schema<
    serializers.empathicVoice.PostedConfigName.Raw,
    Hume.empathicVoice.PostedConfigName
> = core.serialization.object({
    name: core.serialization.string(),
});

export declare namespace PostedConfigName {
    export interface Raw {
        name: string;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/configs/client/requests/PostedConfigVersion.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";
import { PostedBuiltinTool } from "../../../../types/PostedBuiltinTool.js";
import { PostedConfigPromptSpec } from "../../../../types/PostedConfigPromptSpec.js";
import { PostedEllmModel } from "../../../../types/PostedEllmModel.js";
import { PostedEventMessageSpecs } from "../../../../types/PostedEventMessageSpecs.js";
import { PostedLanguageModel } from "../../../../types/PostedLanguageModel.js";
import { PostedNudgeSpec } from "../../../../types/PostedNudgeSpec.js";
import { PostedTimeoutSpecs } from "../../../../types/PostedTimeoutSpecs.js";
import { PostedUserDefinedToolSpec } from "../../../../types/PostedUserDefinedToolSpec.js";
import { PostedWebhookSpec } from "../../../../types/PostedWebhookSpec.js";
import { VoiceRef } from "../../../../types/VoiceRef.js";

export const PostedConfigVersion: core.serialization.Schema<
    serializers.empathicVoice.PostedConfigVersion.Raw,
    Hume.empathicVoice.PostedConfigVersion
> = core.serialization.object({
    builtinTools: core.serialization.property(
        "builtin_tools",
        core.serialization.list(PostedBuiltinTool.optional()).optional(),
    ),
    ellmModel: core.serialization.property("ellm_model", PostedEllmModel.optional()),
    eventMessages: core.serialization.property("event_messages", PostedEventMessageSpecs.optional()),
    eviVersion: core.serialization.property("evi_version", core.serialization.string()),
    languageModel: core.serialization.property("language_model", PostedLanguageModel.optional()),
    nudges: PostedNudgeSpec.optional(),
    prompt: PostedConfigPromptSpec.optional(),
    timeouts: PostedTimeoutSpecs.optional(),
    tools: core.serialization.list(PostedUserDefinedToolSpec.optional()).optional(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
    voice: VoiceRef.optional(),
    webhooks: core.serialization.list(PostedWebhookSpec.optional()).optional(),
});

export declare namespace PostedConfigVersion {
    export interface Raw {
        builtin_tools?: (PostedBuiltinTool.Raw | null | undefined)[] | null;
        ellm_model?: PostedEllmModel.Raw | null;
        event_messages?: PostedEventMessageSpecs.Raw | null;
        evi_version: string;
        language_model?: PostedLanguageModel.Raw | null;
        nudges?: PostedNudgeSpec.Raw | null;
        prompt?: PostedConfigPromptSpec.Raw | null;
        timeouts?: PostedTimeoutSpecs.Raw | null;
        tools?: (PostedUserDefinedToolSpec.Raw | null | undefined)[] | null;
        version_description?: string | null;
        voice?: VoiceRef.Raw | null;
        webhooks?: (PostedWebhookSpec.Raw | null | undefined)[] | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/configs/client/requests/PostedConfigVersionDescription.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedConfigVersionDescription: core.serialization.Schema<
    serializers.empathicVoice.PostedConfigVersionDescription.Raw,
    Hume.empathicVoice.PostedConfigVersionDescription
> = core.serialization.object({
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedConfigVersionDescription {
    export interface Raw {
        version_description?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/configs/client/requests/index.ts
================================================================================
export { PostedConfig } from "./PostedConfig.js";
export { PostedConfigName } from "./PostedConfigName.js";
export { PostedConfigVersion } from "./PostedConfigVersion.js";
export { PostedConfigVersionDescription } from "./PostedConfigVersionDescription.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/configs/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/controlPlane/client/index.ts
================================================================================
export * from "./socket/index.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/controlPlane/client/socket/ControlPlaneSocketResponse.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";
import { SubscribeEvent } from "../../../../types/SubscribeEvent.js";

export const ControlPlaneSocketResponse: core.serialization.Schema<
    serializers.empathicVoice.ControlPlaneSocketResponse.Raw,
    Hume.empathicVoice.SubscribeEvent
> = core.serialization.undiscriminatedUnion([SubscribeEvent]);

export declare namespace ControlPlaneSocketResponse {
    export type Raw = SubscribeEvent.Raw;
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/controlPlane/client/socket/index.ts
================================================================================
export { ControlPlaneSocketResponse } from "./ControlPlaneSocketResponse.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/controlPlane/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/index.ts
================================================================================
export * from "./chat/client/socket/index.js";
export * as chat from "./chat/index.js";
export * from "./chat/types/index.js";
export * from "./configs/client/requests/index.js";
export * as configs from "./configs/index.js";
export * from "./controlPlane/client/socket/index.js";
export * as controlPlane from "./controlPlane/index.js";
export * from "./prompts/client/requests/index.js";
export * as prompts from "./prompts/index.js";
export * from "./tools/client/requests/index.js";
export * as tools from "./tools/index.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/prompts/client/createPrompt.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnPrompt } from "../../../types/ReturnPrompt.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.prompts.createPrompt.Response.Raw,
    Hume.empathicVoice.ReturnPrompt | undefined
> = ReturnPrompt.optional();

export declare namespace Response {
    export type Raw = ReturnPrompt.Raw | null | undefined;
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/prompts/client/createPromptVersion.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnPrompt } from "../../../types/ReturnPrompt.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.prompts.createPromptVersion.Response.Raw,
    Hume.empathicVoice.ReturnPrompt | undefined
> = ReturnPrompt.optional();

export declare namespace Response {
    export type Raw = ReturnPrompt.Raw | null | undefined;
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/prompts/client/getPromptVersion.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnPrompt } from "../../../types/ReturnPrompt.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.prompts.getPromptVersion.Response.Raw,
    Hume.empathicVoice.ReturnPrompt | undefined
> = ReturnPrompt.optional();

export declare namespace Response {
    export type Raw = ReturnPrompt.Raw | null | undefined;
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/prompts/client/index.ts
================================================================================
export * as createPrompt from "./createPrompt.js";
export * as createPromptVersion from "./createPromptVersion.js";
export * as getPromptVersion from "./getPromptVersion.js";
export * from "./requests/index.js";
export * as updatePromptDescription from "./updatePromptDescription.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/prompts/client/requests/PostedPrompt.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedPrompt: core.serialization.Schema<
    serializers.empathicVoice.PostedPrompt.Raw,
    Hume.empathicVoice.PostedPrompt
> = core.serialization.object({
    name: core.serialization.string(),
    text: core.serialization.string(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedPrompt {
    export interface Raw {
        name: string;
        text: string;
        version_description?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/prompts/client/requests/PostedPromptName.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedPromptName: core.serialization.Schema<
    serializers.empathicVoice.PostedPromptName.Raw,
    Hume.empathicVoice.PostedPromptName
> = core.serialization.object({
    name: core.serialization.string(),
});

export declare namespace PostedPromptName {
    export interface Raw {
        name: string;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/prompts/client/requests/PostedPromptVersion.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedPromptVersion: core.serialization.Schema<
    serializers.empathicVoice.PostedPromptVersion.Raw,
    Hume.empathicVoice.PostedPromptVersion
> = core.serialization.object({
    text: core.serialization.string(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedPromptVersion {
    export interface Raw {
        text: string;
        version_description?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/prompts/client/requests/PostedPromptVersionDescription.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedPromptVersionDescription: core.serialization.Schema<
    serializers.empathicVoice.PostedPromptVersionDescription.Raw,
    Hume.empathicVoice.PostedPromptVersionDescription
> = core.serialization.object({
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedPromptVersionDescription {
    export interface Raw {
        version_description?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/prompts/client/requests/index.ts
================================================================================
export { PostedPrompt } from "./PostedPrompt.js";
export { PostedPromptName } from "./PostedPromptName.js";
export { PostedPromptVersion } from "./PostedPromptVersion.js";
export { PostedPromptVersionDescription } from "./PostedPromptVersionDescription.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/prompts/client/updatePromptDescription.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnPrompt } from "../../../types/ReturnPrompt.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.prompts.updatePromptDescription.Response.Raw,
    Hume.empathicVoice.ReturnPrompt | undefined
> = ReturnPrompt.optional();

export declare namespace Response {
    export type Raw = ReturnPrompt.Raw | null | undefined;
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/prompts/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/tools/client/createTool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnUserDefinedTool } from "../../../types/ReturnUserDefinedTool.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.tools.createTool.Response.Raw,
    Hume.empathicVoice.ReturnUserDefinedTool | undefined
> = ReturnUserDefinedTool.optional();

export declare namespace Response {
    export type Raw = ReturnUserDefinedTool.Raw | null | undefined;
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/tools/client/createToolVersion.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnUserDefinedTool } from "../../../types/ReturnUserDefinedTool.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.tools.createToolVersion.Response.Raw,
    Hume.empathicVoice.ReturnUserDefinedTool | undefined
> = ReturnUserDefinedTool.optional();

export declare namespace Response {
    export type Raw = ReturnUserDefinedTool.Raw | null | undefined;
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/tools/client/getToolVersion.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnUserDefinedTool } from "../../../types/ReturnUserDefinedTool.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.tools.getToolVersion.Response.Raw,
    Hume.empathicVoice.ReturnUserDefinedTool | undefined
> = ReturnUserDefinedTool.optional();

export declare namespace Response {
    export type Raw = ReturnUserDefinedTool.Raw | null | undefined;
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/tools/client/index.ts
================================================================================
export * as createTool from "./createTool.js";
export * as createToolVersion from "./createToolVersion.js";
export * as getToolVersion from "./getToolVersion.js";
export * from "./requests/index.js";
export * as updateToolDescription from "./updateToolDescription.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedTool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedUserDefinedTool: core.serialization.Schema<
    serializers.empathicVoice.PostedUserDefinedTool.Raw,
    Hume.empathicVoice.PostedUserDefinedTool
> = core.serialization.object({
    description: core.serialization.string().optional(),
    fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
    name: core.serialization.string(),
    parameters: core.serialization.string(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedUserDefinedTool {
    export interface Raw {
        description?: string | null;
        fallback_content?: string | null;
        name: string;
        parameters: string;
        version_description?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolName.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedUserDefinedToolName: core.serialization.Schema<
    serializers.empathicVoice.PostedUserDefinedToolName.Raw,
    Hume.empathicVoice.PostedUserDefinedToolName
> = core.serialization.object({
    name: core.serialization.string(),
});

export declare namespace PostedUserDefinedToolName {
    export interface Raw {
        name: string;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolVersion.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedUserDefinedToolVersion: core.serialization.Schema<
    serializers.empathicVoice.PostedUserDefinedToolVersion.Raw,
    Hume.empathicVoice.PostedUserDefinedToolVersion
> = core.serialization.object({
    description: core.serialization.string().optional(),
    fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
    parameters: core.serialization.string(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedUserDefinedToolVersion {
    export interface Raw {
        description?: string | null;
        fallback_content?: string | null;
        parameters: string;
        version_description?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolVersionDescription.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedUserDefinedToolVersionDescription: core.serialization.Schema<
    serializers.empathicVoice.PostedUserDefinedToolVersionDescription.Raw,
    Hume.empathicVoice.PostedUserDefinedToolVersionDescription
> = core.serialization.object({
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
});

export declare namespace PostedUserDefinedToolVersionDescription {
    export interface Raw {
        version_description?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/tools/client/requests/index.ts
================================================================================
export { PostedUserDefinedTool } from "./PostedUserDefinedTool.js";
export { PostedUserDefinedToolName } from "./PostedUserDefinedToolName.js";
export { PostedUserDefinedToolVersion } from "./PostedUserDefinedToolVersion.js";
export { PostedUserDefinedToolVersionDescription } from "./PostedUserDefinedToolVersionDescription.js";

================================================================================
// File: src/serialization/resources/empathicVoice/resources/tools/client/updateToolDescription.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ReturnUserDefinedTool } from "../../../types/ReturnUserDefinedTool.js";

export const Response: core.serialization.Schema<
    serializers.empathicVoice.tools.updateToolDescription.Response.Raw,
    Hume.empathicVoice.ReturnUserDefinedTool | undefined
> = ReturnUserDefinedTool.optional();

export declare namespace Response {
    export type Raw = ReturnUserDefinedTool.Raw | null | undefined;
}

================================================================================
// File: src/serialization/resources/empathicVoice/resources/tools/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/serialization/resources/empathicVoice/types/AssistantEnd.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const AssistantEnd: core.serialization.ObjectSchema<
    serializers.empathicVoice.AssistantEnd.Raw,
    Hume.empathicVoice.AssistantEnd
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    type: core.serialization.stringLiteral("assistant_end"),
});

export declare namespace AssistantEnd {
    export interface Raw {
        custom_session_id?: string | null;
        type: "assistant_end";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/AssistantInput.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const AssistantInput: core.serialization.ObjectSchema<
    serializers.empathicVoice.AssistantInput.Raw,
    Hume.empathicVoice.AssistantInput
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    text: core.serialization.string(),
    type: core.serialization.stringLiteral("assistant_input"),
});

export declare namespace AssistantInput {
    export interface Raw {
        custom_session_id?: string | null;
        text: string;
        type: "assistant_input";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/AssistantMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ChatMessage } from "./ChatMessage.js";
import { Inference } from "./Inference.js";

export const AssistantMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.AssistantMessage.Raw,
    Hume.empathicVoice.AssistantMessage
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    fromText: core.serialization.property("from_text", core.serialization.boolean()),
    id: core.serialization.string().optional(),
    isQuickResponse: core.serialization.property("is_quick_response", core.serialization.boolean()),
    language: core.serialization.string().optional(),
    message: ChatMessage,
    models: Inference,
    type: core.serialization.stringLiteral("assistant_message"),
});

export declare namespace AssistantMessage {
    export interface Raw {
        custom_session_id?: string | null;
        from_text: boolean;
        id?: string | null;
        is_quick_response: boolean;
        language?: string | null;
        message: ChatMessage.Raw;
        models: Inference.Raw;
        type: "assistant_message";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/AssistantProsody.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { Inference } from "./Inference.js";

export const AssistantProsody: core.serialization.ObjectSchema<
    serializers.empathicVoice.AssistantProsody.Raw,
    Hume.empathicVoice.AssistantProsody
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    id: core.serialization.string().optional(),
    models: Inference,
    type: core.serialization.stringLiteral("assistant_prosody"),
});

export declare namespace AssistantProsody {
    export interface Raw {
        custom_session_id?: string | null;
        id?: string | null;
        models: Inference.Raw;
        type: "assistant_prosody";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/AudioConfiguration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { Encoding } from "./Encoding.js";

export const AudioConfiguration: core.serialization.ObjectSchema<
    serializers.empathicVoice.AudioConfiguration.Raw,
    Hume.empathicVoice.AudioConfiguration
> = core.serialization.object({
    channels: core.serialization.number(),
    codec: core.serialization.string().optional(),
    encoding: Encoding,
    sampleRate: core.serialization.property("sample_rate", core.serialization.number()),
});

export declare namespace AudioConfiguration {
    export interface Raw {
        channels: number;
        codec?: string | null;
        encoding: Encoding.Raw;
        sample_rate: number;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/AudioInput.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const AudioInput: core.serialization.ObjectSchema<
    serializers.empathicVoice.AudioInput.Raw,
    Hume.empathicVoice.AudioInput
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    data: core.serialization.string(),
    type: core.serialization.stringLiteral("audio_input"),
});

export declare namespace AudioInput {
    export interface Raw {
        custom_session_id?: string | null;
        data: string;
        type: "audio_input";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/AudioOutput.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const AudioOutput: core.serialization.ObjectSchema<
    serializers.empathicVoice.AudioOutput.Raw,
    Hume.empathicVoice.AudioOutput
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    data: core.serialization.string(),
    id: core.serialization.string(),
    index: core.serialization.number(),
    type: core.serialization.stringLiteral("audio_output"),
});

export declare namespace AudioOutput {
    export interface Raw {
        custom_session_id?: string | null;
        data: string;
        id: string;
        index: number;
        type: "audio_output";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/BuiltInTool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const BuiltInTool: core.serialization.Schema<
    serializers.empathicVoice.BuiltInTool.Raw,
    Hume.empathicVoice.BuiltInTool
> = core.serialization.enum_(["web_search", "hang_up"]);

export declare namespace BuiltInTool {
    export type Raw = "web_search" | "hang_up";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/BuiltinToolConfig.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { BuiltInTool } from "./BuiltInTool.js";

export const BuiltinToolConfig: core.serialization.ObjectSchema<
    serializers.empathicVoice.BuiltinToolConfig.Raw,
    Hume.empathicVoice.BuiltinToolConfig
> = core.serialization.object({
    fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
    name: BuiltInTool,
});

export declare namespace BuiltinToolConfig {
    export interface Raw {
        fallback_content?: string | null;
        name: BuiltInTool.Raw;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ChatMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ChatMessageToolResult } from "./ChatMessageToolResult.js";
import { Role } from "./Role.js";
import { ToolCallMessage } from "./ToolCallMessage.js";

export const ChatMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.ChatMessage.Raw,
    Hume.empathicVoice.ChatMessage
> = core.serialization.object({
    content: core.serialization.string().optional(),
    role: Role,
    toolCall: core.serialization.property("tool_call", ToolCallMessage.optional()),
    toolResult: core.serialization.property("tool_result", ChatMessageToolResult.optional()),
});

export declare namespace ChatMessage {
    export interface Raw {
        content?: string | null;
        role: Role.Raw;
        tool_call?: ToolCallMessage.Raw | null;
        tool_result?: ChatMessageToolResult.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ChatMessageToolResult.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ToolErrorMessage } from "./ToolErrorMessage.js";
import { ToolResponseMessage } from "./ToolResponseMessage.js";

export const ChatMessageToolResult: core.serialization.Schema<
    serializers.empathicVoice.ChatMessageToolResult.Raw,
    Hume.empathicVoice.ChatMessageToolResult
> = core.serialization.undiscriminatedUnion([ToolResponseMessage, ToolErrorMessage]);

export declare namespace ChatMessageToolResult {
    export type Raw = ToolResponseMessage.Raw | ToolErrorMessage.Raw;
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ChatMetadata.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ChatMetadata: core.serialization.ObjectSchema<
    serializers.empathicVoice.ChatMetadata.Raw,
    Hume.empathicVoice.ChatMetadata
> = core.serialization.object({
    chatGroupId: core.serialization.property("chat_group_id", core.serialization.string()),
    chatId: core.serialization.property("chat_id", core.serialization.string()),
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    requestId: core.serialization.property("request_id", core.serialization.string().optional()),
    type: core.serialization.stringLiteral("chat_metadata"),
});

export declare namespace ChatMetadata {
    export interface Raw {
        chat_group_id: string;
        chat_id: string;
        custom_session_id?: string | null;
        request_id?: string | null;
        type: "chat_metadata";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ConnectSessionSettings.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ConnectSessionSettingsAudio } from "./ConnectSessionSettingsAudio.js";
import { ConnectSessionSettingsContext } from "./ConnectSessionSettingsContext.js";
import { ConnectSessionSettingsVariablesValue } from "./ConnectSessionSettingsVariablesValue.js";

export const ConnectSessionSettings: core.serialization.ObjectSchema<
    serializers.empathicVoice.ConnectSessionSettings.Raw,
    Hume.empathicVoice.ConnectSessionSettings
> = core.serialization.object({
    audio: ConnectSessionSettingsAudio.optional(),
    context: ConnectSessionSettingsContext.optional(),
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    eventLimit: core.serialization.property("event_limit", core.serialization.number().optional()),
    languageModelApiKey: core.serialization.property("language_model_api_key", core.serialization.string().optional()),
    systemPrompt: core.serialization.property("system_prompt", core.serialization.string().optional()),
    voiceId: core.serialization.property("voice_id", core.serialization.string().optional()),
    variables: core.serialization.record(core.serialization.string(), ConnectSessionSettingsVariablesValue).optional(),
});

export declare namespace ConnectSessionSettings {
    export interface Raw {
        audio?: ConnectSessionSettingsAudio.Raw | null;
        context?: ConnectSessionSettingsContext.Raw | null;
        custom_session_id?: string | null;
        event_limit?: number | null;
        language_model_api_key?: string | null;
        system_prompt?: string | null;
        voice_id?: string | null;
        variables?: Record<string, ConnectSessionSettingsVariablesValue.Raw> | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ConnectSessionSettingsAudio.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { Encoding } from "./Encoding.js";

export const ConnectSessionSettingsAudio: core.serialization.ObjectSchema<
    serializers.empathicVoice.ConnectSessionSettingsAudio.Raw,
    Hume.empathicVoice.ConnectSessionSettingsAudio
> = core.serialization.object({
    channels: core.serialization.number().optional(),
    encoding: Encoding.optional(),
    sampleRate: core.serialization.property("sample_rate", core.serialization.number().optional()),
});

export declare namespace ConnectSessionSettingsAudio {
    export interface Raw {
        channels?: number | null;
        encoding?: Encoding.Raw | null;
        sample_rate?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ConnectSessionSettingsContext.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ContextType } from "./ContextType.js";

export const ConnectSessionSettingsContext: core.serialization.ObjectSchema<
    serializers.empathicVoice.ConnectSessionSettingsContext.Raw,
    Hume.empathicVoice.ConnectSessionSettingsContext
> = core.serialization.object({
    text: core.serialization.string().optional(),
    type: ContextType.optional(),
});

export declare namespace ConnectSessionSettingsContext {
    export interface Raw {
        text?: string | null;
        type?: ContextType.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ConnectSessionSettingsVariablesValue.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ConnectSessionSettingsVariablesValue: core.serialization.Schema<
    serializers.empathicVoice.ConnectSessionSettingsVariablesValue.Raw,
    Hume.empathicVoice.ConnectSessionSettingsVariablesValue
> = core.serialization.undiscriminatedUnion([
    core.serialization.string(),
    core.serialization.number(),
    core.serialization.boolean(),
]);

export declare namespace ConnectSessionSettingsVariablesValue {
    export type Raw = string | number | boolean;
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/Context.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ContextType } from "./ContextType.js";

export const Context: core.serialization.ObjectSchema<
    serializers.empathicVoice.Context.Raw,
    Hume.empathicVoice.Context
> = core.serialization.object({
    text: core.serialization.string(),
    type: ContextType.optional(),
});

export declare namespace Context {
    export interface Raw {
        text: string;
        type?: ContextType.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ContextType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ContextType: core.serialization.Schema<
    serializers.empathicVoice.ContextType.Raw,
    Hume.empathicVoice.ContextType
> = core.serialization.enum_(["persistent", "temporary"]);

export declare namespace ContextType {
    export type Raw = "persistent" | "temporary";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ControlPlanePublishEvent.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AssistantInput } from "./AssistantInput.js";
import { PauseAssistantMessage } from "./PauseAssistantMessage.js";
import { ResumeAssistantMessage } from "./ResumeAssistantMessage.js";
import { SessionSettings } from "./SessionSettings.js";
import { ToolErrorMessage } from "./ToolErrorMessage.js";
import { ToolResponseMessage } from "./ToolResponseMessage.js";
import { UserInput } from "./UserInput.js";

export const ControlPlanePublishEvent: core.serialization.Schema<
    serializers.empathicVoice.ControlPlanePublishEvent.Raw,
    Hume.empathicVoice.ControlPlanePublishEvent
> = core.serialization.undiscriminatedUnion([
    SessionSettings,
    UserInput,
    AssistantInput,
    ToolResponseMessage,
    ToolErrorMessage,
    PauseAssistantMessage,
    ResumeAssistantMessage,
]);

export declare namespace ControlPlanePublishEvent {
    export type Raw =
        | SessionSettings.Raw
        | UserInput.Raw
        | AssistantInput.Raw
        | ToolResponseMessage.Raw
        | ToolErrorMessage.Raw
        | PauseAssistantMessage.Raw
        | ResumeAssistantMessage.Raw;
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/Encoding.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const Encoding: core.serialization.Schema<serializers.empathicVoice.Encoding.Raw, Hume.empathicVoice.Encoding> =
    core.serialization.stringLiteral("linear16");

export declare namespace Encoding {
    export type Raw = "linear16";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ErrorLevel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ErrorLevel: core.serialization.Schema<
    serializers.empathicVoice.ErrorLevel.Raw,
    Hume.empathicVoice.ErrorLevel
> = core.serialization.stringLiteral("warn");

export declare namespace ErrorLevel {
    export type Raw = "warn";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ErrorResponse.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ErrorResponse: core.serialization.ObjectSchema<
    serializers.empathicVoice.ErrorResponse.Raw,
    Hume.empathicVoice.ErrorResponse
> = core.serialization.object({
    code: core.serialization.string().optional(),
    error: core.serialization.string().optional(),
    message: core.serialization.string().optional(),
});

export declare namespace ErrorResponse {
    export interface Raw {
        code?: string | null;
        error?: string | null;
        message?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/HttpValidationError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ValidationError } from "./ValidationError.js";

export const HttpValidationError: core.serialization.ObjectSchema<
    serializers.empathicVoice.HttpValidationError.Raw,
    Hume.empathicVoice.HttpValidationError
> = core.serialization.object({
    detail: core.serialization.list(ValidationError).optional(),
});

export declare namespace HttpValidationError {
    export interface Raw {
        detail?: ValidationError.Raw[] | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/Inference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ProsodyInference } from "./ProsodyInference.js";

export const Inference: core.serialization.ObjectSchema<
    serializers.empathicVoice.Inference.Raw,
    Hume.empathicVoice.Inference
> = core.serialization.object({
    prosody: ProsodyInference.optional(),
});

export declare namespace Inference {
    export interface Raw {
        prosody?: ProsodyInference.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/JsonMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AssistantEnd } from "./AssistantEnd.js";
import { AssistantMessage } from "./AssistantMessage.js";
import { AssistantProsody } from "./AssistantProsody.js";
import { ChatMetadata } from "./ChatMetadata.js";
import { SessionSettings } from "./SessionSettings.js";
import { ToolCallMessage } from "./ToolCallMessage.js";
import { ToolErrorMessage } from "./ToolErrorMessage.js";
import { ToolResponseMessage } from "./ToolResponseMessage.js";
import { UserInterruption } from "./UserInterruption.js";
import { UserMessage } from "./UserMessage.js";
import { WebSocketError } from "./WebSocketError.js";

export const JsonMessage: core.serialization.Schema<
    serializers.empathicVoice.JsonMessage.Raw,
    Hume.empathicVoice.JsonMessage
> = core.serialization.undiscriminatedUnion([
    AssistantEnd,
    AssistantMessage,
    AssistantProsody,
    ChatMetadata,
    WebSocketError,
    UserInterruption,
    UserMessage,
    ToolCallMessage,
    ToolResponseMessage,
    ToolErrorMessage,
    SessionSettings,
]);

export declare namespace JsonMessage {
    export type Raw =
        | AssistantEnd.Raw
        | AssistantMessage.Raw
        | AssistantProsody.Raw
        | ChatMetadata.Raw
        | WebSocketError.Raw
        | UserInterruption.Raw
        | UserMessage.Raw
        | ToolCallMessage.Raw
        | ToolResponseMessage.Raw
        | ToolErrorMessage.Raw
        | SessionSettings.Raw;
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/LanguageModelType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const LanguageModelType: core.serialization.Schema<
    serializers.empathicVoice.LanguageModelType.Raw,
    Hume.empathicVoice.LanguageModelType
> = core.serialization.enum_([
    "claude-3-7-sonnet-latest",
    "claude-3-5-sonnet-latest",
    "claude-3-5-haiku-latest",
    "claude-3-5-sonnet-20240620",
    "claude-3-opus-20240229",
    "claude-3-sonnet-20240229",
    "claude-3-haiku-20240307",
    "claude-sonnet-4-20250514",
    "claude-sonnet-4-5-20250929",
    "claude-haiku-4-5-20251001",
    "us.anthropic.claude-3-5-haiku-20241022-v1:0",
    "us.anthropic.claude-3-5-sonnet-20240620-v1:0",
    "us.anthropic.claude-3-haiku-20240307-v1:0",
    "gpt-oss-120b",
    "qwen-3-235b-a22b",
    "qwen-3-235b-a22b-instruct-2507",
    "qwen-3-235b-a22b-thinking-2507",
    "gemini-1.5-pro",
    "gemini-1.5-flash",
    "gemini-1.5-pro-002",
    "gemini-1.5-flash-002",
    "gemini-2.0-flash",
    "gemini-2.5-flash",
    "gemini-2.5-flash-preview-04-17",
    "gpt-4-turbo",
    "gpt-4-turbo-preview",
    "gpt-3.5-turbo-0125",
    "gpt-3.5-turbo",
    "gpt-4o",
    "gpt-4o-mini",
    "gpt-4.1",
    "gpt-5",
    "gpt-5-mini",
    "gpt-5-nano",
    "gpt-4o-priority",
    "gpt-4o-mini-priority",
    "gpt-4.1-priority",
    "gpt-5-priority",
    "gpt-5-mini-priority",
    "gpt-5-nano-priority",
    "gemma-7b-it",
    "llama3-8b-8192",
    "llama3-70b-8192",
    "llama-3.1-70b-versatile",
    "llama-3.3-70b-versatile",
    "llama-3.1-8b-instant",
    "moonshotai/kimi-k2-instruct",
    "accounts/fireworks/models/mixtral-8x7b-instruct",
    "accounts/fireworks/models/llama-v3p1-405b-instruct",
    "accounts/fireworks/models/llama-v3p1-70b-instruct",
    "accounts/fireworks/models/llama-v3p1-8b-instruct",
    "sonar",
    "sonar-pro",
    "sambanova",
    "DeepSeek-R1-Distill-Llama-70B",
    "Llama-4-Maverick-17B-128E-Instruct",
    "Qwen3-32B",
    "grok-4-fast-non-reasoning-latest",
    "ellm",
    "custom-language-model",
    "hume-evi-3-web-search",
]);

export declare namespace LanguageModelType {
    export type Raw =
        | "claude-3-7-sonnet-latest"
        | "claude-3-5-sonnet-latest"
        | "claude-3-5-haiku-latest"
        | "claude-3-5-sonnet-20240620"
        | "claude-3-opus-20240229"
        | "claude-3-sonnet-20240229"
        | "claude-3-haiku-20240307"
        | "claude-sonnet-4-20250514"
        | "claude-sonnet-4-5-20250929"
        | "claude-haiku-4-5-20251001"
        | "us.anthropic.claude-3-5-haiku-20241022-v1:0"
        | "us.anthropic.claude-3-5-sonnet-20240620-v1:0"
        | "us.anthropic.claude-3-haiku-20240307-v1:0"
        | "gpt-oss-120b"
        | "qwen-3-235b-a22b"
        | "qwen-3-235b-a22b-instruct-2507"
        | "qwen-3-235b-a22b-thinking-2507"
        | "gemini-1.5-pro"
        | "gemini-1.5-flash"
        | "gemini-1.5-pro-002"
        | "gemini-1.5-flash-002"
        | "gemini-2.0-flash"
        | "gemini-2.5-flash"
        | "gemini-2.5-flash-preview-04-17"
        | "gpt-4-turbo"
        | "gpt-4-turbo-preview"
        | "gpt-3.5-turbo-0125"
        | "gpt-3.5-turbo"
        | "gpt-4o"
        | "gpt-4o-mini"
        | "gpt-4.1"
        | "gpt-5"
        | "gpt-5-mini"
        | "gpt-5-nano"
        | "gpt-4o-priority"
        | "gpt-4o-mini-priority"
        | "gpt-4.1-priority"
        | "gpt-5-priority"
        | "gpt-5-mini-priority"
        | "gpt-5-nano-priority"
        | "gemma-7b-it"
        | "llama3-8b-8192"
        | "llama3-70b-8192"
        | "llama-3.1-70b-versatile"
        | "llama-3.3-70b-versatile"
        | "llama-3.1-8b-instant"
        | "moonshotai/kimi-k2-instruct"
        | "accounts/fireworks/models/mixtral-8x7b-instruct"
        | "accounts/fireworks/models/llama-v3p1-405b-instruct"
        | "accounts/fireworks/models/llama-v3p1-70b-instruct"
        | "accounts/fireworks/models/llama-v3p1-8b-instruct"
        | "sonar"
        | "sonar-pro"
        | "sambanova"
        | "DeepSeek-R1-Distill-Llama-70B"
        | "Llama-4-Maverick-17B-128E-Instruct"
        | "Qwen3-32B"
        | "grok-4-fast-non-reasoning-latest"
        | "ellm"
        | "custom-language-model"
        | "hume-evi-3-web-search";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/MillisecondInterval.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const MillisecondInterval: core.serialization.ObjectSchema<
    serializers.empathicVoice.MillisecondInterval.Raw,
    Hume.empathicVoice.MillisecondInterval
> = core.serialization.object({
    begin: core.serialization.number(),
    end: core.serialization.number(),
});

export declare namespace MillisecondInterval {
    export interface Raw {
        begin: number;
        end: number;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ModelProviderEnum.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ModelProviderEnum: core.serialization.Schema<
    serializers.empathicVoice.ModelProviderEnum.Raw,
    Hume.empathicVoice.ModelProviderEnum
> = core.serialization.enum_([
    "GROQ",
    "OPEN_AI",
    "FIREWORKS",
    "ANTHROPIC",
    "CUSTOM_LANGUAGE_MODEL",
    "GOOGLE",
    "HUME_AI",
    "AMAZON_BEDROCK",
    "PERPLEXITY",
    "SAMBANOVA",
    "CEREBRAS",
]);

export declare namespace ModelProviderEnum {
    export type Raw =
        | "GROQ"
        | "OPEN_AI"
        | "FIREWORKS"
        | "ANTHROPIC"
        | "CUSTOM_LANGUAGE_MODEL"
        | "GOOGLE"
        | "HUME_AI"
        | "AMAZON_BEDROCK"
        | "PERPLEXITY"
        | "SAMBANOVA"
        | "CEREBRAS";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PauseAssistantMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PauseAssistantMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.PauseAssistantMessage.Raw,
    Hume.empathicVoice.PauseAssistantMessage
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    type: core.serialization.stringLiteral("pause_assistant_message"),
});

export declare namespace PauseAssistantMessage {
    export interface Raw {
        custom_session_id?: string | null;
        type: "pause_assistant_message";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedBuiltinTool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedBuiltinToolName } from "./PostedBuiltinToolName.js";

export const PostedBuiltinTool: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedBuiltinTool.Raw,
    Hume.empathicVoice.PostedBuiltinTool
> = core.serialization.object({
    fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
    name: PostedBuiltinToolName,
});

export declare namespace PostedBuiltinTool {
    export interface Raw {
        fallback_content?: string | null;
        name: PostedBuiltinToolName.Raw;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedBuiltinToolName.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedBuiltinToolName: core.serialization.Schema<
    serializers.empathicVoice.PostedBuiltinToolName.Raw,
    Hume.empathicVoice.PostedBuiltinToolName
> = core.serialization.enum_(["web_search", "hang_up"]);

export declare namespace PostedBuiltinToolName {
    export type Raw = "web_search" | "hang_up";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedConfigPromptSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedConfigPromptSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedConfigPromptSpec.Raw,
    Hume.empathicVoice.PostedConfigPromptSpec
> = core.serialization.object({
    id: core.serialization.string().optional(),
    text: core.serialization.string().optional(),
    version: core.serialization.number().optional(),
});

export declare namespace PostedConfigPromptSpec {
    export interface Raw {
        id?: string | null;
        text?: string | null;
        version?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedEllmModel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedEllmModel: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedEllmModel.Raw,
    Hume.empathicVoice.PostedEllmModel
> = core.serialization.object({
    allowShortResponses: core.serialization.property("allow_short_responses", core.serialization.boolean().optional()),
});

export declare namespace PostedEllmModel {
    export interface Raw {
        allow_short_responses?: boolean | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedEventMessageSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedEventMessageSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedEventMessageSpec.Raw,
    Hume.empathicVoice.PostedEventMessageSpec
> = core.serialization.object({
    enabled: core.serialization.boolean(),
    text: core.serialization.string().optional(),
});

export declare namespace PostedEventMessageSpec {
    export interface Raw {
        enabled: boolean;
        text?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedEventMessageSpecs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedEventMessageSpec } from "./PostedEventMessageSpec.js";

export const PostedEventMessageSpecs: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedEventMessageSpecs.Raw,
    Hume.empathicVoice.PostedEventMessageSpecs
> = core.serialization.object({
    onInactivityTimeout: core.serialization.property("on_inactivity_timeout", PostedEventMessageSpec.optional()),
    onMaxDurationTimeout: core.serialization.property("on_max_duration_timeout", PostedEventMessageSpec.optional()),
    onNewChat: core.serialization.property("on_new_chat", PostedEventMessageSpec.optional()),
});

export declare namespace PostedEventMessageSpecs {
    export interface Raw {
        on_inactivity_timeout?: PostedEventMessageSpec.Raw | null;
        on_max_duration_timeout?: PostedEventMessageSpec.Raw | null;
        on_new_chat?: PostedEventMessageSpec.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedLanguageModel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { LanguageModelType } from "./LanguageModelType.js";
import { ModelProviderEnum } from "./ModelProviderEnum.js";

export const PostedLanguageModel: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedLanguageModel.Raw,
    Hume.empathicVoice.PostedLanguageModel
> = core.serialization.object({
    modelProvider: core.serialization.property("model_provider", ModelProviderEnum.optional()),
    modelResource: core.serialization.property("model_resource", LanguageModelType.optional()),
    temperature: core.serialization.number().optional(),
});

export declare namespace PostedLanguageModel {
    export interface Raw {
        model_provider?: ModelProviderEnum.Raw | null;
        model_resource?: LanguageModelType.Raw | null;
        temperature?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedNudgeSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedNudgeSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedNudgeSpec.Raw,
    Hume.empathicVoice.PostedNudgeSpec
> = core.serialization.object({
    enabled: core.serialization.boolean().optional(),
    intervalSecs: core.serialization.property("interval_secs", core.serialization.number().optional()),
});

export declare namespace PostedNudgeSpec {
    export interface Raw {
        enabled?: boolean | null;
        interval_secs?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedTimeoutSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedTimeoutSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedTimeoutSpec.Raw,
    Hume.empathicVoice.PostedTimeoutSpec
> = core.serialization.object({
    durationSecs: core.serialization.property("duration_secs", core.serialization.number().optional()),
    enabled: core.serialization.boolean(),
});

export declare namespace PostedTimeoutSpec {
    export interface Raw {
        duration_secs?: number | null;
        enabled: boolean;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedTimeoutSpecs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedTimeoutSpecsInactivity } from "./PostedTimeoutSpecsInactivity.js";
import { PostedTimeoutSpecsMaxDuration } from "./PostedTimeoutSpecsMaxDuration.js";

export const PostedTimeoutSpecs: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedTimeoutSpecs.Raw,
    Hume.empathicVoice.PostedTimeoutSpecs
> = core.serialization.object({
    inactivity: PostedTimeoutSpecsInactivity.optional(),
    maxDuration: core.serialization.property("max_duration", PostedTimeoutSpecsMaxDuration.optional()),
});

export declare namespace PostedTimeoutSpecs {
    export interface Raw {
        inactivity?: PostedTimeoutSpecsInactivity.Raw | null;
        max_duration?: PostedTimeoutSpecsMaxDuration.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedTimeoutSpecsInactivity.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedTimeoutSpecsInactivity: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedTimeoutSpecsInactivity.Raw,
    Hume.empathicVoice.PostedTimeoutSpecsInactivity
> = core.serialization.object({
    durationSecs: core.serialization.property("duration_secs", core.serialization.number().optional()),
    enabled: core.serialization.boolean(),
});

export declare namespace PostedTimeoutSpecsInactivity {
    export interface Raw {
        duration_secs?: number | null;
        enabled: boolean;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedTimeoutSpecsMaxDuration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedTimeoutSpecsMaxDuration: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedTimeoutSpecsMaxDuration.Raw,
    Hume.empathicVoice.PostedTimeoutSpecsMaxDuration
> = core.serialization.object({
    durationSecs: core.serialization.property("duration_secs", core.serialization.number().optional()),
    enabled: core.serialization.boolean(),
});

export declare namespace PostedTimeoutSpecsMaxDuration {
    export interface Raw {
        duration_secs?: number | null;
        enabled: boolean;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedUserDefinedToolSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedUserDefinedToolSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedUserDefinedToolSpec.Raw,
    Hume.empathicVoice.PostedUserDefinedToolSpec
> = core.serialization.object({
    id: core.serialization.string(),
    version: core.serialization.number().optional(),
});

export declare namespace PostedUserDefinedToolSpec {
    export interface Raw {
        id: string;
        version?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedWebhookEventType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedWebhookEventType: core.serialization.Schema<
    serializers.empathicVoice.PostedWebhookEventType.Raw,
    Hume.empathicVoice.PostedWebhookEventType
> = core.serialization.enum_(["chat_started", "chat_ended", "tool_call"]);

export declare namespace PostedWebhookEventType {
    export type Raw = "chat_started" | "chat_ended" | "tool_call";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/PostedWebhookSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedWebhookEventType } from "./PostedWebhookEventType.js";

export const PostedWebhookSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.PostedWebhookSpec.Raw,
    Hume.empathicVoice.PostedWebhookSpec
> = core.serialization.object({
    events: core.serialization.list(PostedWebhookEventType),
    url: core.serialization.string(),
});

export declare namespace PostedWebhookSpec {
    export interface Raw {
        events: PostedWebhookEventType.Raw[];
        url: string;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ProsodyInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { EmotionScores } from "./EmotionScores.js";

export const ProsodyInference: core.serialization.ObjectSchema<
    serializers.empathicVoice.ProsodyInference.Raw,
    Hume.empathicVoice.ProsodyInference
> = core.serialization.object({
    scores: EmotionScores,
});

export declare namespace ProsodyInference {
    export interface Raw {
        scores: EmotionScores.Raw;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ResumeAssistantMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ResumeAssistantMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.ResumeAssistantMessage.Raw,
    Hume.empathicVoice.ResumeAssistantMessage
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    type: core.serialization.stringLiteral("resume_assistant_message"),
});

export declare namespace ResumeAssistantMessage {
    export interface Raw {
        custom_session_id?: string | null;
        type: "resume_assistant_message";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnBuiltinTool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnBuiltinToolToolType } from "./ReturnBuiltinToolToolType.js";

export const ReturnBuiltinTool: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnBuiltinTool.Raw,
    Hume.empathicVoice.ReturnBuiltinTool
> = core.serialization.object({
    fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
    name: core.serialization.string(),
    toolType: core.serialization.property("tool_type", ReturnBuiltinToolToolType),
});

export declare namespace ReturnBuiltinTool {
    export interface Raw {
        fallback_content?: string | null;
        name: string;
        tool_type: ReturnBuiltinToolToolType.Raw;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnBuiltinToolToolType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnBuiltinToolToolType: core.serialization.Schema<
    serializers.empathicVoice.ReturnBuiltinToolToolType.Raw,
    Hume.empathicVoice.ReturnBuiltinToolToolType
> = core.serialization.enum_(["BUILTIN", "FUNCTION"]);

export declare namespace ReturnBuiltinToolToolType {
    export type Raw = "BUILTIN" | "FUNCTION";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChat.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatStatus } from "./ReturnChatStatus.js";
import { ReturnConfigSpec } from "./ReturnConfigSpec.js";

export const ReturnChat: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChat.Raw,
    Hume.empathicVoice.ReturnChat
> = core.serialization.object({
    chatGroupId: core.serialization.property("chat_group_id", core.serialization.string()),
    config: ReturnConfigSpec.optional(),
    endTimestamp: core.serialization.property("end_timestamp", core.serialization.number().optional()),
    eventCount: core.serialization.property("event_count", core.serialization.number().optional()),
    id: core.serialization.string(),
    metadata: core.serialization.string().optional(),
    startTimestamp: core.serialization.property("start_timestamp", core.serialization.number()),
    status: ReturnChatStatus,
});

export declare namespace ReturnChat {
    export interface Raw {
        chat_group_id: string;
        config?: ReturnConfigSpec.Raw | null;
        end_timestamp?: number | null;
        event_count?: number | null;
        id: string;
        metadata?: string | null;
        start_timestamp: number;
        status: ReturnChatStatus.Raw;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatAudioReconstruction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatAudioReconstructionStatus } from "./ReturnChatAudioReconstructionStatus.js";

export const ReturnChatAudioReconstruction: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatAudioReconstruction.Raw,
    Hume.empathicVoice.ReturnChatAudioReconstruction
> = core.serialization.object({
    filename: core.serialization.string().optional(),
    id: core.serialization.string(),
    modifiedAt: core.serialization.property("modified_at", core.serialization.number().optional()),
    signedAudioUrl: core.serialization.property("signed_audio_url", core.serialization.string().optional()),
    signedUrlExpirationTimestampMillis: core.serialization.property(
        "signed_url_expiration_timestamp_millis",
        core.serialization.number().optional(),
    ),
    status: ReturnChatAudioReconstructionStatus,
    userId: core.serialization.property("user_id", core.serialization.string()),
});

export declare namespace ReturnChatAudioReconstruction {
    export interface Raw {
        filename?: string | null;
        id: string;
        modified_at?: number | null;
        signed_audio_url?: string | null;
        signed_url_expiration_timestamp_millis?: number | null;
        status: ReturnChatAudioReconstructionStatus.Raw;
        user_id: string;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatAudioReconstructionStatus.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatAudioReconstructionStatus: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatAudioReconstructionStatus.Raw,
    Hume.empathicVoice.ReturnChatAudioReconstructionStatus
> = core.serialization.enum_(["QUEUED", "IN_PROGRESS", "COMPLETE", "ERROR", "CANCELLED"]);

export declare namespace ReturnChatAudioReconstructionStatus {
    export type Raw = "QUEUED" | "IN_PROGRESS" | "COMPLETE" | "ERROR" | "CANCELLED";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatEvent.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatEventRole } from "./ReturnChatEventRole.js";
import { ReturnChatEventType } from "./ReturnChatEventType.js";

export const ReturnChatEvent: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatEvent.Raw,
    Hume.empathicVoice.ReturnChatEvent
> = core.serialization.object({
    chatId: core.serialization.property("chat_id", core.serialization.string()),
    emotionFeatures: core.serialization.property("emotion_features", core.serialization.string().optional()),
    id: core.serialization.string(),
    messageText: core.serialization.property("message_text", core.serialization.string().optional()),
    metadata: core.serialization.string().optional(),
    relatedEventId: core.serialization.property("related_event_id", core.serialization.string().optional()),
    role: ReturnChatEventRole,
    timestamp: core.serialization.number(),
    type: ReturnChatEventType,
});

export declare namespace ReturnChatEvent {
    export interface Raw {
        chat_id: string;
        emotion_features?: string | null;
        id: string;
        message_text?: string | null;
        metadata?: string | null;
        related_event_id?: string | null;
        role: ReturnChatEventRole.Raw;
        timestamp: number;
        type: ReturnChatEventType.Raw;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatEventRole.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatEventRole: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatEventRole.Raw,
    Hume.empathicVoice.ReturnChatEventRole
> = core.serialization.enum_(["USER", "AGENT", "SYSTEM", "TOOL"]);

export declare namespace ReturnChatEventRole {
    export type Raw = "USER" | "AGENT" | "SYSTEM" | "TOOL";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatEventType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatEventType: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatEventType.Raw,
    Hume.empathicVoice.ReturnChatEventType
> = core.serialization.enum_([
    "FUNCTION_CALL",
    "FUNCTION_CALL_RESPONSE",
    "CHAT_END_MESSAGE",
    "AGENT_MESSAGE",
    "SYSTEM_PROMPT",
    "USER_RECORDING_START_MESSAGE",
    "RESUME_ONSET",
    "USER_INTERRUPTION",
    "CHAT_START_MESSAGE",
    "PAUSE_ONSET",
    "USER_MESSAGE",
]);

export declare namespace ReturnChatEventType {
    export type Raw =
        | "FUNCTION_CALL"
        | "FUNCTION_CALL_RESPONSE"
        | "CHAT_END_MESSAGE"
        | "AGENT_MESSAGE"
        | "SYSTEM_PROMPT"
        | "USER_RECORDING_START_MESSAGE"
        | "RESUME_ONSET"
        | "USER_INTERRUPTION"
        | "CHAT_START_MESSAGE"
        | "PAUSE_ONSET"
        | "USER_MESSAGE";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatGroup.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnConfigSpec } from "./ReturnConfigSpec.js";

export const ReturnChatGroup: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatGroup.Raw,
    Hume.empathicVoice.ReturnChatGroup
> = core.serialization.object({
    active: core.serialization.boolean().optional(),
    firstStartTimestamp: core.serialization.property("first_start_timestamp", core.serialization.number()),
    id: core.serialization.string(),
    mostRecentChatId: core.serialization.property("most_recent_chat_id", core.serialization.string().optional()),
    mostRecentConfig: core.serialization.property("most_recent_config", ReturnConfigSpec.optional()),
    mostRecentStartTimestamp: core.serialization.property("most_recent_start_timestamp", core.serialization.number()),
    numChats: core.serialization.property("num_chats", core.serialization.number()),
});

export declare namespace ReturnChatGroup {
    export interface Raw {
        active?: boolean | null;
        first_start_timestamp: number;
        id: string;
        most_recent_chat_id?: string | null;
        most_recent_config?: ReturnConfigSpec.Raw | null;
        most_recent_start_timestamp: number;
        num_chats: number;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedAudioReconstructions.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatAudioReconstruction } from "./ReturnChatAudioReconstruction.js";
import { ReturnChatGroupPagedAudioReconstructionsPaginationDirection } from "./ReturnChatGroupPagedAudioReconstructionsPaginationDirection.js";

export const ReturnChatGroupPagedAudioReconstructions: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatGroupPagedAudioReconstructions.Raw,
    Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructions
> = core.serialization.object({
    audioReconstructionsPage: core.serialization.property(
        "audio_reconstructions_page",
        core.serialization.list(ReturnChatAudioReconstruction),
    ),
    id: core.serialization.string(),
    numChats: core.serialization.property("num_chats", core.serialization.number()),
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    paginationDirection: core.serialization.property(
        "pagination_direction",
        ReturnChatGroupPagedAudioReconstructionsPaginationDirection,
    ),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
    userId: core.serialization.property("user_id", core.serialization.string()),
});

export declare namespace ReturnChatGroupPagedAudioReconstructions {
    export interface Raw {
        audio_reconstructions_page: ReturnChatAudioReconstruction.Raw[];
        id: string;
        num_chats: number;
        page_number: number;
        page_size: number;
        pagination_direction: ReturnChatGroupPagedAudioReconstructionsPaginationDirection.Raw;
        total_pages: number;
        user_id: string;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedAudioReconstructionsPaginationDirection.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatGroupPagedAudioReconstructionsPaginationDirection: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatGroupPagedAudioReconstructionsPaginationDirection.Raw,
    Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructionsPaginationDirection
> = core.serialization.enum_(["ASC", "DESC"]);

export declare namespace ReturnChatGroupPagedAudioReconstructionsPaginationDirection {
    export type Raw = "ASC" | "DESC";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedChats.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChat } from "./ReturnChat.js";
import { ReturnChatGroupPagedChatsPaginationDirection } from "./ReturnChatGroupPagedChatsPaginationDirection.js";

export const ReturnChatGroupPagedChats: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatGroupPagedChats.Raw,
    Hume.empathicVoice.ReturnChatGroupPagedChats
> = core.serialization.object({
    active: core.serialization.boolean().optional(),
    chatsPage: core.serialization.property("chats_page", core.serialization.list(ReturnChat)),
    firstStartTimestamp: core.serialization.property("first_start_timestamp", core.serialization.number()),
    id: core.serialization.string(),
    mostRecentStartTimestamp: core.serialization.property("most_recent_start_timestamp", core.serialization.number()),
    numChats: core.serialization.property("num_chats", core.serialization.number()),
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    paginationDirection: core.serialization.property(
        "pagination_direction",
        ReturnChatGroupPagedChatsPaginationDirection,
    ),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnChatGroupPagedChats {
    export interface Raw {
        active?: boolean | null;
        chats_page: ReturnChat.Raw[];
        first_start_timestamp: number;
        id: string;
        most_recent_start_timestamp: number;
        num_chats: number;
        page_number: number;
        page_size: number;
        pagination_direction: ReturnChatGroupPagedChatsPaginationDirection.Raw;
        total_pages: number;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedChatsPaginationDirection.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatGroupPagedChatsPaginationDirection: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatGroupPagedChatsPaginationDirection.Raw,
    Hume.empathicVoice.ReturnChatGroupPagedChatsPaginationDirection
> = core.serialization.enum_(["ASC", "DESC"]);

export declare namespace ReturnChatGroupPagedChatsPaginationDirection {
    export type Raw = "ASC" | "DESC";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedEvents.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatEvent } from "./ReturnChatEvent.js";
import { ReturnChatGroupPagedEventsPaginationDirection } from "./ReturnChatGroupPagedEventsPaginationDirection.js";

export const ReturnChatGroupPagedEvents: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatGroupPagedEvents.Raw,
    Hume.empathicVoice.ReturnChatGroupPagedEvents
> = core.serialization.object({
    eventsPage: core.serialization.property("events_page", core.serialization.list(ReturnChatEvent)),
    id: core.serialization.string(),
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    paginationDirection: core.serialization.property(
        "pagination_direction",
        ReturnChatGroupPagedEventsPaginationDirection,
    ),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnChatGroupPagedEvents {
    export interface Raw {
        events_page: ReturnChatEvent.Raw[];
        id: string;
        page_number: number;
        page_size: number;
        pagination_direction: ReturnChatGroupPagedEventsPaginationDirection.Raw;
        total_pages: number;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedEventsPaginationDirection.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatGroupPagedEventsPaginationDirection: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatGroupPagedEventsPaginationDirection.Raw,
    Hume.empathicVoice.ReturnChatGroupPagedEventsPaginationDirection
> = core.serialization.enum_(["ASC", "DESC"]);

export declare namespace ReturnChatGroupPagedEventsPaginationDirection {
    export type Raw = "ASC" | "DESC";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatPagedEvents.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatEvent } from "./ReturnChatEvent.js";
import { ReturnChatPagedEventsPaginationDirection } from "./ReturnChatPagedEventsPaginationDirection.js";
import { ReturnChatPagedEventsStatus } from "./ReturnChatPagedEventsStatus.js";
import { ReturnConfigSpec } from "./ReturnConfigSpec.js";

export const ReturnChatPagedEvents: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnChatPagedEvents.Raw,
    Hume.empathicVoice.ReturnChatPagedEvents
> = core.serialization.object({
    chatGroupId: core.serialization.property("chat_group_id", core.serialization.string()),
    config: ReturnConfigSpec.optional(),
    endTimestamp: core.serialization.property("end_timestamp", core.serialization.number().optional()),
    eventsPage: core.serialization.property("events_page", core.serialization.list(ReturnChatEvent)),
    id: core.serialization.string(),
    metadata: core.serialization.string().optional(),
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    paginationDirection: core.serialization.property("pagination_direction", ReturnChatPagedEventsPaginationDirection),
    startTimestamp: core.serialization.property("start_timestamp", core.serialization.number()),
    status: ReturnChatPagedEventsStatus,
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnChatPagedEvents {
    export interface Raw {
        chat_group_id: string;
        config?: ReturnConfigSpec.Raw | null;
        end_timestamp?: number | null;
        events_page: ReturnChatEvent.Raw[];
        id: string;
        metadata?: string | null;
        page_number: number;
        page_size: number;
        pagination_direction: ReturnChatPagedEventsPaginationDirection.Raw;
        start_timestamp: number;
        status: ReturnChatPagedEventsStatus.Raw;
        total_pages: number;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatPagedEventsPaginationDirection.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatPagedEventsPaginationDirection: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatPagedEventsPaginationDirection.Raw,
    Hume.empathicVoice.ReturnChatPagedEventsPaginationDirection
> = core.serialization.enum_(["ASC", "DESC"]);

export declare namespace ReturnChatPagedEventsPaginationDirection {
    export type Raw = "ASC" | "DESC";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatPagedEventsStatus.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatPagedEventsStatus: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatPagedEventsStatus.Raw,
    Hume.empathicVoice.ReturnChatPagedEventsStatus
> = core.serialization.enum_([
    "ACTIVE",
    "USER_ENDED",
    "USER_TIMEOUT",
    "MAX_DURATION_TIMEOUT",
    "INACTIVITY_TIMEOUT",
    "ERROR",
]);

export declare namespace ReturnChatPagedEventsStatus {
    export type Raw =
        | "ACTIVE"
        | "USER_ENDED"
        | "USER_TIMEOUT"
        | "MAX_DURATION_TIMEOUT"
        | "INACTIVITY_TIMEOUT"
        | "ERROR";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnChatStatus.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnChatStatus: core.serialization.Schema<
    serializers.empathicVoice.ReturnChatStatus.Raw,
    Hume.empathicVoice.ReturnChatStatus
> = core.serialization.enum_([
    "ACTIVE",
    "USER_ENDED",
    "USER_TIMEOUT",
    "MAX_DURATION_TIMEOUT",
    "INACTIVITY_TIMEOUT",
    "ERROR",
]);

export declare namespace ReturnChatStatus {
    export type Raw =
        | "ACTIVE"
        | "USER_ENDED"
        | "USER_TIMEOUT"
        | "MAX_DURATION_TIMEOUT"
        | "INACTIVITY_TIMEOUT"
        | "ERROR";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnConfig.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnBuiltinTool } from "./ReturnBuiltinTool.js";
import { ReturnEllmModel } from "./ReturnEllmModel.js";
import { ReturnEventMessageSpecs } from "./ReturnEventMessageSpecs.js";
import { ReturnLanguageModel } from "./ReturnLanguageModel.js";
import { ReturnNudgeSpec } from "./ReturnNudgeSpec.js";
import { ReturnPrompt } from "./ReturnPrompt.js";
import { ReturnTimeoutSpecs } from "./ReturnTimeoutSpecs.js";
import { ReturnUserDefinedTool } from "./ReturnUserDefinedTool.js";
import { ReturnVoice } from "./ReturnVoice.js";
import { ReturnWebhookSpec } from "./ReturnWebhookSpec.js";

export const ReturnConfig: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnConfig.Raw,
    Hume.empathicVoice.ReturnConfig
> = core.serialization.object({
    builtinTools: core.serialization.property(
        "builtin_tools",
        core.serialization.list(ReturnBuiltinTool.optional()).optional(),
    ),
    createdOn: core.serialization.property("created_on", core.serialization.number().optional()),
    ellmModel: core.serialization.property("ellm_model", ReturnEllmModel.optional()),
    eventMessages: core.serialization.property("event_messages", ReturnEventMessageSpecs.optional()),
    eviVersion: core.serialization.property("evi_version", core.serialization.string().optional()),
    id: core.serialization.string().optional(),
    languageModel: core.serialization.property("language_model", ReturnLanguageModel.optional()),
    modifiedOn: core.serialization.property("modified_on", core.serialization.number().optional()),
    name: core.serialization.string().optional(),
    nudges: ReturnNudgeSpec.optional(),
    prompt: ReturnPrompt.optional(),
    timeouts: ReturnTimeoutSpecs.optional(),
    tools: core.serialization.list(ReturnUserDefinedTool.optional()).optional(),
    version: core.serialization.number().optional(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
    voice: ReturnVoice.optional(),
    webhooks: core.serialization.list(ReturnWebhookSpec.optional()).optional(),
});

export declare namespace ReturnConfig {
    export interface Raw {
        builtin_tools?: (ReturnBuiltinTool.Raw | null | undefined)[] | null;
        created_on?: number | null;
        ellm_model?: ReturnEllmModel.Raw | null;
        event_messages?: ReturnEventMessageSpecs.Raw | null;
        evi_version?: string | null;
        id?: string | null;
        language_model?: ReturnLanguageModel.Raw | null;
        modified_on?: number | null;
        name?: string | null;
        nudges?: ReturnNudgeSpec.Raw | null;
        prompt?: ReturnPrompt.Raw | null;
        timeouts?: ReturnTimeoutSpecs.Raw | null;
        tools?: (ReturnUserDefinedTool.Raw | null | undefined)[] | null;
        version?: number | null;
        version_description?: string | null;
        voice?: ReturnVoice.Raw | null;
        webhooks?: (ReturnWebhookSpec.Raw | null | undefined)[] | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnConfigSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnConfigSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnConfigSpec.Raw,
    Hume.empathicVoice.ReturnConfigSpec
> = core.serialization.object({
    id: core.serialization.string(),
    version: core.serialization.number().optional(),
});

export declare namespace ReturnConfigSpec {
    export interface Raw {
        id: string;
        version?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnEllmModel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnEllmModel: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnEllmModel.Raw,
    Hume.empathicVoice.ReturnEllmModel
> = core.serialization.object({
    allowShortResponses: core.serialization.property("allow_short_responses", core.serialization.boolean()),
});

export declare namespace ReturnEllmModel {
    export interface Raw {
        allow_short_responses: boolean;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnEventMessageSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnEventMessageSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnEventMessageSpec.Raw,
    Hume.empathicVoice.ReturnEventMessageSpec
> = core.serialization.object({
    enabled: core.serialization.boolean(),
    text: core.serialization.string().optional(),
});

export declare namespace ReturnEventMessageSpec {
    export interface Raw {
        enabled: boolean;
        text?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnEventMessageSpecs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnEventMessageSpec } from "./ReturnEventMessageSpec.js";

export const ReturnEventMessageSpecs: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnEventMessageSpecs.Raw,
    Hume.empathicVoice.ReturnEventMessageSpecs
> = core.serialization.object({
    onInactivityTimeout: core.serialization.property("on_inactivity_timeout", ReturnEventMessageSpec.optional()),
    onMaxDurationTimeout: core.serialization.property("on_max_duration_timeout", ReturnEventMessageSpec.optional()),
    onNewChat: core.serialization.property("on_new_chat", ReturnEventMessageSpec.optional()),
});

export declare namespace ReturnEventMessageSpecs {
    export interface Raw {
        on_inactivity_timeout?: ReturnEventMessageSpec.Raw | null;
        on_max_duration_timeout?: ReturnEventMessageSpec.Raw | null;
        on_new_chat?: ReturnEventMessageSpec.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnLanguageModel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { LanguageModelType } from "./LanguageModelType.js";
import { ModelProviderEnum } from "./ModelProviderEnum.js";

export const ReturnLanguageModel: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnLanguageModel.Raw,
    Hume.empathicVoice.ReturnLanguageModel
> = core.serialization.object({
    modelProvider: core.serialization.property("model_provider", ModelProviderEnum.optional()),
    modelResource: core.serialization.property("model_resource", LanguageModelType.optional()),
    temperature: core.serialization.number().optional(),
});

export declare namespace ReturnLanguageModel {
    export interface Raw {
        model_provider?: ModelProviderEnum.Raw | null;
        model_resource?: LanguageModelType.Raw | null;
        temperature?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnNudgeSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnNudgeSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnNudgeSpec.Raw,
    Hume.empathicVoice.ReturnNudgeSpec
> = core.serialization.object({
    enabled: core.serialization.boolean(),
    intervalSecs: core.serialization.property("interval_secs", core.serialization.number().optional()),
});

export declare namespace ReturnNudgeSpec {
    export interface Raw {
        enabled: boolean;
        interval_secs?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnPagedChatGroups.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChatGroup } from "./ReturnChatGroup.js";
import { ReturnPagedChatGroupsPaginationDirection } from "./ReturnPagedChatGroupsPaginationDirection.js";

export const ReturnPagedChatGroups: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnPagedChatGroups.Raw,
    Hume.empathicVoice.ReturnPagedChatGroups
> = core.serialization.object({
    chatGroupsPage: core.serialization.property("chat_groups_page", core.serialization.list(ReturnChatGroup)),
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    paginationDirection: core.serialization.property("pagination_direction", ReturnPagedChatGroupsPaginationDirection),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnPagedChatGroups {
    export interface Raw {
        chat_groups_page: ReturnChatGroup.Raw[];
        page_number: number;
        page_size: number;
        pagination_direction: ReturnPagedChatGroupsPaginationDirection.Raw;
        total_pages: number;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnPagedChatGroupsPaginationDirection.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnPagedChatGroupsPaginationDirection: core.serialization.Schema<
    serializers.empathicVoice.ReturnPagedChatGroupsPaginationDirection.Raw,
    Hume.empathicVoice.ReturnPagedChatGroupsPaginationDirection
> = core.serialization.enum_(["ASC", "DESC"]);

export declare namespace ReturnPagedChatGroupsPaginationDirection {
    export type Raw = "ASC" | "DESC";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnPagedChats.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnChat } from "./ReturnChat.js";
import { ReturnPagedChatsPaginationDirection } from "./ReturnPagedChatsPaginationDirection.js";

export const ReturnPagedChats: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnPagedChats.Raw,
    Hume.empathicVoice.ReturnPagedChats
> = core.serialization.object({
    chatsPage: core.serialization.property("chats_page", core.serialization.list(ReturnChat)),
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    paginationDirection: core.serialization.property("pagination_direction", ReturnPagedChatsPaginationDirection),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnPagedChats {
    export interface Raw {
        chats_page: ReturnChat.Raw[];
        page_number: number;
        page_size: number;
        pagination_direction: ReturnPagedChatsPaginationDirection.Raw;
        total_pages: number;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnPagedChatsPaginationDirection.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnPagedChatsPaginationDirection: core.serialization.Schema<
    serializers.empathicVoice.ReturnPagedChatsPaginationDirection.Raw,
    Hume.empathicVoice.ReturnPagedChatsPaginationDirection
> = core.serialization.enum_(["ASC", "DESC"]);

export declare namespace ReturnPagedChatsPaginationDirection {
    export type Raw = "ASC" | "DESC";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnPagedConfigs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnConfig } from "./ReturnConfig.js";

export const ReturnPagedConfigs: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnPagedConfigs.Raw,
    Hume.empathicVoice.ReturnPagedConfigs
> = core.serialization.object({
    configsPage: core.serialization.property("configs_page", core.serialization.list(ReturnConfig).optional()),
    pageNumber: core.serialization.property("page_number", core.serialization.number().optional()),
    pageSize: core.serialization.property("page_size", core.serialization.number().optional()),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnPagedConfigs {
    export interface Raw {
        configs_page?: ReturnConfig.Raw[] | null;
        page_number?: number | null;
        page_size?: number | null;
        total_pages: number;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnPagedPrompts.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnPrompt } from "./ReturnPrompt.js";

export const ReturnPagedPrompts: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnPagedPrompts.Raw,
    Hume.empathicVoice.ReturnPagedPrompts
> = core.serialization.object({
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    promptsPage: core.serialization.property("prompts_page", core.serialization.list(ReturnPrompt.optional())),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnPagedPrompts {
    export interface Raw {
        page_number: number;
        page_size: number;
        prompts_page: (ReturnPrompt.Raw | null | undefined)[];
        total_pages: number;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnPagedUserDefinedTools.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnUserDefinedTool } from "./ReturnUserDefinedTool.js";

export const ReturnPagedUserDefinedTools: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnPagedUserDefinedTools.Raw,
    Hume.empathicVoice.ReturnPagedUserDefinedTools
> = core.serialization.object({
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    toolsPage: core.serialization.property("tools_page", core.serialization.list(ReturnUserDefinedTool.optional())),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
});

export declare namespace ReturnPagedUserDefinedTools {
    export interface Raw {
        page_number: number;
        page_size: number;
        tools_page: (ReturnUserDefinedTool.Raw | null | undefined)[];
        total_pages: number;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnPrompt.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnPrompt: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnPrompt.Raw,
    Hume.empathicVoice.ReturnPrompt
> = core.serialization.object({
    createdOn: core.serialization.property("created_on", core.serialization.number()),
    id: core.serialization.string(),
    modifiedOn: core.serialization.property("modified_on", core.serialization.number()),
    name: core.serialization.string(),
    text: core.serialization.string(),
    version: core.serialization.number(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
    versionType: core.serialization.property("version_type", core.serialization.string()),
});

export declare namespace ReturnPrompt {
    export interface Raw {
        created_on: number;
        id: string;
        modified_on: number;
        name: string;
        text: string;
        version: number;
        version_description?: string | null;
        version_type: string;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnPromptVersionType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnPromptVersionType: core.serialization.Schema<
    serializers.empathicVoice.ReturnPromptVersionType.Raw,
    Hume.empathicVoice.ReturnPromptVersionType
> = core.serialization.enum_(["FIXED", "LATEST"]);

export declare namespace ReturnPromptVersionType {
    export type Raw = "FIXED" | "LATEST";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnTimeoutSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnTimeoutSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnTimeoutSpec.Raw,
    Hume.empathicVoice.ReturnTimeoutSpec
> = core.serialization.object({
    durationSecs: core.serialization.property("duration_secs", core.serialization.number().optional()),
    enabled: core.serialization.boolean(),
});

export declare namespace ReturnTimeoutSpec {
    export interface Raw {
        duration_secs?: number | null;
        enabled: boolean;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnTimeoutSpecs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnTimeoutSpec } from "./ReturnTimeoutSpec.js";

export const ReturnTimeoutSpecs: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnTimeoutSpecs.Raw,
    Hume.empathicVoice.ReturnTimeoutSpecs
> = core.serialization.object({
    inactivity: ReturnTimeoutSpec,
    maxDuration: core.serialization.property("max_duration", ReturnTimeoutSpec),
});

export declare namespace ReturnTimeoutSpecs {
    export interface Raw {
        inactivity: ReturnTimeoutSpec.Raw;
        max_duration: ReturnTimeoutSpec.Raw;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnUserDefinedTool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnUserDefinedToolToolType } from "./ReturnUserDefinedToolToolType.js";
import { ReturnUserDefinedToolVersionType } from "./ReturnUserDefinedToolVersionType.js";

export const ReturnUserDefinedTool: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnUserDefinedTool.Raw,
    Hume.empathicVoice.ReturnUserDefinedTool
> = core.serialization.object({
    createdOn: core.serialization.property("created_on", core.serialization.number()),
    description: core.serialization.string().optional(),
    fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
    id: core.serialization.string(),
    modifiedOn: core.serialization.property("modified_on", core.serialization.number()),
    name: core.serialization.string(),
    parameters: core.serialization.string(),
    toolType: core.serialization.property("tool_type", ReturnUserDefinedToolToolType),
    version: core.serialization.number(),
    versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
    versionType: core.serialization.property("version_type", ReturnUserDefinedToolVersionType),
});

export declare namespace ReturnUserDefinedTool {
    export interface Raw {
        created_on: number;
        description?: string | null;
        fallback_content?: string | null;
        id: string;
        modified_on: number;
        name: string;
        parameters: string;
        tool_type: ReturnUserDefinedToolToolType.Raw;
        version: number;
        version_description?: string | null;
        version_type: ReturnUserDefinedToolVersionType.Raw;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnUserDefinedToolToolType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnUserDefinedToolToolType: core.serialization.Schema<
    serializers.empathicVoice.ReturnUserDefinedToolToolType.Raw,
    Hume.empathicVoice.ReturnUserDefinedToolToolType
> = core.serialization.enum_(["BUILTIN", "FUNCTION"]);

export declare namespace ReturnUserDefinedToolToolType {
    export type Raw = "BUILTIN" | "FUNCTION";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnUserDefinedToolVersionType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnUserDefinedToolVersionType: core.serialization.Schema<
    serializers.empathicVoice.ReturnUserDefinedToolVersionType.Raw,
    Hume.empathicVoice.ReturnUserDefinedToolVersionType
> = core.serialization.enum_(["FIXED", "LATEST"]);

export declare namespace ReturnUserDefinedToolVersionType {
    export type Raw = "FIXED" | "LATEST";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnVoice.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceProvider } from "./VoiceProvider.js";

export const ReturnVoice: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnVoice.Raw,
    Hume.empathicVoice.ReturnVoice
> = core.serialization.object({
    compatibleOctaveModels: core.serialization.property(
        "compatible_octave_models",
        core.serialization.list(core.serialization.string()).optional(),
    ),
    id: core.serialization.string(),
    name: core.serialization.string(),
    provider: VoiceProvider,
});

export declare namespace ReturnVoice {
    export interface Raw {
        compatible_octave_models?: string[] | null;
        id: string;
        name: string;
        provider: VoiceProvider.Raw;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnWebhookEventType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ReturnWebhookEventType: core.serialization.Schema<
    serializers.empathicVoice.ReturnWebhookEventType.Raw,
    Hume.empathicVoice.ReturnWebhookEventType
> = core.serialization.enum_(["chat_started", "chat_ended", "tool_call"]);

export declare namespace ReturnWebhookEventType {
    export type Raw = "chat_started" | "chat_ended" | "tool_call";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ReturnWebhookSpec.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnWebhookEventType } from "./ReturnWebhookEventType.js";

export const ReturnWebhookSpec: core.serialization.ObjectSchema<
    serializers.empathicVoice.ReturnWebhookSpec.Raw,
    Hume.empathicVoice.ReturnWebhookSpec
> = core.serialization.object({
    events: core.serialization.list(ReturnWebhookEventType),
    url: core.serialization.string(),
});

export declare namespace ReturnWebhookSpec {
    export interface Raw {
        events: ReturnWebhookEventType.Raw[];
        url: string;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/Role.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const Role: core.serialization.Schema<serializers.empathicVoice.Role.Raw, Hume.empathicVoice.Role> =
    core.serialization.enum_(["assistant", "system", "user", "all", "tool", "context"]);

export declare namespace Role {
    export type Raw = "assistant" | "system" | "user" | "all" | "tool" | "context";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/SessionSettings.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AudioConfiguration } from "./AudioConfiguration.js";
import { BuiltinToolConfig } from "./BuiltinToolConfig.js";
import { Context } from "./Context.js";
import { SessionSettingsVariablesValue } from "./SessionSettingsVariablesValue.js";
import { Tool } from "./Tool.js";

export const SessionSettings: core.serialization.ObjectSchema<
    serializers.empathicVoice.SessionSettings.Raw,
    Hume.empathicVoice.SessionSettings
> = core.serialization.object({
    audio: AudioConfiguration.optional(),
    builtinTools: core.serialization.property("builtin_tools", core.serialization.list(BuiltinToolConfig).optional()),
    context: Context.optional(),
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    languageModelApiKey: core.serialization.property("language_model_api_key", core.serialization.string().optional()),
    metadata: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    systemPrompt: core.serialization.property("system_prompt", core.serialization.string().optional()),
    tools: core.serialization.list(Tool).optional(),
    type: core.serialization.stringLiteral("session_settings"),
    variables: core.serialization.record(core.serialization.string(), SessionSettingsVariablesValue).optional(),
    voiceId: core.serialization.property("voice_id", core.serialization.string().optional()),
});

export declare namespace SessionSettings {
    export interface Raw {
        audio?: AudioConfiguration.Raw | null;
        builtin_tools?: BuiltinToolConfig.Raw[] | null;
        context?: Context.Raw | null;
        custom_session_id?: string | null;
        language_model_api_key?: string | null;
        metadata?: Record<string, unknown> | null;
        system_prompt?: string | null;
        tools?: Tool.Raw[] | null;
        type: "session_settings";
        variables?: Record<string, SessionSettingsVariablesValue.Raw> | null;
        voice_id?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/SessionSettingsVariablesValue.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const SessionSettingsVariablesValue: core.serialization.Schema<
    serializers.empathicVoice.SessionSettingsVariablesValue.Raw,
    Hume.empathicVoice.SessionSettingsVariablesValue
> = core.serialization.undiscriminatedUnion([
    core.serialization.string(),
    core.serialization.number(),
    core.serialization.boolean(),
]);

export declare namespace SessionSettingsVariablesValue {
    export type Raw = string | number | boolean;
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/SubscribeEvent.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AssistantEnd } from "./AssistantEnd.js";
import { AssistantMessage } from "./AssistantMessage.js";
import { AssistantProsody } from "./AssistantProsody.js";
import { AudioOutput } from "./AudioOutput.js";
import { ChatMetadata } from "./ChatMetadata.js";
import { SessionSettings } from "./SessionSettings.js";
import { ToolCallMessage } from "./ToolCallMessage.js";
import { ToolErrorMessage } from "./ToolErrorMessage.js";
import { ToolResponseMessage } from "./ToolResponseMessage.js";
import { UserInterruption } from "./UserInterruption.js";
import { UserMessage } from "./UserMessage.js";
import { WebSocketError } from "./WebSocketError.js";

export const SubscribeEvent: core.serialization.Schema<
    serializers.empathicVoice.SubscribeEvent.Raw,
    Hume.empathicVoice.SubscribeEvent
> = core.serialization.undiscriminatedUnion([
    AssistantEnd,
    AssistantMessage,
    AssistantProsody,
    AudioOutput,
    ChatMetadata,
    WebSocketError,
    UserInterruption,
    UserMessage,
    ToolCallMessage,
    ToolResponseMessage,
    ToolErrorMessage,
    SessionSettings,
]);

export declare namespace SubscribeEvent {
    export type Raw =
        | AssistantEnd.Raw
        | AssistantMessage.Raw
        | AssistantProsody.Raw
        | AudioOutput.Raw
        | ChatMetadata.Raw
        | WebSocketError.Raw
        | UserInterruption.Raw
        | UserMessage.Raw
        | ToolCallMessage.Raw
        | ToolResponseMessage.Raw
        | ToolErrorMessage.Raw
        | SessionSettings.Raw;
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/Tool.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ToolType } from "./ToolType.js";

export const Tool: core.serialization.ObjectSchema<serializers.empathicVoice.Tool.Raw, Hume.empathicVoice.Tool> =
    core.serialization.object({
        description: core.serialization.string().optional(),
        fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
        name: core.serialization.string(),
        parameters: core.serialization.string(),
        type: ToolType,
    });

export declare namespace Tool {
    export interface Raw {
        description?: string | null;
        fallback_content?: string | null;
        name: string;
        parameters: string;
        type: ToolType.Raw;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ToolCallMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ToolType } from "./ToolType.js";

export const ToolCallMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.ToolCallMessage.Raw,
    Hume.empathicVoice.ToolCallMessage
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    name: core.serialization.string(),
    parameters: core.serialization.string(),
    responseRequired: core.serialization.property("response_required", core.serialization.boolean()),
    toolCallId: core.serialization.property("tool_call_id", core.serialization.string()),
    toolType: core.serialization.property("tool_type", ToolType),
    type: core.serialization.stringLiteral("tool_call"),
});

export declare namespace ToolCallMessage {
    export interface Raw {
        custom_session_id?: string | null;
        name: string;
        parameters: string;
        response_required: boolean;
        tool_call_id: string;
        tool_type: ToolType.Raw;
        type: "tool_call";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ToolErrorMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ErrorLevel } from "./ErrorLevel.js";
import { ToolType } from "./ToolType.js";

export const ToolErrorMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.ToolErrorMessage.Raw,
    Hume.empathicVoice.ToolErrorMessage
> = core.serialization.object({
    code: core.serialization.string().optional(),
    content: core.serialization.string().optional(),
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    error: core.serialization.string(),
    level: ErrorLevel.optional(),
    toolCallId: core.serialization.property("tool_call_id", core.serialization.string()),
    toolType: core.serialization.property("tool_type", ToolType.optional()),
    type: core.serialization.stringLiteral("tool_error"),
});

export declare namespace ToolErrorMessage {
    export interface Raw {
        code?: string | null;
        content?: string | null;
        custom_session_id?: string | null;
        error: string;
        level?: ErrorLevel.Raw | null;
        tool_call_id: string;
        tool_type?: ToolType.Raw | null;
        type: "tool_error";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ToolResponseMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ToolType } from "./ToolType.js";

export const ToolResponseMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.ToolResponseMessage.Raw,
    Hume.empathicVoice.ToolResponseMessage
> = core.serialization.object({
    content: core.serialization.string(),
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    toolCallId: core.serialization.property("tool_call_id", core.serialization.string()),
    toolName: core.serialization.property("tool_name", core.serialization.string().optional()),
    toolType: core.serialization.property("tool_type", ToolType.optional()),
    type: core.serialization.stringLiteral("tool_response"),
});

export declare namespace ToolResponseMessage {
    export interface Raw {
        content: string;
        custom_session_id?: string | null;
        tool_call_id: string;
        tool_name?: string | null;
        tool_type?: ToolType.Raw | null;
        type: "tool_response";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ToolType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ToolType: core.serialization.Schema<serializers.empathicVoice.ToolType.Raw, Hume.empathicVoice.ToolType> =
    core.serialization.enum_(["builtin", "function"]);

export declare namespace ToolType {
    export type Raw = "builtin" | "function";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/UserInput.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const UserInput: core.serialization.ObjectSchema<
    serializers.empathicVoice.UserInput.Raw,
    Hume.empathicVoice.UserInput
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    text: core.serialization.string(),
    type: core.serialization.stringLiteral("user_input"),
});

export declare namespace UserInput {
    export interface Raw {
        custom_session_id?: string | null;
        text: string;
        type: "user_input";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/UserInterruption.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const UserInterruption: core.serialization.ObjectSchema<
    serializers.empathicVoice.UserInterruption.Raw,
    Hume.empathicVoice.UserInterruption
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    time: core.serialization.number(),
    type: core.serialization.stringLiteral("user_interruption"),
});

export declare namespace UserInterruption {
    export interface Raw {
        custom_session_id?: string | null;
        time: number;
        type: "user_interruption";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/UserMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ChatMessage } from "./ChatMessage.js";
import { Inference } from "./Inference.js";
import { MillisecondInterval } from "./MillisecondInterval.js";

export const UserMessage: core.serialization.ObjectSchema<
    serializers.empathicVoice.UserMessage.Raw,
    Hume.empathicVoice.UserMessage
> = core.serialization.object({
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    fromText: core.serialization.property("from_text", core.serialization.boolean()),
    interim: core.serialization.boolean(),
    language: core.serialization.string().optional(),
    message: ChatMessage,
    models: Inference,
    time: MillisecondInterval,
    type: core.serialization.stringLiteral("user_message"),
});

export declare namespace UserMessage {
    export interface Raw {
        custom_session_id?: string | null;
        from_text: boolean;
        interim: boolean;
        language?: string | null;
        message: ChatMessage.Raw;
        models: Inference.Raw;
        time: MillisecondInterval.Raw;
        type: "user_message";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ValidationError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ValidationErrorLocItem } from "./ValidationErrorLocItem.js";

export const ValidationError: core.serialization.ObjectSchema<
    serializers.empathicVoice.ValidationError.Raw,
    Hume.empathicVoice.ValidationError
> = core.serialization.object({
    loc: core.serialization.list(ValidationErrorLocItem),
    msg: core.serialization.string(),
    type: core.serialization.string(),
});

export declare namespace ValidationError {
    export interface Raw {
        loc: ValidationErrorLocItem.Raw[];
        msg: string;
        type: string;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/ValidationErrorLocItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ValidationErrorLocItem: core.serialization.Schema<
    serializers.empathicVoice.ValidationErrorLocItem.Raw,
    Hume.empathicVoice.ValidationErrorLocItem
> = core.serialization.undiscriminatedUnion([core.serialization.string(), core.serialization.number()]);

export declare namespace ValidationErrorLocItem {
    export type Raw = string | number;
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/VoiceId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceProvider } from "./VoiceProvider.js";

export const VoiceId: core.serialization.ObjectSchema<
    serializers.empathicVoice.VoiceId.Raw,
    Hume.empathicVoice.VoiceId
> = core.serialization.object({
    id: core.serialization.string(),
    provider: VoiceProvider.optional(),
});

export declare namespace VoiceId {
    export interface Raw {
        id: string;
        provider?: VoiceProvider.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/VoiceName.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceProvider } from "./VoiceProvider.js";

export const VoiceName: core.serialization.ObjectSchema<
    serializers.empathicVoice.VoiceName.Raw,
    Hume.empathicVoice.VoiceName
> = core.serialization.object({
    name: core.serialization.string(),
    provider: VoiceProvider.optional(),
});

export declare namespace VoiceName {
    export interface Raw {
        name: string;
        provider?: VoiceProvider.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/VoiceProvider.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const VoiceProvider: core.serialization.Schema<
    serializers.empathicVoice.VoiceProvider.Raw,
    Hume.empathicVoice.VoiceProvider
> = core.serialization.enum_(["HUME_AI", "CUSTOM_VOICE"]);

export declare namespace VoiceProvider {
    export type Raw = "HUME_AI" | "CUSTOM_VOICE";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/VoiceRef.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceId } from "./VoiceId.js";
import { VoiceName } from "./VoiceName.js";

export const VoiceRef: core.serialization.Schema<serializers.empathicVoice.VoiceRef.Raw, Hume.empathicVoice.VoiceRef> =
    core.serialization.undiscriminatedUnion([VoiceId, VoiceName]);

export declare namespace VoiceRef {
    export type Raw = VoiceId.Raw | VoiceName.Raw;
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/WebSocketError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const WebSocketError: core.serialization.ObjectSchema<
    serializers.empathicVoice.WebSocketError.Raw,
    Hume.empathicVoice.WebSocketError
> = core.serialization.object({
    code: core.serialization.string(),
    customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
    message: core.serialization.string(),
    requestId: core.serialization.property("request_id", core.serialization.string().optional()),
    slug: core.serialization.string(),
    type: core.serialization.stringLiteral("error"),
});

export declare namespace WebSocketError {
    export interface Raw {
        code: string;
        custom_session_id?: string | null;
        message: string;
        request_id?: string | null;
        slug: string;
        type: "error";
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/WebhookEvent.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { WebhookEventChatEnded } from "./WebhookEventChatEnded.js";
import { WebhookEventChatStarted } from "./WebhookEventChatStarted.js";
import { WebhookEventToolCall } from "./WebhookEventToolCall.js";

export const WebhookEvent: core.serialization.Schema<
    serializers.empathicVoice.WebhookEvent.Raw,
    Hume.empathicVoice.WebhookEvent
> = core.serialization.undiscriminatedUnion([WebhookEventChatStarted, WebhookEventChatEnded, WebhookEventToolCall]);

export declare namespace WebhookEvent {
    export type Raw = WebhookEventChatStarted.Raw | WebhookEventChatEnded.Raw | WebhookEventToolCall.Raw;
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/WebhookEventBase.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const WebhookEventBase: core.serialization.ObjectSchema<
    serializers.empathicVoice.WebhookEventBase.Raw,
    Hume.empathicVoice.WebhookEventBase
> = core.serialization.object({
    chatGroupId: core.serialization.property("chat_group_id", core.serialization.string()),
    chatId: core.serialization.property("chat_id", core.serialization.string()),
    configId: core.serialization.property("config_id", core.serialization.string().optional()),
});

export declare namespace WebhookEventBase {
    export interface Raw {
        chat_group_id: string;
        chat_id: string;
        config_id?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/WebhookEventChatEnded.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { WebhookEventBase } from "./WebhookEventBase.js";
import { WebhookEventChatStatus } from "./WebhookEventChatStatus.js";

export const WebhookEventChatEnded: core.serialization.ObjectSchema<
    serializers.empathicVoice.WebhookEventChatEnded.Raw,
    Hume.empathicVoice.WebhookEventChatEnded
> = core.serialization
    .object({
        callerNumber: core.serialization.property("caller_number", core.serialization.string().optional()),
        customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
        durationSeconds: core.serialization.property("duration_seconds", core.serialization.number()),
        endReason: core.serialization.property("end_reason", WebhookEventChatStatus),
        endTime: core.serialization.property("end_time", core.serialization.number()),
        eventName: core.serialization.property("event_name", core.serialization.stringLiteral("chat_ended").optional()),
    })
    .extend(WebhookEventBase);

export declare namespace WebhookEventChatEnded {
    export interface Raw extends WebhookEventBase.Raw {
        caller_number?: string | null;
        custom_session_id?: string | null;
        duration_seconds: number;
        end_reason: WebhookEventChatStatus.Raw;
        end_time: number;
        event_name?: "chat_ended" | null;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/WebhookEventChatStartType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const WebhookEventChatStartType: core.serialization.Schema<
    serializers.empathicVoice.WebhookEventChatStartType.Raw,
    Hume.empathicVoice.WebhookEventChatStartType
> = core.serialization.enum_(["new_chat_group", "resumed_chat_group"]);

export declare namespace WebhookEventChatStartType {
    export type Raw = "new_chat_group" | "resumed_chat_group";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/WebhookEventChatStarted.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { WebhookEventBase } from "./WebhookEventBase.js";
import { WebhookEventChatStartType } from "./WebhookEventChatStartType.js";

export const WebhookEventChatStarted: core.serialization.ObjectSchema<
    serializers.empathicVoice.WebhookEventChatStarted.Raw,
    Hume.empathicVoice.WebhookEventChatStarted
> = core.serialization
    .object({
        callerNumber: core.serialization.property("caller_number", core.serialization.string().optional()),
        chatStartType: core.serialization.property("chat_start_type", WebhookEventChatStartType),
        customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
        eventName: core.serialization.property(
            "event_name",
            core.serialization.stringLiteral("chat_started").optional(),
        ),
        startTime: core.serialization.property("start_time", core.serialization.number()),
    })
    .extend(WebhookEventBase);

export declare namespace WebhookEventChatStarted {
    export interface Raw extends WebhookEventBase.Raw {
        caller_number?: string | null;
        chat_start_type: WebhookEventChatStartType.Raw;
        custom_session_id?: string | null;
        event_name?: "chat_started" | null;
        start_time: number;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/WebhookEventChatStatus.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const WebhookEventChatStatus: core.serialization.Schema<
    serializers.empathicVoice.WebhookEventChatStatus.Raw,
    Hume.empathicVoice.WebhookEventChatStatus
> = core.serialization.enum_([
    "ACTIVE",
    "USER_ENDED",
    "USER_TIMEOUT",
    "INACTIVITY_TIMEOUT",
    "MAX_DURATION_TIMEOUT",
    "SILENCE_TIMEOUT",
    "ERROR",
]);

export declare namespace WebhookEventChatStatus {
    export type Raw =
        | "ACTIVE"
        | "USER_ENDED"
        | "USER_TIMEOUT"
        | "INACTIVITY_TIMEOUT"
        | "MAX_DURATION_TIMEOUT"
        | "SILENCE_TIMEOUT"
        | "ERROR";
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/WebhookEventToolCall.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ToolCallMessage } from "./ToolCallMessage.js";
import { WebhookEventBase } from "./WebhookEventBase.js";

export const WebhookEventToolCall: core.serialization.ObjectSchema<
    serializers.empathicVoice.WebhookEventToolCall.Raw,
    Hume.empathicVoice.WebhookEventToolCall
> = core.serialization
    .object({
        callerNumber: core.serialization.property("caller_number", core.serialization.string().optional()),
        customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
        eventName: core.serialization.property("event_name", core.serialization.stringLiteral("tool_call").optional()),
        timestamp: core.serialization.number(),
        toolCallMessage: core.serialization.property("tool_call_message", ToolCallMessage),
    })
    .extend(WebhookEventBase);

export declare namespace WebhookEventToolCall {
    export interface Raw extends WebhookEventBase.Raw {
        caller_number?: string | null;
        custom_session_id?: string | null;
        event_name?: "tool_call" | null;
        timestamp: number;
        tool_call_message: ToolCallMessage.Raw;
    }
}

================================================================================
// File: src/serialization/resources/empathicVoice/types/index.ts
================================================================================
export * from "./AssistantEnd.js";
export * from "./AssistantInput.js";
export * from "./AssistantMessage.js";
export * from "./AssistantProsody.js";
export * from "./AudioConfiguration.js";
export * from "./AudioInput.js";
export * from "./AudioOutput.js";
export * from "./BuiltInTool.js";
export * from "./BuiltinToolConfig.js";
export * from "./ChatMessage.js";
export * from "./ChatMessageToolResult.js";
export * from "./ChatMetadata.js";
export * from "./ConnectSessionSettings.js";
export * from "./ConnectSessionSettingsAudio.js";
export * from "./ConnectSessionSettingsContext.js";
export * from "./ConnectSessionSettingsVariablesValue.js";
export * from "./Context.js";
export * from "./ContextType.js";
export * from "./ControlPlanePublishEvent.js";
export * from "./EmotionScores.js";
export * from "./Encoding.js";
export * from "./ErrorLevel.js";
export * from "./ErrorResponse.js";
export * from "./HttpValidationError.js";
export * from "./Inference.js";
export * from "./JsonMessage.js";
export * from "./LanguageModelType.js";
export * from "./MillisecondInterval.js";
export * from "./ModelProviderEnum.js";
export * from "./PauseAssistantMessage.js";
export * from "./PostedBuiltinTool.js";
export * from "./PostedBuiltinToolName.js";
export * from "./PostedConfigPromptSpec.js";
export * from "./PostedEllmModel.js";
export * from "./PostedEventMessageSpec.js";
export * from "./PostedEventMessageSpecs.js";
export * from "./PostedLanguageModel.js";
export * from "./PostedNudgeSpec.js";
export * from "./PostedTimeoutSpec.js";
export * from "./PostedTimeoutSpecs.js";
export * from "./PostedTimeoutSpecsInactivity.js";
export * from "./PostedTimeoutSpecsMaxDuration.js";
export * from "./PostedUserDefinedToolSpec.js";
export * from "./PostedWebhookEventType.js";
export * from "./PostedWebhookSpec.js";
export * from "./ProsodyInference.js";
export * from "./ResumeAssistantMessage.js";
export * from "./ReturnBuiltinTool.js";
export * from "./ReturnBuiltinToolToolType.js";
export * from "./ReturnChat.js";
export * from "./ReturnChatAudioReconstruction.js";
export * from "./ReturnChatAudioReconstructionStatus.js";
export * from "./ReturnChatEvent.js";
export * from "./ReturnChatEventRole.js";
export * from "./ReturnChatEventType.js";
export * from "./ReturnChatGroup.js";
export * from "./ReturnChatGroupPagedAudioReconstructions.js";
export * from "./ReturnChatGroupPagedAudioReconstructionsPaginationDirection.js";
export * from "./ReturnChatGroupPagedChats.js";
export * from "./ReturnChatGroupPagedChatsPaginationDirection.js";
export * from "./ReturnChatGroupPagedEvents.js";
export * from "./ReturnChatGroupPagedEventsPaginationDirection.js";
export * from "./ReturnChatPagedEvents.js";
export * from "./ReturnChatPagedEventsPaginationDirection.js";
export * from "./ReturnChatPagedEventsStatus.js";
export * from "./ReturnChatStatus.js";
export * from "./ReturnConfig.js";
export * from "./ReturnConfigSpec.js";
export * from "./ReturnEllmModel.js";
export * from "./ReturnEventMessageSpec.js";
export * from "./ReturnEventMessageSpecs.js";
export * from "./ReturnLanguageModel.js";
export * from "./ReturnNudgeSpec.js";
export * from "./ReturnPagedChatGroups.js";
export * from "./ReturnPagedChatGroupsPaginationDirection.js";
export * from "./ReturnPagedChats.js";
export * from "./ReturnPagedChatsPaginationDirection.js";
export * from "./ReturnPagedConfigs.js";
export * from "./ReturnPagedPrompts.js";
export * from "./ReturnPagedUserDefinedTools.js";
export * from "./ReturnPrompt.js";
export * from "./ReturnPromptVersionType.js";
export * from "./ReturnTimeoutSpec.js";
export * from "./ReturnTimeoutSpecs.js";
export * from "./ReturnUserDefinedTool.js";
export * from "./ReturnUserDefinedToolToolType.js";
export * from "./ReturnUserDefinedToolVersionType.js";
export * from "./ReturnVoice.js";
export * from "./ReturnWebhookEventType.js";
export * from "./ReturnWebhookSpec.js";
export * from "./Role.js";
export * from "./SessionSettings.js";
export * from "./SessionSettingsVariablesValue.js";
export * from "./SubscribeEvent.js";
export * from "./Tool.js";
export * from "./ToolCallMessage.js";
export * from "./ToolErrorMessage.js";
export * from "./ToolResponseMessage.js";
export * from "./ToolType.js";
export * from "./UserInput.js";
export * from "./UserInterruption.js";
export * from "./UserMessage.js";
export * from "./ValidationError.js";
export * from "./ValidationErrorLocItem.js";
export * from "./VoiceId.js";
export * from "./VoiceName.js";
export * from "./VoiceProvider.js";
export * from "./VoiceRef.js";
export * from "./WebhookEvent.js";
export * from "./WebhookEventBase.js";
export * from "./WebhookEventChatEnded.js";
export * from "./WebhookEventChatStarted.js";
export * from "./WebhookEventChatStartType.js";
export * from "./WebhookEventChatStatus.js";
export * from "./WebhookEventToolCall.js";
export * from "./WebSocketError.js";

================================================================================
// File: src/serialization/resources/expressionMeasurement/index.ts
================================================================================
export * from "./resources/index.js";

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/client/getJobPredictions.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { UnionPredictResult } from "../types/UnionPredictResult.js";

export const Response: core.serialization.Schema<
    serializers.expressionMeasurement.batch.getJobPredictions.Response.Raw,
    Hume.expressionMeasurement.batch.UnionPredictResult[]
> = core.serialization.list(UnionPredictResult);

export declare namespace Response {
    export type Raw = UnionPredictResult.Raw[];
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/client/index.ts
================================================================================
export * as getJobPredictions from "./getJobPredictions.js";
export * as listJobs from "./listJobs.js";

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/client/listJobs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { UnionJob } from "../types/UnionJob.js";

export const Response: core.serialization.Schema<
    serializers.expressionMeasurement.batch.listJobs.Response.Raw,
    Hume.expressionMeasurement.batch.UnionJob[]
> = core.serialization.list(UnionJob);

export declare namespace Response {
    export type Raw = UnionJob.Raw[];
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/index.ts
================================================================================
export * from "./client/index.js";
export * from "./types/index.js";

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Alternative.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Alternative: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Alternative.Raw,
    Hume.expressionMeasurement.batch.Alternative
> = core.serialization.stringLiteral("language_only");

export declare namespace Alternative {
    export type Raw = "language_only";
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Bcp47Tag.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Bcp47Tag: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Bcp47Tag.Raw,
    Hume.expressionMeasurement.batch.Bcp47Tag
> = core.serialization.enum_([
    "zh",
    "da",
    "nl",
    "en",
    "en-AU",
    "en-IN",
    "en-NZ",
    "en-GB",
    "fr",
    "fr-CA",
    "de",
    "hi",
    "hi-Latn",
    "id",
    "it",
    "ja",
    "ko",
    "no",
    "pl",
    "pt",
    "pt-BR",
    "pt-PT",
    "ru",
    "es",
    "es-419",
    "sv",
    "ta",
    "tr",
    "uk",
]);

export declare namespace Bcp47Tag {
    export type Raw =
        | "zh"
        | "da"
        | "nl"
        | "en"
        | "en-AU"
        | "en-IN"
        | "en-NZ"
        | "en-GB"
        | "fr"
        | "fr-CA"
        | "de"
        | "hi"
        | "hi-Latn"
        | "id"
        | "it"
        | "ja"
        | "ko"
        | "no"
        | "pl"
        | "pt"
        | "pt-BR"
        | "pt-PT"
        | "ru"
        | "es"
        | "es-419"
        | "sv"
        | "ta"
        | "tr"
        | "uk";
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/BoundingBox.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const BoundingBox: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.BoundingBox.Raw,
    Hume.expressionMeasurement.batch.BoundingBox
> = core.serialization.object({
    x: core.serialization.number(),
    y: core.serialization.number(),
    w: core.serialization.number(),
    h: core.serialization.number(),
});

export declare namespace BoundingBox {
    export interface Raw {
        x: number;
        y: number;
        w: number;
        h: number;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/BurstPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { DescriptionsScore } from "./DescriptionsScore.js";
import { EmotionScore } from "./EmotionScore.js";
import { TimeInterval } from "./TimeInterval.js";

export const BurstPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.BurstPrediction.Raw,
    Hume.expressionMeasurement.batch.BurstPrediction
> = core.serialization.object({
    time: TimeInterval,
    emotions: core.serialization.list(EmotionScore),
    descriptions: core.serialization.list(DescriptionsScore),
});

export declare namespace BurstPrediction {
    export interface Raw {
        time: TimeInterval.Raw;
        emotions: EmotionScore.Raw[];
        descriptions: DescriptionsScore.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Classification.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Classification: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Classification.Raw,
    Hume.expressionMeasurement.batch.Classification
> = core.serialization.record(core.serialization.string(), core.serialization.unknown());

export declare namespace Classification {
    export type Raw = Record<string, unknown>;
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedEmbeddingGeneration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const CompletedEmbeddingGeneration: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CompletedEmbeddingGeneration.Raw,
    Hume.expressionMeasurement.batch.CompletedEmbeddingGeneration
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
    startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
    endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
});

export declare namespace CompletedEmbeddingGeneration {
    export interface Raw {
        created_timestamp_ms: number;
        started_timestamp_ms: number;
        ended_timestamp_ms: number;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const CompletedInference: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CompletedInference.Raw,
    Hume.expressionMeasurement.batch.CompletedInference
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
    startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
    endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
    numPredictions: core.serialization.property("num_predictions", core.serialization.number()),
    numErrors: core.serialization.property("num_errors", core.serialization.number()),
});

export declare namespace CompletedInference {
    export interface Raw {
        created_timestamp_ms: number;
        started_timestamp_ms: number;
        ended_timestamp_ms: number;
        num_predictions: number;
        num_errors: number;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedState.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CompletedInference } from "./CompletedInference.js";

export const CompletedState: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CompletedState.Raw,
    Hume.expressionMeasurement.batch.CompletedState
> = core.serialization.object({}).extend(CompletedInference);

export declare namespace CompletedState {
    export interface Raw extends CompletedInference.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedTlInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const CompletedTlInference: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CompletedTlInference.Raw,
    Hume.expressionMeasurement.batch.CompletedTlInference
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
    startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
    endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
    numPredictions: core.serialization.property("num_predictions", core.serialization.number()),
    numErrors: core.serialization.property("num_errors", core.serialization.number()),
});

export declare namespace CompletedTlInference {
    export interface Raw {
        created_timestamp_ms: number;
        started_timestamp_ms: number;
        ended_timestamp_ms: number;
        num_predictions: number;
        num_errors: number;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedTraining.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { TrainingCustomModel } from "./TrainingCustomModel.js";

export const CompletedTraining: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CompletedTraining.Raw,
    Hume.expressionMeasurement.batch.CompletedTraining
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
    startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
    endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
    customModel: core.serialization.property("custom_model", TrainingCustomModel),
    alternatives: core.serialization.record(core.serialization.string(), TrainingCustomModel).optional(),
});

export declare namespace CompletedTraining {
    export interface Raw {
        created_timestamp_ms: number;
        started_timestamp_ms: number;
        ended_timestamp_ms: number;
        custom_model: TrainingCustomModel.Raw;
        alternatives?: Record<string, TrainingCustomModel.Raw> | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CustomModelId } from "./CustomModelId.js";
import { CustomModelVersionId } from "./CustomModelVersionId.js";

export const CustomModel: core.serialization.Schema<
    serializers.expressionMeasurement.batch.CustomModel.Raw,
    Hume.expressionMeasurement.batch.CustomModel
> = core.serialization.undiscriminatedUnion([CustomModelId, CustomModelVersionId]);

export declare namespace CustomModel {
    export type Raw = CustomModelId.Raw | CustomModelVersionId.Raw;
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const CustomModelId: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CustomModelId.Raw,
    Hume.expressionMeasurement.batch.CustomModelId
> = core.serialization.object({
    id: core.serialization.string(),
});

export declare namespace CustomModelId {
    export interface Raw {
        id: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const CustomModelPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CustomModelPrediction.Raw,
    Hume.expressionMeasurement.batch.CustomModelPrediction
> = core.serialization.object({
    output: core.serialization.record(core.serialization.string(), core.serialization.number()),
    error: core.serialization.string(),
    taskType: core.serialization.property("task_type", core.serialization.string()),
});

export declare namespace CustomModelPrediction {
    export interface Raw {
        output: Record<string, number>;
        error: string;
        task_type: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Tag } from "./Tag.js";

export const CustomModelRequest: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CustomModelRequest.Raw,
    Hume.expressionMeasurement.batch.CustomModelRequest
> = core.serialization.object({
    name: core.serialization.string(),
    description: core.serialization.string().optional(),
    tags: core.serialization.list(Tag).optional(),
});

export declare namespace CustomModelRequest {
    export interface Raw {
        name: string;
        description?: string | null;
        tags?: Tag.Raw[] | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelVersionId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const CustomModelVersionId: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CustomModelVersionId.Raw,
    Hume.expressionMeasurement.batch.CustomModelVersionId
> = core.serialization.object({
    versionId: core.serialization.property("version_id", core.serialization.string()),
});

export declare namespace CustomModelVersionId {
    export interface Raw {
        version_id: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelsInferenceJob.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { JobTlInference } from "./JobTlInference.js";

export const CustomModelsInferenceJob: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CustomModelsInferenceJob.Raw,
    Hume.expressionMeasurement.batch.CustomModelsInferenceJob
> = core.serialization
    .object({
        type: core.serialization.string(),
    })
    .extend(JobTlInference);

export declare namespace CustomModelsInferenceJob {
    export interface Raw extends JobTlInference.Raw {
        type: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelsTrainingJob.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { JobTraining } from "./JobTraining.js";

export const CustomModelsTrainingJob: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.CustomModelsTrainingJob.Raw,
    Hume.expressionMeasurement.batch.CustomModelsTrainingJob
> = core.serialization
    .object({
        type: core.serialization.string(),
    })
    .extend(JobTraining);

export declare namespace CustomModelsTrainingJob {
    export interface Raw extends JobTraining.Raw {
        type: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Dataset.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { DatasetId } from "./DatasetId.js";
import { DatasetVersionId } from "./DatasetVersionId.js";

export const Dataset: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Dataset.Raw,
    Hume.expressionMeasurement.batch.Dataset
> = core.serialization.undiscriminatedUnion([DatasetId, DatasetVersionId]);

export declare namespace Dataset {
    export type Raw = DatasetId.Raw | DatasetVersionId.Raw;
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/DatasetId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const DatasetId: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.DatasetId.Raw,
    Hume.expressionMeasurement.batch.DatasetId
> = core.serialization.object({
    id: core.serialization.string(),
});

export declare namespace DatasetId {
    export interface Raw {
        id: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/DatasetVersionId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const DatasetVersionId: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.DatasetVersionId.Raw,
    Hume.expressionMeasurement.batch.DatasetVersionId
> = core.serialization.object({
    versionId: core.serialization.property("version_id", core.serialization.string()),
});

export declare namespace DatasetVersionId {
    export interface Raw {
        version_id: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Direction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Direction: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Direction.Raw,
    Hume.expressionMeasurement.batch.Direction
> = core.serialization.enum_(["asc", "desc"]);

export declare namespace Direction {
    export type Raw = "asc" | "desc";
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/EmbeddingGenerationBaseRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { RegistryFileDetail } from "./RegistryFileDetail.js";

export const EmbeddingGenerationBaseRequest: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.EmbeddingGenerationBaseRequest.Raw,
    Hume.expressionMeasurement.batch.EmbeddingGenerationBaseRequest
> = core.serialization.object({
    registryFileDetails: core.serialization.property(
        "registry_file_details",
        core.serialization.list(RegistryFileDetail).optional(),
    ),
});

export declare namespace EmbeddingGenerationBaseRequest {
    export interface Raw {
        registry_file_details?: RegistryFileDetail.Raw[] | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/EmbeddingGenerationJob.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { JobEmbeddingGeneration } from "./JobEmbeddingGeneration.js";

export const EmbeddingGenerationJob: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.EmbeddingGenerationJob.Raw,
    Hume.expressionMeasurement.batch.EmbeddingGenerationJob
> = core.serialization
    .object({
        type: core.serialization.string(),
    })
    .extend(JobEmbeddingGeneration);

export declare namespace EmbeddingGenerationJob {
    export interface Raw extends JobEmbeddingGeneration.Raw {
        type: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Error_.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Error_: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Error_.Raw,
    Hume.expressionMeasurement.batch.Error_
> = core.serialization.object({
    message: core.serialization.string(),
    file: core.serialization.string(),
});

export declare namespace Error_ {
    export interface Raw {
        message: string;
        file: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/EvaluationArgs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ValidationArgs } from "./ValidationArgs.js";

export const EvaluationArgs: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.EvaluationArgs.Raw,
    Hume.expressionMeasurement.batch.EvaluationArgs
> = core.serialization.object({
    validation: ValidationArgs.optional(),
});

export declare namespace EvaluationArgs {
    export interface Raw {
        validation?: ValidationArgs.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Face.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Unconfigurable } from "./Unconfigurable.js";

export const Face: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Face.Raw,
    Hume.expressionMeasurement.batch.Face
> = core.serialization.object({
    fpsPred: core.serialization.property("fps_pred", core.serialization.number().optional()),
    probThreshold: core.serialization.property("prob_threshold", core.serialization.number().optional()),
    identifyFaces: core.serialization.property("identify_faces", core.serialization.boolean().optional()),
    minFaceSize: core.serialization.property("min_face_size", core.serialization.number().optional()),
    facs: Unconfigurable.optional(),
    descriptions: Unconfigurable.optional(),
    saveFaces: core.serialization.property("save_faces", core.serialization.boolean().optional()),
});

export declare namespace Face {
    export interface Raw {
        fps_pred?: number | null;
        prob_threshold?: number | null;
        identify_faces?: boolean | null;
        min_face_size?: number | null;
        facs?: Unconfigurable.Raw | null;
        descriptions?: Unconfigurable.Raw | null;
        save_faces?: boolean | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/FacePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { BoundingBox } from "./BoundingBox.js";
import { DescriptionsScore } from "./DescriptionsScore.js";
import { EmotionScore } from "./EmotionScore.js";
import { FacsScore } from "./FacsScore.js";

export const FacePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.FacePrediction.Raw,
    Hume.expressionMeasurement.batch.FacePrediction
> = core.serialization.object({
    frame: core.serialization.number(),
    time: core.serialization.number(),
    prob: core.serialization.number(),
    box: BoundingBox,
    emotions: core.serialization.list(EmotionScore),
    facs: core.serialization.list(FacsScore).optional(),
    descriptions: core.serialization.list(DescriptionsScore).optional(),
});

export declare namespace FacePrediction {
    export interface Raw {
        frame: number;
        time: number;
        prob: number;
        box: BoundingBox.Raw;
        emotions: EmotionScore.Raw[];
        facs?: FacsScore.Raw[] | null;
        descriptions?: DescriptionsScore.Raw[] | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/FacemeshPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { EmotionScore } from "./EmotionScore.js";

export const FacemeshPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.FacemeshPrediction.Raw,
    Hume.expressionMeasurement.batch.FacemeshPrediction
> = core.serialization.object({
    emotions: core.serialization.list(EmotionScore),
});

export declare namespace FacemeshPrediction {
    export interface Raw {
        emotions: EmotionScore.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Failed.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Failed: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Failed.Raw,
    Hume.expressionMeasurement.batch.Failed
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
    startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
    endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
    message: core.serialization.string(),
});

export declare namespace Failed {
    export interface Raw {
        created_timestamp_ms: number;
        started_timestamp_ms: number;
        ended_timestamp_ms: number;
        message: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/FailedState.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Failed } from "./Failed.js";

export const FailedState: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.FailedState.Raw,
    Hume.expressionMeasurement.batch.FailedState
> = core.serialization.object({}).extend(Failed);

export declare namespace FailedState {
    export interface Raw extends Failed.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/File_.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const File_: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.File_.Raw,
    Hume.expressionMeasurement.batch.File_
> = core.serialization.object({
    filename: core.serialization.string().optional(),
    contentType: core.serialization.property("content_type", core.serialization.string().optional()),
    md5Sum: core.serialization.property("md5sum", core.serialization.string()),
});

export declare namespace File_ {
    export interface Raw {
        filename?: string | null;
        content_type?: string | null;
        md5sum: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Granularity.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Granularity: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Granularity.Raw,
    Hume.expressionMeasurement.batch.Granularity
> = core.serialization.enum_(["word", "sentence", "utterance", "conversational_turn"]);

export declare namespace Granularity {
    export type Raw = "word" | "sentence" | "utterance" | "conversational_turn";
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsBurstPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { BurstPrediction } from "./BurstPrediction.js";

export const GroupedPredictionsBurstPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.GroupedPredictionsBurstPrediction.Raw,
    Hume.expressionMeasurement.batch.GroupedPredictionsBurstPrediction
> = core.serialization.object({
    id: core.serialization.string(),
    predictions: core.serialization.list(BurstPrediction),
});

export declare namespace GroupedPredictionsBurstPrediction {
    export interface Raw {
        id: string;
        predictions: BurstPrediction.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsFacePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { FacePrediction } from "./FacePrediction.js";

export const GroupedPredictionsFacePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.GroupedPredictionsFacePrediction.Raw,
    Hume.expressionMeasurement.batch.GroupedPredictionsFacePrediction
> = core.serialization.object({
    id: core.serialization.string(),
    predictions: core.serialization.list(FacePrediction),
});

export declare namespace GroupedPredictionsFacePrediction {
    export interface Raw {
        id: string;
        predictions: FacePrediction.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsFacemeshPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { FacemeshPrediction } from "./FacemeshPrediction.js";

export const GroupedPredictionsFacemeshPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.GroupedPredictionsFacemeshPrediction.Raw,
    Hume.expressionMeasurement.batch.GroupedPredictionsFacemeshPrediction
> = core.serialization.object({
    id: core.serialization.string(),
    predictions: core.serialization.list(FacemeshPrediction),
});

export declare namespace GroupedPredictionsFacemeshPrediction {
    export interface Raw {
        id: string;
        predictions: FacemeshPrediction.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsLanguagePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { LanguagePrediction } from "./LanguagePrediction.js";

export const GroupedPredictionsLanguagePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.GroupedPredictionsLanguagePrediction.Raw,
    Hume.expressionMeasurement.batch.GroupedPredictionsLanguagePrediction
> = core.serialization.object({
    id: core.serialization.string(),
    predictions: core.serialization.list(LanguagePrediction),
});

export declare namespace GroupedPredictionsLanguagePrediction {
    export interface Raw {
        id: string;
        predictions: LanguagePrediction.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsNerPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { NerPrediction } from "./NerPrediction.js";

export const GroupedPredictionsNerPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.GroupedPredictionsNerPrediction.Raw,
    Hume.expressionMeasurement.batch.GroupedPredictionsNerPrediction
> = core.serialization.object({
    id: core.serialization.string(),
    predictions: core.serialization.list(NerPrediction),
});

export declare namespace GroupedPredictionsNerPrediction {
    export interface Raw {
        id: string;
        predictions: NerPrediction.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsProsodyPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ProsodyPrediction } from "./ProsodyPrediction.js";

export const GroupedPredictionsProsodyPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.GroupedPredictionsProsodyPrediction.Raw,
    Hume.expressionMeasurement.batch.GroupedPredictionsProsodyPrediction
> = core.serialization.object({
    id: core.serialization.string(),
    predictions: core.serialization.list(ProsodyPrediction),
});

export declare namespace GroupedPredictionsProsodyPrediction {
    export interface Raw {
        id: string;
        predictions: ProsodyPrediction.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/InProgress.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const InProgress: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InProgress.Raw,
    Hume.expressionMeasurement.batch.InProgress
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
    startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
});

export declare namespace InProgress {
    export interface Raw {
        created_timestamp_ms: number;
        started_timestamp_ms: number;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/InProgressState.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InProgress } from "./InProgress.js";

export const InProgressState: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InProgressState.Raw,
    Hume.expressionMeasurement.batch.InProgressState
> = core.serialization.object({}).extend(InProgress);

export declare namespace InProgressState {
    export interface Raw extends InProgress.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceBaseRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Models } from "./Models.js";
import { Transcription } from "./Transcription.js";

export const InferenceBaseRequest: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InferenceBaseRequest.Raw,
    Hume.expressionMeasurement.batch.InferenceBaseRequest
> = core.serialization.object({
    models: Models.optional(),
    transcription: Transcription.optional(),
    urls: core.serialization.list(core.serialization.string()).optional(),
    text: core.serialization.list(core.serialization.string()).optional(),
    callbackUrl: core.serialization.property("callback_url", core.serialization.string().optional()),
    notify: core.serialization.boolean().optional(),
});

export declare namespace InferenceBaseRequest {
    export interface Raw {
        models?: Models.Raw | null;
        transcription?: Transcription.Raw | null;
        urls?: string[] | null;
        text?: string[] | null;
        callback_url?: string | null;
        notify?: boolean | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceJob.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { JobInference } from "./JobInference.js";

export const InferenceJob: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InferenceJob.Raw,
    Hume.expressionMeasurement.batch.InferenceJob
> = core.serialization
    .object({
        type: core.serialization.string(),
    })
    .extend(JobInference);

export declare namespace InferenceJob {
    export interface Raw extends JobInference.Raw {
        type: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/InferencePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ModelsPredictions } from "./ModelsPredictions.js";

export const InferencePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InferencePrediction.Raw,
    Hume.expressionMeasurement.batch.InferencePrediction
> = core.serialization.object({
    file: core.serialization.string(),
    models: ModelsPredictions,
});

export declare namespace InferencePrediction {
    export interface Raw {
        file: string;
        models: ModelsPredictions.Raw;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { File_ } from "./File_.js";
import { Models } from "./Models.js";
import { Transcription } from "./Transcription.js";

export const InferenceRequest: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InferenceRequest.Raw,
    Hume.expressionMeasurement.batch.InferenceRequest
> = core.serialization.object({
    models: Models.optional(),
    transcription: Transcription.optional(),
    urls: core.serialization.list(core.serialization.string()).optional(),
    text: core.serialization.list(core.serialization.string()).optional(),
    callbackUrl: core.serialization.property("callback_url", core.serialization.string().optional()),
    notify: core.serialization.boolean().optional(),
    files: core.serialization.list(File_),
});

export declare namespace InferenceRequest {
    export interface Raw {
        models?: Models.Raw | null;
        transcription?: Transcription.Raw | null;
        urls?: string[] | null;
        text?: string[] | null;
        callback_url?: string | null;
        notify?: boolean | null;
        files: File_.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceResults.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Error_ } from "./Error_.js";
import { InferencePrediction } from "./InferencePrediction.js";

export const InferenceResults: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InferenceResults.Raw,
    Hume.expressionMeasurement.batch.InferenceResults
> = core.serialization.object({
    predictions: core.serialization.list(InferencePrediction),
    errors: core.serialization.list(Error_),
});

export declare namespace InferenceResults {
    export interface Raw {
        predictions: InferencePrediction.Raw[];
        errors: Error_.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceSourcePredictResult.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InferenceResults } from "./InferenceResults.js";
import { Source } from "./Source.js";

export const InferenceSourcePredictResult: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.InferenceSourcePredictResult.Raw,
    Hume.expressionMeasurement.batch.InferenceSourcePredictResult
> = core.serialization.object({
    source: Source,
    results: InferenceResults.optional(),
    error: core.serialization.string().optional(),
});

export declare namespace InferenceSourcePredictResult {
    export interface Raw {
        source: Source.Raw;
        results?: InferenceResults.Raw | null;
        error?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/JobEmbeddingGeneration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { EmbeddingGenerationBaseRequest } from "./EmbeddingGenerationBaseRequest.js";
import { StateEmbeddingGeneration } from "./StateEmbeddingGeneration.js";

export const JobEmbeddingGeneration: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.JobEmbeddingGeneration.Raw,
    Hume.expressionMeasurement.batch.JobEmbeddingGeneration
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string()),
    userId: core.serialization.property("user_id", core.serialization.string()),
    request: EmbeddingGenerationBaseRequest,
    state: StateEmbeddingGeneration,
});

export declare namespace JobEmbeddingGeneration {
    export interface Raw {
        job_id: string;
        user_id: string;
        request: EmbeddingGenerationBaseRequest.Raw;
        state: StateEmbeddingGeneration.Raw;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/JobId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const JobId: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.JobId.Raw,
    Hume.expressionMeasurement.batch.JobId
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string()),
});

export declare namespace JobId {
    export interface Raw {
        job_id: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/JobInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InferenceRequest } from "./InferenceRequest.js";
import { StateInference } from "./StateInference.js";

export const JobInference: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.JobInference.Raw,
    Hume.expressionMeasurement.batch.JobInference
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string()),
    request: InferenceRequest,
    state: StateInference,
});

export declare namespace JobInference {
    export interface Raw {
        job_id: string;
        request: InferenceRequest.Raw;
        state: StateInference.Raw;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/JobTlInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { StateTlInference } from "./StateTlInference.js";
import { TlInferenceBaseRequest } from "./TlInferenceBaseRequest.js";

export const JobTlInference: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.JobTlInference.Raw,
    Hume.expressionMeasurement.batch.JobTlInference
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string()),
    userId: core.serialization.property("user_id", core.serialization.string()),
    request: TlInferenceBaseRequest,
    state: StateTlInference,
});

export declare namespace JobTlInference {
    export interface Raw {
        job_id: string;
        user_id: string;
        request: TlInferenceBaseRequest.Raw;
        state: StateTlInference.Raw;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/JobTraining.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { StateTraining } from "./StateTraining.js";
import { TrainingBaseRequest } from "./TrainingBaseRequest.js";

export const JobTraining: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.JobTraining.Raw,
    Hume.expressionMeasurement.batch.JobTraining
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string()),
    userId: core.serialization.property("user_id", core.serialization.string()),
    request: TrainingBaseRequest,
    state: StateTraining,
});

export declare namespace JobTraining {
    export interface Raw {
        job_id: string;
        user_id: string;
        request: TrainingBaseRequest.Raw;
        state: StateTraining.Raw;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Language.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Granularity } from "./Granularity.js";
import { Unconfigurable } from "./Unconfigurable.js";

export const Language: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Language.Raw,
    Hume.expressionMeasurement.batch.Language
> = core.serialization.object({
    granularity: Granularity.optional(),
    sentiment: Unconfigurable.optional(),
    toxicity: Unconfigurable.optional(),
    identifySpeakers: core.serialization.property("identify_speakers", core.serialization.boolean().optional()),
});

export declare namespace Language {
    export interface Raw {
        granularity?: Granularity.Raw | null;
        sentiment?: Unconfigurable.Raw | null;
        toxicity?: Unconfigurable.Raw | null;
        identify_speakers?: boolean | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/LanguagePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { EmotionScore } from "./EmotionScore.js";
import { PositionInterval } from "./PositionInterval.js";
import { SentimentScore } from "./SentimentScore.js";
import { TimeInterval } from "./TimeInterval.js";
import { ToxicityScore } from "./ToxicityScore.js";

export const LanguagePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.LanguagePrediction.Raw,
    Hume.expressionMeasurement.batch.LanguagePrediction
> = core.serialization.object({
    text: core.serialization.string(),
    position: PositionInterval,
    time: TimeInterval.optional(),
    confidence: core.serialization.number().optional(),
    speakerConfidence: core.serialization.property("speaker_confidence", core.serialization.number().optional()),
    emotions: core.serialization.list(EmotionScore),
    sentiment: core.serialization.list(SentimentScore).optional(),
    toxicity: core.serialization.list(ToxicityScore).optional(),
});

export declare namespace LanguagePrediction {
    export interface Raw {
        text: string;
        position: PositionInterval.Raw;
        time?: TimeInterval.Raw | null;
        confidence?: number | null;
        speaker_confidence?: number | null;
        emotions: EmotionScore.Raw[];
        sentiment?: SentimentScore.Raw[] | null;
        toxicity?: ToxicityScore.Raw[] | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Models.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Face } from "./Face.js";
import { Language } from "./Language.js";
import { Ner } from "./Ner.js";
import { Prosody } from "./Prosody.js";
import { Unconfigurable } from "./Unconfigurable.js";

export const Models: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Models.Raw,
    Hume.expressionMeasurement.batch.Models
> = core.serialization.object({
    face: Face.optional(),
    burst: Unconfigurable.optional(),
    prosody: Prosody.optional(),
    language: Language.optional(),
    ner: Ner.optional(),
    facemesh: Unconfigurable.optional(),
});

export declare namespace Models {
    export interface Raw {
        face?: Face.Raw | null;
        burst?: Unconfigurable.Raw | null;
        prosody?: Prosody.Raw | null;
        language?: Language.Raw | null;
        ner?: Ner.Raw | null;
        facemesh?: Unconfigurable.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/ModelsPredictions.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { PredictionsOptionalNullBurstPrediction } from "./PredictionsOptionalNullBurstPrediction.js";
import { PredictionsOptionalNullFacemeshPrediction } from "./PredictionsOptionalNullFacemeshPrediction.js";
import { PredictionsOptionalNullFacePrediction } from "./PredictionsOptionalNullFacePrediction.js";
import { PredictionsOptionalTranscriptionMetadataLanguagePrediction } from "./PredictionsOptionalTranscriptionMetadataLanguagePrediction.js";
import { PredictionsOptionalTranscriptionMetadataNerPrediction } from "./PredictionsOptionalTranscriptionMetadataNerPrediction.js";
import { PredictionsOptionalTranscriptionMetadataProsodyPrediction } from "./PredictionsOptionalTranscriptionMetadataProsodyPrediction.js";

export const ModelsPredictions: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.ModelsPredictions.Raw,
    Hume.expressionMeasurement.batch.ModelsPredictions
> = core.serialization.object({
    face: PredictionsOptionalNullFacePrediction.optional(),
    burst: PredictionsOptionalNullBurstPrediction.optional(),
    prosody: PredictionsOptionalTranscriptionMetadataProsodyPrediction.optional(),
    language: PredictionsOptionalTranscriptionMetadataLanguagePrediction.optional(),
    ner: PredictionsOptionalTranscriptionMetadataNerPrediction.optional(),
    facemesh: PredictionsOptionalNullFacemeshPrediction.optional(),
});

export declare namespace ModelsPredictions {
    export interface Raw {
        face?: PredictionsOptionalNullFacePrediction.Raw | null;
        burst?: PredictionsOptionalNullBurstPrediction.Raw | null;
        prosody?: PredictionsOptionalTranscriptionMetadataProsodyPrediction.Raw | null;
        language?: PredictionsOptionalTranscriptionMetadataLanguagePrediction.Raw | null;
        ner?: PredictionsOptionalTranscriptionMetadataNerPrediction.Raw | null;
        facemesh?: PredictionsOptionalNullFacemeshPrediction.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Ner.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Ner: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Ner.Raw,
    Hume.expressionMeasurement.batch.Ner
> = core.serialization.object({
    identifySpeakers: core.serialization.property("identify_speakers", core.serialization.boolean().optional()),
});

export declare namespace Ner {
    export interface Raw {
        identify_speakers?: boolean | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/NerPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { EmotionScore } from "./EmotionScore.js";
import { PositionInterval } from "./PositionInterval.js";
import { TimeInterval } from "./TimeInterval.js";

export const NerPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.NerPrediction.Raw,
    Hume.expressionMeasurement.batch.NerPrediction
> = core.serialization.object({
    entity: core.serialization.string(),
    position: PositionInterval,
    entityConfidence: core.serialization.property("entity_confidence", core.serialization.number()),
    support: core.serialization.number(),
    uri: core.serialization.string(),
    linkWord: core.serialization.property("link_word", core.serialization.string()),
    time: TimeInterval.optional(),
    confidence: core.serialization.number().optional(),
    speakerConfidence: core.serialization.property("speaker_confidence", core.serialization.number().optional()),
    emotions: core.serialization.list(EmotionScore),
});

export declare namespace NerPrediction {
    export interface Raw {
        entity: string;
        position: PositionInterval.Raw;
        entity_confidence: number;
        support: number;
        uri: string;
        link_word: string;
        time?: TimeInterval.Raw | null;
        confidence?: number | null;
        speaker_confidence?: number | null;
        emotions: EmotionScore.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Null.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Null: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Null.Raw,
    Hume.expressionMeasurement.batch.Null
> = core.serialization.record(core.serialization.string(), core.serialization.unknown());

export declare namespace Null {
    export type Raw = Record<string, unknown>;
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/PositionInterval.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const PositionInterval: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PositionInterval.Raw,
    Hume.expressionMeasurement.batch.PositionInterval
> = core.serialization.object({
    begin: core.serialization.number(),
    end: core.serialization.number(),
});

export declare namespace PositionInterval {
    export interface Raw {
        begin: number;
        end: number;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullBurstPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { GroupedPredictionsBurstPrediction } from "./GroupedPredictionsBurstPrediction.js";
import { Null } from "./Null.js";

export const PredictionsOptionalNullBurstPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PredictionsOptionalNullBurstPrediction.Raw,
    Hume.expressionMeasurement.batch.PredictionsOptionalNullBurstPrediction
> = core.serialization.object({
    metadata: Null.optional(),
    groupedPredictions: core.serialization.property(
        "grouped_predictions",
        core.serialization.list(GroupedPredictionsBurstPrediction),
    ),
});

export declare namespace PredictionsOptionalNullBurstPrediction {
    export interface Raw {
        metadata?: Null.Raw | null;
        grouped_predictions: GroupedPredictionsBurstPrediction.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullFacePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { GroupedPredictionsFacePrediction } from "./GroupedPredictionsFacePrediction.js";
import { Null } from "./Null.js";

export const PredictionsOptionalNullFacePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PredictionsOptionalNullFacePrediction.Raw,
    Hume.expressionMeasurement.batch.PredictionsOptionalNullFacePrediction
> = core.serialization.object({
    metadata: Null.optional(),
    groupedPredictions: core.serialization.property(
        "grouped_predictions",
        core.serialization.list(GroupedPredictionsFacePrediction),
    ),
});

export declare namespace PredictionsOptionalNullFacePrediction {
    export interface Raw {
        metadata?: Null.Raw | null;
        grouped_predictions: GroupedPredictionsFacePrediction.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullFacemeshPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { GroupedPredictionsFacemeshPrediction } from "./GroupedPredictionsFacemeshPrediction.js";
import { Null } from "./Null.js";

export const PredictionsOptionalNullFacemeshPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PredictionsOptionalNullFacemeshPrediction.Raw,
    Hume.expressionMeasurement.batch.PredictionsOptionalNullFacemeshPrediction
> = core.serialization.object({
    metadata: Null.optional(),
    groupedPredictions: core.serialization.property(
        "grouped_predictions",
        core.serialization.list(GroupedPredictionsFacemeshPrediction),
    ),
});

export declare namespace PredictionsOptionalNullFacemeshPrediction {
    export interface Raw {
        metadata?: Null.Raw | null;
        grouped_predictions: GroupedPredictionsFacemeshPrediction.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataLanguagePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { GroupedPredictionsLanguagePrediction } from "./GroupedPredictionsLanguagePrediction.js";
import { TranscriptionMetadata } from "./TranscriptionMetadata.js";

export const PredictionsOptionalTranscriptionMetadataLanguagePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataLanguagePrediction.Raw,
    Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataLanguagePrediction
> = core.serialization.object({
    metadata: TranscriptionMetadata.optional(),
    groupedPredictions: core.serialization.property(
        "grouped_predictions",
        core.serialization.list(GroupedPredictionsLanguagePrediction),
    ),
});

export declare namespace PredictionsOptionalTranscriptionMetadataLanguagePrediction {
    export interface Raw {
        metadata?: TranscriptionMetadata.Raw | null;
        grouped_predictions: GroupedPredictionsLanguagePrediction.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataNerPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { GroupedPredictionsNerPrediction } from "./GroupedPredictionsNerPrediction.js";
import { TranscriptionMetadata } from "./TranscriptionMetadata.js";

export const PredictionsOptionalTranscriptionMetadataNerPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataNerPrediction.Raw,
    Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataNerPrediction
> = core.serialization.object({
    metadata: TranscriptionMetadata.optional(),
    groupedPredictions: core.serialization.property(
        "grouped_predictions",
        core.serialization.list(GroupedPredictionsNerPrediction),
    ),
});

export declare namespace PredictionsOptionalTranscriptionMetadataNerPrediction {
    export interface Raw {
        metadata?: TranscriptionMetadata.Raw | null;
        grouped_predictions: GroupedPredictionsNerPrediction.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataProsodyPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { GroupedPredictionsProsodyPrediction } from "./GroupedPredictionsProsodyPrediction.js";
import { TranscriptionMetadata } from "./TranscriptionMetadata.js";

export const PredictionsOptionalTranscriptionMetadataProsodyPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataProsodyPrediction.Raw,
    Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataProsodyPrediction
> = core.serialization.object({
    metadata: TranscriptionMetadata.optional(),
    groupedPredictions: core.serialization.property(
        "grouped_predictions",
        core.serialization.list(GroupedPredictionsProsodyPrediction),
    ),
});

export declare namespace PredictionsOptionalTranscriptionMetadataProsodyPrediction {
    export interface Raw {
        metadata?: TranscriptionMetadata.Raw | null;
        grouped_predictions: GroupedPredictionsProsodyPrediction.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Prosody.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Granularity } from "./Granularity.js";
import { Window } from "./Window.js";

export const Prosody: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Prosody.Raw,
    Hume.expressionMeasurement.batch.Prosody
> = core.serialization.object({
    granularity: Granularity.optional(),
    window: Window.optional(),
    identifySpeakers: core.serialization.property("identify_speakers", core.serialization.boolean().optional()),
});

export declare namespace Prosody {
    export interface Raw {
        granularity?: Granularity.Raw | null;
        window?: Window.Raw | null;
        identify_speakers?: boolean | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/ProsodyPrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { EmotionScore } from "./EmotionScore.js";
import { TimeInterval } from "./TimeInterval.js";

export const ProsodyPrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.ProsodyPrediction.Raw,
    Hume.expressionMeasurement.batch.ProsodyPrediction
> = core.serialization.object({
    text: core.serialization.string().optional(),
    time: TimeInterval,
    confidence: core.serialization.number().optional(),
    speakerConfidence: core.serialization.property("speaker_confidence", core.serialization.number().optional()),
    emotions: core.serialization.list(EmotionScore),
});

export declare namespace ProsodyPrediction {
    export interface Raw {
        text?: string | null;
        time: TimeInterval.Raw;
        confidence?: number | null;
        speaker_confidence?: number | null;
        emotions: EmotionScore.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Queued.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Queued: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Queued.Raw,
    Hume.expressionMeasurement.batch.Queued
> = core.serialization.object({
    createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
});

export declare namespace Queued {
    export interface Raw {
        created_timestamp_ms: number;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/QueuedState.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Queued } from "./Queued.js";

export const QueuedState: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.QueuedState.Raw,
    Hume.expressionMeasurement.batch.QueuedState
> = core.serialization.object({}).extend(Queued);

export declare namespace QueuedState {
    export interface Raw extends Queued.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/RegistryFileDetail.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const RegistryFileDetail: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.RegistryFileDetail.Raw,
    Hume.expressionMeasurement.batch.RegistryFileDetail
> = core.serialization.object({
    fileId: core.serialization.property("file_id", core.serialization.string()),
    fileUrl: core.serialization.property("file_url", core.serialization.string()),
});

export declare namespace RegistryFileDetail {
    export interface Raw {
        file_id: string;
        file_url: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Regression.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Regression: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Regression.Raw,
    Hume.expressionMeasurement.batch.Regression
> = core.serialization.record(core.serialization.string(), core.serialization.unknown());

export declare namespace Regression {
    export type Raw = Record<string, unknown>;
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/SortBy.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const SortBy: core.serialization.Schema<
    serializers.expressionMeasurement.batch.SortBy.Raw,
    Hume.expressionMeasurement.batch.SortBy
> = core.serialization.enum_(["created", "started", "ended"]);

export declare namespace SortBy {
    export type Raw = "created" | "started" | "ended";
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Source.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { SourceFile } from "./SourceFile.js";
import { SourceTextSource } from "./SourceTextSource.js";
import { SourceUrl } from "./SourceUrl.js";

export const Source: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Source.Raw,
    Hume.expressionMeasurement.batch.Source
> = core.serialization
    .union("type", {
        url: SourceUrl,
        file: SourceFile,
        text: SourceTextSource,
    })
    .transform<Hume.expressionMeasurement.batch.Source>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace Source {
    export type Raw = Source.Url | Source.File | Source.Text;

    export interface Url extends SourceUrl.Raw {
        type: "url";
    }

    export interface File extends SourceFile.Raw {
        type: "file";
    }

    export interface Text extends SourceTextSource.Raw {
        type: "text";
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/SourceFile.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { File_ } from "./File_.js";

export const SourceFile: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.SourceFile.Raw,
    Hume.expressionMeasurement.batch.SourceFile
> = core.serialization.object({}).extend(File_);

export declare namespace SourceFile {
    export interface Raw extends File_.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/SourceTextSource.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const SourceTextSource: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.SourceTextSource.Raw,
    Hume.expressionMeasurement.batch.SourceTextSource
> = core.serialization.object({});

export declare namespace SourceTextSource {
    export type Raw = {};
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/SourceUrl.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Url } from "./Url.js";

export const SourceUrl: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.SourceUrl.Raw,
    Hume.expressionMeasurement.batch.SourceUrl
> = core.serialization.object({}).extend(Url);

export declare namespace SourceUrl {
    export interface Raw extends Url.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGeneration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { StateEmbeddingGenerationCompletedEmbeddingGeneration } from "./StateEmbeddingGenerationCompletedEmbeddingGeneration.js";
import { StateEmbeddingGenerationFailed } from "./StateEmbeddingGenerationFailed.js";
import { StateEmbeddingGenerationInProgress } from "./StateEmbeddingGenerationInProgress.js";
import { StateEmbeddingGenerationQueued } from "./StateEmbeddingGenerationQueued.js";

export const StateEmbeddingGeneration: core.serialization.Schema<
    serializers.expressionMeasurement.batch.StateEmbeddingGeneration.Raw,
    Hume.expressionMeasurement.batch.StateEmbeddingGeneration
> = core.serialization
    .union("status", {
        QUEUED: StateEmbeddingGenerationQueued,
        IN_PROGRESS: StateEmbeddingGenerationInProgress,
        COMPLETED: StateEmbeddingGenerationCompletedEmbeddingGeneration,
        FAILED: StateEmbeddingGenerationFailed,
    })
    .transform<Hume.expressionMeasurement.batch.StateEmbeddingGeneration>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace StateEmbeddingGeneration {
    export type Raw =
        | StateEmbeddingGeneration.Queued
        | StateEmbeddingGeneration.InProgress
        | StateEmbeddingGeneration.Completed
        | StateEmbeddingGeneration.Failed;

    export interface Queued extends StateEmbeddingGenerationQueued.Raw {
        status: "QUEUED";
    }

    export interface InProgress extends StateEmbeddingGenerationInProgress.Raw {
        status: "IN_PROGRESS";
    }

    export interface Completed extends StateEmbeddingGenerationCompletedEmbeddingGeneration.Raw {
        status: "COMPLETED";
    }

    export interface Failed extends StateEmbeddingGenerationFailed.Raw {
        status: "FAILED";
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationCompletedEmbeddingGeneration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CompletedEmbeddingGeneration } from "./CompletedEmbeddingGeneration.js";

export const StateEmbeddingGenerationCompletedEmbeddingGeneration: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateEmbeddingGenerationCompletedEmbeddingGeneration.Raw,
    Hume.expressionMeasurement.batch.StateEmbeddingGenerationCompletedEmbeddingGeneration
> = core.serialization.object({}).extend(CompletedEmbeddingGeneration);

export declare namespace StateEmbeddingGenerationCompletedEmbeddingGeneration {
    export interface Raw extends CompletedEmbeddingGeneration.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationFailed.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Failed } from "./Failed.js";

export const StateEmbeddingGenerationFailed: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateEmbeddingGenerationFailed.Raw,
    Hume.expressionMeasurement.batch.StateEmbeddingGenerationFailed
> = core.serialization.object({}).extend(Failed);

export declare namespace StateEmbeddingGenerationFailed {
    export interface Raw extends Failed.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationInProgress.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InProgress } from "./InProgress.js";

export const StateEmbeddingGenerationInProgress: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateEmbeddingGenerationInProgress.Raw,
    Hume.expressionMeasurement.batch.StateEmbeddingGenerationInProgress
> = core.serialization.object({}).extend(InProgress);

export declare namespace StateEmbeddingGenerationInProgress {
    export interface Raw extends InProgress.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationQueued.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Queued } from "./Queued.js";

export const StateEmbeddingGenerationQueued: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateEmbeddingGenerationQueued.Raw,
    Hume.expressionMeasurement.batch.StateEmbeddingGenerationQueued
> = core.serialization.object({}).extend(Queued);

export declare namespace StateEmbeddingGenerationQueued {
    export interface Raw extends Queued.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CompletedState } from "./CompletedState.js";
import { FailedState } from "./FailedState.js";
import { InProgressState } from "./InProgressState.js";
import { QueuedState } from "./QueuedState.js";

export const StateInference: core.serialization.Schema<
    serializers.expressionMeasurement.batch.StateInference.Raw,
    Hume.expressionMeasurement.batch.StateInference
> = core.serialization
    .union("status", {
        QUEUED: QueuedState,
        IN_PROGRESS: InProgressState,
        COMPLETED: CompletedState,
        FAILED: FailedState,
    })
    .transform<Hume.expressionMeasurement.batch.StateInference>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace StateInference {
    export type Raw =
        | StateInference.Queued
        | StateInference.InProgress
        | StateInference.Completed
        | StateInference.Failed;

    export interface Queued extends QueuedState.Raw {
        status: "QUEUED";
    }

    export interface InProgress extends InProgressState.Raw {
        status: "IN_PROGRESS";
    }

    export interface Completed extends CompletedState.Raw {
        status: "COMPLETED";
    }

    export interface Failed extends FailedState.Raw {
        status: "FAILED";
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { StateTlInferenceCompletedTlInference } from "./StateTlInferenceCompletedTlInference.js";
import { StateTlInferenceFailed } from "./StateTlInferenceFailed.js";
import { StateTlInferenceInProgress } from "./StateTlInferenceInProgress.js";
import { StateTlInferenceQueued } from "./StateTlInferenceQueued.js";

export const StateTlInference: core.serialization.Schema<
    serializers.expressionMeasurement.batch.StateTlInference.Raw,
    Hume.expressionMeasurement.batch.StateTlInference
> = core.serialization
    .union("status", {
        QUEUED: StateTlInferenceQueued,
        IN_PROGRESS: StateTlInferenceInProgress,
        COMPLETED: StateTlInferenceCompletedTlInference,
        FAILED: StateTlInferenceFailed,
    })
    .transform<Hume.expressionMeasurement.batch.StateTlInference>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace StateTlInference {
    export type Raw =
        | StateTlInference.Queued
        | StateTlInference.InProgress
        | StateTlInference.Completed
        | StateTlInference.Failed;

    export interface Queued extends StateTlInferenceQueued.Raw {
        status: "QUEUED";
    }

    export interface InProgress extends StateTlInferenceInProgress.Raw {
        status: "IN_PROGRESS";
    }

    export interface Completed extends StateTlInferenceCompletedTlInference.Raw {
        status: "COMPLETED";
    }

    export interface Failed extends StateTlInferenceFailed.Raw {
        status: "FAILED";
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInferenceCompletedTlInference.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CompletedTlInference } from "./CompletedTlInference.js";

export const StateTlInferenceCompletedTlInference: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTlInferenceCompletedTlInference.Raw,
    Hume.expressionMeasurement.batch.StateTlInferenceCompletedTlInference
> = core.serialization.object({}).extend(CompletedTlInference);

export declare namespace StateTlInferenceCompletedTlInference {
    export interface Raw extends CompletedTlInference.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInferenceFailed.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Failed } from "./Failed.js";

export const StateTlInferenceFailed: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTlInferenceFailed.Raw,
    Hume.expressionMeasurement.batch.StateTlInferenceFailed
> = core.serialization.object({}).extend(Failed);

export declare namespace StateTlInferenceFailed {
    export interface Raw extends Failed.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInferenceInProgress.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InProgress } from "./InProgress.js";

export const StateTlInferenceInProgress: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTlInferenceInProgress.Raw,
    Hume.expressionMeasurement.batch.StateTlInferenceInProgress
> = core.serialization.object({}).extend(InProgress);

export declare namespace StateTlInferenceInProgress {
    export interface Raw extends InProgress.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInferenceQueued.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Queued } from "./Queued.js";

export const StateTlInferenceQueued: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTlInferenceQueued.Raw,
    Hume.expressionMeasurement.batch.StateTlInferenceQueued
> = core.serialization.object({}).extend(Queued);

export declare namespace StateTlInferenceQueued {
    export interface Raw extends Queued.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTraining.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { StateTrainingCompletedTraining } from "./StateTrainingCompletedTraining.js";
import { StateTrainingFailed } from "./StateTrainingFailed.js";
import { StateTrainingInProgress } from "./StateTrainingInProgress.js";
import { StateTrainingQueued } from "./StateTrainingQueued.js";

export const StateTraining: core.serialization.Schema<
    serializers.expressionMeasurement.batch.StateTraining.Raw,
    Hume.expressionMeasurement.batch.StateTraining
> = core.serialization
    .union("status", {
        QUEUED: StateTrainingQueued,
        IN_PROGRESS: StateTrainingInProgress,
        COMPLETED: StateTrainingCompletedTraining,
        FAILED: StateTrainingFailed,
    })
    .transform<Hume.expressionMeasurement.batch.StateTraining>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace StateTraining {
    export type Raw = StateTraining.Queued | StateTraining.InProgress | StateTraining.Completed | StateTraining.Failed;

    export interface Queued extends StateTrainingQueued.Raw {
        status: "QUEUED";
    }

    export interface InProgress extends StateTrainingInProgress.Raw {
        status: "IN_PROGRESS";
    }

    export interface Completed extends StateTrainingCompletedTraining.Raw {
        status: "COMPLETED";
    }

    export interface Failed extends StateTrainingFailed.Raw {
        status: "FAILED";
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTrainingCompletedTraining.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CompletedTraining } from "./CompletedTraining.js";

export const StateTrainingCompletedTraining: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTrainingCompletedTraining.Raw,
    Hume.expressionMeasurement.batch.StateTrainingCompletedTraining
> = core.serialization.object({}).extend(CompletedTraining);

export declare namespace StateTrainingCompletedTraining {
    export interface Raw extends CompletedTraining.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTrainingFailed.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Failed } from "./Failed.js";

export const StateTrainingFailed: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTrainingFailed.Raw,
    Hume.expressionMeasurement.batch.StateTrainingFailed
> = core.serialization.object({}).extend(Failed);

export declare namespace StateTrainingFailed {
    export interface Raw extends Failed.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTrainingInProgress.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InProgress } from "./InProgress.js";

export const StateTrainingInProgress: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTrainingInProgress.Raw,
    Hume.expressionMeasurement.batch.StateTrainingInProgress
> = core.serialization.object({}).extend(InProgress);

export declare namespace StateTrainingInProgress {
    export interface Raw extends InProgress.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTrainingQueued.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Queued } from "./Queued.js";

export const StateTrainingQueued: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.StateTrainingQueued.Raw,
    Hume.expressionMeasurement.batch.StateTrainingQueued
> = core.serialization.object({}).extend(Queued);

export declare namespace StateTrainingQueued {
    export interface Raw extends Queued.Raw {}
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Status.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Status: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Status.Raw,
    Hume.expressionMeasurement.batch.Status
> = core.serialization.enum_(["QUEUED", "IN_PROGRESS", "COMPLETED", "FAILED"]);

export declare namespace Status {
    export type Raw = "QUEUED" | "IN_PROGRESS" | "COMPLETED" | "FAILED";
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Tag.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Tag: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Tag.Raw,
    Hume.expressionMeasurement.batch.Tag
> = core.serialization.object({
    key: core.serialization.string(),
    value: core.serialization.string(),
});

export declare namespace Tag {
    export interface Raw {
        key: string;
        value: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Target.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Target: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Target.Raw,
    Hume.expressionMeasurement.batch.Target
> = core.serialization.undiscriminatedUnion([
    core.serialization.number(),
    core.serialization.number(),
    core.serialization.string(),
]);

export declare namespace Target {
    export type Raw = number | number | string;
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Task.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { TaskClassification } from "./TaskClassification.js";
import { TaskRegression } from "./TaskRegression.js";

export const Task: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Task.Raw,
    Hume.expressionMeasurement.batch.Task
> = core.serialization
    .union("type", {
        classification: TaskClassification,
        regression: TaskRegression,
    })
    .transform<Hume.expressionMeasurement.batch.Task>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace Task {
    export type Raw = Task.Classification | Task.Regression;

    export interface Classification extends TaskClassification.Raw {
        type: "classification";
    }

    export interface Regression extends TaskRegression.Raw {
        type: "regression";
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/TaskClassification.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TaskClassification: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TaskClassification.Raw,
    Hume.expressionMeasurement.batch.TaskClassification
> = core.serialization.object({});

export declare namespace TaskClassification {
    export type Raw = {};
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/TaskRegression.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TaskRegression: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TaskRegression.Raw,
    Hume.expressionMeasurement.batch.TaskRegression
> = core.serialization.object({});

export declare namespace TaskRegression {
    export type Raw = {};
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/TextSource.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TextSource: core.serialization.Schema<
    serializers.expressionMeasurement.batch.TextSource.Raw,
    Hume.expressionMeasurement.batch.TextSource
> = core.serialization.record(core.serialization.string(), core.serialization.unknown());

export declare namespace TextSource {
    export type Raw = Record<string, unknown>;
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/TimeInterval.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TimeInterval: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TimeInterval.Raw,
    Hume.expressionMeasurement.batch.TimeInterval
> = core.serialization.object({
    begin: core.serialization.number(),
    end: core.serialization.number(),
});

export declare namespace TimeInterval {
    export interface Raw {
        begin: number;
        end: number;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/TlInferenceBaseRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CustomModel } from "./CustomModel.js";

export const TlInferenceBaseRequest: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TlInferenceBaseRequest.Raw,
    Hume.expressionMeasurement.batch.TlInferenceBaseRequest
> = core.serialization.object({
    customModel: core.serialization.property("custom_model", CustomModel),
    urls: core.serialization.list(core.serialization.string()).optional(),
    callbackUrl: core.serialization.property("callback_url", core.serialization.string().optional()),
    notify: core.serialization.boolean().optional(),
});

export declare namespace TlInferenceBaseRequest {
    export interface Raw {
        custom_model: CustomModel.Raw;
        urls?: string[] | null;
        callback_url?: string | null;
        notify?: boolean | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/TlInferencePrediction.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { CustomModelPrediction } from "./CustomModelPrediction.js";

export const TlInferencePrediction: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TlInferencePrediction.Raw,
    Hume.expressionMeasurement.batch.TlInferencePrediction
> = core.serialization.object({
    file: core.serialization.string(),
    fileType: core.serialization.property("file_type", core.serialization.string()),
    customModels: core.serialization.property(
        "custom_models",
        core.serialization.record(core.serialization.string(), CustomModelPrediction),
    ),
});

export declare namespace TlInferencePrediction {
    export interface Raw {
        file: string;
        file_type: string;
        custom_models: Record<string, CustomModelPrediction.Raw>;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/TlInferenceResults.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Error_ } from "./Error_.js";
import { TlInferencePrediction } from "./TlInferencePrediction.js";

export const TlInferenceResults: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TlInferenceResults.Raw,
    Hume.expressionMeasurement.batch.TlInferenceResults
> = core.serialization.object({
    predictions: core.serialization.list(TlInferencePrediction),
    errors: core.serialization.list(Error_),
});

export declare namespace TlInferenceResults {
    export interface Raw {
        predictions: TlInferencePrediction.Raw[];
        errors: Error_.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/TlInferenceSourcePredictResult.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Source } from "./Source.js";
import { TlInferenceResults } from "./TlInferenceResults.js";

export const TlInferenceSourcePredictResult: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TlInferenceSourcePredictResult.Raw,
    Hume.expressionMeasurement.batch.TlInferenceSourcePredictResult
> = core.serialization.object({
    source: Source,
    results: TlInferenceResults.optional(),
    error: core.serialization.string().optional(),
});

export declare namespace TlInferenceSourcePredictResult {
    export interface Raw {
        source: Source.Raw;
        results?: TlInferenceResults.Raw | null;
        error?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/TrainingBaseRequest.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Alternative } from "./Alternative.js";
import { CustomModelRequest } from "./CustomModelRequest.js";
import { Dataset } from "./Dataset.js";
import { EvaluationArgs } from "./EvaluationArgs.js";
import { Task } from "./Task.js";

export const TrainingBaseRequest: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TrainingBaseRequest.Raw,
    Hume.expressionMeasurement.batch.TrainingBaseRequest
> = core.serialization.object({
    customModel: core.serialization.property("custom_model", CustomModelRequest),
    dataset: Dataset,
    targetFeature: core.serialization.property("target_feature", core.serialization.string().optional()),
    task: Task.optional(),
    evaluation: EvaluationArgs.optional(),
    alternatives: core.serialization.list(Alternative).optional(),
    callbackUrl: core.serialization.property("callback_url", core.serialization.string().optional()),
    notify: core.serialization.boolean().optional(),
});

export declare namespace TrainingBaseRequest {
    export interface Raw {
        custom_model: CustomModelRequest.Raw;
        dataset: Dataset.Raw;
        target_feature?: string | null;
        task?: Task.Raw | null;
        evaluation?: EvaluationArgs.Raw | null;
        alternatives?: Alternative.Raw[] | null;
        callback_url?: string | null;
        notify?: boolean | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/TrainingCustomModel.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TrainingCustomModel: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TrainingCustomModel.Raw,
    Hume.expressionMeasurement.batch.TrainingCustomModel
> = core.serialization.object({
    id: core.serialization.string(),
    versionId: core.serialization.property("version_id", core.serialization.string().optional()),
});

export declare namespace TrainingCustomModel {
    export interface Raw {
        id: string;
        version_id?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Transcription.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Bcp47Tag } from "./Bcp47Tag.js";

export const Transcription: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Transcription.Raw,
    Hume.expressionMeasurement.batch.Transcription
> = core.serialization.object({
    language: Bcp47Tag.optional(),
    identifySpeakers: core.serialization.property("identify_speakers", core.serialization.boolean().optional()),
    confidenceThreshold: core.serialization.property("confidence_threshold", core.serialization.number().optional()),
});

export declare namespace Transcription {
    export interface Raw {
        language?: Bcp47Tag.Raw | null;
        identify_speakers?: boolean | null;
        confidence_threshold?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/TranscriptionMetadata.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Bcp47Tag } from "./Bcp47Tag.js";

export const TranscriptionMetadata: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.TranscriptionMetadata.Raw,
    Hume.expressionMeasurement.batch.TranscriptionMetadata
> = core.serialization.object({
    confidence: core.serialization.number(),
    detectedLanguage: core.serialization.property("detected_language", Bcp47Tag.optional()),
});

export declare namespace TranscriptionMetadata {
    export interface Raw {
        confidence: number;
        detected_language?: Bcp47Tag.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Type.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Type: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Type.Raw,
    Hume.expressionMeasurement.batch.Type
> = core.serialization.enum_(["EMBEDDING_GENERATION", "INFERENCE", "TL_INFERENCE", "TRAINING"]);

export declare namespace Type {
    export type Raw = "EMBEDDING_GENERATION" | "INFERENCE" | "TL_INFERENCE" | "TRAINING";
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Unconfigurable.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Unconfigurable: core.serialization.Schema<
    serializers.expressionMeasurement.batch.Unconfigurable.Raw,
    Hume.expressionMeasurement.batch.Unconfigurable
> = core.serialization.record(core.serialization.string(), core.serialization.unknown());

export declare namespace Unconfigurable {
    export type Raw = Record<string, unknown>;
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/UnionJob.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InferenceJob } from "./InferenceJob.js";

export const UnionJob: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.UnionJob.Raw,
    Hume.expressionMeasurement.batch.UnionJob
> = InferenceJob;

export declare namespace UnionJob {
    export type Raw = InferenceJob.Raw;
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/UnionPredictResult.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import type * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { InferenceSourcePredictResult } from "./InferenceSourcePredictResult.js";

export const UnionPredictResult: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.UnionPredictResult.Raw,
    Hume.expressionMeasurement.batch.UnionPredictResult
> = InferenceSourcePredictResult;

export declare namespace UnionPredictResult {
    export type Raw = InferenceSourcePredictResult.Raw;
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Url.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Url: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Url.Raw,
    Hume.expressionMeasurement.batch.Url
> = core.serialization.object({
    url: core.serialization.string(),
});

export declare namespace Url {
    export interface Raw {
        url: string;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/ValidationArgs.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { Target } from "./Target.js";

export const ValidationArgs: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.ValidationArgs.Raw,
    Hume.expressionMeasurement.batch.ValidationArgs
> = core.serialization.object({
    positiveLabel: core.serialization.property("positive_label", Target.optional()),
});

export declare namespace ValidationArgs {
    export interface Raw {
        positive_label?: Target.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/When.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const When: core.serialization.Schema<
    serializers.expressionMeasurement.batch.When.Raw,
    Hume.expressionMeasurement.batch.When
> = core.serialization.enum_(["created_before", "created_after"]);

export declare namespace When {
    export type Raw = "created_before" | "created_after";
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/Window.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const Window: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.batch.Window.Raw,
    Hume.expressionMeasurement.batch.Window
> = core.serialization.object({
    length: core.serialization.number().optional(),
    step: core.serialization.number().optional(),
});

export declare namespace Window {
    export interface Raw {
        length?: number | null;
        step?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/batch/types/index.ts
================================================================================
export * from "./Alternative.js";
export * from "./Bcp47Tag.js";
export * from "./BoundingBox.js";
export * from "./BurstPrediction.js";
export * from "./Classification.js";
export * from "./CompletedEmbeddingGeneration.js";
export * from "./CompletedInference.js";
export * from "./CompletedState.js";
export * from "./CompletedTlInference.js";
export * from "./CompletedTraining.js";
export * from "./CustomModel.js";
export * from "./CustomModelId.js";
export * from "./CustomModelPrediction.js";
export * from "./CustomModelRequest.js";
export * from "./CustomModelsInferenceJob.js";
export * from "./CustomModelsTrainingJob.js";
export * from "./CustomModelVersionId.js";
export * from "./Dataset.js";
export * from "./DatasetId.js";
export * from "./DatasetVersionId.js";
export * from "./DescriptionsScore.js";
export * from "./Direction.js";
export * from "./EmbeddingGenerationBaseRequest.js";
export * from "./EmbeddingGenerationJob.js";
export * from "./EmotionScore.js";
export * from "./Error_.js";
export * from "./EvaluationArgs.js";
export * from "./Face.js";
export * from "./FacemeshPrediction.js";
export * from "./FacePrediction.js";
export * from "./FacsScore.js";
export * from "./Failed.js";
export * from "./FailedState.js";
export * from "./File_.js";
export * from "./Granularity.js";
export * from "./GroupedPredictionsBurstPrediction.js";
export * from "./GroupedPredictionsFacemeshPrediction.js";
export * from "./GroupedPredictionsFacePrediction.js";
export * from "./GroupedPredictionsLanguagePrediction.js";
export * from "./GroupedPredictionsNerPrediction.js";
export * from "./GroupedPredictionsProsodyPrediction.js";
export * from "./InferenceBaseRequest.js";
export * from "./InferenceJob.js";
export * from "./InferencePrediction.js";
export * from "./InferenceRequest.js";
export * from "./InferenceResults.js";
export * from "./InferenceSourcePredictResult.js";
export * from "./InProgress.js";
export * from "./InProgressState.js";
export * from "./JobEmbeddingGeneration.js";
export * from "./JobId.js";
export * from "./JobInference.js";
export * from "./JobTlInference.js";
export * from "./JobTraining.js";
export * from "./Language.js";
export * from "./LanguagePrediction.js";
export * from "./Models.js";
export * from "./ModelsPredictions.js";
export * from "./Ner.js";
export * from "./NerPrediction.js";
export * from "./Null.js";
export * from "./PositionInterval.js";
export * from "./PredictionsOptionalNullBurstPrediction.js";
export * from "./PredictionsOptionalNullFacemeshPrediction.js";
export * from "./PredictionsOptionalNullFacePrediction.js";
export * from "./PredictionsOptionalTranscriptionMetadataLanguagePrediction.js";
export * from "./PredictionsOptionalTranscriptionMetadataNerPrediction.js";
export * from "./PredictionsOptionalTranscriptionMetadataProsodyPrediction.js";
export * from "./Prosody.js";
export * from "./ProsodyPrediction.js";
export * from "./Queued.js";
export * from "./QueuedState.js";
export * from "./RegistryFileDetail.js";
export * from "./Regression.js";
export * from "./SentimentScore.js";
export * from "./SortBy.js";
export * from "./Source.js";
export * from "./SourceFile.js";
export * from "./SourceTextSource.js";
export * from "./SourceUrl.js";
export * from "./StateEmbeddingGeneration.js";
export * from "./StateEmbeddingGenerationCompletedEmbeddingGeneration.js";
export * from "./StateEmbeddingGenerationFailed.js";
export * from "./StateEmbeddingGenerationInProgress.js";
export * from "./StateEmbeddingGenerationQueued.js";
export * from "./StateInference.js";
export * from "./StateTlInference.js";
export * from "./StateTlInferenceCompletedTlInference.js";
export * from "./StateTlInferenceFailed.js";
export * from "./StateTlInferenceInProgress.js";
export * from "./StateTlInferenceQueued.js";
export * from "./StateTraining.js";
export * from "./StateTrainingCompletedTraining.js";
export * from "./StateTrainingFailed.js";
export * from "./StateTrainingInProgress.js";
export * from "./StateTrainingQueued.js";
export * from "./Status.js";
export * from "./Tag.js";
export * from "./Target.js";
export * from "./Task.js";
export * from "./TaskClassification.js";
export * from "./TaskRegression.js";
export * from "./TextSource.js";
export * from "./TimeInterval.js";
export * from "./TlInferenceBaseRequest.js";
export * from "./TlInferencePrediction.js";
export * from "./TlInferenceResults.js";
export * from "./TlInferenceSourcePredictResult.js";
export * from "./ToxicityScore.js";
export * from "./TrainingBaseRequest.js";
export * from "./TrainingCustomModel.js";
export * from "./Transcription.js";
export * from "./TranscriptionMetadata.js";
export * from "./Type.js";
export * from "./Unconfigurable.js";
export * from "./UnionJob.js";
export * from "./UnionPredictResult.js";
export * from "./Url.js";
export * from "./ValidationArgs.js";
export * from "./When.js";
export * from "./Window.js";

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/index.ts
================================================================================
export * as batch from "./batch/index.js";
export * as stream from "./stream/index.js";

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/index.ts
================================================================================
export * from "./resources/index.js";
export * from "./types/index.js";

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/index.ts
================================================================================
export * from "./stream/client/socket/index.js";
export * as stream from "./stream/index.js";
export * from "./stream/types/index.js";

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/client/index.ts
================================================================================
export * from "./socket/index.js";

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/client/socket/StreamSocketResponse.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../../api/index.js";
import * as core from "../../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../../index.js";
import { SubscribeEvent } from "../../types/SubscribeEvent.js";

export const StreamSocketResponse: core.serialization.Schema<
    serializers.expressionMeasurement.stream.StreamSocketResponse.Raw,
    Hume.expressionMeasurement.stream.SubscribeEvent
> = core.serialization.undiscriminatedUnion([SubscribeEvent]);

export declare namespace StreamSocketResponse {
    export type Raw = SubscribeEvent.Raw;
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/client/socket/index.ts
================================================================================
export { StreamSocketResponse } from "./StreamSocketResponse.js";

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/index.ts
================================================================================
export * from "./client/index.js";
export * from "./types/index.js";

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/Config.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamFace } from "./StreamFace.js";
import { StreamLanguage } from "./StreamLanguage.js";

export const Config: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.Config.Raw,
    Hume.expressionMeasurement.stream.Config
> = core.serialization.object({
    burst: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    face: StreamFace.optional(),
    facemesh: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    language: StreamLanguage.optional(),
    prosody: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
});

export declare namespace Config {
    export interface Raw {
        burst?: Record<string, unknown> | null;
        face?: StreamFace.Raw | null;
        facemesh?: Record<string, unknown> | null;
        language?: StreamLanguage.Raw | null;
        prosody?: Record<string, unknown> | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/JobDetails.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";

export const JobDetails: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.JobDetails.Raw,
    Hume.expressionMeasurement.stream.JobDetails
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string().optional()),
});

export declare namespace JobDetails {
    export interface Raw {
        job_id?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamErrorMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { JobDetails } from "./JobDetails.js";

export const StreamErrorMessage: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamErrorMessage.Raw,
    Hume.expressionMeasurement.stream.StreamErrorMessage
> = core.serialization.object({
    error: core.serialization.string().optional(),
    code: core.serialization.string().optional(),
    payloadId: core.serialization.property("payload_id", core.serialization.string().optional()),
    jobDetails: core.serialization.property("job_details", JobDetails.optional()),
});

export declare namespace StreamErrorMessage {
    export interface Raw {
        error?: string | null;
        code?: string | null;
        payload_id?: string | null;
        job_details?: JobDetails.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamFace.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";

export const StreamFace: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamFace.Raw,
    Hume.expressionMeasurement.stream.StreamFace
> = core.serialization.object({
    facs: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    descriptions: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    identifyFaces: core.serialization.property("identify_faces", core.serialization.boolean().optional()),
    fpsPred: core.serialization.property("fps_pred", core.serialization.number().optional()),
    probThreshold: core.serialization.property("prob_threshold", core.serialization.number().optional()),
    minFaceSize: core.serialization.property("min_face_size", core.serialization.number().optional()),
});

export declare namespace StreamFace {
    export interface Raw {
        facs?: Record<string, unknown> | null;
        descriptions?: Record<string, unknown> | null;
        identify_faces?: boolean | null;
        fps_pred?: number | null;
        prob_threshold?: number | null;
        min_face_size?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamLanguage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";

export const StreamLanguage: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamLanguage.Raw,
    Hume.expressionMeasurement.stream.StreamLanguage
> = core.serialization.object({
    sentiment: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    toxicity: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
    granularity: core.serialization.string().optional(),
});

export declare namespace StreamLanguage {
    export interface Raw {
        sentiment?: Record<string, unknown> | null;
        toxicity?: Record<string, unknown> | null;
        granularity?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictions.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamModelPredictionsBurst } from "./StreamModelPredictionsBurst.js";
import { StreamModelPredictionsFace } from "./StreamModelPredictionsFace.js";
import { StreamModelPredictionsFacemesh } from "./StreamModelPredictionsFacemesh.js";
import { StreamModelPredictionsJobDetails } from "./StreamModelPredictionsJobDetails.js";
import { StreamModelPredictionsLanguage } from "./StreamModelPredictionsLanguage.js";
import { StreamModelPredictionsProsody } from "./StreamModelPredictionsProsody.js";

export const StreamModelPredictions: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictions.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictions
> = core.serialization.object({
    payloadId: core.serialization.property("payload_id", core.serialization.string().optional()),
    jobDetails: core.serialization.property("job_details", StreamModelPredictionsJobDetails.optional()),
    burst: StreamModelPredictionsBurst.optional(),
    face: StreamModelPredictionsFace.optional(),
    facemesh: StreamModelPredictionsFacemesh.optional(),
    language: StreamModelPredictionsLanguage.optional(),
    prosody: StreamModelPredictionsProsody.optional(),
});

export declare namespace StreamModelPredictions {
    export interface Raw {
        payload_id?: string | null;
        job_details?: StreamModelPredictionsJobDetails.Raw | null;
        burst?: StreamModelPredictionsBurst.Raw | null;
        face?: StreamModelPredictionsFace.Raw | null;
        facemesh?: StreamModelPredictionsFacemesh.Raw | null;
        language?: StreamModelPredictionsLanguage.Raw | null;
        prosody?: StreamModelPredictionsProsody.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsBurst.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamModelPredictionsBurstPredictionsItem } from "./StreamModelPredictionsBurstPredictionsItem.js";

export const StreamModelPredictionsBurst: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsBurst.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsBurst
> = core.serialization.object({
    predictions: core.serialization.list(StreamModelPredictionsBurstPredictionsItem).optional(),
});

export declare namespace StreamModelPredictionsBurst {
    export interface Raw {
        predictions?: StreamModelPredictionsBurstPredictionsItem.Raw[] | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsBurstPredictionsItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
import { TimeRange } from "../../../types/TimeRange.js";

export const StreamModelPredictionsBurstPredictionsItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsBurstPredictionsItem.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsBurstPredictionsItem
> = core.serialization.object({
    time: TimeRange.optional(),
    emotions: EmotionEmbedding.optional(),
});

export declare namespace StreamModelPredictionsBurstPredictionsItem {
    export interface Raw {
        time?: TimeRange.Raw | null;
        emotions?: EmotionEmbedding.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFace.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamModelPredictionsFacePredictionsItem } from "./StreamModelPredictionsFacePredictionsItem.js";

export const StreamModelPredictionsFace: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsFace.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsFace
> = core.serialization.object({
    predictions: core.serialization.list(StreamModelPredictionsFacePredictionsItem).optional(),
});

export declare namespace StreamModelPredictionsFace {
    export interface Raw {
        predictions?: StreamModelPredictionsFacePredictionsItem.Raw[] | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacePredictionsItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
import { StreamBoundingBox } from "../../../types/StreamBoundingBox.js";

export const StreamModelPredictionsFacePredictionsItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsFacePredictionsItem.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsFacePredictionsItem
> = core.serialization.object({
    frame: core.serialization.number().optional(),
    time: core.serialization.number().optional(),
    bbox: StreamBoundingBox.optional(),
    prob: core.serialization.number().optional(),
    faceId: core.serialization.property("face_id", core.serialization.string().optional()),
    emotions: EmotionEmbedding.optional(),
    facs: EmotionEmbedding.optional(),
    descriptions: EmotionEmbedding.optional(),
});

export declare namespace StreamModelPredictionsFacePredictionsItem {
    export interface Raw {
        frame?: number | null;
        time?: number | null;
        bbox?: StreamBoundingBox.Raw | null;
        prob?: number | null;
        face_id?: string | null;
        emotions?: EmotionEmbedding.Raw | null;
        facs?: EmotionEmbedding.Raw | null;
        descriptions?: EmotionEmbedding.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacemesh.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamModelPredictionsFacemeshPredictionsItem } from "./StreamModelPredictionsFacemeshPredictionsItem.js";

export const StreamModelPredictionsFacemesh: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsFacemesh.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsFacemesh
> = core.serialization.object({
    predictions: core.serialization.list(StreamModelPredictionsFacemeshPredictionsItem).optional(),
});

export declare namespace StreamModelPredictionsFacemesh {
    export interface Raw {
        predictions?: StreamModelPredictionsFacemeshPredictionsItem.Raw[] | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacemeshPredictionsItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";

export const StreamModelPredictionsFacemeshPredictionsItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsFacemeshPredictionsItem.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsFacemeshPredictionsItem
> = core.serialization.object({
    emotions: EmotionEmbedding.optional(),
});

export declare namespace StreamModelPredictionsFacemeshPredictionsItem {
    export interface Raw {
        emotions?: EmotionEmbedding.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsJobDetails.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";

export const StreamModelPredictionsJobDetails: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsJobDetails.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsJobDetails
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string().optional()),
});

export declare namespace StreamModelPredictionsJobDetails {
    export interface Raw {
        job_id?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsLanguage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamModelPredictionsLanguagePredictionsItem } from "./StreamModelPredictionsLanguagePredictionsItem.js";

export const StreamModelPredictionsLanguage: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsLanguage.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsLanguage
> = core.serialization.object({
    predictions: core.serialization.list(StreamModelPredictionsLanguagePredictionsItem).optional(),
});

export declare namespace StreamModelPredictionsLanguage {
    export interface Raw {
        predictions?: StreamModelPredictionsLanguagePredictionsItem.Raw[] | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsLanguagePredictionsItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
import { Sentiment } from "../../../types/Sentiment.js";
import { TextPosition } from "../../../types/TextPosition.js";
import { Toxicity } from "../../../types/Toxicity.js";

export const StreamModelPredictionsLanguagePredictionsItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsLanguagePredictionsItem.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsLanguagePredictionsItem
> = core.serialization.object({
    text: core.serialization.string().optional(),
    position: TextPosition.optional(),
    emotions: EmotionEmbedding.optional(),
    sentiment: Sentiment.optional(),
    toxicity: Toxicity.optional(),
});

export declare namespace StreamModelPredictionsLanguagePredictionsItem {
    export interface Raw {
        text?: string | null;
        position?: TextPosition.Raw | null;
        emotions?: EmotionEmbedding.Raw | null;
        sentiment?: Sentiment.Raw | null;
        toxicity?: Toxicity.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsProsody.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamModelPredictionsProsodyPredictionsItem } from "./StreamModelPredictionsProsodyPredictionsItem.js";

export const StreamModelPredictionsProsody: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsProsody.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsProsody
> = core.serialization.object({
    predictions: core.serialization.list(StreamModelPredictionsProsodyPredictionsItem).optional(),
});

export declare namespace StreamModelPredictionsProsody {
    export interface Raw {
        predictions?: StreamModelPredictionsProsodyPredictionsItem.Raw[] | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsProsodyPredictionsItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
import { TimeRange } from "../../../types/TimeRange.js";

export const StreamModelPredictionsProsodyPredictionsItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelPredictionsProsodyPredictionsItem.Raw,
    Hume.expressionMeasurement.stream.StreamModelPredictionsProsodyPredictionsItem
> = core.serialization.object({
    time: TimeRange.optional(),
    emotions: EmotionEmbedding.optional(),
});

export declare namespace StreamModelPredictionsProsodyPredictionsItem {
    export interface Raw {
        time?: TimeRange.Raw | null;
        emotions?: EmotionEmbedding.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelsEndpointPayload.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { Config } from "./Config.js";

export const StreamModelsEndpointPayload: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamModelsEndpointPayload.Raw,
    Hume.expressionMeasurement.stream.StreamModelsEndpointPayload
> = core.serialization.object({
    data: core.serialization.string().optional(),
    models: Config.optional(),
    streamWindowMs: core.serialization.property("stream_window_ms", core.serialization.number().optional()),
    resetStream: core.serialization.property("reset_stream", core.serialization.boolean().optional()),
    rawText: core.serialization.property("raw_text", core.serialization.boolean().optional()),
    jobDetails: core.serialization.property("job_details", core.serialization.boolean().optional()),
    payloadId: core.serialization.property("payload_id", core.serialization.string().optional()),
});

export declare namespace StreamModelsEndpointPayload {
    export interface Raw {
        data?: string | null;
        models?: Config.Raw | null;
        stream_window_ms?: number | null;
        reset_stream?: boolean | null;
        raw_text?: boolean | null;
        job_details?: boolean | null;
        payload_id?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamWarningMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamWarningMessageJobDetails } from "./StreamWarningMessageJobDetails.js";

export const StreamWarningMessage: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamWarningMessage.Raw,
    Hume.expressionMeasurement.stream.StreamWarningMessage
> = core.serialization.object({
    warning: core.serialization.string().optional(),
    code: core.serialization.string().optional(),
    payloadId: core.serialization.property("payload_id", core.serialization.string().optional()),
    jobDetails: core.serialization.property("job_details", StreamWarningMessageJobDetails.optional()),
});

export declare namespace StreamWarningMessage {
    export interface Raw {
        warning?: string | null;
        code?: string | null;
        payload_id?: string | null;
        job_details?: StreamWarningMessageJobDetails.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamWarningMessageJobDetails.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";

export const StreamWarningMessageJobDetails: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamWarningMessageJobDetails.Raw,
    Hume.expressionMeasurement.stream.StreamWarningMessageJobDetails
> = core.serialization.object({
    jobId: core.serialization.property("job_id", core.serialization.string().optional()),
});

export declare namespace StreamWarningMessageJobDetails {
    export interface Raw {
        job_id?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/SubscribeEvent.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../../api/index.js";
import * as core from "../../../../../../../../core/index.js";
import type * as serializers from "../../../../../../../index.js";
import { StreamErrorMessage } from "./StreamErrorMessage.js";
import { StreamModelPredictions } from "./StreamModelPredictions.js";
import { StreamWarningMessage } from "./StreamWarningMessage.js";

export const SubscribeEvent: core.serialization.Schema<
    serializers.expressionMeasurement.stream.SubscribeEvent.Raw,
    Hume.expressionMeasurement.stream.SubscribeEvent
> = core.serialization.undiscriminatedUnion([StreamModelPredictions, StreamErrorMessage, StreamWarningMessage]);

export declare namespace SubscribeEvent {
    export type Raw = StreamModelPredictions.Raw | StreamErrorMessage.Raw | StreamWarningMessage.Raw;
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/index.ts
================================================================================
export * from "./Config.js";
export * from "./JobDetails.js";
export * from "./StreamErrorMessage.js";
export * from "./StreamFace.js";
export * from "./StreamLanguage.js";
export * from "./StreamModelPredictions.js";
export * from "./StreamModelPredictionsBurst.js";
export * from "./StreamModelPredictionsBurstPredictionsItem.js";
export * from "./StreamModelPredictionsFace.js";
export * from "./StreamModelPredictionsFacemesh.js";
export * from "./StreamModelPredictionsFacemeshPredictionsItem.js";
export * from "./StreamModelPredictionsFacePredictionsItem.js";
export * from "./StreamModelPredictionsJobDetails.js";
export * from "./StreamModelPredictionsLanguage.js";
export * from "./StreamModelPredictionsLanguagePredictionsItem.js";
export * from "./StreamModelPredictionsProsody.js";
export * from "./StreamModelPredictionsProsodyPredictionsItem.js";
export * from "./StreamModelsEndpointPayload.js";
export * from "./StreamWarningMessage.js";
export * from "./StreamWarningMessageJobDetails.js";
export * from "./SubscribeEvent.js";

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/types/EmotionEmbedding.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { EmotionEmbeddingItem } from "./EmotionEmbeddingItem.js";

export const EmotionEmbedding: core.serialization.Schema<
    serializers.expressionMeasurement.stream.EmotionEmbedding.Raw,
    Hume.expressionMeasurement.stream.EmotionEmbedding
> = core.serialization.list(EmotionEmbeddingItem);

export declare namespace EmotionEmbedding {
    export type Raw = EmotionEmbeddingItem.Raw[];
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/types/EmotionEmbeddingItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const EmotionEmbeddingItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.EmotionEmbeddingItem.Raw,
    Hume.expressionMeasurement.stream.EmotionEmbeddingItem
> = core.serialization.object({
    name: core.serialization.string().optional(),
    score: core.serialization.number().optional(),
});

export declare namespace EmotionEmbeddingItem {
    export interface Raw {
        name?: string | null;
        score?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/types/Sentiment.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { SentimentItem } from "./SentimentItem.js";

export const Sentiment: core.serialization.Schema<
    serializers.expressionMeasurement.stream.Sentiment.Raw,
    Hume.expressionMeasurement.stream.Sentiment
> = core.serialization.list(SentimentItem);

export declare namespace Sentiment {
    export type Raw = SentimentItem.Raw[];
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/types/SentimentItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const SentimentItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.SentimentItem.Raw,
    Hume.expressionMeasurement.stream.SentimentItem
> = core.serialization.object({
    name: core.serialization.string().optional(),
    score: core.serialization.number().optional(),
});

export declare namespace SentimentItem {
    export interface Raw {
        name?: string | null;
        score?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/types/StreamBoundingBox.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const StreamBoundingBox: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.StreamBoundingBox.Raw,
    Hume.expressionMeasurement.stream.StreamBoundingBox
> = core.serialization.object({
    x: core.serialization.number().optional(),
    y: core.serialization.number().optional(),
    w: core.serialization.number().optional(),
    h: core.serialization.number().optional(),
});

export declare namespace StreamBoundingBox {
    export interface Raw {
        x?: number | null;
        y?: number | null;
        w?: number | null;
        h?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/types/TextPosition.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TextPosition: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.TextPosition.Raw,
    Hume.expressionMeasurement.stream.TextPosition
> = core.serialization.object({
    begin: core.serialization.number().optional(),
    end: core.serialization.number().optional(),
});

export declare namespace TextPosition {
    export interface Raw {
        begin?: number | null;
        end?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/types/TimeRange.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const TimeRange: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.TimeRange.Raw,
    Hume.expressionMeasurement.stream.TimeRange
> = core.serialization.object({
    begin: core.serialization.number().optional(),
    end: core.serialization.number().optional(),
});

export declare namespace TimeRange {
    export interface Raw {
        begin?: number | null;
        end?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/types/Toxicity.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";
import { ToxicityItem } from "./ToxicityItem.js";

export const Toxicity: core.serialization.Schema<
    serializers.expressionMeasurement.stream.Toxicity.Raw,
    Hume.expressionMeasurement.stream.Toxicity
> = core.serialization.list(ToxicityItem);

export declare namespace Toxicity {
    export type Raw = ToxicityItem.Raw[];
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/types/ToxicityItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../api/index.js";
import * as core from "../../../../../../core/index.js";
import type * as serializers from "../../../../../index.js";

export const ToxicityItem: core.serialization.ObjectSchema<
    serializers.expressionMeasurement.stream.ToxicityItem.Raw,
    Hume.expressionMeasurement.stream.ToxicityItem
> = core.serialization.object({
    name: core.serialization.string().optional(),
    score: core.serialization.number().optional(),
});

export declare namespace ToxicityItem {
    export interface Raw {
        name?: string | null;
        score?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/expressionMeasurement/resources/stream/types/index.ts
================================================================================
export * from "./EmotionEmbedding.js";
export * from "./EmotionEmbeddingItem.js";
export * from "./Sentiment.js";
export * from "./SentimentItem.js";
export * from "./StreamBoundingBox.js";
export * from "./TextPosition.js";
export * from "./TimeRange.js";
export * from "./Toxicity.js";
export * from "./ToxicityItem.js";

================================================================================
// File: src/serialization/resources/index.ts
================================================================================
export * as empathicVoice from "./empathicVoice/index.js";
export * as expressionMeasurement from "./expressionMeasurement/index.js";
export * as tts from "./tts/index.js";

================================================================================
// File: src/serialization/resources/tts/index.ts
================================================================================
export * from "./resources/index.js";
export * from "./types/index.js";

================================================================================
// File: src/serialization/resources/tts/resources/index.ts
================================================================================
export * from "./streamInput/client/socket/index.js";
export * as streamInput from "./streamInput/index.js";
export * from "./voices/client/requests/index.js";
export * as voices from "./voices/index.js";

================================================================================
// File: src/serialization/resources/tts/resources/streamInput/client/index.ts
================================================================================
export * from "./socket/index.js";

================================================================================
// File: src/serialization/resources/tts/resources/streamInput/client/socket/StreamInputSocketResponse.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";
import { TtsOutput } from "../../../../types/TtsOutput.js";

export const StreamInputSocketResponse: core.serialization.Schema<
    serializers.tts.StreamInputSocketResponse.Raw,
    Hume.tts.TtsOutput
> = core.serialization.undiscriminatedUnion([TtsOutput]);

export declare namespace StreamInputSocketResponse {
    export type Raw = TtsOutput.Raw;
}

================================================================================
// File: src/serialization/resources/tts/resources/streamInput/client/socket/index.ts
================================================================================
export { StreamInputSocketResponse } from "./StreamInputSocketResponse.js";

================================================================================
// File: src/serialization/resources/tts/resources/streamInput/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/serialization/resources/tts/resources/voices/client/index.ts
================================================================================
export * from "./requests/index.js";

================================================================================
// File: src/serialization/resources/tts/resources/voices/client/requests/PostedVoice.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../../../../api/index.js";
import * as core from "../../../../../../../core/index.js";
import type * as serializers from "../../../../../../index.js";

export const PostedVoice: core.serialization.Schema<serializers.tts.PostedVoice.Raw, Hume.tts.PostedVoice> =
    core.serialization.object({
        generationId: core.serialization.property("generation_id", core.serialization.string()),
        name: core.serialization.string(),
    });

export declare namespace PostedVoice {
    export interface Raw {
        generation_id: string;
        name: string;
    }
}

================================================================================
// File: src/serialization/resources/tts/resources/voices/client/requests/index.ts
================================================================================
export { PostedVoice } from "./PostedVoice.js";

================================================================================
// File: src/serialization/resources/tts/resources/voices/index.ts
================================================================================
export * from "./client/index.js";

================================================================================
// File: src/serialization/resources/tts/types/AudioEncoding.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AudioFormatType } from "./AudioFormatType.js";

export const AudioEncoding: core.serialization.ObjectSchema<serializers.tts.AudioEncoding.Raw, Hume.tts.AudioEncoding> =
    core.serialization.object({
        format: AudioFormatType,
        sampleRate: core.serialization.property("sample_rate", core.serialization.number()),
    });

export declare namespace AudioEncoding {
    export interface Raw {
        format: AudioFormatType.Raw;
        sample_rate: number;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/AudioFormatType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const AudioFormatType: core.serialization.Schema<serializers.tts.AudioFormatType.Raw, Hume.tts.AudioFormatType> =
    core.serialization.enum_(["mp3", "pcm", "wav"]);

export declare namespace AudioFormatType {
    export type Raw = "mp3" | "pcm" | "wav";
}

================================================================================
// File: src/serialization/resources/tts/types/ErrorResponse.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ErrorResponse: core.serialization.ObjectSchema<serializers.tts.ErrorResponse.Raw, Hume.tts.ErrorResponse> =
    core.serialization.object({
        code: core.serialization.string().optional(),
        error: core.serialization.string().optional(),
        message: core.serialization.string().optional(),
    });

export declare namespace ErrorResponse {
    export interface Raw {
        code?: string | null;
        error?: string | null;
        message?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/Format.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { FormatMp3 } from "./FormatMp3.js";
import { FormatPcm } from "./FormatPcm.js";
import { FormatWav } from "./FormatWav.js";

export const Format: core.serialization.Schema<serializers.tts.Format.Raw, Hume.tts.Format> =
    core.serialization.undiscriminatedUnion([FormatMp3, FormatPcm, FormatWav]);

export declare namespace Format {
    export type Raw = FormatMp3.Raw | FormatPcm.Raw | FormatWav.Raw;
}

================================================================================
// File: src/serialization/resources/tts/types/FormatMp3.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const FormatMp3: core.serialization.ObjectSchema<serializers.tts.FormatMp3.Raw, Hume.tts.FormatMp3> =
    core.serialization.object({
        type: core.serialization.stringLiteral("mp3"),
    });

export declare namespace FormatMp3 {
    export interface Raw {
        type: "mp3";
    }
}

================================================================================
// File: src/serialization/resources/tts/types/FormatPcm.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const FormatPcm: core.serialization.ObjectSchema<serializers.tts.FormatPcm.Raw, Hume.tts.FormatPcm> =
    core.serialization.object({
        type: core.serialization.stringLiteral("pcm"),
    });

export declare namespace FormatPcm {
    export interface Raw {
        type: "pcm";
    }
}

================================================================================
// File: src/serialization/resources/tts/types/FormatWav.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const FormatWav: core.serialization.ObjectSchema<serializers.tts.FormatWav.Raw, Hume.tts.FormatWav> =
    core.serialization.object({
        type: core.serialization.stringLiteral("wav"),
    });

export declare namespace FormatWav {
    export interface Raw {
        type: "wav";
    }
}

================================================================================
// File: src/serialization/resources/tts/types/HttpValidationError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ValidationError } from "./ValidationError.js";

export const HttpValidationError: core.serialization.ObjectSchema<
    serializers.tts.HttpValidationError.Raw,
    Hume.tts.HttpValidationError
> = core.serialization.object({
    detail: core.serialization.list(ValidationError).optional(),
});

export declare namespace HttpValidationError {
    export interface Raw {
        detail?: ValidationError.Raw[] | null;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/MillisecondInterval.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const MillisecondInterval: core.serialization.ObjectSchema<
    serializers.tts.MillisecondInterval.Raw,
    Hume.tts.MillisecondInterval
> = core.serialization.object({
    begin: core.serialization.number(),
    end: core.serialization.number(),
});

export declare namespace MillisecondInterval {
    export interface Raw {
        begin: number;
        end: number;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/OctaveVersion.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const OctaveVersion: core.serialization.Schema<serializers.tts.OctaveVersion.Raw, Hume.tts.OctaveVersion> =
    core.serialization.enum_(["1", "2"]);

export declare namespace OctaveVersion {
    export type Raw = "1" | "2";
}

================================================================================
// File: src/serialization/resources/tts/types/PostedContext.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedContextWithGenerationId } from "./PostedContextWithGenerationId.js";
import { PostedContextWithUtterances } from "./PostedContextWithUtterances.js";

export const PostedContext: core.serialization.Schema<serializers.tts.PostedContext.Raw, Hume.tts.PostedContext> =
    core.serialization.undiscriminatedUnion([PostedContextWithGenerationId, PostedContextWithUtterances]);

export declare namespace PostedContext {
    export type Raw = PostedContextWithGenerationId.Raw | PostedContextWithUtterances.Raw;
}

================================================================================
// File: src/serialization/resources/tts/types/PostedContextWithGenerationId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const PostedContextWithGenerationId: core.serialization.ObjectSchema<
    serializers.tts.PostedContextWithGenerationId.Raw,
    Hume.tts.PostedContextWithGenerationId
> = core.serialization.object({
    generationId: core.serialization.property("generation_id", core.serialization.string()),
});

export declare namespace PostedContextWithGenerationId {
    export interface Raw {
        generation_id: string;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/PostedContextWithUtterances.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedUtterance } from "./PostedUtterance.js";

export const PostedContextWithUtterances: core.serialization.ObjectSchema<
    serializers.tts.PostedContextWithUtterances.Raw,
    Hume.tts.PostedContextWithUtterances
> = core.serialization.object({
    utterances: core.serialization.list(PostedUtterance),
});

export declare namespace PostedContextWithUtterances {
    export interface Raw {
        utterances: PostedUtterance.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/tts/types/PostedTts.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { Format } from "./Format.js";
import { OctaveVersion } from "./OctaveVersion.js";
import { PostedContext } from "./PostedContext.js";
import { PostedUtterance } from "./PostedUtterance.js";
import { TimestampType } from "./TimestampType.js";

export const PostedTts: core.serialization.ObjectSchema<serializers.tts.PostedTts.Raw, Hume.tts.PostedTts> =
    core.serialization.object({
        context: PostedContext.optional(),
        format: Format.optional(),
        includeTimestampTypes: core.serialization.property(
            "include_timestamp_types",
            core.serialization.list(TimestampType).optional(),
        ),
        numGenerations: core.serialization.property("num_generations", core.serialization.number().optional()),
        splitUtterances: core.serialization.property("split_utterances", core.serialization.boolean().optional()),
        stripHeaders: core.serialization.property("strip_headers", core.serialization.boolean().optional()),
        utterances: core.serialization.list(PostedUtterance),
        version: OctaveVersion.optional(),
        instantMode: core.serialization.property("instant_mode", core.serialization.boolean().optional()),
    });

export declare namespace PostedTts {
    export interface Raw {
        context?: PostedContext.Raw | null;
        format?: Format.Raw | null;
        include_timestamp_types?: TimestampType.Raw[] | null;
        num_generations?: number | null;
        split_utterances?: boolean | null;
        strip_headers?: boolean | null;
        utterances: PostedUtterance.Raw[];
        version?: OctaveVersion.Raw | null;
        instant_mode?: boolean | null;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/PostedUtterance.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedUtteranceVoice } from "./PostedUtteranceVoice.js";

export const PostedUtterance: core.serialization.ObjectSchema<
    serializers.tts.PostedUtterance.Raw,
    Hume.tts.PostedUtterance
> = core.serialization.object({
    description: core.serialization.string().optional(),
    speed: core.serialization.number().optional(),
    text: core.serialization.string(),
    trailingSilence: core.serialization.property("trailing_silence", core.serialization.number().optional()),
    voice: PostedUtteranceVoice.optional(),
});

export declare namespace PostedUtterance {
    export interface Raw {
        description?: string | null;
        speed?: number | null;
        text: string;
        trailing_silence?: number | null;
        voice?: PostedUtteranceVoice.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/PostedUtteranceVoice.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedUtteranceVoiceWithId } from "./PostedUtteranceVoiceWithId.js";
import { PostedUtteranceVoiceWithName } from "./PostedUtteranceVoiceWithName.js";

export const PostedUtteranceVoice: core.serialization.Schema<
    serializers.tts.PostedUtteranceVoice.Raw,
    Hume.tts.PostedUtteranceVoice
> = core.serialization.undiscriminatedUnion([PostedUtteranceVoiceWithId, PostedUtteranceVoiceWithName]);

export declare namespace PostedUtteranceVoice {
    export type Raw = PostedUtteranceVoiceWithId.Raw | PostedUtteranceVoiceWithName.Raw;
}

================================================================================
// File: src/serialization/resources/tts/types/PostedUtteranceVoiceWithId.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceProvider } from "./VoiceProvider.js";

export const PostedUtteranceVoiceWithId: core.serialization.ObjectSchema<
    serializers.tts.PostedUtteranceVoiceWithId.Raw,
    Hume.tts.PostedUtteranceVoiceWithId
> = core.serialization.object({
    id: core.serialization.string(),
    provider: VoiceProvider.optional(),
});

export declare namespace PostedUtteranceVoiceWithId {
    export interface Raw {
        id: string;
        provider?: VoiceProvider.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/PostedUtteranceVoiceWithName.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceProvider } from "./VoiceProvider.js";

export const PostedUtteranceVoiceWithName: core.serialization.ObjectSchema<
    serializers.tts.PostedUtteranceVoiceWithName.Raw,
    Hume.tts.PostedUtteranceVoiceWithName
> = core.serialization.object({
    name: core.serialization.string(),
    provider: VoiceProvider.optional(),
});

export declare namespace PostedUtteranceVoiceWithName {
    export interface Raw {
        name: string;
        provider?: VoiceProvider.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/PublishTts.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { PostedUtteranceVoice } from "./PostedUtteranceVoice.js";

export const PublishTts: core.serialization.ObjectSchema<serializers.tts.PublishTts.Raw, Hume.tts.PublishTts> =
    core.serialization.object({
        close: core.serialization.boolean().optional(),
        description: core.serialization.string().optional(),
        flush: core.serialization.boolean().optional(),
        speed: core.serialization.number().optional(),
        text: core.serialization.string().optional(),
        trailingSilence: core.serialization.property("trailing_silence", core.serialization.number().optional()),
        voice: PostedUtteranceVoice.optional(),
    });

export declare namespace PublishTts {
    export interface Raw {
        close?: boolean | null;
        description?: string | null;
        flush?: boolean | null;
        speed?: number | null;
        text?: string | null;
        trailing_silence?: number | null;
        voice?: PostedUtteranceVoice.Raw | null;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/ReturnGeneration.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AudioEncoding } from "./AudioEncoding.js";
import { Snippet } from "./Snippet.js";

export const ReturnGeneration: core.serialization.ObjectSchema<
    serializers.tts.ReturnGeneration.Raw,
    Hume.tts.ReturnGeneration
> = core.serialization.object({
    audio: core.serialization.string(),
    duration: core.serialization.number(),
    encoding: AudioEncoding,
    fileSize: core.serialization.property("file_size", core.serialization.number()),
    generationId: core.serialization.property("generation_id", core.serialization.string()),
    snippets: core.serialization.list(core.serialization.list(Snippet)),
});

export declare namespace ReturnGeneration {
    export interface Raw {
        audio: string;
        duration: number;
        encoding: AudioEncoding.Raw;
        file_size: number;
        generation_id: string;
        snippets: Snippet.Raw[][];
    }
}

================================================================================
// File: src/serialization/resources/tts/types/ReturnPagedVoices.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnVoice } from "./ReturnVoice.js";

export const ReturnPagedVoices: core.serialization.ObjectSchema<
    serializers.tts.ReturnPagedVoices.Raw,
    Hume.tts.ReturnPagedVoices
> = core.serialization.object({
    pageNumber: core.serialization.property("page_number", core.serialization.number()),
    pageSize: core.serialization.property("page_size", core.serialization.number()),
    totalPages: core.serialization.property("total_pages", core.serialization.number()),
    voicesPage: core.serialization.property("voices_page", core.serialization.list(ReturnVoice)),
});

export declare namespace ReturnPagedVoices {
    export interface Raw {
        page_number: number;
        page_size: number;
        total_pages: number;
        voices_page: ReturnVoice.Raw[];
    }
}

================================================================================
// File: src/serialization/resources/tts/types/ReturnTts.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ReturnGeneration } from "./ReturnGeneration.js";

export const ReturnTts: core.serialization.ObjectSchema<serializers.tts.ReturnTts.Raw, Hume.tts.ReturnTts> =
    core.serialization.object({
        generations: core.serialization.list(ReturnGeneration),
        requestId: core.serialization.property("request_id", core.serialization.string().optional()),
    });

export declare namespace ReturnTts {
    export interface Raw {
        generations: ReturnGeneration.Raw[];
        request_id?: string | null;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/ReturnVoice.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { VoiceProvider } from "./VoiceProvider.js";

export const ReturnVoice: core.serialization.ObjectSchema<serializers.tts.ReturnVoice.Raw, Hume.tts.ReturnVoice> =
    core.serialization.object({
        compatibleOctaveModels: core.serialization.property(
            "compatible_octave_models",
            core.serialization.list(core.serialization.string()).optional(),
        ),
        id: core.serialization.string(),
        name: core.serialization.string(),
        provider: VoiceProvider,
    });

export declare namespace ReturnVoice {
    export interface Raw {
        compatible_octave_models?: string[] | null;
        id: string;
        name: string;
        provider: VoiceProvider.Raw;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/Snippet.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { Timestamp } from "./Timestamp.js";

export const Snippet: core.serialization.ObjectSchema<serializers.tts.Snippet.Raw, Hume.tts.Snippet> =
    core.serialization.object({
        audio: core.serialization.string(),
        generationId: core.serialization.property("generation_id", core.serialization.string()),
        id: core.serialization.string(),
        text: core.serialization.string(),
        timestamps: core.serialization.list(Timestamp),
        transcribedText: core.serialization.property("transcribed_text", core.serialization.string().optional()),
        utteranceIndex: core.serialization.property("utterance_index", core.serialization.number().optional()),
    });

export declare namespace Snippet {
    export interface Raw {
        audio: string;
        generation_id: string;
        id: string;
        text: string;
        timestamps: Timestamp.Raw[];
        transcribed_text?: string | null;
        utterance_index?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/SnippetAudioChunk.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { AudioFormatType } from "./AudioFormatType.js";
import { Snippet } from "./Snippet.js";

export const SnippetAudioChunk: core.serialization.ObjectSchema<
    serializers.tts.SnippetAudioChunk.Raw,
    Hume.tts.SnippetAudioChunk
> = core.serialization.object({
    audio: core.serialization.string(),
    audioFormat: core.serialization.property("audio_format", AudioFormatType),
    chunkIndex: core.serialization.property("chunk_index", core.serialization.number()),
    generationId: core.serialization.property("generation_id", core.serialization.string()),
    isLastChunk: core.serialization.property("is_last_chunk", core.serialization.boolean()),
    requestId: core.serialization.property("request_id", core.serialization.string()),
    snippet: Snippet.optional(),
    snippetId: core.serialization.property("snippet_id", core.serialization.string()),
    text: core.serialization.string(),
    transcribedText: core.serialization.property("transcribed_text", core.serialization.string().optional()),
    type: core.serialization.stringLiteral("audio"),
    utteranceIndex: core.serialization.property("utterance_index", core.serialization.number().optional()),
});

export declare namespace SnippetAudioChunk {
    export interface Raw {
        audio: string;
        audio_format: AudioFormatType.Raw;
        chunk_index: number;
        generation_id: string;
        is_last_chunk: boolean;
        request_id: string;
        snippet?: Snippet.Raw | null;
        snippet_id: string;
        text: string;
        transcribed_text?: string | null;
        type: "audio";
        utterance_index?: number | null;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/Timestamp.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { MillisecondInterval } from "./MillisecondInterval.js";
import { TimestampType } from "./TimestampType.js";

export const Timestamp: core.serialization.ObjectSchema<serializers.tts.Timestamp.Raw, Hume.tts.Timestamp> =
    core.serialization.object({
        text: core.serialization.string(),
        time: MillisecondInterval,
        type: TimestampType,
    });

export declare namespace Timestamp {
    export interface Raw {
        text: string;
        time: MillisecondInterval.Raw;
        type: TimestampType.Raw;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/TimestampMessage.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { Timestamp } from "./Timestamp.js";

export const TimestampMessage: core.serialization.ObjectSchema<
    serializers.tts.TimestampMessage.Raw,
    Hume.tts.TimestampMessage
> = core.serialization.object({
    generationId: core.serialization.property("generation_id", core.serialization.string()),
    requestId: core.serialization.property("request_id", core.serialization.string()),
    snippetId: core.serialization.property("snippet_id", core.serialization.string()),
    timestamp: Timestamp,
    type: core.serialization.stringLiteral("timestamp"),
});

export declare namespace TimestampMessage {
    export interface Raw {
        generation_id: string;
        request_id: string;
        snippet_id: string;
        timestamp: Timestamp.Raw;
        type: "timestamp";
    }
}

================================================================================
// File: src/serialization/resources/tts/types/TimestampType.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const TimestampType: core.serialization.Schema<serializers.tts.TimestampType.Raw, Hume.tts.TimestampType> =
    core.serialization.enum_(["word", "phoneme"]);

export declare namespace TimestampType {
    export type Raw = "word" | "phoneme";
}

================================================================================
// File: src/serialization/resources/tts/types/TtsOutput.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { SnippetAudioChunk } from "./SnippetAudioChunk.js";
import { TimestampMessage } from "./TimestampMessage.js";

export const TtsOutput: core.serialization.Schema<serializers.tts.TtsOutput.Raw, Hume.tts.TtsOutput> =
    core.serialization.undiscriminatedUnion([SnippetAudioChunk, TimestampMessage]);

export declare namespace TtsOutput {
    export type Raw = SnippetAudioChunk.Raw | TimestampMessage.Raw;
}

================================================================================
// File: src/serialization/resources/tts/types/ValidationError.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";
import { ValidationErrorLocItem } from "./ValidationErrorLocItem.js";

export const ValidationError: core.serialization.ObjectSchema<
    serializers.tts.ValidationError.Raw,
    Hume.tts.ValidationError
> = core.serialization.object({
    loc: core.serialization.list(ValidationErrorLocItem),
    msg: core.serialization.string(),
    type: core.serialization.string(),
});

export declare namespace ValidationError {
    export interface Raw {
        loc: ValidationErrorLocItem.Raw[];
        msg: string;
        type: string;
    }
}

================================================================================
// File: src/serialization/resources/tts/types/ValidationErrorLocItem.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const ValidationErrorLocItem: core.serialization.Schema<
    serializers.tts.ValidationErrorLocItem.Raw,
    Hume.tts.ValidationErrorLocItem
> = core.serialization.undiscriminatedUnion([core.serialization.string(), core.serialization.number()]);

export declare namespace ValidationErrorLocItem {
    export type Raw = string | number;
}

================================================================================
// File: src/serialization/resources/tts/types/VoiceProvider.ts
================================================================================
// This file was auto-generated by Fern from our API Definition.

import type * as Hume from "../../../../api/index.js";
import * as core from "../../../../core/index.js";
import type * as serializers from "../../../index.js";

export const VoiceProvider: core.serialization.Schema<serializers.tts.VoiceProvider.Raw, Hume.tts.VoiceProvider> =
    core.serialization.enum_(["HUME_AI", "CUSTOM_VOICE"]);

export declare namespace VoiceProvider {
    export type Raw = "HUME_AI" | "CUSTOM_VOICE";
}

================================================================================
// File: src/serialization/resources/tts/types/index.ts
================================================================================
export * from "./AudioEncoding.js";
export * from "./AudioFormatType.js";
export * from "./ErrorResponse.js";
export * from "./Format.js";
export * from "./FormatMp3.js";
export * from "./FormatPcm.js";
export * from "./FormatWav.js";
export * from "./HttpValidationError.js";
export * from "./MillisecondInterval.js";
export * from "./OctaveVersion.js";
export * from "./PostedContext.js";
export * from "./PostedContextWithGenerationId.js";
export * from "./PostedContextWithUtterances.js";
export * from "./PostedTts.js";
export * from "./PostedUtterance.js";
export * from "./PostedUtteranceVoice.js";
export * from "./PostedUtteranceVoiceWithId.js";
export * from "./PostedUtteranceVoiceWithName.js";
export * from "./PublishTts.js";
export * from "./ReturnGeneration.js";
export * from "./ReturnPagedVoices.js";
export * from "./ReturnTts.js";
export * from "./ReturnVoice.js";
export * from "./Snippet.js";
export * from "./SnippetAudioChunk.js";
export * from "./Timestamp.js";
export * from "./TimestampMessage.js";
export * from "./TimestampType.js";
export * from "./TtsOutput.js";
export * from "./ValidationError.js";
export * from "./ValidationErrorLocItem.js";
export * from "./VoiceProvider.js";

================================================================================
// File: src/version.ts
================================================================================
export const SDK_VERSION = "0.15.11";

================================================================================
// File: src/wrapper/EVIWebAudioPlayer.ts
================================================================================
import { convertBase64ToBlob } from "./convertBase64ToBlob.js";
import type { AudioOutput } from "api/resources/empathicVoice";
import { convertLinearFrequenciesToBark } from "./convertFrequencyScale.js";
import { generateEmptyFft } from "./generateEmptyFft.js";

/**
 * Options for configuring an {@link EVIWebAudioPlayer}.
 *
 * @default `{}` for sensible defaults.
 */
export interface EVIWebAudioPlayerOptions {
    /**
     * Initial master gain, via a `GainNode`, from `0` (_silent_) to `1` (_full volume_).
     * Values outside this range are clamped.
     *
     * @default 1
     */
    volume?: number;
    /**
     * Disable AudioWorklet Mode and use Regular Buffer Mode instead.
     * Regular Buffer Mode falls back to AudioBufferSourceNode in the main thread if worklets aren't available.
     * @default false (AudioWorklet Mode enabled)
     */
    disableAudioWorklet?: boolean;
    /**
     * Real-time FFT (frequency-domain) settings **only** for visualization.
     *
     * - **Disable**: omit or `{ enabled: false }` – no `AnalyserNode` is created.
     * - **Defaults**: `{ enabled: true }` → 2048-point FFT at 16 ms (~60 Hz), mapped to 24 Bark bands.
     * - **Custom**: supply {@link EVIWebAudioPlayerFFTOptions} to override `size`, `interval`, or `transform`.
     */
    fft?: EVIWebAudioPlayerFFTOptions;
}

/**
 * FFT (frequency-domain) options for visualization.
 *
 * Pass `{ enabled: true }` for defaults, or omit/disable entirely for zero overhead.
 */
export type EVIWebAudioPlayerFFTOptions = FftEnabled | FftDisabled;

type FftDisabled = {
    /**
     * Turn visualization data OFF—skip analyser creation entirely (zero extra CPU).
     */
    enabled: false;
};

type FftEnabled = {
    /**
     * Turn visualization data ON—create an `AnalyserNode`, poll it, and emit `'fft'` events.
     */
    enabled: true;
    /**
     * FFT size (power-of-two, 32 – 32768).
     * Defaults to 2048 → 1024 bins (~ 23 Hz at 48 kHz).
     * @default 2048
     */
    size?: number;
    /**
     * Polling interval, in **milliseconds**.
     * Default 16 ms (~ 60 Hz) to sync with `requestAnimationFrame()`.
     * @default 16
     */
    interval?: number;
    /**
     * Custom post-processing for raw magnitude data. Omit for built-in 24-band Bark mapping.
     *
     * @param bins PCM byte magnitudes (0 – 255) from `AnalyserNode`.
     * @param sampleRate `AudioContext` sample rate in Hz.
     * @returns Payload emitted with each `'fft'` event.
     */
    transform?: (bins: Uint8Array, sampleRate: number) => number[];
};

type ResolvedFftOptions = {
    readonly size: number;
    readonly interval: number;
    readonly transform: (bins: Uint8Array, sampleRate: number) => number[];
};

type PlayerEventMap = {
    play: CustomEvent<{ id: string }>;
    stop: CustomEvent<{ id: string }>;
    fft: CustomEvent<{ fft: number[] }>;
    error: CustomEvent<{ message: string }>;
};

/**
 * A sequential, glitch-free Web-Audio player for **EVI** audio output.
 *
 * - **Decoding & playback**: base-64 PCM chunks feed an `AudioWorkletNode` and play in order, without gaps.
 * - **One-time init**: await {@link init} in a user-gesture to build audio graph and unlock the browser’s
 *  `AudioContext`; later calls are no-ops.
 * - **Optional FFT**: `{ fft: { enabled: true } }` adds an `AnalyserNode` and emits `'fft'` events; omit to skip.
 * - **Controls**: {@link setVolume}, {@link mute}, {@link unmute}, {@link stop}, {@link dispose}.
 * - **Events**: listen for `'play'`, `'stop'`, `'fft'`, `'error'`.
 */
export class EVIWebAudioPlayer extends EventTarget {
    /** Default URL of the `audio-worklet.js` processor module, fetched from Hume AI’s CDN. */
    static #DEFAULT_WORKLET_URL = "https://storage.googleapis.com/evi-react-sdk-assets/audio-worklet-20250506.js";
    /** Default FFT size (power-of-two). */
    static #DEFAULT_FFT_SIZE = 2048;
    /** Default analyser poll interval (16 ms). */
    static #DEFAULT_FFT_INTERVAL = 16;

    /** `true` while any clip is currently audible. */
    get playing(): boolean {
        return this.#playing;
    }
    /** `true` if gain is set to 0 via {@link mute}. */
    get muted(): boolean {
        return this.#muted;
    }
    /** Current output gain (0‑1). */
    get volume(): number {
        return this.#volume;
    }
    /** Most recent FFT frame (empty when analyser disabled). */
    get fft(): number[] {
        return this.#fft;
    }

    #ctx: AudioContext | null = null;
    #workletNode: AudioWorkletNode | null = null;
    #analyserNode: AnalyserNode | null = null;
    #gainNode: GainNode | null = null;

    #initialized = false;
    #playing = false;
    #muted = false;
    #volume: number;
    #disableAudioWorklet: boolean;

    #fft: number[] = generateEmptyFft();
    #fftTimer: number | null = null;
    #fftOptions: ResolvedFftOptions | null = null;

    #clipQueue: Array<{ id: string; buffer: AudioBuffer; index: number }> = [];
    #currentlyPlayingAudioBuffer: AudioBufferSourceNode | null = null;
    #isProcessing = false;
    // chunkBufferQueues and #lastQueuedChunk are used to make sure that
    // we don't play chunks out of order. #chunkBufferQueues is NOT the
    // audio playback queue.
    #lastQueuedChunk: { id: string; index: number } | null = null;
    #chunkBufferQueues: Record<string, Array<AudioBuffer | undefined>> = {};

    constructor(private readonly opts: EVIWebAudioPlayerOptions = {}) {
        super();
        this.#volume = opts.volume ?? 1.0;
        this.#disableAudioWorklet = opts.disableAudioWorklet ?? false;

        // Resolve FFT options if enabled
        if (opts.fft?.enabled) {
            const { size, interval, transform } = opts.fft;
            this.#fftOptions = {
                size: size ?? EVIWebAudioPlayer.#DEFAULT_FFT_SIZE,
                interval: interval ?? EVIWebAudioPlayer.#DEFAULT_FFT_INTERVAL,
                transform: transform ?? ((bins, sampleRate) => convertLinearFrequenciesToBark(bins, sampleRate)),
            };
        }
    }

    /**
     * * Subscribes to a player event and returns `this` for chaining.
     *
     * @param type One of `'play'`, `'stop'`, `'fft'`, or `'error'`.
     * @param fn Handler invoked with the event’s typed `detail` payload.
     * @param opts Optional `AddEventListenerOptions` (e.g. `{ once: true }`).
     *
     * @example
     *  ```ts
     *  const player = new EVIWebAudioPlayer();
     *  player
     *    .on('play', e => console.log('play',  e.detail.id))
     *    .on('stop', e => console.log('stop',  e.detail.id))
     *    .on('fft', e => console.log('stop',  e.detail.fft))
     *    .on('error', e => console.error('error', e.detail.message));
     *  ```
     */
    on<K extends keyof PlayerEventMap>(
        type: K,
        fn: (e: PlayerEventMap[K]) => void,
        opts?: AddEventListenerOptions,
    ): this {
        super.addEventListener(type, fn as EventListener, opts);
        return this;
    }

    /**
     * Set up and start the player’s Web-Audio pipeline.
     *
     * - Creates a **suspended** `AudioContext`, loads the worklet processor, wires `AudioWorkletNode → (AnalyserNode?) → GainNode → destination`, then calls `resume()`.
     * - Must be awaited inside a user-gesture (click/tap/key); later calls are no-ops.
     * - If `fft.enabled` is `false` (or `fft` is omitted), no `AnalyserNode` or polling timer is created.
     *
     * **Safari quirk:** Safari locks an `AudioContext` to the device’s current sample rate at creation.
     * If you open a Bluetooth headset mic afterward, the OS may switch to the 16 kHz HFP profile and down-sample playback, which sounds “telephone-y.”
     * To avoid this, call `getUserMedia()` (or otherwise open audio input) **before** `init()`.
     *
     * @throws {Error} If the browser lacks `AudioWorklet` support, or if `AudioContext.resume()` is rejected (autoplay policy, device error).
     */
    async init(): Promise<void> {
        if (this.#initialized) return;

        // Create the AudioContext
        this.#ctx = new AudioContext();

        // Fail fast if AudioWorklet isn’t supported
        if (!this.#ctx.audioWorklet) {
            console.warn("AudioWorklet is not supported in this browser. Falling back to Regular Buffer Mode.");
            this.#disableAudioWorklet = true;
        }

        try {
            // Build GainNode
            this.#gainNode = this.#ctx.createGain();
            this.#gainNode.gain.value = this.#volume;

            // Build AnalyserNode (optional)
            if (this.#fftOptions) {
                this.#analyserNode = this.#ctx.createAnalyser();
                this.#analyserNode.fftSize = this.#fftOptions.size;
            } else {
                // Always create AnalyserNode, even if FFT is disabled, to avoid null checks in Buffer Mode
                this.#analyserNode = this.#ctx.createAnalyser();
                this.#analyserNode.fftSize = EVIWebAudioPlayer.#DEFAULT_FFT_SIZE;
            }

            if (!this.#disableAudioWorklet) {
                // Loads the AudioWorklet processor module.
                await this.#ctx.audioWorklet.addModule(EVIWebAudioPlayer.#DEFAULT_WORKLET_URL);

                // Build AudioWorkletNode
                this.#workletNode = new AudioWorkletNode(this.#ctx, "audio-processor");

                // When the worklet posts { type: "ended" }, mark playback stopped and emit a `'stop'` event.
                this.#workletNode.port.onmessage = (e: MessageEvent) => {
                    if ((e.data as { type?: string }).type === "ended") {
                        this.#playing = false;
                        this.dispatchEvent(new CustomEvent("stop", { detail: { id: "stream" } }));
                    }
                };

                // Audio graph nodes
                const workletNode = this.#workletNode; // AudioWorkletNode (PCM processor)
                const analyserNode = this.#analyserNode; // Optional AnalyserNode (FFT)
                const gainNode = this.#gainNode; // GainNode (volume control)
                const destination = this.#ctx.destination; // AudioDestinationNode (speakers)

                // Analyser node is filtered out of audio graph if null (FFT disabled)
                const audioGraph = [workletNode, analyserNode, gainNode, destination].filter(Boolean) as AudioNode[];

                // Wire nodes: AudioWorkletNode → (AnalyserNode?) → GainNode → AudioDestinationNode
                audioGraph.reduce((prev, next) => (prev.connect(next), next));
            } else {
                // Regular Buffer Mode
                const analyserNode = this.#analyserNode;
                const gainNode = this.#gainNode;
                const destination = this.#ctx.destination;

                // Wire nodes: (AnalyserNode?) → GainNode → AudioDestinationNode
                const audioGraph = [analyserNode, gainNode, destination].filter(Boolean) as AudioNode[];
                audioGraph.reduce((prev, next) => (prev.connect(next), next));
            }

            // If an analyser is configured, begin polling it at the resolved interval and dispatching `'fft'` events for each frame.
            this.#startAnalyserPollingIfEnabled();

            // Resume the AudioContext now that the audio graph is fully wired.
            // Browsers allow `resume()` only inside a user-gesture callback.
            // Any rejection (autoplay policy, hardware issue, etc.) is caught by the outer catch-block below, which emits an 'error' event and re-throws.
            await this.#ctx.resume();

            this.#initialized = true;
        } catch (err) {
            const suffix = err instanceof Error ? `: ${err.message}` : String(err);
            this.#emitError(`Failed to initialize audio player${suffix}`);
            throw err;
        }
    }

    /**
     * Queue one {@link AudioOutput} message for playback.
     *
     * Decodes the base-64 PCM data, sends it to the `AudioWorkletNode` for glitch-free, in-order playback, and emits `'play'` for the first chunk of a new stream.
     *
     * @param message The `AudioOutput` message received from EVI’s WebSocket.
     *
     * @see {@link https://dev.hume.ai/reference/empathic-voice-interface-evi/chat/chat#receive.Audio-Output.type API Reference}
     */
    async enqueue(message: AudioOutput): Promise<void> {
        if (!this.#initialized || !this.#ctx) {
            this.#emitError("Audio player is not initialized");
            return;
        }

        if (!this.#disableAudioWorklet) {
            try {
                const { data, id } = message;

                const blob = convertBase64ToBlob(data);
                const buffer = await blob.arrayBuffer();

                const audio = await this.#ctx.decodeAudioData(buffer);
                const pcmData = audio.getChannelData(0);

                this.#workletNode!.port.postMessage({ type: "audio", data: pcmData });

                this.#playing = true;
                this.dispatchEvent(new CustomEvent("play", { detail: { id } }));
            } catch (err) {
                const msg = err instanceof Error ? err.message : "Unknown error";
                this.#emitError(`Failed to queue clip: ${msg}`);
            }
        } else {
            // Regular Buffer Mode
            try {
                const audioBuffer = await this.#convertToAudioBuffer(message);
                if (!audioBuffer) {
                    this.#emitError("Failed to convert data to audio buffer");
                    return;
                }

                const playableBuffers = this.#getNextAudioBuffers(message, audioBuffer);
                if (playableBuffers.length === 0) {
                    return;
                }

                for (const nextAudioBufferToPlay of playableBuffers) {
                    this.#clipQueue.push({
                        id: nextAudioBufferToPlay.id,
                        buffer: nextAudioBufferToPlay.buffer,
                        index: nextAudioBufferToPlay.index,
                    });
                    if (this.#clipQueue.length === 1) {
                        this.#playNextClip();
                    }
                }
            } catch (e) {
                const eMessage = e instanceof Error ? e.message : "Unknown error";
                this.#emitError(`Failed to add clip to queue: ${eMessage}`);
            }
        }
    }

    /**
     * Flush the worklet queue and output silence.
     */
    stop(): void {
        if (!this.#disableAudioWorklet) {
            // Clear buffered audio from the worklet queue
            this.#workletNode?.port.postMessage({ type: "fadeAndClear" });
        } else {
            // Regular Buffer mode
            if (this.#currentlyPlayingAudioBuffer) {
                this.#currentlyPlayingAudioBuffer.stop();
                this.#currentlyPlayingAudioBuffer.disconnect();
                this.#currentlyPlayingAudioBuffer = null;
            }
            this.#clipQueue = [];
            this.#isProcessing = false;
        }

        // Restart analyser polling so fft events continue after stopping or clearing the queue
        this.#startAnalyserPollingIfEnabled();

        this.#playing = false;
        this.dispatchEvent(new CustomEvent("stop", { detail: { id: "manual" } }));
    }

    /**
     * Set the master gain ({@link volume}) to a value between `0` (_silent_) and `1` (_full volume_).
     *
     * - Clamps out-of-range values.
     * - If called before {@link init}, stores volume for when `AudioContext` is created.
     * - If currently {@link muted}, updates stored volume but keeps output silent until {@link unmute}.
     *
     * @param volume Desired gain; clamped to [0, 1].
     */
    setVolume(volume: number): void {
        const clampedVolume = Math.max(0, Math.min(volume, 1));
        this.#volume = clampedVolume;

        if (this.#gainNode && this.#ctx && !this.#muted) {
            this.#gainNode.gain.setValueAtTime(clampedVolume, this.#ctx.currentTime);
        }
    }

    /**
     * Mute output instantly by setting the gain to 0. Retains the last volume internally for later restore.
     */
    mute(): void {
        if (!this.#gainNode || !this.#ctx) return;
        this.#gainNode.gain.setValueAtTime(0, this.#ctx.currentTime);
        this.#muted = true;
    }

    /**
     * Restore output gain to the last set volume (via setVolume).
     */
    unmute(): void {
        if (!this.#gainNode || !this.#ctx) return;
        this.#gainNode.gain.setValueAtTime(this.#volume, this.#ctx.currentTime);
        this.#muted = false;
    }

    /**
     * Tear down all Web-Audio resources (worklet, analyser, gain, context) and reset state so {@link init} can be called again.
     */
    dispose(): void {
        if (this.#fftTimer != null) {
            clearInterval(this.#fftTimer);
            this.#fftTimer = null;
        }

        if (!this.#disableAudioWorklet) {
            this.#workletNode?.port.postMessage({ type: "fadeAndClear" });
            this.#workletNode?.port.postMessage({ type: "end" });
            this.#workletNode?.port.close();
            this.#workletNode?.disconnect();
        } else {
            // Regular Buffer mode
            if (this.#currentlyPlayingAudioBuffer) {
                this.#currentlyPlayingAudioBuffer.stop();
                this.#currentlyPlayingAudioBuffer.disconnect();
                this.#currentlyPlayingAudioBuffer = null;
            }
            this.#clipQueue = [];
            this.#isProcessing = false;
        }

        this.#analyserNode?.disconnect();

        this.#gainNode?.disconnect();
        this.#ctx?.close().catch(() => void 0);

        this.#initialized = false;
        this.#playing = false;
        this.#fft = generateEmptyFft();
    }

    /**
     * Polls the AnalyserNode at the configured interval, applies the FFT transform, and emits `'fft'` events.
     * No-ops if no analyser is present.
     */
    #startAnalyserPollingIfEnabled() {
        if (!this.#fftOptions || !this.#analyserNode) return;
        if (this.#fftTimer) clearInterval(this.#fftTimer);

        const { interval, transform } = this.#fftOptions;

        this.#fftTimer = window.setInterval(() => {
            const bins = new Uint8Array(this.#analyserNode!.frequencyBinCount);
            this.#analyserNode!.getByteFrequencyData(bins);
            this.#fft = transform(bins, this.#ctx!.sampleRate);
            this.dispatchEvent(new CustomEvent("fft", { detail: { fft: this.#fft } }));
        }, interval);
    }

    /**
     * Emit an `error` event with the supplied message.
     */
    #emitError(message: string) {
        this.dispatchEvent(new CustomEvent("error", { detail: { message } }));
    }

    /**
     * Converts a base64 encoded audio data message to an AudioBuffer.
     */
    async #convertToAudioBuffer(message: AudioOutput): Promise<AudioBuffer | undefined> {
        if (!this.#initialized || !this.#ctx) {
            this.#emitError("Audio player has not been initialized");
            return;
        }
        const blob = convertBase64ToBlob(message.data);
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await this.#ctx.decodeAudioData(arrayBuffer);
        return audioBuffer;
    }

    /**
     * Manages incoming audio chunks to ensure they are processed in the correct order.
     */
    #getNextAudioBuffers(
        message: AudioOutput,
        audioBuffer: AudioBuffer,
    ): Array<{ id: string; index: number; buffer: AudioBuffer }> {
        // Prevent prototype pollution by restricting dangerous property names.
        if (message.id === "__proto__" || message.id === "constructor" || message.id === "prototype") {
            this.#emitError(`Attempted to use a dangerous property name as message ID: ${message.id}`);
            return [];
        }
        //1. Add the current buffer to the queue
        if (!this.#chunkBufferQueues[message.id]) {
            this.#chunkBufferQueues[message.id] = [];
        }

        // Ensure message.index is a safe, non-negative integer to prevent prototype pollution.
        if (!Number.isInteger(message.index) || message.index < 0) {
            this.#emitError(`Attempted to use an invalid index: ${message.index}`);
            return [];
        }

        const queueForCurrMessage = this.#chunkBufferQueues[message.id] || [];
        queueForCurrMessage[message.index] = audioBuffer;

        // 2. Now collect buffers that are ready to be played
        const lastId = this.#lastQueuedChunk?.id;
        const buffers: Array<{ id: string; index: number; buffer: AudioBuffer }> = [];

        // If the current message ID is different from the last one that was added
        // to the queue, that means that we're playing a new message now, so the first chunk
        // we play needs to be at index 0.
        if (message.id !== lastId) {
            if (queueForCurrMessage[0]) {
                this.#lastQueuedChunk = { id: message.id, index: 0 };
                buffers.push({
                    id: message.id,
                    index: 0,
                    buffer: queueForCurrMessage[0],
                });
                queueForCurrMessage[0] = undefined;
            } else {
                return [];
            }
        }

        // Drain the queue - basically if any chunks were received out of order previously,
        // and they're now ready to be played because the earlier chunks
        // have been received, we can add them to the buffers array.
        let nextIdx = (this.#lastQueuedChunk?.index || 0) + 1;
        let nextBuf = queueForCurrMessage[nextIdx];
        while (nextBuf) {
            buffers.push({ index: nextIdx, buffer: nextBuf, id: message.id });
            queueForCurrMessage[nextIdx] = undefined;
            this.#lastQueuedChunk = { id: message.id, index: nextIdx };
            nextIdx += 1;
            nextBuf = queueForCurrMessage[nextIdx];
        }

        return buffers;
    }

    /**
     * Only for Regular Buffer mode.
     * This function is called when the current audio clip ends.
     * It will play the next clip in the queue if there is one.
     */
    #playNextClip() {
        if (this.#clipQueue.length === 0 || this.#isProcessing) {
            return;
        }

        if (this.#analyserNode === null || this.#ctx === null) {
            this.#emitError("Audio player is not initialized");
            return;
        }

        const nextClip = this.#clipQueue.shift();

        if (!nextClip) {
            return;
        }

        this.#isProcessing = true;
        this.#playing = true;

        const bufferSource = this.#ctx.createBufferSource();

        bufferSource.buffer = nextClip.buffer;

        if (this.#analyserNode) {
            bufferSource.connect(this.#analyserNode);
        }

        if (this.#gainNode) {
            this.#analyserNode?.connect(this.#gainNode);
            this.#gainNode.connect(this.#ctx.destination);
        } else {
            this.#analyserNode?.connect(this.#ctx.destination);
        }

        this.#currentlyPlayingAudioBuffer = bufferSource;

        this.#startAnalyserPollingIfEnabled();

        bufferSource.start(0);
        if (nextClip.index === 0) {
            this.dispatchEvent(new CustomEvent("play", { detail: { id: nextClip.id } }));
        }

        bufferSource.onended = () => {
            if (this.#fftTimer) {
                clearInterval(this.#fftTimer);
                this.#fftTimer = null;
            }
            this.#fft = generateEmptyFft();
            bufferSource.disconnect();
            this.#isProcessing = false;
            this.#playing = false;
            this.dispatchEvent(new CustomEvent("stop", { detail: { id: nextClip.id } }));
            this.#currentlyPlayingAudioBuffer = null;
            this.#playNextClip();
        };
    }
}

================================================================================
// File: src/wrapper/HumeClient.ts
================================================================================
import { HumeClient as FernClient } from "../Client.js";
import * as core from "../core/index.js";
import { ExpressionMeasurement } from "./expressionMeasurement/ExpressionMeasurementClient.js";
import * as environments from "../environments.js";
import { SDK_VERSION } from "../version.js";

export declare namespace HumeClient {
    type Options = Omit<FernClient.Options, "environment"> & { accessToken?: string } & (
            | { accessToken: NonNullable<core.Supplier<string>> }
            | { apiKey: NonNullable<FernClient.Options["apiKey"]> }
        ) & {
            environment?: core.Supplier<environments.HumeEnvironment | environments.HumeEnvironmentUrls | string>;
        };
}

export class HumeClient extends FernClient {
    constructor(_options: HumeClient.Options) {
        let options: FernClient.Options;
        let oldEnvironment: HumeClient.Options["environment"];
        ({ environment: oldEnvironment, ...options } = _options || {});

        // Check if both accessToken and Authorization header are provided (case-insensitive)
        if (_options.accessToken && _options.headers) {
            const hasAuthHeader = Object.keys(_options.headers).some((key) => key.toLowerCase() === "authorization");
            if (hasAuthHeader) {
                throw new Error("Cannot provide both 'accessToken' and 'headers.Authorization'. Please use only one.");
            }
        }

        if (_options.accessToken) {
            options.headers = {
                ...options.headers,
                Authorization: core.Supplier.map(_options.accessToken, (token) => `Bearer ${token}`),
            };
        }

        // Add telemetry headers
        options.headers = {
            ...options.headers,
            "X-Hume-Client-Name": "typescript_sdk",
            "X-Hume-Client-Version": SDK_VERSION,
        };

        // Allow setting a single url http://... or https://... for environment'
        if (oldEnvironment) {
            const environment: FernClient.Options["environment"] = _options.environment
                ? core.Supplier.map(
                      _options.environment,
                      (e): environments.HumeEnvironment | environments.HumeEnvironmentUrls => {
                          if (typeof e === "string") {
                              if (e.startsWith("http://")) {
                                  return {
                                      base: e,
                                      evi: e.replace("http://", "ws://") + "/v0/evi",
                                      tts: e.replace("http://", "ws://") + "/v0/tts",
                                      stream: e.replace("http://", "ws://") + "/v0/stream",
                                  };
                              }
                              if (e.startsWith("https://")) {
                                  return {
                                      base: e,
                                      evi: e.replace("https://", "wss://") + "/v0/evi",
                                      tts: e.replace("https://", "wss://") + "/v0/tts",
                                      stream: e.replace("https://", "wss://") + "/v0/stream",
                                  };
                              }
                              return {
                                  base: "https://" + e,
                                  evi: "wss://" + e + "/v0/evi",
                                  tts: "wss://" + e + "/v0/tts",
                                  stream: "wss://" + e + "/v0/stream",
                              };
                          } else {
                              return e;
                          }
                      },
                  )
                : undefined;
            options.environment = environment;
        }

        super(options);
    }

    // We need to override this from FernClient to use the extended
    // `ExpressionMeasurement` from `wrapper` and not `api/resources/`
    protected _expressionMeasurement: ExpressionMeasurement | undefined;

    public get expressionMeasurement(): ExpressionMeasurement {
        return (this._expressionMeasurement ??= new ExpressionMeasurement(this._options));
    }
}

================================================================================
// File: src/wrapper/SilenceFiller.ts
================================================================================
/**
 * A minimal Writable-like interface that SilenceFiller can pipe to.
 * This matches the subset of Node.js Writable that we need.
 */
export interface PipeDestination {
    write(chunk: Uint8Array): boolean;
    end?(): void;
    on?(event: "drain", listener: () => void): this;
    once?(event: "drain", listener: () => void): this;
    removeListener?(event: "drain", listener: () => void): this;
}

type EventListener = (...args: unknown[]) => void;

/**
 * SilenceFiller is a pipeable stream that intersperses incoming audio data
 * with bytes of silence. This is important in some cases to keep an audio
 * stream "alive". Audio players, such as ffmpeg, can interpret inactivity as
 * meaning the stream is ended, or disconnected.
 *
 * This implementation does not depend on Node.js built-ins and can work in
 * any JavaScript environment, while still being pipeable to Node.js streams.
 *
 * @example
 * ```typescript
 * import { SilenceFiller } from 'hume';
 *
 * const BYTES_PER_SAMPLE = 2; // 16-bit samples
 * const SAMPLE_RATE = 48000;
 * const BUFFER_SIZE = Math.floor(SAMPLE_RATE * 0.1 * BYTES_PER_SAMPLE); // 100ms buffer
 * const silenceFiller = new SilenceFiller(BUFFER_SIZE, SAMPLE_RATE, BYTES_PER_SAMPLE, 10);
 *
 * // Pipe silence filler output to audio player stdin
 * silenceFiller.pipe(audioPlayer.stdin);
 *
 * // Handle pipe errors
 * silenceFiller.on('error', (err) => {
 *   console.error("SilenceFiller error:", err);
 * });
 *
 * // Write audio data as it arrives
 * silenceFiller.writeAudio(audioBuffer);
 *
 * // End the stream when done
 * await silenceFiller.endStream();
 * ```
 */
export class SilenceFiller {
    private unclockedSilenceFiller: UnclockedSilenceFiller;
    private isStarted: boolean = false;
    private pushIntervalId: ReturnType<typeof setInterval> | null = null;
    private bytesPerSample: number;
    private pushIntervalMs: number;
    private destination: PipeDestination | null = null;
    private eventListeners: Map<string, Set<EventListener>> = new Map();
    private ended: boolean = false;

    /**
     * Creates a new SilenceFiller instance.
     *
     * @param pushIntervalMs - The interval in milliseconds for pushing audio data (default: 5ms).
     * @param sampleRate - The sample rate of the audio (e.g., 48000).
     * @param bytesPerSample - The number of bytes per audio sample (e.g., 2 for 16-bit).
     * @param bufferSize - How much to 'prebuffer'. If you set this too low there
     * is a chance that playback will stutter, but if you set it too high
     * playback will take longer to start.
     */
    constructor(
        pushIntervalMs: number = 5,
        sampleRate: number = 48000,
        bytesPerSample: number = 2,
        bufferSize: number = 9600,
    ) {
        this.unclockedSilenceFiller = new UnclockedSilenceFiller(bufferSize, sampleRate, bytesPerSample);
        this.bytesPerSample = bytesPerSample;
        this.pushIntervalMs = pushIntervalMs;
    }

    /**
     * Pipes the output of this SilenceFiller to a writable destination.
     *
     * @param destination - The destination to pipe to (e.g., a Node.js Writable stream).
     * @returns The destination, for chaining.
     */
    pipe<T extends PipeDestination>(destination: T): T {
        this.destination = destination;
        return destination;
    }

    /**
     * Registers an event listener.
     *
     * @param event - The event name ('error', 'end').
     * @param listener - The listener function.
     * @returns This instance, for chaining.
     */
    on(event: string, listener: EventListener): this {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, new Set());
        }
        this.eventListeners.get(event)!.add(listener);
        return this;
    }

    /**
     * Registers a one-time event listener.
     *
     * @param event - The event name ('error', 'end').
     * @param listener - The listener function.
     * @returns This instance, for chaining.
     */
    once(event: string, listener: EventListener): this {
        const onceWrapper: EventListener = (...args: unknown[]) => {
            this.off(event, onceWrapper);
            listener(...args);
        };
        return this.on(event, onceWrapper);
    }

    /**
     * Removes an event listener.
     *
     * @param event - The event name.
     * @param listener - The listener function to remove.
     * @returns This instance, for chaining.
     */
    off(event: string, listener: EventListener): this {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            listeners.delete(listener);
        }
        return this;
    }

    /**
     * Emits an event to all registered listeners.
     *
     * @param event - The event name.
     * @param args - Arguments to pass to listeners.
     */
    private emit(event: string, ...args: unknown[]): void {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            for (const listener of listeners) {
                try {
                    listener(...args);
                } catch {
                    // Ignore errors in listeners
                }
            }
        }
    }

    /**
     * Writes audio data to the silence filler.
     *
     * @param audioBuffer - The audio buffer to write (Uint8Array or Buffer).
     */
    writeAudio(audioBuffer: Uint8Array): void {
        const now = Date.now();
        try {
            this.unclockedSilenceFiller.writeAudio(audioBuffer, now);
            if (!this.isStarted && this.unclockedSilenceFiller.donePrebuffering) {
                this.isStarted = true;
                this.startPushInterval();
            }
        } catch (error) {
            console.error(`[SilenceFiller] Error writing audio:`, error);
            this.emit("error", error);
        }
    }

    private startPushInterval(): void {
        this.pushIntervalId = setInterval(() => {
            this.pushData();
        }, this.pushIntervalMs);
    }

    private pushData(): void {
        if (!this.isStarted || !this.destination) return;

        try {
            const now = Date.now();
            const audioChunk = this.unclockedSilenceFiller.readAudio(now);

            if (audioChunk && audioChunk.length > 0) {
                // Ensure chunk size is aligned to bytesPerSample
                const alignedChunkSize = Math.floor(audioChunk.length / this.bytesPerSample) * this.bytesPerSample;

                if (alignedChunkSize > 0) {
                    const chunk = audioChunk.subarray(0, alignedChunkSize);
                    this.destination.write(chunk);
                }
            }
        } catch (error) {
            console.error(`[SilenceFiller] Error pushing data:`, error);
            this.emit("error", error);
        }
    }

    /**
     * Ends the stream and drains all remaining audio data.
     *
     * @returns A promise that resolves when the stream has ended.
     */
    endStream(): Promise<void> {
        return new Promise((resolve) => {
            if (this.ended) {
                resolve();
                return;
            }
            this.ended = true;

            // Stop pushing data
            if (this.pushIntervalId) {
                clearInterval(this.pushIntervalId);
                this.pushIntervalId = null;
            }

            // Drain all remaining audio from SilenceFiller
            const now = Date.now();

            // Keep reading until no more audio is available
            while (this.destination) {
                const remainingChunk = this.unclockedSilenceFiller.readAudio(now);

                if (!remainingChunk || remainingChunk.length === 0) {
                    break;
                }

                const alignedChunkSize = Math.floor(remainingChunk.length / this.bytesPerSample) * this.bytesPerSample;
                if (alignedChunkSize > 0) {
                    const chunk = remainingChunk.subarray(0, alignedChunkSize);
                    this.destination.write(chunk);
                }
            }

            this.emit("end");
            resolve();
        });
    }
}

/**
 * Does the actual calculation of how interspersing audio with silence
 * is "pure" in the sense that it does not rely on the system clock.
 * It's up to the caller to provide timestamps.
 *
 * @internal
 */
export class UnclockedSilenceFiller {
    private audioQueue: Uint8Array[] = [];
    private totalBufferedBytes: number = 0;
    private startTimestamp: number | null = null;
    private totalBytesSent: number = 0;
    public donePrebuffering: boolean = false;
    private bufferSize: number;
    private sampleRate: number;
    private bytesPerSample: number;

    constructor(bufferSize: number, sampleRate: number, bytesPerSample: number) {
        this.bufferSize = bufferSize;
        this.sampleRate = sampleRate;
        this.bytesPerSample = bytesPerSample;
    }

    writeAudio(audioBuffer: Uint8Array, timestamp: number): void {
        this.audioQueue.push(audioBuffer);
        this.totalBufferedBytes += audioBuffer.length;

        if (this.startTimestamp === null) {
            this.startTimestamp = timestamp;
        }

        if (!this.donePrebuffering && this.totalBufferedBytes >= this.bufferSize) {
            this.donePrebuffering = true;
        }
    }

    readAudio(timestamp: number): Uint8Array | null {
        if (this.startTimestamp === null || !this.donePrebuffering) {
            return null;
        }

        const elapsedMs = timestamp - this.startTimestamp;

        const targetBytesSent = Math.floor(((this.sampleRate * elapsedMs) / 1000) * this.bytesPerSample);

        const bytesNeeded = targetBytesSent - this.totalBytesSent;

        if (bytesNeeded <= 0) {
            return null;
        }

        // Ensure bytesNeeded is a multiple of bytesPerSample
        const alignedBytesNeeded = Math.floor(bytesNeeded / this.bytesPerSample) * this.bytesPerSample;

        if (alignedBytesNeeded <= 0) {
            return null;
        }

        let chunk = new Uint8Array(0);

        // Drain from queue until we have enough bytes
        while (chunk.length < alignedBytesNeeded && this.audioQueue.length > 0) {
            const nextBuffer = this.audioQueue.shift()!;
            chunk = concatUint8Arrays(chunk, nextBuffer);
            this.totalBufferedBytes -= nextBuffer.length;
        }

        // If we have more than needed, put the excess back
        if (chunk.length > alignedBytesNeeded) {
            const excess = chunk.subarray(alignedBytesNeeded);
            this.audioQueue.unshift(excess);
            this.totalBufferedBytes += excess.length;
            chunk = chunk.subarray(0, alignedBytesNeeded);
        }

        // Fill remaining with silence if needed
        if (chunk.length < alignedBytesNeeded) {
            const silenceNeeded = new Uint8Array(alignedBytesNeeded - chunk.length); // Uint8Array is zero-filled by default
            chunk = concatUint8Arrays(chunk, silenceNeeded);
        }

        // Update total bytes sent
        this.totalBytesSent += chunk.length;

        return chunk;
    }
}

/**
 * Concatenates two Uint8Arrays into a new Uint8Array.
 */
function concatUint8Arrays(a: Uint8Array, b: Uint8Array): Uint8Array {
    const result = new Uint8Array(a.length + b.length);
    result.set(a, 0);
    result.set(b, a.length);
    return result;
}

================================================================================
// File: src/wrapper/base64Decode.ts
================================================================================
export function base64Decode(str: string): string | Buffer {
    if (typeof Buffer === "function") {
        // Node.js environment
        return Buffer.from(str, "base64");
    } else if (typeof atob === "function") {
        // Browser environment
        return atob(str);
    } else {
        throw new Error("Base64 encoding not supported in this environment.");
    }
}

================================================================================
// File: src/wrapper/base64Encode.ts
================================================================================
export function base64Encode(str: string): string {
    if (typeof Buffer === "function") {
        // Node.js environment
        return Buffer.from(str).toString("base64");
    } else if (typeof btoa === "function") {
        // Browser environment
        return btoa(str);
    } else {
        throw new Error("Base64 encoding not supported in this environment.");
    }
}

================================================================================
// File: src/wrapper/checkForAudioTracks.ts
================================================================================
/**
 * @name checkForAudioTracks
 * @description
 * Check if a MediaStream has audio tracks.
 * @param stream
 * The MediaStream to check
 */
export const checkForAudioTracks = (stream: MediaStream): void => {
    const tracks = stream.getAudioTracks();

    if (tracks.length === 0) {
        throw new Error("No audio tracks");
    }
    if (tracks.length > 1) {
        throw new Error("Multiple audio tracks");
    }
    const track = tracks[0];
    if (!track) {
        throw new Error("No audio track");
    }
};

================================================================================
// File: src/wrapper/collate.ts
================================================================================
/**
 * Takes an async iterator that yields interleaved items from different groups
 * and produces an iterator that yields items in group order.
 *
 * Example:
 *   Input:  A1, B1, A2, A3 (final), C1, C2, C3 (final), B2 (final)
 *   Output: A1, A2, A3, B1, B2, C1, C2, C3
 *
 * This is useful when using synthesizeJsonStreaming with num_generations > 1
 *
 * @example
 * ```typescript
 *
 * import { collate } from 'hume';
 *
 * const stream = hume.synthesizeJsonStreaming({
 *   ...
 * })
 *
 * const contiguous = collate(
 *   stream
 *   (chunk) => chunk.generationId,
 *   (chunk) => chunk.isLastChunk
 * );
 *
 * for await (const item of contiguous) {
 *   audioPlayer.write(item.audio)
 * }
 * ```
 *
 * @param source - Async iterable that yields interleaved items.
 * @param groupBy - Function to determine a "key" that determines the group identity for each item.
 * @param isFinal - Function to determine if an item is the final item in its group.
 * @returns An async iterable that yields items in group order.
 */
export async function* collate<TItem, TKey>(
    source: AsyncIterable<TItem>,
    groupBy: (x: TItem) => TKey,
    isFinal: (x: TItem) => boolean,
): AsyncIterable<TItem> {
    const buffers = new Map<TKey, TItem[]>();
    const order: TKey[] = [];
    let current: TKey | undefined;

    const ensure = (k: TKey) => {
        if (!buffers.has(k)) {
            buffers.set(k, []);
            order.push(k);
        }
    };

    const flushGroup = function* (k: TKey) {
        const buf = buffers.get(k);
        if (!buf) return;
        for (const item of buf) yield item;
        buffers.delete(k);
    };

    const nextGroup = (): TKey | undefined => {
        // pop the next group in first-seen order that still has a buffer
        while (order.length && !buffers.has(order[0])) order.shift();
        return order.shift();
    };

    for await (const item of source) {
        const k = groupBy(item);

        if (current === undefined) current = k;
        ensure(k);
        buffers.get(k)!.push(item);

        // if we just saw the final item for the current group, flush it and advance
        if (k === current && isFinal(item)) {
            yield* flushGroup(current);
            current = nextGroup();
        }
    }

    // stream ended; flush remaining groups in first-seen order
    if (current !== undefined) {
        if (buffers.has(current)) yield* flushGroup(current);
        while (true) {
            const k = nextGroup();
            if (k === undefined) break;
            yield* flushGroup(k);
        }
    }
}

================================================================================
// File: src/wrapper/convertBase64ToBlob.ts
================================================================================
/**
 * Converts a base64-encoded string into a `Blob` object with the specified content type.
 *
 * @param {string} base64 - The base64-encoded string representing binary data.
 * @param {string} contentType - The MIME type to assign to the resulting `Blob`.
 * @returns {Blob} A `Blob` object containing the binary data from the base64 string.
 */
export function convertBase64ToBlob(base64: string, contentType?: string): Blob {
    // Decode base64 string to a binary string
    const binaryString = window.atob(base64);

    // Create a Uint8Array with the same length as the binary string
    const byteArray = new Uint8Array(binaryString.length);

    // Fill the Uint8Array by converting each character's Unicode value to a byte
    for (let i = 0; i < binaryString.length; i++) {
        byteArray[i] = binaryString.charCodeAt(i);
    }

    // Create and return a Blob with the specified content type
    return new Blob([byteArray], { type: contentType });
}

================================================================================
// File: src/wrapper/convertBlobToBase64.ts
================================================================================
/**
 * Converts a `Blob` object into a base64-encoded string.
 * The resulting string contains the binary data from the `Blob`.
 *
 * @param {Blob} blob - The `Blob` object to convert to base64.
 * @returns {Promise<string>} A promise that resolves to a base64-encoded string representing the `Blob` data.
 */
export function convertBlobToBase64(blob: Blob): Promise<string> {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();

        // Handle the load event which is triggered when readAsDataURL completes
        reader.onloadend = () => {
            // Ensure reader.result is not null and is a string
            if (typeof reader.result === "string") {
                // Extract the Base64 encoded string, skipping the data URL prefix (e.g., "data:image/png;base64,")
                const base64Data = reader.result.split(",")[1];
                if (base64Data) {
                    resolve(base64Data);
                } else {
                    reject(new Error("Failed to split the result into Base64 data."));
                }
            } else {
                reject(new Error("FileReader result is null or not a string."));
            }
        };

        // Handle errors during the read process
        reader.onerror = () => {
            reject(new Error(`Error reading blob: ${reader.error?.message}`));
        };

        // Initiate reading the blob as a data URL
        reader.readAsDataURL(blob);
    });
}

================================================================================
// File: src/wrapper/convertFrequencyScale.ts
================================================================================
// This function converts linear-scaled frequency decibels from an AnalyserNode's frequncy data to Bark scale [https://en.wikipedia.org/wiki/Bark_scale]
// This implementation uses a simple approach of mapping indices in the linear-scaled array to the closest
// Bark scale center frequency and is not intended to be an accurate representation, but rather "close-enough" for visualization purposes
const barkCenterFrequencies = [
    50, 150, 250, 350, 450, 570, 700, 840, 1000, 1170, 1370, 1600, 1850, 2150, 2500, 2900, 3400, 4000, 4800, 5800, 7000,
    8500, 10500, 13500,
]; // Center frequency value in Hz

// Min/max values from https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
const minValue = 0;
const maxValue = 255;

export function convertLinearFrequenciesToBark(linearData: Uint8Array, sampleRate: number): number[] {
    const maxFrequency = sampleRate / 2;
    const frequencyResolution = maxFrequency / linearData.length;

    const barkFrequencies = barkCenterFrequencies.map((barkFreq) => {
        const linearDataIndex = Math.round(barkFreq / frequencyResolution);
        if (linearDataIndex >= 0 && linearDataIndex < linearData.length) {
            return (((linearData[linearDataIndex] ?? 0) - minValue) / (maxValue - minValue)) * 2;
        } else {
            return 0;
        }
    });

    return barkFrequencies;
}

================================================================================
// File: src/wrapper/ensureSingleValidAudioTrack.ts
================================================================================
/**
 * Ensures that the given media stream contains exactly one valid audio track.
 * Throws an error if no audio tracks are found, if there is more than one audio track,
 * or if the sole audio track is falsy.
 *
 * @param {MediaStream} stream - The media stream object containing audio tracks to validate.
 * @throws {Error} "No audio tracks" if the stream contains zero audio tracks.
 * @throws {Error} "Multiple audio tracks" if the stream contains more than one audio track.
 * @throws {Error} "No audio track" if the sole audio track is falsy.
 */
export const ensureSingleValidAudioTrack = (stream: MediaStream): void => {
    const tracks = stream.getAudioTracks();

    if (tracks.length === 0) {
        throw new Error("No audio tracks available");
    } else if (tracks.length > 1) {
        throw new Error("Multiple audio tracks found");
    } else if (!tracks[0]) {
        throw new Error("The audio track is invalid");
    }
};

================================================================================
// File: src/wrapper/expressionMeasurement/ExpressionMeasurementClient.ts
================================================================================
import { ExpressionMeasurementClient as FernClient } from "../../api/resources/expressionMeasurement/client/Client.js";
import { BatchClient } from "./batch/BatchClient.js";
import { StreamClient } from "./streaming/StreamingClient.js";

export class ExpressionMeasurement extends FernClient {
    protected _batch: BatchClient | undefined;

    // BatchClient here is overridden from the generated version, we wrap expression measurement jobs in
    // a helper that makes it easier to await the result of a job.
    public get batch(): BatchClient {
        return (this._batch ??= new BatchClient(this._options));
    }

    // Streamclient here is an addition -- not present on the base FernClient.
    protected _stream: StreamClient | undefined;

    public get stream(): StreamClient {
        return (this._stream ??= new StreamClient(this._options));
    }
}

================================================================================
// File: src/wrapper/expressionMeasurement/batch/BatchClient.ts
================================================================================
import { BatchClient as FernClient } from "../../../api/resources/expressionMeasurement/resources/batch/client/Client.js";
import * as Hume from "../../../api/index.js";
import { Job } from "./Job.js";
import * as core from "../../../core/index.js";

export class BatchClient extends FernClient {
    // This just wraps the return value of the base class's `startInferenceJob` and `startInferenceJobFromLocalFile` methods
    // and returns a `Job` instance (has helper functions to await the job's result) instead of a raw job ID.
    public startInferenceJob(
        request: Hume.expressionMeasurement.batch.InferenceBaseRequest = {},
        requestOptions?: FernClient.RequestOptions,
    ): core.HttpResponsePromise<Job> {
        return core.HttpResponsePromise.fromPromise(
            super
                .startInferenceJob(request, requestOptions)
                .withRawResponse()
                .then((result) => {
                    return { data: new Job(result.data.jobId, this), rawResponse: result.rawResponse };
                }),
        );
    }

    public startInferenceJobFromLocalFile(
        request: Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest,
        requestOptions?: FernClient.RequestOptions,
    ): core.HttpResponsePromise<Job> {
        return core.HttpResponsePromise.fromPromise(
            super
                .startInferenceJobFromLocalFile(request, requestOptions)
                .withRawResponse()
                .then((result) => {
                    return { data: new Job(result.data.jobId, this), rawResponse: result.rawResponse };
                }),
        );
    }
}

================================================================================
// File: src/wrapper/expressionMeasurement/batch/Job.ts
================================================================================
import * as Hume from "../../../api/index.js";
import * as errors from "../../../errors/index.js";
import { BatchClient } from "./BatchClient.js";

export class Job implements Hume.expressionMeasurement.batch.JobId {
    constructor(
        public readonly jobId: string,
        private readonly client: BatchClient,
    ) {}

    public async awaitCompletion(timeoutInSeconds = 300): Promise<void> {
        return new Promise((resolve, reject) => {
            const poller = new JobCompletionPoller(this.jobId, this.client);
            poller.start(resolve);
            setTimeout(() => {
                poller.stop();
                reject(new errors.HumeTimeoutError("Timeout exceeded when polling for job completion"));
            }, timeoutInSeconds * 1_000);
        });
    }
}

class JobCompletionPoller {
    private isPolling = true;
    constructor(
        private readonly jobId: string,
        private readonly client: BatchClient,
    ) {}

    public start(onTerminal: () => void) {
        this.isPolling = true;
        this.poll(onTerminal);
    }

    public stop() {
        this.isPolling = false;
    }

    private async poll(onTerminal: () => void): Promise<void> {
        try {
            const jobDetails = await this.client.getJobDetails(this.jobId);
            if (jobDetails.state.status === "COMPLETED" || jobDetails.state.status === "FAILED") {
                onTerminal();
                this.stop();
            }
        } catch {
            // swallow errors while polling
        }

        if (this.isPolling) {
            setTimeout(() => this.poll(onTerminal), 1_000);
        }
    }
}

================================================================================
// File: src/wrapper/expressionMeasurement/streaming/StreamSocket.ts
================================================================================
import WebSocket from "ws";
import { v4 as uuid } from "uuid";
import { parse } from "./StreamingClient.js";
import { base64Encode } from "../../base64Encode.js";
import * as Hume from "../../../api/index.js";
import * as errors from "../../../errors/index.js";
import * as serializers from "../../../serialization/index.js";
import * as fs from "fs";

export declare namespace StreamSocket {
    interface Args {
        websocket: WebSocket;
        config: Hume.expressionMeasurement.stream.Config;
        streamWindowMs?: number;
    }
}

export class StreamSocket {
    readonly websocket: WebSocket;
    private readonly streamWindowMs?: number;
    private config: Hume.expressionMeasurement.stream.Config;

    constructor({ websocket, config, streamWindowMs }: StreamSocket.Args) {
        this.websocket = websocket;
        this.config = config;
        this.streamWindowMs = streamWindowMs;
    }

    /**
     * Send file on the `StreamSocket`
     *
     * @param file A fs.ReadStream | File | Blob
     * @param config This method is intended for use with a `LanguageConfig`.
     * When the socket is configured for other modalities this method will fail.
     */
    public async sendFile({
        file,
        config,
    }: {
        file: fs.ReadStream | Blob;
        config?: Hume.expressionMeasurement.stream.Config;
    }): Promise<Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage> {
        if (config != null) {
            this.config = config;
        }
        let contents = "";
        if (file instanceof fs.ReadStream) {
            const chunks: Buffer[] = [];
            for await (const chunk of file) {
                chunks.push(Buffer.from(chunk));
            }
            contents = Buffer.concat(chunks).toString("base64");
        } else if (file instanceof Blob) {
            const toBase64 = (file: Blob): Promise<string> =>
                new Promise((res) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => res(reader.result as string);
                });
            contents = await toBase64(file);
        } else {
            throw new errors.HumeError({
                message: `file must be one of ReadStream or Blob.`,
            });
        }
        const request: Hume.expressionMeasurement.stream.StreamModelsEndpointPayload = {
            payloadId: uuid(),
            data: contents,
            models: this.config,
            rawText: false,
        };
        if (this.streamWindowMs != null) {
            request.streamWindowMs = this.streamWindowMs;
        }
        const response = await this.send(request);
        if (response == null) {
            throw new errors.HumeError({
                message: `Received no response after sending file: ${file}`,
            });
        }
        return response;
    }

    /**
     * Send text on the `StreamSocket`
     *
     * @param text Text to send to the language model.
     * @param config This method is intended for use with a `LanguageConfig`.
     * When the socket is configured for other modalities this method will fail.
     */
    public async sendText({
        text,
        config,
    }: {
        text: string;
        config?: Hume.expressionMeasurement.stream.Config;
    }): Promise<Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage> {
        if (config != null) {
            this.config = config;
        }
        const request: Hume.expressionMeasurement.stream.StreamModelsEndpointPayload = {
            payloadId: uuid(),
            data: text,
            rawText: true,
            models: this.config,
        };
        if (this.streamWindowMs != null) {
            request.streamWindowMs = this.streamWindowMs;
        }
        const response = await this.send(request);
        if (response == null) {
            throw new errors.HumeError({
                message: `Received no response after sending text: ${text}`,
            });
        }
        return response;
    }

    /**
     * Send facemesh landmarks on the `StreamSocket`
     *
     * @param landmarks List of landmark points for multiple faces.
     * The shape of this 3-dimensional list should be (n, 478, 3) where n is the number
     * of faces to be processed, 478 is the number of MediaPipe landmarks per face and 3
     * represents the (x, y, z) coordinates of each landmark.
     * @param config List of model configurations.
     * If set these configurations will overwrite existing configurations
     */
    public async sendFacemesh({
        landmarks,
        config,
    }: {
        landmarks: number[][][];
        config?: Hume.expressionMeasurement.stream.Config;
    }): Promise<Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage> {
        const response = this.sendText({
            text: base64Encode(JSON.stringify(landmarks)),
            config,
        });
        return response;
    }

    /**
     *
     * Reset the streaming sliding window.
     *
     * Call this method when some media has been fully processed and you want to continue using the same
     * streaming connection without leaking context across media samples.
     */
    public async reset(): Promise<void> {
        await this.send({
            resetStream: true,
        });
    }

    /**
     *
     * Get details associated with the current streaming connection.
     *
     */
    public async getJobDetails(): Promise<void> {
        await this.send({
            jobDetails: true,
        });
    }

    /**
     * Closes the underlying socket.
     */
    public close(): void {
        this.websocket.close();
    }

    private async send(
        payload: Hume.expressionMeasurement.stream.StreamModelsEndpointPayload,
    ): Promise<Hume.expressionMeasurement.stream.Config | void> {
        await this.tillSocketOpen();
        const jsonPayload = serializers.expressionMeasurement.stream.StreamModelsEndpointPayload.jsonOrThrow(payload, {
            unrecognizedObjectKeys: "strip",
        });
        this.websocket.send(JSON.stringify(jsonPayload));
        const response = await new Promise<
            Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage | undefined
        >((resolve) => {
            this.websocket.addEventListener("message", (event) => {
                const response = parse(event.data);
                resolve(response);
            });
        });
        if (response != null && isError(response)) {
            throw new errors.HumeError({
                message: `CODE ${response.code}: ${response.error}`,
            });
        }
        return response;
    }

    private async tillSocketOpen(): Promise<WebSocket> {
        if (this.websocket.readyState === WebSocket.OPEN) {
            return this.websocket;
        }
        return new Promise((resolve, reject) => {
            this.websocket.addEventListener("open", () => {
                resolve(this.websocket);
            });

            this.websocket.addEventListener("error", (event) => {
                reject(event);
            });
        });
    }
}

function isError(
    response: Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage,
): response is Hume.expressionMeasurement.stream.StreamErrorMessage {
    return (response as Hume.expressionMeasurement.stream.StreamErrorMessage).error != null;
}

================================================================================
// File: src/wrapper/expressionMeasurement/streaming/StreamingClient.ts
================================================================================
import * as Hume from "../../../api/index.js";
import * as serializers from "../../../serialization/index.js";
import * as core from "../../../core/index.js";
import { StreamSocket } from "./StreamSocket.js";
import WebSocket from "ws";

export declare namespace StreamClient {
    interface Options {
        apiKey?: core.Supplier<string | undefined>;
    }

    interface ConnectArgs {
        /* Job config */
        config: Hume.expressionMeasurement.stream.Config;
        /* Length of the sliding window in milliseconds to use when 
            aggregating media across streaming payloads within one WebSocket connection. */
        streamWindowMs?: number;

        onOpen?: (event: WebSocket.Event) => void;
        onMessage?: (message: Hume.expressionMeasurement.stream.Config) => void;
        onError?: (error: Hume.expressionMeasurement.stream.StreamErrorMessage) => void;
        onClose?: (event: WebSocket.Event) => void;
    }
}

export class StreamClient {
    constructor(protected readonly _options: StreamClient.Options) {}

    public connect(args: StreamClient.ConnectArgs): StreamSocket {
        const websocket = new WebSocket(`wss://api.hume.ai/v0/stream/models`, {
            headers: {
                "X-Hume-Api-Key": typeof this._options.apiKey === "string" ? this._options.apiKey : "",
            },
            timeout: 10,
        });

        websocket.addEventListener("open", (event) => {
            args.onOpen?.(event);
        });

        websocket.addEventListener("error", (e) => {
            args.onError?.({
                code: e.type,
                error: e.message,
            });
        });

        websocket.addEventListener("message", async ({ data }) => {
            parse(data, {
                onMessage: args.onMessage,
                onError: args.onError,
            });
        });

        websocket.addEventListener("close", (event) => {
            args.onClose?.(event);
        });

        return new StreamSocket({
            websocket,
            streamWindowMs: args.streamWindowMs,
            config: args.config,
        });
    }
}

export function parse(
    data: WebSocket.Data,
    args: {
        onMessage?: (message: Hume.expressionMeasurement.stream.Config) => void;
        onError?: (error: Hume.expressionMeasurement.stream.StreamErrorMessage) => void;
    } = {},
): Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage | undefined {
    const message = JSON.parse(data as string);

    const parsedResponse = serializers.expressionMeasurement.stream.Config.parse(message, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true,
        breadcrumbsPrefix: ["response"],
    });
    if (parsedResponse.ok) {
        args.onMessage?.(parsedResponse.value);
        return parsedResponse.value;
    }

    const parsedError = serializers.expressionMeasurement.stream.StreamErrorMessage.parse(message, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true,
        breadcrumbsPrefix: ["response"],
    });
    if (parsedError.ok) {
        args.onError?.(parsedError.value);
        return parsedError.value;
    }
}

================================================================================
// File: src/wrapper/fetchAccessToken.ts
================================================================================
import { base64Encode } from "./base64Encode.js";
import { z } from "zod";

/**
 * Fetches a new access token from the Hume API using the provided API key and Secret key.
 *
 * @param args - The arguments for the request.
 * @example
 * ```typescript
 * async function getToken() {
 *   const accessToken = await fetchAccessToken({
 *     apiKey: 'test',
 *     secretKey: 'test',
 *   });
 *
 *   console.log(accessToken); // Outputs the access token
 * }
 * ```
 */
export const fetchAccessToken = async ({
    apiKey,
    secretKey,
    host = "api.hume.ai",
}: {
    apiKey: string;
    secretKey: string;
    host?: string;
}): Promise<string> => {
    const authString = `${apiKey}:${secretKey}`;
    const encoded = base64Encode(authString);

    const res = await fetch(`https://${host}/oauth2-cc/token`, {
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            Authorization: `Basic ${encoded}`,
        },
        body: new URLSearchParams({
            grant_type: "client_credentials",
        }).toString(),
    });
    if (!res.ok) {
        throw new Error(`Failed to fetch access token: (${res.status} ${res.statusText})\n ${await res.text()}`);
    }
    return z
        .object({
            access_token: z.string(),
        })
        .transform((data) => {
            return data.access_token;
        })
        .parse(await res.json());
};

================================================================================
// File: src/wrapper/generateEmptyFft.ts
================================================================================
export function generateEmptyFft(): number[] {
    return Array.from({ length: 24 }).map(() => 0);
}

================================================================================
// File: src/wrapper/getAudioStream.ts
================================================================================
export type AudioStreamOptions = {
    echoCancellation?: boolean;
    noiseSuppression?: boolean;
    autoGainControl?: boolean;
};

/**
 * Requests an audio stream from the user's device using the `getUserMedia` API.
 * The stream will have echo cancellation, noise suppression, and auto gain control enabled.
 *
 * @returns {Promise<MediaStream>} A promise that resolves to a `MediaStream` containing audio data only.
 * @throws {DOMException} If the user denies access or no audio input devices are found.
 */
export const getAudioStream = async (audioStreamOptions: AudioStreamOptions = {}): Promise<MediaStream> => {
    const { echoCancellation = true, noiseSuppression = true, autoGainControl = true } = audioStreamOptions;
    return navigator.mediaDevices.getUserMedia({
        audio: {
            echoCancellation,
            noiseSuppression,
            autoGainControl,
        },
        video: false,
    });
};

================================================================================
// File: src/wrapper/getBrowserSupportedMimeType.ts
================================================================================
/**
 * Enum representing the supported MIME types for audio recording.
 */
export enum MimeType {
    WEBM = "audio/webm",
    MP4 = "audio/mp4",
    WAV = "audio/wav",
}

/**
 * Represents a successful result where a compatible MIME type was found.
 * @property {true} success - Indicates a successful result.
 * @property {MimeType} mimeType - The MIME type supported by the browser.
 */
type MimeTypeSuccessResult = { success: true; mimeType: MimeType };

/**
 * Represents a failure result when no compatible MIME type is supported or an error occurs.
 * @property {false} success - Indicates a failure result.
 * @property {Error} error - The error explaining why a compatible MIME type was not found.
 */
type MimeTypeFailureResult = { success: false; error: Error };

/**
 * Union type representing the possible outcomes of checking for a supported MIME type.
 * Could either be a successful or failure result.
 */
type MimeTypeResult = MimeTypeSuccessResult | MimeTypeFailureResult;

/**
 * Checks whether the `MediaRecorder` API is supported in the current environment.
 *
 * @returns {boolean} Returns `true` if the `MediaRecorder` API is supported, otherwise `false`.
 */
function isMediaRecorderSupported(): boolean {
    return typeof MediaRecorder !== "undefined";
}

/**
 * Finds and returns the first MIME type from the given array that is supported by the `MediaRecorder`.
 *
 * @param {MimeType[]} mimeTypes - An array of MIME types to check for compatibility.
 * @returns {MimeType | null} The first supported MIME type or `null` if none are supported.
 */
function getSupportedMimeType(mimeTypes: MimeType[]): MimeType | null {
    return mimeTypes.find((type) => MediaRecorder.isTypeSupported(type)) || null;
}

/**
 * Determines if the current browser supports any of the predefined audio MIME types
 * (WEBM, MP4, or WAV) via the `MediaRecorder` API.
 *
 * @returns {MimeTypeResult} An object containing the success status and either a supported MIME type or an error.
 * @throws {Error} If the `MediaRecorder` API is not supported by the browser or no compatible types are found.
 */
export function getBrowserSupportedMimeType(): MimeTypeResult {
    // Check if the MediaRecorder API is supported in the current environment.
    if (!isMediaRecorderSupported()) {
        return {
            success: false,
            error: new Error("MediaRecorder is not supported"),
        };
    }

    const COMPATIBLE_MIME_TYPES = [MimeType.WEBM, MimeType.MP4, MimeType.WAV];

    // Find the first compatible MIME type that the browser's MediaRecorder supports.
    const supportedMimeType = getSupportedMimeType(COMPATIBLE_MIME_TYPES);

    // If no compatible MIME type is found, return a failure result with an appropriate error message.
    if (!supportedMimeType) {
        return {
            success: false,
            error: new Error("Browser does not support any compatible mime types"),
        };
    }

    // If a compatible MIME type is found, return a success result with the supported MIME type.
    return {
        success: true,
        mimeType: supportedMimeType,
    };
}

================================================================================
// File: src/wrapper/index.ts
================================================================================
export { base64Decode } from "./base64Decode.js";
export { base64Encode } from "./base64Encode.js";
export { convertBase64ToBlob } from "./convertBase64ToBlob.js";
export { convertBlobToBase64 } from "./convertBlobToBase64.js";
export { ensureSingleValidAudioTrack } from "./ensureSingleValidAudioTrack.js";
export { checkForAudioTracks } from "./checkForAudioTracks.js";
export { fetchAccessToken } from "./fetchAccessToken.js";
export { getAudioStream } from "./getAudioStream.js";
export { MimeType, getBrowserSupportedMimeType } from "./getBrowserSupportedMimeType.js";
export { HumeClient } from "./HumeClient.js";
export { ExpressionMeasurement } from "./expressionMeasurement/ExpressionMeasurementClient.js";
export { EVIWebAudioPlayer } from "./EVIWebAudioPlayer.js";
export type { EVIWebAudioPlayerFFTOptions, EVIWebAudioPlayerOptions } from "./EVIWebAudioPlayer.js";
export { collate } from "./collate.js";
export { SilenceFiller } from "./SilenceFiller.js";
export type { PipeDestination } from "./SilenceFiller.js";

/**
 * @deprecated SilenceFiller no longer requires dynamic import. Use `import { SilenceFiller } from 'hume'` directly.
 */
export const createSilenceFiller = async (): Promise<typeof import("./SilenceFiller.js").SilenceFiller> => {
    const { SilenceFiller } = await import("./SilenceFiller.js");
    return SilenceFiller;
};

================================================================================
// File: tsconfig.base.json
================================================================================
{
    "compilerOptions": {
        "extendedDiagnostics": true,
        "strict": true,
        "target": "ES6",
        "moduleResolution": "node",
        "esModuleInterop": true,
        "skipLibCheck": true,
        "declaration": true,
        "outDir": "dist",
        "rootDir": "src",
        "baseUrl": "src",
        "isolatedModules": true,
        "isolatedDeclarations": true
    },
    "include": ["src"],
    "exclude": []
}

================================================================================
// File: tsconfig.cjs.json
================================================================================
{
    "extends": "./tsconfig.base.json",
    "compilerOptions": {
        "module": "CommonJS",
        "outDir": "dist/cjs"
    },
    "include": ["src"],
    "exclude": []
}

================================================================================
// File: tsconfig.dev.json
================================================================================
{
    "extends": "./tsconfig.json",
    "include": ["src/**/*.ts", "src/**/*.js", "tests", "eslint.config.mjs", "jest.config.mjs"],
    "exclude": ["dist"]
}

================================================================================
// File: tsconfig.esm.json
================================================================================
{
    "extends": "./tsconfig.base.json",
    "compilerOptions": {
        "module": "esnext",
        "outDir": "dist/esm",
        "verbatimModuleSyntax": true
    },
    "include": ["src"],
    "exclude": []
}

================================================================================
// File: vitest.config.mts
================================================================================
import { defineConfig } from "vitest/config";
export default defineConfig({
    test: {
        projects: [
            {
                test: {
                    globals: true,
                    name: "unit",
                    environment: "node",
                    root: "./tests",
                    include: ["**/*.test.{js,ts,jsx,tsx}"],
                    exclude: ["wire/**"],
                    setupFiles: ["./setup.ts"],
                },
            },
            {
                test: {
                    globals: true,
                    name: "wire",
                    environment: "node",
                    root: "./tests/wire",
                    setupFiles: ["../setup.ts", "../mock-server/setup.ts"],
                },
            },
        ],
        passWithNoTests: true,
    },
});

