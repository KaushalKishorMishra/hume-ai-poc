This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where line numbers have been added, content has been formatted for parsing in markdown style.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Content has been formatted for parsing in markdown style
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.fern/
  metadata.json
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
  workflows/
    ci.yml
    publish.yml
    test-examples-dependabot.yml
  dependabot.yml
scripts/
  rename-to-esm-files.js
src/
  api/
    resources/
      empathicVoice/
        client/
          Client.ts
          index.ts
        errors/
          BadRequestError.ts
          index.ts
          UnprocessableEntityError.ts
        resources/
          chat/
            client/
              Client.ts
              Client.ts.diff
              index.ts
              index.ts.diff
              Socket.ts
              Socket.ts.diff
            types/
              index.ts
              PublishEvent.ts
              SubscribeEvent.ts
            index.ts
            index.ts.diff
          chatGroups/
            client/
              requests/
                ChatGroupsGetAudioRequest.ts
                ChatGroupsGetChatGroupRequest.ts
                ChatGroupsListChatGroupEventsRequest.ts
                ChatGroupsListChatGroupsRequest.ts
                index.ts
              Client.ts
              index.ts
            index.ts
          chats/
            client/
              requests/
                ChatsListChatEventsRequest.ts
                ChatsListChatsRequest.ts
                index.ts
              Client.ts
              index.ts
            index.ts
          configs/
            client/
              requests/
                ConfigsListConfigsRequest.ts
                ConfigsListConfigVersionsRequest.ts
                index.ts
                PostedConfig.ts
                PostedConfigName.ts
                PostedConfigVersion.ts
                PostedConfigVersionDescription.ts
              Client.ts
              index.ts
            index.ts
          controlPlane/
            client/
              Client.ts
              Client.ts.diff
              index.ts
              Socket.ts
            index.ts
          prompts/
            client/
              requests/
                index.ts
                PostedPrompt.ts
                PostedPromptName.ts
                PostedPromptVersion.ts
                PostedPromptVersionDescription.ts
                PromptsListPromptsRequest.ts
                PromptsListPromptVersionsRequest.ts
              Client.ts
              index.ts
            index.ts
          tools/
            client/
              requests/
                index.ts
                PostedUserDefinedTool.ts
                PostedUserDefinedToolName.ts
                PostedUserDefinedToolVersion.ts
                PostedUserDefinedToolVersionDescription.ts
                ToolsListToolsRequest.ts
                ToolsListToolVersionsRequest.ts
              Client.ts
              index.ts
            index.ts
          index.ts
        types/
          AssistantEnd.ts
          AssistantInput.ts
          AssistantMessage.ts
          AssistantProsody.ts
          AudioConfiguration.ts
          AudioInput.ts
          AudioOutput.ts
          BuiltInTool.ts
          BuiltinToolConfig.ts
          ChatMessage.ts
          ChatMessageToolResult.ts
          ChatMetadata.ts
          ConnectSessionSettings.ts
          ConnectSessionSettingsAudio.ts
          ConnectSessionSettingsContext.ts
          ConnectSessionSettingsVariablesValue.ts
          Context.ts
          ContextType.ts
          ControlPlanePublishEvent.ts
          EmotionScores.ts
          Encoding.ts
          ErrorLevel.ts
          ErrorResponse.ts
          HttpValidationError.ts
          index.ts
          Inference.ts
          JsonMessage.ts
          LanguageModelType.ts
          MillisecondInterval.ts
          ModelProviderEnum.ts
          PauseAssistantMessage.ts
          PostedBuiltinTool.ts
          PostedBuiltinToolName.ts
          PostedConfigPromptSpec.ts
          PostedEllmModel.ts
          PostedEventMessageSpec.ts
          PostedEventMessageSpecs.ts
          PostedLanguageModel.ts
          PostedNudgeSpec.ts
          PostedTimeoutSpec.ts
          PostedTimeoutSpecs.ts
          PostedTimeoutSpecsInactivity.ts
          PostedTimeoutSpecsMaxDuration.ts
          PostedUserDefinedToolSpec.ts
          PostedWebhookEventType.ts
          PostedWebhookSpec.ts
          ProsodyInference.ts
          ResumeAssistantMessage.ts
          ReturnBuiltinTool.ts
          ReturnBuiltinToolToolType.ts
          ReturnChat.ts
          ReturnChatAudioReconstruction.ts
          ReturnChatAudioReconstructionStatus.ts
          ReturnChatEvent.ts
          ReturnChatEventRole.ts
          ReturnChatEventType.ts
          ReturnChatGroup.ts
          ReturnChatGroupPagedAudioReconstructions.ts
          ReturnChatGroupPagedAudioReconstructionsPaginationDirection.ts
          ReturnChatGroupPagedChats.ts
          ReturnChatGroupPagedChatsPaginationDirection.ts
          ReturnChatGroupPagedEvents.ts
          ReturnChatGroupPagedEventsPaginationDirection.ts
          ReturnChatPagedEvents.ts
          ReturnChatPagedEventsPaginationDirection.ts
          ReturnChatPagedEventsStatus.ts
          ReturnChatStatus.ts
          ReturnConfig.ts
          ReturnConfigSpec.ts
          ReturnEllmModel.ts
          ReturnEventMessageSpec.ts
          ReturnEventMessageSpecs.ts
          ReturnLanguageModel.ts
          ReturnNudgeSpec.ts
          ReturnPagedChatGroups.ts
          ReturnPagedChatGroupsPaginationDirection.ts
          ReturnPagedChats.ts
          ReturnPagedChatsPaginationDirection.ts
          ReturnPagedConfigs.ts
          ReturnPagedPrompts.ts
          ReturnPagedUserDefinedTools.ts
          ReturnPrompt.ts
          ReturnPromptVersionType.ts
          ReturnTimeoutSpec.ts
          ReturnTimeoutSpecs.ts
          ReturnUserDefinedTool.ts
          ReturnUserDefinedToolToolType.ts
          ReturnUserDefinedToolVersionType.ts
          ReturnVoice.ts
          ReturnWebhookEventType.ts
          ReturnWebhookSpec.ts
          Role.ts
          SessionSettings.ts
          SessionSettingsVariablesValue.ts
          SubscribeEvent.ts
          Tool.ts
          ToolCallMessage.ts
          ToolErrorMessage.ts
          ToolResponseMessage.ts
          ToolType.ts
          UserInput.ts
          UserInterruption.ts
          UserMessage.ts
          ValidationError.ts
          ValidationErrorLocItem.ts
          VoiceId.ts
          VoiceName.ts
          VoiceProvider.ts
          VoiceRef.ts
          WebhookEvent.ts
          WebhookEventBase.ts
          WebhookEventChatEnded.ts
          WebhookEventChatStarted.ts
          WebhookEventChatStartType.ts
          WebhookEventChatStatus.ts
          WebhookEventToolCall.ts
          WebSocketError.ts
        index.ts
      expressionMeasurement/
        client/
          Client.ts
          index.ts
        resources/
          batch/
            client/
              requests/
                BatchListJobsRequest.ts
                BatchStartInferenceJobFromLocalFileRequest.ts
                index.ts
              Client.ts
              index.ts
            types/
              Alternative.ts
              Bcp47Tag.ts
              BoundingBox.ts
              BurstPrediction.ts
              Classification.ts
              CompletedEmbeddingGeneration.ts
              CompletedInference.ts
              CompletedState.ts
              CompletedTlInference.ts
              CompletedTraining.ts
              CustomModel.ts
              CustomModelId.ts
              CustomModelPrediction.ts
              CustomModelRequest.ts
              CustomModelsInferenceJob.ts
              CustomModelsTrainingJob.ts
              CustomModelVersionId.ts
              Dataset.ts
              DatasetId.ts
              DatasetVersionId.ts
              DescriptionsScore.ts
              Direction.ts
              EmbeddingGenerationBaseRequest.ts
              EmbeddingGenerationJob.ts
              EmotionScore.ts
              Error_.ts
              EvaluationArgs.ts
              Face.ts
              FacemeshPrediction.ts
              FacePrediction.ts
              FacsScore.ts
              Failed.ts
              FailedState.ts
              File_.ts
              Granularity.ts
              GroupedPredictionsBurstPrediction.ts
              GroupedPredictionsFacemeshPrediction.ts
              GroupedPredictionsFacePrediction.ts
              GroupedPredictionsLanguagePrediction.ts
              GroupedPredictionsNerPrediction.ts
              GroupedPredictionsProsodyPrediction.ts
              index.ts
              InferenceBaseRequest.ts
              InferenceJob.ts
              InferencePrediction.ts
              InferenceRequest.ts
              InferenceResults.ts
              InferenceSourcePredictResult.ts
              InProgress.ts
              InProgressState.ts
              JobEmbeddingGeneration.ts
              JobId.ts
              JobInference.ts
              JobTlInference.ts
              JobTraining.ts
              Language.ts
              LanguagePrediction.ts
              Models.ts
              ModelsPredictions.ts
              Ner.ts
              NerPrediction.ts
              Null.ts
              PositionInterval.ts
              PredictionsOptionalNullBurstPrediction.ts
              PredictionsOptionalNullFacemeshPrediction.ts
              PredictionsOptionalNullFacePrediction.ts
              PredictionsOptionalTranscriptionMetadataLanguagePrediction.ts
              PredictionsOptionalTranscriptionMetadataNerPrediction.ts
              PredictionsOptionalTranscriptionMetadataProsodyPrediction.ts
              Prosody.ts
              ProsodyPrediction.ts
              Queued.ts
              QueuedState.ts
              RegistryFileDetail.ts
              Regression.ts
              SentimentScore.ts
              SortBy.ts
              Source.ts
              SourceFile.ts
              SourceTextSource.ts
              SourceUrl.ts
              StateEmbeddingGeneration.ts
              StateEmbeddingGenerationCompletedEmbeddingGeneration.ts
              StateEmbeddingGenerationFailed.ts
              StateEmbeddingGenerationInProgress.ts
              StateEmbeddingGenerationQueued.ts
              StateInference.ts
              StateTlInference.ts
              StateTlInferenceCompletedTlInference.ts
              StateTlInferenceFailed.ts
              StateTlInferenceInProgress.ts
              StateTlInferenceQueued.ts
              StateTraining.ts
              StateTrainingCompletedTraining.ts
              StateTrainingFailed.ts
              StateTrainingInProgress.ts
              StateTrainingQueued.ts
              Status.ts
              Tag.ts
              Target.ts
              Task.ts
              TaskClassification.ts
              TaskRegression.ts
              TextSource.ts
              TimeInterval.ts
              TlInferenceBaseRequest.ts
              TlInferencePrediction.ts
              TlInferenceResults.ts
              TlInferenceSourcePredictResult.ts
              ToxicityScore.ts
              TrainingBaseRequest.ts
              TrainingCustomModel.ts
              Transcription.ts
              TranscriptionMetadata.ts
              Type.ts
              Unconfigurable.ts
              UnionJob.ts
              UnionPredictResult.ts
              Url.ts
              ValidationArgs.ts
              When.ts
              Window.ts
            index.ts
          stream/
            resources/
              stream/
                client/
                  Client.ts
                  index.ts
                  Socket.ts
                types/
                  Config.ts
                  index.ts
                  JobDetails.ts
                  StreamErrorMessage.ts
                  StreamFace.ts
                  StreamLanguage.ts
                  StreamModelPredictions.ts
                  StreamModelPredictionsBurst.ts
                  StreamModelPredictionsBurstPredictionsItem.ts
                  StreamModelPredictionsFace.ts
                  StreamModelPredictionsFacemesh.ts
                  StreamModelPredictionsFacemeshPredictionsItem.ts
                  StreamModelPredictionsFacePredictionsItem.ts
                  StreamModelPredictionsJobDetails.ts
                  StreamModelPredictionsLanguage.ts
                  StreamModelPredictionsLanguagePredictionsItem.ts
                  StreamModelPredictionsProsody.ts
                  StreamModelPredictionsProsodyPredictionsItem.ts
                  StreamModelsEndpointPayload.ts
                  StreamWarningMessage.ts
                  StreamWarningMessageJobDetails.ts
                  SubscribeEvent.ts
                index.ts
              index.ts
            types/
              EmotionEmbedding.ts
              EmotionEmbeddingItem.ts
              index.ts
              Sentiment.ts
              SentimentItem.ts
              StreamBoundingBox.ts
              TextPosition.ts
              TimeRange.ts
              Toxicity.ts
              ToxicityItem.ts
            index.ts
          index.ts
        index.ts
      tts/
        client/
          requests/
            ConvertVoiceFileRequest.ts
            ConvertVoiceJsonRequest.ts
            index.ts
          Client.ts
          index.ts
        errors/
          BadRequestError.ts
          index.ts
          UnprocessableEntityError.ts
        resources/
          streamInput/
            client/
              Client.ts
              Client.ts.diff
              index.ts
              Socket.ts
            index.ts
          voices/
            client/
              requests/
                index.ts
                PostedVoice.ts
                VoicesDeleteRequest.ts
                VoicesListRequest.ts
              Client.ts
              index.ts
            index.ts
          index.ts
        types/
          AudioEncoding.ts
          AudioFormatType.ts
          ErrorResponse.ts
          Format.ts
          FormatMp3.ts
          FormatPcm.ts
          FormatWav.ts
          HttpValidationError.ts
          index.ts
          MillisecondInterval.ts
          OctaveVersion.ts
          PostedContext.ts
          PostedContextWithGenerationId.ts
          PostedContextWithUtterances.ts
          PostedTts.ts
          PostedUtterance.ts
          PostedUtteranceVoice.ts
          PostedUtteranceVoiceWithId.ts
          PostedUtteranceVoiceWithName.ts
          PublishTts.ts
          ReturnGeneration.ts
          ReturnPagedVoices.ts
          ReturnTts.ts
          ReturnVoice.ts
          Snippet.ts
          SnippetAudioChunk.ts
          Timestamp.ts
          TimestampMessage.ts
          TimestampType.ts
          TtsOutput.ts
          ValidationError.ts
          ValidationErrorLocItem.ts
          VoiceProvider.ts
        index.ts
      index.ts
    index.ts
  auth/
    HeaderAuthProvider.ts
    HeaderAuthProvider.ts.diff
    index.ts
  core/
    auth/
      AuthProvider.ts
      AuthRequest.ts
      BasicAuth.ts
      BearerToken.ts
      index.ts
      NoOpAuthProvider.ts
    fetcher/
      APIResponse.ts
      BinaryResponse.ts
      createRequestUrl.ts
      EndpointMetadata.ts
      EndpointSupplier.ts
      Fetcher.ts
      getErrorResponseBody.ts
      getFetchFn.ts
      getHeader.ts
      getRequestBody.ts
      getResponseBody.ts
      Headers.ts
      HttpResponsePromise.ts
      index.ts
      makeRequest.ts
      RawResponse.ts
      requestWithRetries.ts
      signals.ts
      Supplier.ts
      Supplier.ts.diff
    file/
      exports.ts
      file.ts
      index.ts
      types.ts
    form-data-utils/
      encodeAsFormParameter.ts
      FormDataWrapper.ts
      index.ts
    logging/
      exports.ts
      index.ts
      logger.ts
    pagination/
      CustomPager.ts
      exports.ts
      index.ts
      Page.ts
    runtime/
      index.ts
      runtime.ts
    schemas/
      builders/
        bigint/
          bigint.ts
          index.ts
        date/
          date.ts
          index.ts
        enum/
          enum.ts
          index.ts
        lazy/
          index.ts
          lazy.ts
          lazyObject.ts
        list/
          index.ts
          list.ts
        literals/
          booleanLiteral.ts
          index.ts
          stringLiteral.ts
        object/
          index.ts
          object.ts
          objectWithoutOptionalProperties.ts
          property.ts
          types.ts
        object-like/
          getObjectLikeUtils.ts
          index.ts
          types.ts
        primitives/
          any.ts
          boolean.ts
          index.ts
          never.ts
          number.ts
          string.ts
          unknown.ts
        record/
          index.ts
          record.ts
          types.ts
        schema-utils/
          getSchemaUtils.ts
          index.ts
          JsonError.ts
          ParseError.ts
          stringifyValidationErrors.ts
        set/
          index.ts
          set.ts
        undiscriminated-union/
          index.ts
          types.ts
          undiscriminatedUnion.ts
        union/
          discriminant.ts
          index.ts
          types.ts
          union.ts
        index.ts
      utils/
        addQuestionMarksToNullableProperties.ts
        createIdentitySchemaCreator.ts
        entries.ts
        filterObject.ts
        getErrorMessageForIncorrectType.ts
        isPlainObject.ts
        keys.ts
        MaybePromise.ts
        maybeSkipValidation.ts
        partition.ts
      index.ts
      Schema.ts
    stream/
      index.ts
      Stream.ts
    url/
      encodePathParam.ts
      index.ts
      join.ts
      qs.ts
    utils/
      index.ts
      setObjectProperty.ts
    websocket/
      events.ts
      exports.ts
      index.ts
      ws.ts
      ws.ts.diff
    base64.ts
    exports.ts
    headers.ts
    index.ts
    json.ts
  errors/
    handleNonStatusCodeError.ts
    HumeError.ts
    HumeTimeoutError.ts
    index.ts
  serialization/
    resources/
      empathicVoice/
        resources/
          chat/
            client/
              socket/
                ChatSocketResponse.ts
                index.ts
              index.ts
            types/
              index.ts
              PublishEvent.ts
              SubscribeEvent.ts
            index.ts
            index.ts.diff
          configs/
            client/
              requests/
                index.ts
                PostedConfig.ts
                PostedConfigName.ts
                PostedConfigVersion.ts
                PostedConfigVersionDescription.ts
              index.ts
            index.ts
          controlPlane/
            client/
              socket/
                ControlPlaneSocketResponse.ts
                index.ts
              index.ts
            index.ts
          prompts/
            client/
              requests/
                index.ts
                PostedPrompt.ts
                PostedPromptName.ts
                PostedPromptVersion.ts
                PostedPromptVersionDescription.ts
              createPrompt.ts
              createPromptVersion.ts
              getPromptVersion.ts
              index.ts
              updatePromptDescription.ts
            index.ts
          tools/
            client/
              requests/
                index.ts
                PostedUserDefinedTool.ts
                PostedUserDefinedToolName.ts
                PostedUserDefinedToolVersion.ts
                PostedUserDefinedToolVersionDescription.ts
              createTool.ts
              createToolVersion.ts
              getToolVersion.ts
              index.ts
              updateToolDescription.ts
            index.ts
          index.ts
        types/
          AssistantEnd.ts
          AssistantInput.ts
          AssistantMessage.ts
          AssistantProsody.ts
          AudioConfiguration.ts
          AudioInput.ts
          AudioOutput.ts
          BuiltInTool.ts
          BuiltinToolConfig.ts
          ChatMessage.ts
          ChatMessageToolResult.ts
          ChatMetadata.ts
          ConnectSessionSettings.ts
          ConnectSessionSettingsAudio.ts
          ConnectSessionSettingsContext.ts
          ConnectSessionSettingsVariablesValue.ts
          Context.ts
          ContextType.ts
          ControlPlanePublishEvent.ts
          EmotionScores.ts
          Encoding.ts
          ErrorLevel.ts
          ErrorResponse.ts
          HttpValidationError.ts
          index.ts
          Inference.ts
          JsonMessage.ts
          LanguageModelType.ts
          MillisecondInterval.ts
          ModelProviderEnum.ts
          PauseAssistantMessage.ts
          PostedBuiltinTool.ts
          PostedBuiltinToolName.ts
          PostedConfigPromptSpec.ts
          PostedEllmModel.ts
          PostedEventMessageSpec.ts
          PostedEventMessageSpecs.ts
          PostedLanguageModel.ts
          PostedNudgeSpec.ts
          PostedTimeoutSpec.ts
          PostedTimeoutSpecs.ts
          PostedTimeoutSpecsInactivity.ts
          PostedTimeoutSpecsMaxDuration.ts
          PostedUserDefinedToolSpec.ts
          PostedWebhookEventType.ts
          PostedWebhookSpec.ts
          ProsodyInference.ts
          ResumeAssistantMessage.ts
          ReturnBuiltinTool.ts
          ReturnBuiltinToolToolType.ts
          ReturnChat.ts
          ReturnChatAudioReconstruction.ts
          ReturnChatAudioReconstructionStatus.ts
          ReturnChatEvent.ts
          ReturnChatEventRole.ts
          ReturnChatEventType.ts
          ReturnChatGroup.ts
          ReturnChatGroupPagedAudioReconstructions.ts
          ReturnChatGroupPagedAudioReconstructionsPaginationDirection.ts
          ReturnChatGroupPagedChats.ts
          ReturnChatGroupPagedChatsPaginationDirection.ts
          ReturnChatGroupPagedEvents.ts
          ReturnChatGroupPagedEventsPaginationDirection.ts
          ReturnChatPagedEvents.ts
          ReturnChatPagedEventsPaginationDirection.ts
          ReturnChatPagedEventsStatus.ts
          ReturnChatStatus.ts
          ReturnConfig.ts
          ReturnConfigSpec.ts
          ReturnEllmModel.ts
          ReturnEventMessageSpec.ts
          ReturnEventMessageSpecs.ts
          ReturnLanguageModel.ts
          ReturnNudgeSpec.ts
          ReturnPagedChatGroups.ts
          ReturnPagedChatGroupsPaginationDirection.ts
          ReturnPagedChats.ts
          ReturnPagedChatsPaginationDirection.ts
          ReturnPagedConfigs.ts
          ReturnPagedPrompts.ts
          ReturnPagedUserDefinedTools.ts
          ReturnPrompt.ts
          ReturnPromptVersionType.ts
          ReturnTimeoutSpec.ts
          ReturnTimeoutSpecs.ts
          ReturnUserDefinedTool.ts
          ReturnUserDefinedToolToolType.ts
          ReturnUserDefinedToolVersionType.ts
          ReturnVoice.ts
          ReturnWebhookEventType.ts
          ReturnWebhookSpec.ts
          Role.ts
          SessionSettings.ts
          SessionSettingsVariablesValue.ts
          SubscribeEvent.ts
          Tool.ts
          ToolCallMessage.ts
          ToolErrorMessage.ts
          ToolResponseMessage.ts
          ToolType.ts
          UserInput.ts
          UserInterruption.ts
          UserMessage.ts
          ValidationError.ts
          ValidationErrorLocItem.ts
          VoiceId.ts
          VoiceName.ts
          VoiceProvider.ts
          VoiceRef.ts
          WebhookEvent.ts
          WebhookEventBase.ts
          WebhookEventChatEnded.ts
          WebhookEventChatStarted.ts
          WebhookEventChatStartType.ts
          WebhookEventChatStatus.ts
          WebhookEventToolCall.ts
          WebSocketError.ts
        index.ts
      expressionMeasurement/
        resources/
          batch/
            client/
              getJobPredictions.ts
              index.ts
              listJobs.ts
            types/
              Alternative.ts
              Bcp47Tag.ts
              BoundingBox.ts
              BurstPrediction.ts
              Classification.ts
              CompletedEmbeddingGeneration.ts
              CompletedInference.ts
              CompletedState.ts
              CompletedTlInference.ts
              CompletedTraining.ts
              CustomModel.ts
              CustomModelId.ts
              CustomModelPrediction.ts
              CustomModelRequest.ts
              CustomModelsInferenceJob.ts
              CustomModelsTrainingJob.ts
              CustomModelVersionId.ts
              Dataset.ts
              DatasetId.ts
              DatasetVersionId.ts
              DescriptionsScore.ts
              Direction.ts
              EmbeddingGenerationBaseRequest.ts
              EmbeddingGenerationJob.ts
              EmotionScore.ts
              Error_.ts
              EvaluationArgs.ts
              Face.ts
              FacemeshPrediction.ts
              FacePrediction.ts
              FacsScore.ts
              Failed.ts
              FailedState.ts
              File_.ts
              Granularity.ts
              GroupedPredictionsBurstPrediction.ts
              GroupedPredictionsFacemeshPrediction.ts
              GroupedPredictionsFacePrediction.ts
              GroupedPredictionsLanguagePrediction.ts
              GroupedPredictionsNerPrediction.ts
              GroupedPredictionsProsodyPrediction.ts
              index.ts
              InferenceBaseRequest.ts
              InferenceJob.ts
              InferencePrediction.ts
              InferenceRequest.ts
              InferenceResults.ts
              InferenceSourcePredictResult.ts
              InProgress.ts
              InProgressState.ts
              JobEmbeddingGeneration.ts
              JobId.ts
              JobInference.ts
              JobTlInference.ts
              JobTraining.ts
              Language.ts
              LanguagePrediction.ts
              Models.ts
              ModelsPredictions.ts
              Ner.ts
              NerPrediction.ts
              Null.ts
              PositionInterval.ts
              PredictionsOptionalNullBurstPrediction.ts
              PredictionsOptionalNullFacemeshPrediction.ts
              PredictionsOptionalNullFacePrediction.ts
              PredictionsOptionalTranscriptionMetadataLanguagePrediction.ts
              PredictionsOptionalTranscriptionMetadataNerPrediction.ts
              PredictionsOptionalTranscriptionMetadataProsodyPrediction.ts
              Prosody.ts
              ProsodyPrediction.ts
              Queued.ts
              QueuedState.ts
              RegistryFileDetail.ts
              Regression.ts
              SentimentScore.ts
              SortBy.ts
              Source.ts
              SourceFile.ts
              SourceTextSource.ts
              SourceUrl.ts
              StateEmbeddingGeneration.ts
              StateEmbeddingGenerationCompletedEmbeddingGeneration.ts
              StateEmbeddingGenerationFailed.ts
              StateEmbeddingGenerationInProgress.ts
              StateEmbeddingGenerationQueued.ts
              StateInference.ts
              StateTlInference.ts
              StateTlInferenceCompletedTlInference.ts
              StateTlInferenceFailed.ts
              StateTlInferenceInProgress.ts
              StateTlInferenceQueued.ts
              StateTraining.ts
              StateTrainingCompletedTraining.ts
              StateTrainingFailed.ts
              StateTrainingInProgress.ts
              StateTrainingQueued.ts
              Status.ts
              Tag.ts
              Target.ts
              Task.ts
              TaskClassification.ts
              TaskRegression.ts
              TextSource.ts
              TimeInterval.ts
              TlInferenceBaseRequest.ts
              TlInferencePrediction.ts
              TlInferenceResults.ts
              TlInferenceSourcePredictResult.ts
              ToxicityScore.ts
              TrainingBaseRequest.ts
              TrainingCustomModel.ts
              Transcription.ts
              TranscriptionMetadata.ts
              Type.ts
              Unconfigurable.ts
              UnionJob.ts
              UnionPredictResult.ts
              Url.ts
              ValidationArgs.ts
              When.ts
              Window.ts
            index.ts
          stream/
            resources/
              stream/
                client/
                  socket/
                    index.ts
                    StreamSocketResponse.ts
                  index.ts
                types/
                  Config.ts
                  index.ts
                  JobDetails.ts
                  StreamErrorMessage.ts
                  StreamFace.ts
                  StreamLanguage.ts
                  StreamModelPredictions.ts
                  StreamModelPredictionsBurst.ts
                  StreamModelPredictionsBurstPredictionsItem.ts
                  StreamModelPredictionsFace.ts
                  StreamModelPredictionsFacemesh.ts
                  StreamModelPredictionsFacemeshPredictionsItem.ts
                  StreamModelPredictionsFacePredictionsItem.ts
                  StreamModelPredictionsJobDetails.ts
                  StreamModelPredictionsLanguage.ts
                  StreamModelPredictionsLanguagePredictionsItem.ts
                  StreamModelPredictionsProsody.ts
                  StreamModelPredictionsProsodyPredictionsItem.ts
                  StreamModelsEndpointPayload.ts
                  StreamWarningMessage.ts
                  StreamWarningMessageJobDetails.ts
                  SubscribeEvent.ts
                index.ts
              index.ts
            types/
              EmotionEmbedding.ts
              EmotionEmbeddingItem.ts
              index.ts
              Sentiment.ts
              SentimentItem.ts
              StreamBoundingBox.ts
              TextPosition.ts
              TimeRange.ts
              Toxicity.ts
              ToxicityItem.ts
            index.ts
          index.ts
        index.ts
      tts/
        resources/
          streamInput/
            client/
              socket/
                index.ts
                StreamInputSocketResponse.ts
              index.ts
            index.ts
          voices/
            client/
              requests/
                index.ts
                PostedVoice.ts
              index.ts
            index.ts
          index.ts
        types/
          AudioEncoding.ts
          AudioFormatType.ts
          ErrorResponse.ts
          Format.ts
          FormatMp3.ts
          FormatPcm.ts
          FormatWav.ts
          HttpValidationError.ts
          index.ts
          MillisecondInterval.ts
          OctaveVersion.ts
          PostedContext.ts
          PostedContextWithGenerationId.ts
          PostedContextWithUtterances.ts
          PostedTts.ts
          PostedUtterance.ts
          PostedUtteranceVoice.ts
          PostedUtteranceVoiceWithId.ts
          PostedUtteranceVoiceWithName.ts
          PublishTts.ts
          ReturnGeneration.ts
          ReturnPagedVoices.ts
          ReturnTts.ts
          ReturnVoice.ts
          Snippet.ts
          SnippetAudioChunk.ts
          Timestamp.ts
          TimestampMessage.ts
          TimestampType.ts
          TtsOutput.ts
          ValidationError.ts
          ValidationErrorLocItem.ts
          VoiceProvider.ts
        index.ts
      index.ts
    index.ts
  wrapper/
    expressionMeasurement/
      batch/
        BatchClient.ts
        Job.ts
      streaming/
        StreamingClient.ts
        StreamSocket.ts
      ExpressionMeasurementClient.ts
    base64Decode.ts
    base64Encode.ts
    checkForAudioTracks.ts
    collate.ts
    convertBase64ToBlob.ts
    convertBlobToBase64.ts
    convertFrequencyScale.ts
    ensureSingleValidAudioTrack.ts
    EVIWebAudioPlayer.ts
    fetchAccessToken.ts
    generateEmptyFft.ts
    getAudioStream.ts
    getBrowserSupportedMimeType.ts
    HumeClient.ts
    index.ts
    SilenceFiller.ts
  BaseClient.ts
  Client.ts
  environments.ts
  exports.ts
  index.ts
  index.ts.diff
  version.ts
tests/
  mock-server/
    mockEndpointBuilder.ts
    MockServer.ts
    MockServerPool.ts
    randomBaseUrl.ts
    setup.ts
    withFormUrlEncoded.ts
    withHeaders.ts
    withJson.ts
  unit/
    auth/
      auth.test.ts
      BasicAuth.test.ts
      BearerToken.test.ts
    fetcher/
      createRequestUrl.test.ts
      Fetcher.test.ts
      getRequestBody.test.ts
      getResponseBody.test.ts
      HttpResponsePromise.test.ts
      logging.test.ts
      makeRequest.test.ts
      RawResponse.test.ts
      redacting.test.ts
      requestWithRetries.test.ts
      signals.test.ts
      test-file.txt
    file/
      file.test.ts
      test-file.txt
    form-data-utils/
      encodeAsFormParameter.test.ts
      formDataWrapper.test.ts
    logging/
      logger.test.ts
    schemas/
      bigint/
        bigint.test.ts
      date/
        date.test.ts
      enum/
        enum.test.ts
      lazy/
        recursive/
          a.ts
          b.ts
        lazy.test.ts
        lazyObject.test.ts
      list/
        list.test.ts
      literals/
        stringLiteral.test.ts
      object/
        extend.test.ts
        object.test.ts
        objectWithoutOptionalProperties.test.ts
        passthrough.test.ts
      object-like/
        withParsedProperties.test.ts
      primitives/
        any.test.ts
        boolean.test.ts
        never.test.ts
        number.test.ts
        string.test.ts
        unknown.test.ts
      record/
        record.test.ts
      schema-utils/
        getSchemaUtils.test.ts
      set/
        set.test.ts
      undiscriminated-union/
        undiscriminatedUnion.test.ts
      union/
        union.test.ts
      utils/
        itSchema.ts
        itValidate.ts
      schema.test.ts
      skipValidation.test.ts
    stream/
      Stream.test.ts
    url/
      join.test.ts
      qs.test.ts
    utils/
      setObjectProperty.test.ts
    base64.test.ts
    test-file.txt
  wire/
    empathic-voice/
      chatGroups.test.ts
      chats.test.ts
      configs.test.ts
      controlPlane.test.ts
      prompts.test.ts
      tools.test.ts
    expression-measurement/
      batch/
        main.test.ts
    tts/
      main.test.ts
      voices.test.ts
    .gitkeep
  BrowserTestEnvironment.ts
  custom.test.ts
  setup.ts
  tsconfig.json
.fernignore
.gitignore
.nvmrc
.prettierignore
biome.json
CITATIONS.md
CONTRIBUTING.md
eslint.config.mjs
justfile
LICENSE
package.json
pnpm-workspace.yaml
README.md
reference.md
tsconfig.base.json
tsconfig.cjs.json
tsconfig.dev.json
tsconfig.esm.json
tsconfig.json
vitest.config.mts
```

# Files

## File: .fern/metadata.json
````json
 1: {
 2:     "cliVersion": "3.4.3",
 3:     "generatorName": "fernapi/fern-typescript-node-sdk",
 4:     "generatorVersion": "3.43.3",
 5:     "generatorConfig": {
 6:         "extraDependencies": {
 7:             "uuid": "9.0.1",
 8:             "zod": "^3.23.8"
 9:         },
10:         "extraDevDependencies": {
11:             "@types/uuid": "9.0.7",
12:             "@types/ws": "^8.5.9"
13:         },
14:         "formDataSupport": "Node18",
15:         "noSerdeLayer": false,
16:         "enableInlineTypes": false,
17:         "allowCustomFetcher": true,
18:         "shouldGenerateWebsocketClients": true,
19:         "namespaceExport": "Hume"
20:     },
21:     "sdkVersion": "0.15.11"
22: }
````

## File: .github/ISSUE_TEMPLATE/bug_report.md
````markdown
 1: ---
 2: name: Bug report
 3: about: Create a report to help us improve
 4: title: ""
 5: labels: ""
 6: assignees: ""
 7: ---
 8: 
 9: **Describe the bug**
10: A clear and concise description of what the bug is.
11: 
12: **To Reproduce**
13: Steps to reproduce the behavior:
14: 
15: 1. Go to '...'
16: 2. Click on '....'
17: 3. Scroll down to '....'
18: 4. See error
19: 
20: **Expected behavior**
21: A clear and concise description of what you expected to happen.
22: 
23: **Screenshots**
24: If applicable, add screenshots to help explain your problem.
25: 
26: **Desktop (please complete the following information):**
27: 
28: - OS: [e.g. iOS]
29: - Browser [e.g. chrome, safari]
30: - Version [e.g. 22]
31: 
32: **Smartphone (please complete the following information):**
33: 
34: - Device: [e.g. iPhone6]
35: - OS: [e.g. iOS8.1]
36: - Browser [e.g. stock browser, safari]
37: - Version [e.g. 22]
38: 
39: **Additional context**
40: Add any other context about the problem here.
````

## File: .github/ISSUE_TEMPLATE/feature_request.md
````markdown
 1: ---
 2: name: Feature request
 3: about: Suggest an idea for this project
 4: title: ""
 5: labels: ""
 6: assignees: ""
 7: ---
 8: 
 9: **Is your feature request related to a problem? Please describe.**
10: A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
11: 
12: **Describe the solution you'd like**
13: A clear and concise description of what you want to happen.
14: 
15: **Describe alternatives you've considered**
16: A clear and concise description of any alternative solutions or features you've considered.
17: 
18: **Additional context**
19: Add any other context or screenshots about the feature request here.
````

## File: .github/workflows/ci.yml
````yaml
  1: name: ci
  2: 
  3: on:
  4:   push:
  5:   pull_request:
  6:     types: [synchronize, reopened, ready_for_review]
  7: 
  8: jobs:
  9:   format:
 10:     runs-on: ubuntu-latest
 11:     # Only run on push events to branches (not tags), and not on main/master
 12:     if: github.event_name == 'push' && !contains(github.ref, 'refs/tags/') && github.ref != 'refs/heads/main' && github.ref != 'refs/heads/master'
 13:     permissions:
 14:       contents: write
 15:     steps:
 16:       - name: Checkout repo
 17:         uses: actions/checkout@v4
 18:         with:
 19:           ref: ${{ github.head_ref || github.ref }}
 20:           token: ${{ secrets.GITHUB_TOKEN }}
 21: 
 22:       - name: Set up node
 23:         uses: actions/setup-node@v4
 24:         with:
 25:           node-version: '18.18.0'
 26: 
 27:       - name: Install pnpm
 28:         uses: pnpm/action-setup@v4
 29: 
 30:       - name: Install dependencies
 31:         run: pnpm install
 32: 
 33:       - name: Run formatter
 34:         run: pnpm format
 35: 
 36:       - name: Check for formatting changes
 37:         id: verify_diff
 38:         run: |
 39:           git diff --exit-code || echo "has_changes=true" >> $GITHUB_OUTPUT
 40: 
 41:       - name: Commit formatting changes
 42:         if: steps.verify_diff.outputs.has_changes == 'true'
 43:         uses: stefanzweifel/git-auto-commit-action@v5
 44:         with:
 45:           commit_message: 'style: auto-format code'
 46:           commit_options: '--no-verify'
 47: 
 48:       - name: Fail if formatting was needed
 49:         if: steps.verify_diff.outputs.has_changes == 'true'
 50:         run: |
 51:           echo "::error::Code was not properly formatted. Auto-format commit has been pushed. Please pull the latest changes."
 52:           exit 1
 53: 
 54:   compile:
 55:     runs-on: ubuntu-latest
 56:     needs: [format]
 57:     # Run if format succeeded or was skipped (on main/tags)
 58:     if: always() && github.event_name == 'push' && (needs.format.result == 'success' || needs.format.result == 'skipped')
 59:     permissions:
 60:       contents: read
 61:     steps:
 62:       - name: Checkout repo
 63:         uses: actions/checkout@v4
 64: 
 65:       - name: Set up node
 66:         uses: actions/setup-node@v4
 67:         with:
 68:           node-version: '18.18.0'
 69: 
 70:       - name: Install pnpm
 71:         uses: pnpm/action-setup@v4
 72: 
 73:       - name: Install dependencies
 74:         run: pnpm install
 75: 
 76:       - name: Compile
 77:         run: pnpm build
 78: 
 79:   test:
 80:     runs-on: ubuntu-latest
 81:     needs: [format]
 82:     # Run if format succeeded or was skipped (on main/tags)
 83:     if: always() && github.event_name == 'push' && (needs.format.result == 'success' || needs.format.result == 'skipped')
 84:     permissions:
 85:       contents: read
 86:     steps:
 87:       - name: Checkout repo
 88:         uses: actions/checkout@v4
 89: 
 90:       - name: Set up node
 91:         uses: actions/setup-node@v4
 92:         with:
 93:           node-version: '18.18.0'
 94: 
 95:       - name: Install pnpm
 96:         uses: pnpm/action-setup@v4
 97: 
 98:       - name: Install dependencies
 99:         run: pnpm install
100: 
101:       - name: Check for formatting issues
102:         run: pnpm format:check
103: 
104:       - name: Run tests
105:         # --configLoader runner is used to make vitest able to load its config as a ESM module in node 18. We wouldn't need to specify this if we didn't support node 18.
106:         run: pnpm test --configLoader runner
107: 
108:   test-examples:
109:     runs-on: ubuntu-latest
110:     # Run on pull_request events and push events (to test feature branches)
111:     if: (github.event_name == 'pull_request' || github.event_name == 'push') && github.actor != 'dependabot[bot]'
112:     permissions:
113:       contents: read
114:     steps:
115:       - name: Checkout SDK repo (PR branch)
116:         uses: actions/checkout@v4
117:         with:
118:           path: sdk
119:           # checkout the PR branch, not main
120:           ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}
121:           fetch-depth: 0
122: 
123:       - name: Checkout examples repo
124:         uses: actions/checkout@v4
125:         with:
126:           repository: humeai/hume-api-examples
127:           path: examples
128: 
129:       - name: Set up node
130:         uses: actions/setup-node@v4
131:         with:
132:           node-version: '20'
133: 
134:       - name: Install pnpm
135:         uses: pnpm/action-setup@v4
136:         with:
137:           version: 10.20.0
138: 
139:       - name: Build SDK
140:         working-directory: ./sdk
141:         run: |
142:           echo "=== SDK Build Info ==="
143:           echo "Branch: ${{ github.head_ref || github.ref_name || 'unknown' }}"
144:           echo "Ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}"
145:           echo "Commit SHA: $(git rev-parse HEAD)"
146:           echo "Branch name: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'detached')"
147:           echo "======================"
148:           pnpm install
149:           pnpm build
150:           echo "SDK version from package.json: $(node -p "require('./package.json').version")"
151: 
152:       - name: Link SDK to examples
153:         run: |
154:           cd ./sdk
155:           SDK_VERSION=$(node -p "require('./package.json').version")
156:           SDK_PATH=$(pwd)
157:           echo "=== Linking SDK ==="
158:           echo "SDK version: $SDK_VERSION"
159:           echo "SDK path: $SDK_PATH"
160:           pnpm link --global
161:           cd ../examples/evi/evi-typescript-quickstart
162:           pnpm install --no-frozen-lockfile
163:           pnpm remove hume || true
164:           pnpm link hume
165:           echo ""
166:           echo "=== Verifying Linked SDK ==="
167:           if [ -L node_modules/hume ]; then
168:             LINK_TARGET=$(readlink -f node_modules/hume)
169:             echo "✓ node_modules/hume is a symlink"
170:             echo "  Link target: $LINK_TARGET"
171:             if [[ "$LINK_TARGET" == *"$SDK_PATH"* ]] || [[ "$LINK_TARGET" == *"global"* ]]; then
172:               echo "✓ Link points to local SDK (not npm package)"
173:             else
174:               echo "✗ WARNING: Link may not point to local SDK"
175:             fi
176:           else
177:             echo "✗ ERROR: node_modules/hume is NOT a symlink - using npm package!"
178:             exit 1
179:           fi
180:           INSTALLED_VERSION=$(node -p "require('hume/package.json').version")
181:           echo "Installed hume version: $INSTALLED_VERSION"
182:           if [ "$INSTALLED_VERSION" != "$SDK_VERSION" ]; then
183:             echo "✗ WARNING: Version mismatch! Expected $SDK_VERSION, got $INSTALLED_VERSION"
184:           else
185:             echo "✓ Version matches: $INSTALLED_VERSION"
186:           fi
187:           echo "===================="
188:           cd ../../tts/tts-typescript-quickstart
189:           pnpm install --no-frozen-lockfile
190:           pnpm remove hume || true
191:           pnpm link hume
192:           echo ""
193:           echo "=== Verifying Linked SDK ==="
194:           if [ -L node_modules/hume ]; then
195:             LINK_TARGET=$(readlink -f node_modules/hume)
196:             echo "✓ node_modules/hume is a symlink"
197:             echo "  Link target: $LINK_TARGET"
198:             if [[ "$LINK_TARGET" == *"$SDK_PATH"* ]] || [[ "$LINK_TARGET" == *"global"* ]]; then
199:               echo "✓ Link points to local SDK (not npm package)"
200:             else
201:               echo "✗ WARNING: Link may not point to local SDK"
202:             fi
203:           else
204:             echo "✗ ERROR: node_modules/hume is NOT a symlink - using npm package!"
205:             exit 1
206:           fi
207:           INSTALLED_VERSION=$(node -p "require('hume/package.json').version")
208:           echo "Installed hume version: $INSTALLED_VERSION"
209:           if [ "$INSTALLED_VERSION" != "$SDK_VERSION" ]; then
210:             echo "✗ WARNING: Version mismatch! Expected $SDK_VERSION, got $INSTALLED_VERSION"
211:           else
212:             echo "✓ Version matches: $INSTALLED_VERSION"
213:           fi
214:           echo "===================="
215: 
216:       - name: Run example evi-typescript-quickstart
217:         working-directory: ./examples/evi/evi-typescript-quickstart
218:         run: pnpm run test
219:         env:
220:           TEST_HUME_API_KEY: ${{ secrets.TEST_HUME_API_KEY }}
221:           TEST_HUME_SECRET_KEY: ${{ secrets.TEST_HUME_SECRET_KEY }}
222: 
223:       - name: Run example tts-typescript-quickstart
224:         working-directory: ./examples/tts/tts-typescript-quickstart
225:         run: pnpm run test
226:         env:
227:           TEST_HUME_API_KEY: ${{ secrets.TEST_HUME_API_KEY }}
228:           TEST_HUME_SECRET_KEY: ${{ secrets.TEST_HUME_SECRET_KEY }}
229: 
230:   publish:
231:     needs: [compile, test]
232:     if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
233:     runs-on: ubuntu-latest
234:     permissions:
235:       id-token: write # Required for OIDC publishing to NPM
236:       contents: read
237:     steps:
238:       - name: Checkout repo
239:         uses: actions/checkout@v4
240: 
241:       - name: Set up node
242:         uses: actions/setup-node@v4
243:         with:
244:           node-version: '18.18.0'
245:           registry-url: 'https://registry.npmjs.org'
246: 
247:       - name: Setup pnpm
248:         run: npm install -g pnpm
249: 
250:       - name: Install dependencies
251:         run: pnpm install
252: 
253:       - name: Build
254:         run: pnpm build
255: 
256:       - name: Publish to npm
257:         run: |
258: 
259:           publish() {
260:             npx -y npm@latest publish --provenance "$@"
261:           }
262:           if [[ ${GITHUB_REF} == *alpha* ]]; then
263:             publish --access public --tag alpha
264:           elif [[ ${GITHUB_REF} == *beta* ]]; then
265:             publish --access public --tag beta
266:           else
267:             publish --access public
268:           fi
269:       - name: Trigger React SDK bump
270:         uses: peter-evans/repository-dispatch@v4
271:         with:
272:           token: ${{ secrets.REPO_DISPATCH_TOKEN }}
273:           repository: HumeAI/hume-react-sdk
274:           event-type: typescript-sdk-published
275:           client-payload: |
276:             {
277:               "version": "${{ github.ref_name }}",
278:               "tag": "${{ github.ref_name }}",
279:               "is_prerelease": ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') }}
280:             }
````

## File: .github/workflows/publish.yml
````yaml
 1: name: Manual Publish to npm
 2: 
 3: on:
 4:   workflow_dispatch:
 5:     inputs:
 6:       tag:
 7:         description: 'Git tag to publish (e.g., 0.15.12)'
 8:         required: true
 9:         type: string
10:       npm_tag:
11:         description: 'npm dist-tag (latest, alpha, beta)'
12:         required: false
13:         default: 'latest'
14:         type: choice
15:         options:
16:           - latest
17:           - alpha
18:           - beta
19: 
20: jobs:
21:   publish:
22:     runs-on: ubuntu-latest
23:     permissions:
24:       id-token: write
25:       contents: read
26:     steps:
27:       - name: Checkout repo at tag
28:         uses: actions/checkout@v4
29:         with:
30:           ref: ${{ inputs.tag }}
31: 
32:       - name: Verify tag exists
33:         run: |
34:           if ! git describe --tags --exact-match HEAD 2>/dev/null; then
35:             echo "Warning: HEAD is not at an exact tag. Proceeding anyway with ref: ${{ inputs.tag }}"
36:           fi
37: 
38:       - name: Set up node
39:         uses: actions/setup-node@v4
40:         with:
41:           node-version: '18.18.0'
42:           registry-url: 'https://registry.npmjs.org'
43: 
44:       - name: Setup pnpm
45:         run: npm install -g pnpm
46: 
47:       - name: Install dependencies
48:         run: pnpm install
49: 
50:       - name: Build
51:         run: pnpm build
52: 
53:       - name: Verify version matches tag
54:         run: |
55:           PACKAGE_VERSION=$(node -p "require('./package.json').version")
56:           echo "Package version: $PACKAGE_VERSION"
57:           echo "Input tag: ${{ inputs.tag }}"
58:           if [ "$PACKAGE_VERSION" != "${{ inputs.tag }}" ]; then
59:             echo "Warning: package.json version ($PACKAGE_VERSION) does not match input tag (${{ inputs.tag }})"
60:           fi
61: 
62:       - name: Publish to npm
63:         run: npx -y npm@latest publish --provenance --access public --tag ${{ inputs.npm_tag }}
64: 
65:       - name: Trigger React SDK bump
66:         if: inputs.npm_tag == 'latest'
67:         uses: peter-evans/repository-dispatch@v4
68:         with:
69:           token: ${{ secrets.REPO_DISPATCH_TOKEN }}
70:           repository: HumeAI/hume-react-sdk
71:           event-type: typescript-sdk-published
72:           client-payload: |
73:             {
74:               "version": "${{ inputs.tag }}",
75:               "tag": "${{ inputs.tag }}",
76:               "is_prerelease": ${{ inputs.npm_tag != 'latest' }}
77:             }
````

## File: .github/workflows/test-examples-dependabot.yml
````yaml
  1: name: test-examples-dependabot
  2: 
  3: on:
  4:   pull_request_target:
  5:     types: [opened, synchronize, reopened]
  6: 
  7: jobs:
  8:   test-examples-dependabot:
  9:     runs-on: ubuntu-latest
 10:     if: github.event_name == 'pull_request_target' && github.actor == 'dependabot[bot]'
 11:     permissions:
 12:       contents: read
 13:       pull-requests: read
 14: 
 15:     steps:
 16:       - name: Checkout base SHA (trusted)
 17:         uses: actions/checkout@v4
 18:         with:
 19:           path: sdk
 20:           ref: ${{ github.event.pull_request.base.sha }}
 21:           fetch-depth: 0
 22:           persist-credentials: false
 23: 
 24:       - name: Verify PR changes are dependency-only
 25:         working-directory: sdk
 26:         env:
 27:           GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
 28:           REPO: ${{ github.repository }}
 29:           PR: ${{ github.event.pull_request.number }}
 30:         run: |
 31:           set -euo pipefail
 32: 
 33:           files="$(curl -fsSL \
 34:             -H "Authorization: Bearer $GH_TOKEN" \
 35:             -H "Accept: application/vnd.github+json" \
 36:             "https://api.github.com/repos/$REPO/pulls/$PR/files?per_page=100" \
 37:             | jq -r '.[].filename')"
 38: 
 39:           echo "Changed files:"
 40:           echo "$files"
 41: 
 42:           allowed='^(
 43:             package\.json|
 44:             pnpm-lock\.yaml|
 45:             pnpm-workspace\.yaml|
 46:             \.npmrc|
 47:             examples/.*/package\.json|
 48:             examples/.*/pnpm-lock\.yaml
 49:           )$'
 50: 
 51:           bad="$(echo "$files" | tr -d '\r' | grep -Ev "$allowed" || true)"
 52:           if [ -n "$bad" ]; then
 53:             echo "::error::Disallowed file changes in Dependabot PR:"
 54:             echo "$bad"
 55:             exit 1
 56:           fi
 57: 
 58:       - name: Apply Dependabot PR patch
 59:         working-directory: sdk
 60:         env:
 61:           GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
 62:           REPO: ${{ github.repository }}
 63:           PR: ${{ github.event.pull_request.number }}
 64:         run: |
 65:           set -euo pipefail
 66:           curl -fsSL \
 67:             -H "Authorization: Bearer $GH_TOKEN" \
 68:             -H "Accept: application/vnd.github.v3.patch" \
 69:             "https://api.github.com/repos/$REPO/pulls/$PR" \
 70:             > pr.patch
 71:           git apply --whitespace=nowarn pr.patch
 72: 
 73:       - name: Checkout examples repo
 74:         uses: actions/checkout@v4
 75:         with:
 76:           repository: humeai/hume-api-examples
 77:           path: examples
 78:           fetch-depth: 0
 79: 
 80:       - name: Set up node
 81:         uses: actions/setup-node@v4
 82:         with:
 83:           node-version: '18.18.0'
 84: 
 85:       - name: Install pnpm
 86:         uses: pnpm/action-setup@v4
 87:         with:
 88:           version: '10.20.0'
 89: 
 90:       - name: Build SDK
 91:         working-directory: ./sdk
 92:         run: |
 93:           echo "=== SDK Build Info ==="
 94:           echo "Branch: ${{ github.head_ref || github.ref_name || 'unknown' }}"
 95:           echo "Ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}"
 96:           echo "Commit SHA: $(git rev-parse HEAD)"
 97:           echo "Branch name: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'detached')"
 98:           echo "======================"
 99:           pnpm install
100:           pnpm build
101:           echo "SDK version from package.json: $(node -p "require('./package.json').version")"
102: 
103:       - name: Link SDK to examples
104:         run: |
105:           cd ./sdk
106:           SDK_VERSION=$(node -p "require('./package.json').version")
107:           SDK_PATH=$(pwd)
108:           echo "=== Linking SDK ==="
109:           echo "SDK version: $SDK_VERSION"
110:           echo "SDK path: $SDK_PATH"
111:           pnpm link --global
112: 
113:           cd ../examples/evi/evi-typescript-quickstart
114:           pnpm install --no-frozen-lockfile
115:           pnpm remove hume || true
116:           pnpm link hume
117: 
118:           echo ""
119:           echo "=== Verifying Linked SDK ==="
120:           if [ -L node_modules/hume ]; then
121:             LINK_TARGET=$(readlink -f node_modules/hume)
122:             echo "✓ node_modules/hume is a symlink"
123:             echo "  Link target: $LINK_TARGET"
124:             if [[ "$LINK_TARGET" == *"$SDK_PATH"* ]] || [[ "$LINK_TARGET" == *"global"* ]]; then
125:               echo "✓ Link points to local SDK (not npm package)"
126:             else
127:               echo "✗ WARNING: Link may not point to local SDK"
128:             fi
129:           else
130:             echo "✗ ERROR: node_modules/hume is NOT a symlink - using npm package!"
131:             exit 1
132:           fi
133: 
134:           INSTALLED_VERSION=$(node -p "require('hume/package.json').version")
135:           echo "Installed hume version: $INSTALLED_VERSION"
136:           if [ "$INSTALLED_VERSION" != "$SDK_VERSION" ]; then
137:             echo "✗ WARNING: Version mismatch! Expected $SDK_VERSION, got $INSTALLED_VERSION"
138:           else
139:             echo "✓ Version matches: $INSTALLED_VERSION"
140:           fi
141:           echo "===================="
142: 
143:           cd ../../tts/tts-typescript-quickstart
144:           pnpm install --no-frozen-lockfile
145:           pnpm remove hume || true
146:           pnpm link hume
147: 
148:           echo ""
149:           echo "=== Verifying Linked SDK ==="
150:           if [ -L node_modules/hume ]; then
151:             LINK_TARGET=$(readlink -f node_modules/hume)
152:             echo "✓ node_modules/hume is a symlink"
153:             echo "  Link target: $LINK_TARGET"
154:             if [[ "$LINK_TARGET" == *"$SDK_PATH"* ]] || [[ "$LINK_TARGET" == *"global"* ]]; then
155:               echo "✓ Link points to local SDK (not npm package)"
156:             else
157:               echo "✗ WARNING: Link may not point to local SDK"
158:             fi
159:           else
160:             echo "✗ ERROR: node_modules/hume is NOT a symlink - using npm package!"
161:             exit 1
162:           fi
163: 
164:           INSTALLED_VERSION=$(node -p "require('hume/package.json').version")
165:           echo "Installed hume version: $INSTALLED_VERSION"
166:           if [ "$INSTALLED_VERSION" != "$SDK_VERSION" ]; then
167:             echo "✗ WARNING: Version mismatch! Expected $SDK_VERSION, got $INSTALLED_VERSION"
168:           else
169:             echo "✓ Version matches: $INSTALLED_VERSION"
170:           fi
171:           echo "===================="
172: 
173:       - name: Run example evi-typescript-quickstart
174:         working-directory: ./examples/evi/evi-typescript-quickstart
175:         env:
176:           TEST_HUME_API_KEY: ${{ secrets.TEST_HUME_API_KEY }}
177:           TEST_HUME_SECRET_KEY: ${{ secrets.TEST_HUME_SECRET_KEY }}
178:         run: pnpm run test
179: 
180:       - name: Run example tts-typescript-quickstart
181:         working-directory: ./examples/tts/tts-typescript-quickstart
182:         env:
183:           TEST_HUME_API_KEY: ${{ secrets.TEST_HUME_API_KEY }}
184:           TEST_HUME_SECRET_KEY: ${{ secrets.TEST_HUME_SECRET_KEY }}
185:         run: pnpm run test
````

## File: .github/dependabot.yml
````yaml
 1: version: 2
 2: 
 3: updates:
 4:     # check for updated versions of github actions on a weekly basis
 5:     - package-ecosystem: "github-actions"
 6:       directory: "/"
 7:       schedule:
 8:           interval: "weekly"
 9:           day: "monday"
10:           time: "06:00"
11:           timezone: "America/New_York"
12:       commit-message:
13:           prefix: "[github actions] "
14:       open-pull-requests-limit: 5
15: 
16:     # commented out for now because dep versions are defined in fern-config,
17:     # so each Fern generation will overwrite any updates made by Dependabot in this SDK
18: 
19:     # check for updated versions of npm dependencies on a daily basis
20:     # - package-ecosystem: "npm"
21:     #   directory: "/"
22:     #   schedule:
23:     #       interval: "daily"
24:     #       time: "06:00"
25:     #       timezone: "America/New_York"
26:     #   commit-message:
27:     #       prefix: "[npm] "
28:     #   open-pull-requests-limit: 5
````

## File: scripts/rename-to-esm-files.js
````javascript
  1: #!/usr/bin/env node
  2: 
  3: const fs = require("fs").promises;
  4: const path = require("path");
  5: 
  6: const extensionMap = {
  7:     ".js": ".mjs",
  8:     ".d.ts": ".d.mts",
  9: };
 10: const oldExtensions = Object.keys(extensionMap);
 11: 
 12: async function findFiles(rootPath) {
 13:     const files = [];
 14: 
 15:     async function scan(directory) {
 16:         const entries = await fs.readdir(directory, { withFileTypes: true });
 17: 
 18:         for (const entry of entries) {
 19:             const fullPath = path.join(directory, entry.name);
 20: 
 21:             if (entry.isDirectory()) {
 22:                 if (entry.name !== "node_modules" && !entry.name.startsWith(".")) {
 23:                     await scan(fullPath);
 24:                 }
 25:             } else if (entry.isFile()) {
 26:                 if (oldExtensions.some((ext) => entry.name.endsWith(ext))) {
 27:                     files.push(fullPath);
 28:                 }
 29:             }
 30:         }
 31:     }
 32: 
 33:     await scan(rootPath);
 34:     return files;
 35: }
 36: 
 37: async function updateFiles(files) {
 38:     const updatedFiles = [];
 39:     for (const file of files) {
 40:         const updated = await updateFileContents(file);
 41:         updatedFiles.push(updated);
 42:     }
 43: 
 44:     console.log(`Updated imports in ${updatedFiles.length} files.`);
 45: }
 46: 
 47: async function updateFileContents(file) {
 48:     const content = await fs.readFile(file, "utf8");
 49: 
 50:     let newContent = content;
 51:     // Update each extension type defined in the map
 52:     for (const [oldExt, newExt] of Object.entries(extensionMap)) {
 53:         // Handle static imports/exports
 54:         const staticRegex = new RegExp(`(import|export)(.+from\\s+['"])(\\.\\.?\\/[^'"]+)(\\${oldExt})(['"])`, "g");
 55:         newContent = newContent.replace(staticRegex, `$1$2$3${newExt}$5`);
 56: 
 57:         // Handle dynamic imports (yield import, await import, regular import())
 58:         const dynamicRegex = new RegExp(
 59:             `(yield\\s+import|await\\s+import|import)\\s*\\(\\s*['"](\\.\\.\?\\/[^'"]+)(\\${oldExt})['"]\\s*\\)`,
 60:             "g",
 61:         );
 62:         newContent = newContent.replace(dynamicRegex, `$1("$2${newExt}")`);
 63:     }
 64: 
 65:     if (content !== newContent) {
 66:         await fs.writeFile(file, newContent, "utf8");
 67:         return true;
 68:     }
 69:     return false;
 70: }
 71: 
 72: async function renameFiles(files) {
 73:     let counter = 0;
 74:     for (const file of files) {
 75:         const ext = oldExtensions.find((ext) => file.endsWith(ext));
 76:         const newExt = extensionMap[ext];
 77: 
 78:         if (newExt) {
 79:             const newPath = file.slice(0, -ext.length) + newExt;
 80:             await fs.rename(file, newPath);
 81:             counter++;
 82:         }
 83:     }
 84: 
 85:     console.log(`Renamed ${counter} files.`);
 86: }
 87: 
 88: async function main() {
 89:     try {
 90:         const targetDir = process.argv[2];
 91:         if (!targetDir) {
 92:             console.error("Please provide a target directory");
 93:             process.exit(1);
 94:         }
 95: 
 96:         const targetPath = path.resolve(targetDir);
 97:         const targetStats = await fs.stat(targetPath);
 98: 
 99:         if (!targetStats.isDirectory()) {
100:             console.error("The provided path is not a directory");
101:             process.exit(1);
102:         }
103: 
104:         console.log(`Scanning directory: ${targetDir}`);
105: 
106:         const files = await findFiles(targetDir);
107: 
108:         if (files.length === 0) {
109:             console.log("No matching files found.");
110:             process.exit(0);
111:         }
112: 
113:         console.log(`Found ${files.length} files.`);
114:         await updateFiles(files);
115:         await renameFiles(files);
116:         console.log("\nDone!");
117:     } catch (error) {
118:         console.error("An error occurred:", error.message);
119:         process.exit(1);
120:     }
121: }
122: 
123: main();
````

## File: src/api/resources/empathicVoice/client/Client.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type { BaseClientOptions } from "../../../../BaseClient.js";
 4: import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
 5: import { ChatClient } from "../resources/chat/client/Client.js";
 6: import { ChatGroupsClient } from "../resources/chatGroups/client/Client.js";
 7: import { ChatsClient } from "../resources/chats/client/Client.js";
 8: import { ConfigsClient } from "../resources/configs/client/Client.js";
 9: import { ControlPlaneClient } from "../resources/controlPlane/client/Client.js";
10: import { PromptsClient } from "../resources/prompts/client/Client.js";
11: import { ToolsClient } from "../resources/tools/client/Client.js";
12: 
13: export declare namespace EmpathicVoiceClient {
14:     export type Options = BaseClientOptions;
15: }
16: 
17: export class EmpathicVoiceClient {
18:     protected readonly _options: NormalizedClientOptionsWithAuth<EmpathicVoiceClient.Options>;
19:     protected _controlPlane: ControlPlaneClient | undefined;
20:     protected _chatGroups: ChatGroupsClient | undefined;
21:     protected _chats: ChatsClient | undefined;
22:     protected _configs: ConfigsClient | undefined;
23:     protected _prompts: PromptsClient | undefined;
24:     protected _tools: ToolsClient | undefined;
25:     protected _chat: ChatClient | undefined;
26: 
27:     constructor(options: EmpathicVoiceClient.Options = {}) {
28:         this._options = normalizeClientOptionsWithAuth(options);
29:     }
30: 
31:     public get controlPlane(): ControlPlaneClient {
32:         return (this._controlPlane ??= new ControlPlaneClient(this._options));
33:     }
34: 
35:     public get chatGroups(): ChatGroupsClient {
36:         return (this._chatGroups ??= new ChatGroupsClient(this._options));
37:     }
38: 
39:     public get chats(): ChatsClient {
40:         return (this._chats ??= new ChatsClient(this._options));
41:     }
42: 
43:     public get configs(): ConfigsClient {
44:         return (this._configs ??= new ConfigsClient(this._options));
45:     }
46: 
47:     public get prompts(): PromptsClient {
48:         return (this._prompts ??= new PromptsClient(this._options));
49:     }
50: 
51:     public get tools(): ToolsClient {
52:         return (this._tools ??= new ToolsClient(this._options));
53:     }
54: 
55:     public get chat(): ChatClient {
56:         return (this._chat ??= new ChatClient(this._options));
57:     }
58: }
````

## File: src/api/resources/empathicVoice/client/index.ts
````typescript
1: export {};
````

## File: src/api/resources/empathicVoice/errors/BadRequestError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as core from "../../../../core/index.js";
 4: import * as errors from "../../../../errors/index.js";
 5: import type * as Hume from "../../../index.js";
 6: 
 7: export class BadRequestError extends errors.HumeError {
 8:     constructor(body: Hume.empathicVoice.ErrorResponse, rawResponse?: core.RawResponse) {
 9:         super({
10:             message: "BadRequestError",
11:             statusCode: 400,
12:             body: body,
13:             rawResponse: rawResponse,
14:         });
15:         Object.setPrototypeOf(this, new.target.prototype);
16:         if (Error.captureStackTrace) {
17:             Error.captureStackTrace(this, this.constructor);
18:         }
19: 
20:         this.name = this.constructor.name;
21:     }
22: }
````

## File: src/api/resources/empathicVoice/errors/index.ts
````typescript
1: export * from "./BadRequestError.js";
2: export * from "./UnprocessableEntityError.js";
````

## File: src/api/resources/empathicVoice/errors/UnprocessableEntityError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as core from "../../../../core/index.js";
 4: import * as errors from "../../../../errors/index.js";
 5: import type * as Hume from "../../../index.js";
 6: 
 7: export class UnprocessableEntityError extends errors.HumeError {
 8:     constructor(body: Hume.empathicVoice.HttpValidationError, rawResponse?: core.RawResponse) {
 9:         super({
10:             message: "UnprocessableEntityError",
11:             statusCode: 422,
12:             body: body,
13:             rawResponse: rawResponse,
14:         });
15:         Object.setPrototypeOf(this, new.target.prototype);
16:         if (Error.captureStackTrace) {
17:             Error.captureStackTrace(this, this.constructor);
18:         }
19: 
20:         this.name = this.constructor.name;
21:     }
22: }
````

## File: src/api/resources/empathicVoice/resources/chat/client/Client.ts
````typescript
  1: /** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
  2: import type { BaseClientOptions } from "../../../../../../BaseClient.js";
  3: import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
  4: import * as core from "../../../../../../core/index.js";
  5: import * as environments from "../../../../../../environments.js";
  6: import * as serializers from "../../../../../../serialization/index.js";
  7: import type * as Hume from "../../../../../index.js";
  8: import { mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
  9: import { ChatSocket } from "./Socket.js";
 10: 
 11: export declare namespace ChatClient {
 12:     export type Options = BaseClientOptions;
 13: 
 14:     export interface ConnectArgs {
 15:         accessToken?: string;
 16:         allowConnection?: boolean;
 17:         configId?: string;
 18:         /** Accepts both string and number for backward compatibility */
 19:         configVersion?: string | number;
 20:         eventLimit?: number;
 21:         resumedChatGroupId?: string;
 22:         verboseTranscription?: boolean;
 23:         /** @deprecated Use sessionSettings.voiceId instead */
 24:         voiceId?: string;
 25:         apiKey?: string;
 26:         sessionSettings?: Hume.empathicVoice.ConnectSessionSettings;
 27:         /** Extra query parameters sent at WebSocket connection  for backward compatibility */
 28:         queryParams?: Record<string, string | string[] | object | object[]>;
 29:         /** Arbitrary headers to send with the websocket connect request. */
 30:         headers?: Record<string, string>;
 31:         debug?: boolean;
 32:         reconnectAttempts?: number;
 33:     }
 34: }
 35: 
 36: export class ChatClient {
 37:     protected readonly _options: NormalizedClientOptions<ChatClient.Options>;
 38: 
 39:     constructor(options: ChatClient.Options = {}) {
 40:         this._options = normalizeClientOptions(options);
 41:     }
 42: 
 43:     public connect(args: ChatClient.ConnectArgs = {}): ChatSocket {
 44:         const {
 45:             accessToken,
 46:             allowConnection,
 47:             configId,
 48:             configVersion,
 49:             eventLimit,
 50:             resumedChatGroupId,
 51:             verboseTranscription,
 52:             voiceId,
 53:             apiKey,
 54:             sessionSettings,
 55:             queryParams,
 56:             headers,
 57:             debug,
 58:             reconnectAttempts,
 59:         } = args;
 60: 
 61:         const _queryParams: Record<string, string | string[] | object | object[] | null | undefined> = {
 62:             access_token: accessToken,
 63:             allow_connection: allowConnection != null ? (allowConnection ? "true" : "false") : undefined,
 64:             config_id: configId,
 65:             config_version:
 66:                 configVersion != null
 67:                     ? typeof configVersion === "number"
 68:                         ? configVersion.toString()
 69:                         : configVersion
 70:                     : undefined,
 71:             event_limit: eventLimit != null ? eventLimit.toString() : undefined,
 72:             resumed_chat_group_id: resumedChatGroupId,
 73:             verbose_transcription: verboseTranscription != null ? verboseTranscription.toString() : undefined,
 74:             voice_id: voiceId,
 75:             api_key: apiKey,
 76:             session_settings:
 77:                 sessionSettings != null
 78:                     ? serializers.empathicVoice.ConnectSessionSettings.jsonOrThrow(sessionSettings, {
 79:                           unrecognizedObjectKeys: "passthrough",
 80:                           allowUnrecognizedUnionMembers: true,
 81:                           allowUnrecognizedEnumValues: true,
 82:                           omitUndefined: true,
 83:                           breadcrumbsPrefix: ["request", "sessionSettings"],
 84:                       })
 85:                     : undefined,
 86:         };
 87: 
 88:         // Merge in any additional query parameters
 89:         if (queryParams != null) {
 90:             for (const [name, value] of Object.entries(queryParams)) {
 91:                 _queryParams[name] = value;
 92:             }
 93:         }
 94: 
 95:         const _headers: Record<string, unknown> = mergeOnlyDefinedHeaders({
 96:             ...this._getCustomAuthorizationHeaders(),
 97:             ...headers,
 98:         });
 99:         const socket = new core.ReconnectingWebSocket({
100:             url: core.url.join(
101:                 core.Supplier.get(this._options.baseUrl) ??
102:                     (core.Supplier.get(this._options.environment) ?? environments.HumeEnvironment.Prod).evi,
103:                 "/chat",
104:             ),
105:             protocols: [],
106:             queryParameters: _queryParams,
107:             headers: _headers,
108:             options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
109:         });
110: 
111:         return new ChatSocket({ socket });
112:     }
113: 
114:     protected _getCustomAuthorizationHeaders(): Record<string, string | null | undefined> {
115:         const apiKeyValue = core.Supplier.get(this._options.apiKey);
116:         // This `authHeaderValue` is manually added as if you don't provide it it will
117:         // be omitted from the headers which means it won't reach the logic in ws.ts that
118:         // extracts values from the headers and adds them to query parameters.
119:         const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
120:         return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
121:     }
122: }
````

## File: src/api/resources/empathicVoice/resources/chat/client/Client.ts.diff
````diff
  1: diff --git a/src/api/resources/empathicVoice/resources/chat/client/Client.ts b/src/api/resources/empathicVoice/resources/chat/client/Client.ts
  2: index b67a3a3..6a5e46a 100644
  3: --- a/src/api/resources/empathicVoice/resources/chat/client/Client.ts
  4: +++ b/src/api/resources/empathicVoice/resources/chat/client/Client.ts
  5: @@ -1,36 +1,26 @@
  6: -/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
  7: +// This file was auto-generated by Fern from our API Definition.
  8:  
  9: -import * as environments from "../../../../../../environments.js";
 10: +import type { BaseClientOptions } from "../../../../../../BaseClient.js";
 11: +import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
 12:  import * as core from "../../../../../../core/index.js";
 13: -import * as Hume from "../../../../../index.js";
 14: -import { mergeOnlyDefinedHeaders, mergeHeaders } from "../../../../../../core/headers.js";
 15: +import * as environments from "../../../../../../environments.js";
 16:  import * as serializers from "../../../../../../serialization/index.js";
 17: +import type * as Hume from "../../../../../index.js";
 18:  import { ChatSocket } from "./Socket.js";
 19:  
 20:  export declare namespace ChatClient {
 21: -    export interface Options {
 22: -        environment?: core.Supplier<environments.HumeEnvironment | environments.HumeEnvironmentUrls>;
 23: -        /** Specify a custom URL to connect the client to. */
 24: -        baseUrl?: core.Supplier<string>;
 25: -        apiKey?: core.Supplier<string | undefined>;
 26: -        /** Additional headers to include in requests. */
 27: -        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
 28: -    }
 29: +    export type Options = BaseClientOptions;
 30:  
 31:      export interface ConnectArgs {
 32: -        accessToken?: string | undefined;
 33: -        configId?: string | undefined;
 34: -        configVersion?: string | number | undefined;
 35: -        eventLimit?: number | undefined;
 36: -        resumedChatGroupId?: string | undefined;
 37: -        verboseTranscription?: boolean | undefined;
 38: -        allowConnection?: boolean | undefined;
 39: -        /** @deprecated Use sessionSettings.voiceId instead */
 40: -        voiceId?: string | undefined;
 41: -        apiKey?: string | undefined;
 42: -        sessionSettings?: Hume.empathicVoice.ConnectSessionSettings;
 43: -        /** Extra query parameters sent at WebSocket connection */
 44: -        queryParams?: Record<string, string | string[] | object | object[]>;
 45: +        accessToken?: string;
 46: +        allowConnection?: boolean;
 47: +        configId?: string;
 48: +        configVersion?: number;
 49: +        eventLimit?: number;
 50: +        resumedChatGroupId?: string;
 51: +        verboseTranscription?: boolean;
 52: +        apiKey?: string;
 53: +        sessionSettings: Hume.empathicVoice.ConnectSessionSettings;
 54:          /** Arbitrary headers to send with the websocket connect request. */
 55:          headers?: Record<string, string>;
 56:          /** Enable debug mode on the websocket. Defaults to false. */
 57: @@ -41,97 +31,49 @@ export declare namespace ChatClient {
 58:  }
 59:  
 60:  export class ChatClient {
 61: -    protected readonly _options: ChatClient.Options;
 62: +    protected readonly _options: NormalizedClientOptions<ChatClient.Options>;
 63:  
 64: -    constructor(_options: ChatClient.Options = {}) {
 65: -        this._options = _options;
 66: +    constructor(options: ChatClient.Options = {}) {
 67: +        this._options = normalizeClientOptions(options);
 68:      }
 69:  
 70: -    public connect(args: ChatClient.ConnectArgs = {}): ChatSocket {
 71: +    public async connect(args: ChatClient.ConnectArgs): Promise<ChatSocket> {
 72:          const {
 73:              accessToken,
 74: +            allowConnection,
 75:              configId,
 76:              configVersion,
 77:              eventLimit,
 78:              resumedChatGroupId,
 79:              verboseTranscription,
 80: -            voiceId,
 81:              apiKey,
 82:              sessionSettings,
 83: -            queryParams,
 84:              headers,
 85:              debug,
 86:              reconnectAttempts,
 87: -            allowConnection,
 88:          } = args;
 89: -        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
 90: -
 91: -        if (accessToken != null) {
 92: -            _queryParams["access_token"] = accessToken;
 93: -        }
 94: -
 95: -        if (configId != null) {
 96: -            _queryParams["config_id"] = configId;
 97: -        }
 98: -
 99: -        if (configVersion != null) {
100: -            _queryParams["config_version"] =
101: -                typeof configVersion === "number" ? configVersion.toString() : configVersion;
102: -        }
103: -
104: -        if (eventLimit != null) {
105: -            _queryParams["event_limit"] = eventLimit.toString();
106: -        }
107: -
108: -        if (resumedChatGroupId != null) {
109: -            _queryParams["resumed_chat_group_id"] = resumedChatGroupId;
110: -        }
111: -
112: -        if (verboseTranscription != null) {
113: -            _queryParams["verbose_transcription"] = verboseTranscription.toString();
114: -        }
115: -
116: -        if (voiceId != null) {
117: -            _queryParams["voice_id"] = voiceId;
118: -        }
119: -
120: -        if (apiKey != null) {
121: -            _queryParams["api_key"] = apiKey;
122: -        }
123: -
124: -        if (allowConnection != null) {
125: -            _queryParams["allow_connection"] = allowConnection === true ? "true" : "false";
126: -        }
127: -
128: -        if (sessionSettings != null) {
129: -            _queryParams["session_settings"] = serializers.empathicVoice.ConnectSessionSettings.jsonOrThrow(
130: -                sessionSettings,
131: -                {
132: -                    unrecognizedObjectKeys: "passthrough",
133: -                    allowUnrecognizedUnionMembers: true,
134: -                    allowUnrecognizedEnumValues: true,
135: -                    omitUndefined: true,
136: -                    breadcrumbsPrefix: ["request", "sessionSettings"],
137: -                },
138: -            );
139: -        }
140: -
141: -        // Merge in any additional query parameters
142: -        if (queryParams != null) {
143: -            for (const [name, value] of Object.entries(queryParams)) {
144: -                _queryParams[name] = value;
145: -            }
146: -        }
147: -
148: -        let _headers: Record<string, unknown> = mergeHeaders(
149: -            mergeOnlyDefinedHeaders({ ...this._getCustomAuthorizationHeaders() }),
150: -            headers,
151: -        );
152: -
153: +        const _queryParams: Record<string, unknown> = {
154: +            access_token: accessToken,
155: +            allow_connection: allowConnection,
156: +            config_id: configId,
157: +            config_version: configVersion,
158: +            event_limit: eventLimit,
159: +            resumed_chat_group_id: resumedChatGroupId,
160: +            verbose_transcription: verboseTranscription,
161: +            api_key: apiKey,
162: +            session_settings: serializers.empathicVoice.ConnectSessionSettings.jsonOrThrow(sessionSettings, {
163: +                unrecognizedObjectKeys: "passthrough",
164: +                allowUnrecognizedUnionMembers: true,
165: +                allowUnrecognizedEnumValues: true,
166: +                omitUndefined: true,
167: +                breadcrumbsPrefix: ["request", "sessionSettings"],
168: +            }),
169: +        };
170: +        const _headers: Record<string, unknown> = { ...headers };
171:          const socket = new core.ReconnectingWebSocket({
172:              url: core.url.join(
173: -                core.Supplier.get(this._options["baseUrl"]) ??
174: -                    (core.Supplier.get(this._options["environment"]) ?? environments.HumeEnvironment.Prod).evi,
175: +                (await core.Supplier.get(this._options.baseUrl)) ??
176: +                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).evi,
177:                  "/chat",
178:              ),
179:              protocols: [],
180: @@ -141,13 +83,4 @@ export class ChatClient {
181:          });
182:          return new ChatSocket({ socket });
183:      }
184: -
185: -    protected _getCustomAuthorizationHeaders(): Record<string, string | null | undefined> {
186: -        const apiKeyValue = core.Supplier.get(this._options.apiKey);
187: -        // This `authHeaderValue` is manually added as if you don't provide it it will
188: -        // be omitted from the headers which means it won't reach the logic in ws.ts that
189: -        // extracts values from the headers and adds them to query parameters.
190: -        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
191: -        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
192: -    }
193:  }
````

## File: src/api/resources/empathicVoice/resources/chat/client/index.ts
````typescript
1: /** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
2: export { ChatSocket } from "./Socket.js";
3: export { ChatClient as Chat } from "./Client.js";
````

## File: src/api/resources/empathicVoice/resources/chat/client/index.ts.diff
````diff
1: diff --git a/src/api/resources/empathicVoice/resources/chat/client/index.ts b/src/api/resources/empathicVoice/resources/chat/client/index.ts
2: index ff59f82..cb0ff5c 100644
3: --- a/src/api/resources/empathicVoice/resources/chat/client/index.ts
4: +++ b/src/api/resources/empathicVoice/resources/chat/client/index.ts
5: @@ -1,3 +1 @@
6: -/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
7: -export { ChatSocket } from "./Socket.js";
8: -export { ChatClient as Chat } from "./Client.js";
9: +export {};
````

## File: src/api/resources/empathicVoice/resources/chat/client/Socket.ts
````typescript
  1: /** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
  2: 
  3: import * as core from "../../../../../../core/index.js";
  4: import * as Hume from "../../../../../index.js";
  5: import { PublishEvent } from "../../../../../../serialization/resources/empathicVoice/resources/chat/types/PublishEvent.js";
  6: import { fromJson } from "../../../../../../core/json.js";
  7: import * as serializers from "../../../../../../serialization/index.js";
  8: 
  9: export declare namespace ChatSocket {
 10:     export interface Args {
 11:         socket: core.ReconnectingWebSocket;
 12:     }
 13: 
 14:     export type Response = Hume.empathicVoice.SubscribeEvent & { receivedAt: Date };
 15:     type EventHandlers = {
 16:         open?: () => void;
 17:         message?: (message: Response) => void;
 18:         close?: (event: core.CloseEvent) => void;
 19:         error?: (error: Error) => void;
 20:     };
 21: }
 22: 
 23: export class ChatSocket {
 24:     public readonly socket: core.ReconnectingWebSocket;
 25:     protected readonly eventHandlers: ChatSocket.EventHandlers = {};
 26:     private handleOpen: () => void = () => {
 27:         this.eventHandlers.open?.();
 28:     };
 29:     private handleMessage: (event: { data: string }) => void = (event) => {
 30:         const data = fromJson(event.data);
 31: 
 32:         const parsedResponse = serializers.empathicVoice.ChatSocketResponse.parse(data, {
 33:             unrecognizedObjectKeys: "passthrough",
 34:             allowUnrecognizedUnionMembers: true,
 35:             allowUnrecognizedEnumValues: true,
 36:             skipValidation: true,
 37:             omitUndefined: true,
 38:         });
 39:         if (parsedResponse.ok) {
 40:             this.eventHandlers.message?.({
 41:                 ...parsedResponse.value,
 42:                 receivedAt: new Date(),
 43:             });
 44:         } else {
 45:             this.eventHandlers.error?.(new Error("Received unknown message type"));
 46:         }
 47:     };
 48:     private handleClose: (event: core.CloseEvent) => void = (event) => {
 49:         this.eventHandlers.close?.(event);
 50:     };
 51:     private handleError: (event: core.ErrorEvent) => void = (event) => {
 52:         const message = event.message;
 53:         this.eventHandlers.error?.(new Error(message));
 54:     };
 55: 
 56:     constructor(args: ChatSocket.Args) {
 57:         this.socket = args.socket;
 58:         this.socket.addEventListener("open", this.handleOpen);
 59:         this.socket.addEventListener("message", this.handleMessage);
 60:         this.socket.addEventListener("close", this.handleClose);
 61:         this.socket.addEventListener("error", this.handleError);
 62:     }
 63: 
 64:     /** The current state of the connection; this is one of the readyState constants. */
 65:     get readyState(): number {
 66:         return this.socket.readyState;
 67:     }
 68: 
 69:     /**
 70:      * @param event - The event to attach to.
 71:      * @param callback - The callback to run when the event is triggered.
 72:      * Usage:
 73:      * ```typescript
 74:      * this.on('open', () => {
 75:      *     console.log('The websocket is open');
 76:      * });
 77:      * ```
 78:      */
 79:     public on<T extends keyof ChatSocket.EventHandlers>(event: T, callback: ChatSocket.EventHandlers[T]): void {
 80:         this.eventHandlers[event] = callback;
 81:     }
 82: 
 83:     public sendPublish(message: Hume.empathicVoice.PublishEvent): void {
 84:         this.assertSocketIsOpen();
 85:         const jsonPayload = PublishEvent.jsonOrThrow(message, {
 86:             unrecognizedObjectKeys: "passthrough",
 87:             allowUnrecognizedUnionMembers: true,
 88:             allowUnrecognizedEnumValues: true,
 89:             skipValidation: true,
 90:             omitUndefined: true,
 91:         });
 92:         this.socket.send(JSON.stringify(jsonPayload));
 93:     }
 94: 
 95:     /**
 96:      * Send audio input
 97:      */
 98:     public sendAudioInput(message: Omit<Hume.empathicVoice.AudioInput, "type">): void {
 99:         this.sendPublish({
100:             type: "audio_input",
101:             ...message,
102:         });
103:     }
104: 
105:     /**
106:      * Send session settings
107:      */
108:     public sendSessionSettings(message: Omit<Hume.empathicVoice.SessionSettings, "type"> = {}): void {
109:         this.sendPublish({
110:             type: "session_settings",
111:             ...message,
112:         });
113:     }
114: 
115:     /**
116:      * Send assistant input
117:      */
118:     public sendAssistantInput(message: Omit<Hume.empathicVoice.AssistantInput, "type">): void {
119:         this.sendPublish({
120:             type: "assistant_input",
121:             ...message,
122:         });
123:     }
124: 
125:     /**
126:      * Send pause assistant message
127:      */
128:     public pauseAssistant(message: Omit<Hume.empathicVoice.PauseAssistantMessage, "type"> = {}): void {
129:         this.sendPublish({
130:             type: "pause_assistant_message",
131:             ...message,
132:         });
133:     }
134: 
135:     /**
136:      * Send resume assistant message
137:      */
138:     public resumeAssistant(message: Omit<Hume.empathicVoice.ResumeAssistantMessage, "type"> = {}): void {
139:         this.sendPublish({
140:             type: "resume_assistant_message",
141:             ...message,
142:         });
143:     }
144: 
145:     /**
146:      * Send tool response message
147:      */
148:     public sendToolResponseMessage(message: Omit<Hume.empathicVoice.ToolResponseMessage, "type">): void {
149:         this.sendPublish({
150:             type: "tool_response",
151:             ...message,
152:         });
153:     }
154: 
155:     /**
156:      * Send tool error message
157:      */
158:     public sendToolErrorMessage(message: Omit<Hume.empathicVoice.ToolErrorMessage, "type">): void {
159:         this.sendPublish({
160:             type: "tool_error",
161:             ...message,
162:         });
163:     }
164: 
165:     /**
166:      * Send text input
167:      */
168:     public sendUserInput(text: string): void {
169:         this.sendPublish({
170:             type: "user_input",
171:             text,
172:         });
173:     }
174: 
175:     /** Connect to the websocket and register event handlers. */
176:     public connect(): ChatSocket {
177:         this.socket.reconnect();
178: 
179:         this.socket.addEventListener("open", this.handleOpen);
180:         this.socket.addEventListener("message", this.handleMessage);
181:         this.socket.addEventListener("close", this.handleClose);
182:         this.socket.addEventListener("error", this.handleError);
183: 
184:         return this;
185:     }
186: 
187:     /** Close the websocket and unregister event handlers. */
188:     public close(): void {
189:         this.socket.close();
190: 
191:         this.handleClose({ code: 1000 } as CloseEvent);
192: 
193:         this.socket.removeEventListener("open", this.handleOpen);
194:         this.socket.removeEventListener("message", this.handleMessage);
195:         this.socket.removeEventListener("close", this.handleClose);
196:         this.socket.removeEventListener("error", this.handleError);
197:     }
198: 
199:     /** Returns a promise that resolves when the websocket is open. */
200:     public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
201:         if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
202:             return this.socket;
203:         }
204: 
205:         return new Promise((resolve, reject) => {
206:             this.socket.addEventListener("open", () => {
207:                 resolve(this.socket);
208:             });
209: 
210:             this.socket.addEventListener("error", (event: unknown) => {
211:                 reject(event);
212:             });
213:         });
214:     }
215: 
216:     /**
217:      * @deprecated Use waitForOpen() instead
218:      */
219:     public async tillSocketOpen(): Promise<core.ReconnectingWebSocket> {
220:         return this.waitForOpen();
221:     }
222: 
223:     /** Asserts that the websocket is open. */
224:     private assertSocketIsOpen(): void {
225:         if (!this.socket) {
226:             throw new Error("Socket is not connected.");
227:         }
228: 
229:         if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
230:             throw new Error("Socket is not open.");
231:         }
232:     }
233: 
234:     /** Send a binary payload to the websocket. */
235:     protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
236:         this.socket.send(payload);
237:     }
238: }
````

## File: src/api/resources/empathicVoice/resources/chat/client/Socket.ts.diff
````diff
  1: diff --git a/src/api/resources/empathicVoice/resources/chat/client/Socket.ts b/src/api/resources/empathicVoice/resources/chat/client/Socket.ts
  2: index a55c7b5..0f2f2a5 100644
  3: --- a/src/api/resources/empathicVoice/resources/chat/client/Socket.ts
  4: +++ b/src/api/resources/empathicVoice/resources/chat/client/Socket.ts
  5: @@ -1,17 +1,17 @@
  6: -/** THIS FILE IS MANUALLY MAINTAINED: see .fernignore */
  7: +// This file was auto-generated by Fern from our API Definition.
  8:  
  9:  import * as core from "../../../../../../core/index.js";
 10: -import * as Hume from "../../../../../index.js";
 11: -import { PublishEvent } from "../../../../../../serialization/resources/empathicVoice/resources/chat/types/PublishEvent.js";
 12:  import { fromJson } from "../../../../../../core/json.js";
 13:  import * as serializers from "../../../../../../serialization/index.js";
 14: +import { PublishEvent } from "../../../../../../serialization/resources/empathicVoice/resources/chat/types/PublishEvent.js";
 15: +import type * as Hume from "../../../../../index.js";
 16:  
 17:  export declare namespace ChatSocket {
 18:      export interface Args {
 19:          socket: core.ReconnectingWebSocket;
 20:      }
 21:  
 22: -    export type Response = Hume.empathicVoice.SubscribeEvent & { receivedAt: Date };
 23: +    export type Response = Hume.empathicVoice.SubscribeEvent;
 24:      type EventHandlers = {
 25:          open?: () => void;
 26:          message?: (message: Response) => void;
 27: @@ -37,10 +37,7 @@ export class ChatSocket {
 28:              omitUndefined: true,
 29:          });
 30:          if (parsedResponse.ok) {
 31: -            this.eventHandlers.message?.({
 32: -                ...parsedResponse.value,
 33: -                receivedAt: new Date(),
 34: -            });
 35: +            this.eventHandlers.message?.(parsedResponse.value);
 36:          } else {
 37:              this.eventHandlers.error?.(new Error("Received unknown message type"));
 38:          }
 39: @@ -92,86 +89,6 @@ export class ChatSocket {
 40:          this.socket.send(JSON.stringify(jsonPayload));
 41:      }
 42:  
 43: -    /**
 44: -     * Send audio input
 45: -     */
 46: -    public sendAudioInput(message: Omit<Hume.empathicVoice.AudioInput, "type">): void {
 47: -        this.sendPublish({
 48: -            type: "audio_input",
 49: -            ...message,
 50: -        });
 51: -    }
 52: -
 53: -    /**
 54: -     * Send session settings
 55: -     */
 56: -    public sendSessionSettings(message: Omit<Hume.empathicVoice.SessionSettings, "type"> = {}): void {
 57: -        this.sendPublish({
 58: -            type: "session_settings",
 59: -            ...message,
 60: -        });
 61: -    }
 62: -
 63: -    /**
 64: -     * Send assistant input
 65: -     */
 66: -    public sendAssistantInput(message: Omit<Hume.empathicVoice.AssistantInput, "type">): void {
 67: -        this.sendPublish({
 68: -            type: "assistant_input",
 69: -            ...message,
 70: -        });
 71: -    }
 72: -
 73: -    /**
 74: -     * Send pause assistant message
 75: -     */
 76: -    public pauseAssistant(message: Omit<Hume.empathicVoice.PauseAssistantMessage, "type"> = {}): void {
 77: -        this.sendPublish({
 78: -            type: "pause_assistant_message",
 79: -            ...message,
 80: -        });
 81: -    }
 82: -
 83: -    /**
 84: -     * Send resume assistant message
 85: -     */
 86: -    public resumeAssistant(message: Omit<Hume.empathicVoice.ResumeAssistantMessage, "type"> = {}): void {
 87: -        this.sendPublish({
 88: -            type: "resume_assistant_message",
 89: -            ...message,
 90: -        });
 91: -    }
 92: -
 93: -    /**
 94: -     * Send tool response message
 95: -     */
 96: -    public sendToolResponseMessage(message: Omit<Hume.empathicVoice.ToolResponseMessage, "type">): void {
 97: -        this.sendPublish({
 98: -            type: "tool_response",
 99: -            ...message,
100: -        });
101: -    }
102: -
103: -    /**
104: -     * Send tool error message
105: -     */
106: -    public sendToolErrorMessage(message: Omit<Hume.empathicVoice.ToolErrorMessage, "type">): void {
107: -        this.sendPublish({
108: -            type: "tool_error",
109: -            ...message,
110: -        });
111: -    }
112: -
113: -    /**
114: -     * Send text input
115: -     */
116: -    public sendUserInput(text: string): void {
117: -        this.sendPublish({
118: -            type: "user_input",
119: -            text,
120: -        });
121: -    }
122: -
123:      /** Connect to the websocket and register event handlers. */
124:      public connect(): ChatSocket {
125:          this.socket.reconnect();
126: @@ -213,13 +130,6 @@ export class ChatSocket {
127:          });
128:      }
129:  
130: -    /**
131: -     * @deprecated Use waitForOpen() instead
132: -     */
133: -    public async tillSocketOpen(): Promise<core.ReconnectingWebSocket> {
134: -        return this.waitForOpen();
135: -    }
136: -
137:      /** Asserts that the websocket is open. */
138:      private assertSocketIsOpen(): void {
139:          if (!this.socket) {
````

## File: src/api/resources/empathicVoice/resources/chat/types/index.ts
````typescript
1: export * from "./PublishEvent.js";
````

## File: src/api/resources/empathicVoice/resources/chat/types/PublishEvent.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export type PublishEvent =
 6:     | Hume.empathicVoice.AudioInput
 7:     | Hume.empathicVoice.SessionSettings
 8:     | Hume.empathicVoice.UserInput
 9:     | Hume.empathicVoice.AssistantInput
10:     | Hume.empathicVoice.ToolResponseMessage
11:     | Hume.empathicVoice.ToolErrorMessage
12:     | Hume.empathicVoice.PauseAssistantMessage
13:     | Hume.empathicVoice.ResumeAssistantMessage;
````

## File: src/api/resources/empathicVoice/resources/chat/types/SubscribeEvent.ts
````typescript
 1: /**
 2:  * This file was manually added to provide backward compatibility.
 3:  *
 4:  * @deprecated Use `Hume.empathicVoice.SubscribeEvent` instead.
 5:  * This type alias will be removed in a future version.
 6:  */
 7: 
 8: import type { SubscribeEvent as NewSubscribeEvent } from "../../../types/SubscribeEvent.js";
 9: 
10: /**
11:  * @deprecated Use `Hume.empathicVoice.SubscribeEvent` instead.
12:  * This type alias will be removed in a future version.
13:  */
14: export type SubscribeEvent = NewSubscribeEvent;
````

## File: src/api/resources/empathicVoice/resources/chat/index.ts
````typescript
1: export * from "./types/index.js";
2: export * from "./client/index.js";
3: /**
4:  * @deprecated Use `Hume.empathicVoice.SubscribeEvent` instead.
5:  * This type alias will be removed in a future version.
6:  */
7: export type { SubscribeEvent } from "./types/SubscribeEvent.js";
````

## File: src/api/resources/empathicVoice/resources/chat/index.ts.diff
````diff
 1: diff --git a/src/api/resources/empathicVoice/resources/chat/index.ts b/src/api/resources/empathicVoice/resources/chat/index.ts
 2: index a2f33dc..d9adb1a 100644
 3: --- a/src/api/resources/empathicVoice/resources/chat/index.ts
 4: +++ b/src/api/resources/empathicVoice/resources/chat/index.ts
 5: @@ -1,7 +1,2 @@
 6: -export * from "./types/index.js";
 7:  export * from "./client/index.js";
 8: -/**
 9: - * @deprecated Use `Hume.empathicVoice.SubscribeEvent` instead.
10: - * This type alias will be removed in a future version.
11: - */
12: -export type { SubscribeEvent } from "./types/SubscribeEvent.js";
13: +export * from "./types/index.js";
````

## File: src/api/resources/empathicVoice/resources/chatGroups/client/requests/ChatGroupsGetAudioRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         pageNumber: 0,
 7:  *         pageSize: 10,
 8:  *         ascendingOrder: true
 9:  *     }
10:  */
11: export interface ChatGroupsGetAudioRequest {
12:     /**
13:      * Specifies the page number to retrieve, enabling pagination.
14:      *
15:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
16:      */
17:     pageNumber?: number;
18:     /**
19:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
20:      *
21:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
22:      */
23:     pageSize?: number;
24:     /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
25:     ascendingOrder?: boolean;
26: }
````

## File: src/api/resources/empathicVoice/resources/chatGroups/client/requests/ChatGroupsGetChatGroupRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         pageNumber: 0,
 7:  *         pageSize: 1,
 8:  *         ascendingOrder: true
 9:  *     }
10:  */
11: export interface ChatGroupsGetChatGroupRequest {
12:     /** Chat status to apply to the chat. String from the ChatStatus enum. */
13:     status?: string;
14:     /**
15:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
16:      *
17:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
18:      */
19:     pageSize?: number;
20:     /**
21:      * Specifies the page number to retrieve, enabling pagination.
22:      *
23:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
24:      */
25:     pageNumber?: number;
26:     /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
27:     ascendingOrder?: boolean;
28: }
````

## File: src/api/resources/empathicVoice/resources/chatGroups/client/requests/ChatGroupsListChatGroupEventsRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         pageNumber: 0,
 7:  *         pageSize: 3,
 8:  *         ascendingOrder: true
 9:  *     }
10:  */
11: export interface ChatGroupsListChatGroupEventsRequest {
12:     /**
13:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
14:      *
15:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
16:      */
17:     pageSize?: number;
18:     /**
19:      * Specifies the page number to retrieve, enabling pagination.
20:      *
21:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
22:      */
23:     pageNumber?: number;
24:     /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
25:     ascendingOrder?: boolean;
26: }
````

## File: src/api/resources/empathicVoice/resources/chatGroups/client/requests/ChatGroupsListChatGroupsRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         pageNumber: 0,
 7:  *         pageSize: 1,
 8:  *         ascendingOrder: true,
 9:  *         configId: "1b60e1a0-cc59-424a-8d2c-189d354db3f3"
10:  *     }
11:  */
12: export interface ChatGroupsListChatGroupsRequest {
13:     /**
14:      * Specifies the page number to retrieve, enabling pagination.
15:      *
16:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
17:      */
18:     pageNumber?: number;
19:     /**
20:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
21:      *
22:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
23:      */
24:     pageSize?: number;
25:     /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
26:     ascendingOrder?: boolean;
27:     /** Filter chatgroups to only include chats that used this config in their most recent chat. */
28:     configId?: string;
29: }
````

## File: src/api/resources/empathicVoice/resources/chatGroups/client/requests/index.ts
````typescript
1: export type { ChatGroupsGetAudioRequest } from "./ChatGroupsGetAudioRequest.js";
2: export type { ChatGroupsGetChatGroupRequest } from "./ChatGroupsGetChatGroupRequest.js";
3: export type { ChatGroupsListChatGroupEventsRequest } from "./ChatGroupsListChatGroupEventsRequest.js";
4: export type { ChatGroupsListChatGroupsRequest } from "./ChatGroupsListChatGroupsRequest.js";
````

## File: src/api/resources/empathicVoice/resources/chatGroups/client/Client.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
  4: import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
  5: import { mergeHeaders } from "../../../../../../core/headers.js";
  6: import * as core from "../../../../../../core/index.js";
  7: import * as environments from "../../../../../../environments.js";
  8: import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
  9: import * as errors from "../../../../../../errors/index.js";
 10: import * as serializers from "../../../../../../serialization/index.js";
 11: import * as Hume from "../../../../../index.js";
 12: 
 13: export declare namespace ChatGroupsClient {
 14:     export type Options = BaseClientOptions;
 15: 
 16:     export interface RequestOptions extends BaseRequestOptions {}
 17: }
 18: 
 19: export class ChatGroupsClient {
 20:     protected readonly _options: NormalizedClientOptionsWithAuth<ChatGroupsClient.Options>;
 21: 
 22:     constructor(options: ChatGroupsClient.Options = {}) {
 23:         this._options = normalizeClientOptionsWithAuth(options);
 24:     }
 25: 
 26:     /**
 27:      * @param {Hume.empathicVoice.ChatGroupsListChatGroupsRequest} request
 28:      * @param {ChatGroupsClient.RequestOptions} requestOptions - Request-specific configuration.
 29:      *
 30:      * @throws {@link Hume.empathicVoice.BadRequestError}
 31:      *
 32:      * @example
 33:      *     await client.empathicVoice.chatGroups.listChatGroups({
 34:      *         pageNumber: 0,
 35:      *         pageSize: 1,
 36:      *         ascendingOrder: true,
 37:      *         configId: "1b60e1a0-cc59-424a-8d2c-189d354db3f3"
 38:      *     })
 39:      */
 40:     public async listChatGroups(
 41:         request: Hume.empathicVoice.ChatGroupsListChatGroupsRequest = {},
 42:         requestOptions?: ChatGroupsClient.RequestOptions,
 43:     ): Promise<core.Page<Hume.empathicVoice.ReturnChatGroup, Hume.empathicVoice.ReturnPagedChatGroups>> {
 44:         const list = core.HttpResponsePromise.interceptFunction(
 45:             async (
 46:                 request: Hume.empathicVoice.ChatGroupsListChatGroupsRequest,
 47:             ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedChatGroups>> => {
 48:                 const { pageNumber, pageSize, ascendingOrder, configId } = request;
 49:                 const _queryParams: Record<string, unknown> = {
 50:                     page_number: pageNumber,
 51:                     page_size: pageSize,
 52:                     ascending_order: ascendingOrder,
 53:                     config_id: configId,
 54:                 };
 55:                 const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
 56:                 const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
 57:                     _authRequest.headers,
 58:                     this._options?.headers,
 59:                     requestOptions?.headers,
 60:                 );
 61:                 const _response = await (this._options.fetcher ?? core.fetcher)({
 62:                     url: core.url.join(
 63:                         (await core.Supplier.get(this._options.baseUrl)) ??
 64:                             ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
 65:                                 .base,
 66:                         "v0/evi/chat_groups",
 67:                     ),
 68:                     method: "GET",
 69:                     headers: _headers,
 70:                     queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
 71:                     timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
 72:                     maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
 73:                     abortSignal: requestOptions?.abortSignal,
 74:                     fetchFn: this._options?.fetch,
 75:                     logging: this._options.logging,
 76:                 });
 77:                 if (_response.ok) {
 78:                     return {
 79:                         data: serializers.empathicVoice.ReturnPagedChatGroups.parseOrThrow(_response.body, {
 80:                             unrecognizedObjectKeys: "passthrough",
 81:                             allowUnrecognizedUnionMembers: true,
 82:                             allowUnrecognizedEnumValues: true,
 83:                             skipValidation: true,
 84:                             breadcrumbsPrefix: ["response"],
 85:                         }),
 86:                         rawResponse: _response.rawResponse,
 87:                     };
 88:                 }
 89:                 if (_response.error.reason === "status-code") {
 90:                     switch (_response.error.statusCode) {
 91:                         case 400:
 92:                             throw new Hume.empathicVoice.BadRequestError(
 93:                                 serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
 94:                                     unrecognizedObjectKeys: "passthrough",
 95:                                     allowUnrecognizedUnionMembers: true,
 96:                                     allowUnrecognizedEnumValues: true,
 97:                                     skipValidation: true,
 98:                                     breadcrumbsPrefix: ["response"],
 99:                                 }),
100:                                 _response.rawResponse,
101:                             );
102:                         default:
103:                             throw new errors.HumeError({
104:                                 statusCode: _response.error.statusCode,
105:                                 body: _response.error.body,
106:                                 rawResponse: _response.rawResponse,
107:                             });
108:                     }
109:                 }
110:                 return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chat_groups");
111:             },
112:         );
113:         let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
114:         const dataWithRawResponse = await list(request).withRawResponse();
115:         return new core.Page<Hume.empathicVoice.ReturnChatGroup, Hume.empathicVoice.ReturnPagedChatGroups>({
116:             response: dataWithRawResponse.data,
117:             rawResponse: dataWithRawResponse.rawResponse,
118:             hasNextPage: (response) => (response?.chatGroupsPage ?? []).length > 0,
119:             getItems: (response) => response?.chatGroupsPage ?? [],
120:             loadPage: (_response) => {
121:                 _offset += 1;
122:                 return list(core.setObjectProperty(request, "pageNumber", _offset));
123:             },
124:         });
125:     }
126: 
127:     /**
128:      * @param {string} id - Identifier for a chat. Formatted as a UUID.
129:      * @param {Hume.empathicVoice.ChatGroupsGetChatGroupRequest} request
130:      * @param {ChatGroupsClient.RequestOptions} requestOptions - Request-specific configuration.
131:      *
132:      * @throws {@link Hume.empathicVoice.BadRequestError}
133:      *
134:      * @example
135:      *     await client.empathicVoice.chatGroups.getChatGroup("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
136:      *         pageNumber: 0,
137:      *         pageSize: 1,
138:      *         ascendingOrder: true
139:      *     })
140:      */
141:     public getChatGroup(
142:         id: string,
143:         request: Hume.empathicVoice.ChatGroupsGetChatGroupRequest = {},
144:         requestOptions?: ChatGroupsClient.RequestOptions,
145:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnChatGroupPagedChats> {
146:         return core.HttpResponsePromise.fromPromise(this.__getChatGroup(id, request, requestOptions));
147:     }
148: 
149:     private async __getChatGroup(
150:         id: string,
151:         request: Hume.empathicVoice.ChatGroupsGetChatGroupRequest = {},
152:         requestOptions?: ChatGroupsClient.RequestOptions,
153:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatGroupPagedChats>> {
154:         const { status, pageSize, pageNumber, ascendingOrder } = request;
155:         const _queryParams: Record<string, unknown> = {
156:             status,
157:             page_size: pageSize,
158:             page_number: pageNumber,
159:             ascending_order: ascendingOrder,
160:         };
161:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
162:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
163:             _authRequest.headers,
164:             this._options?.headers,
165:             requestOptions?.headers,
166:         );
167:         const _response = await (this._options.fetcher ?? core.fetcher)({
168:             url: core.url.join(
169:                 (await core.Supplier.get(this._options.baseUrl)) ??
170:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
171:                 `v0/evi/chat_groups/${core.url.encodePathParam(id)}`,
172:             ),
173:             method: "GET",
174:             headers: _headers,
175:             queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
176:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
177:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
178:             abortSignal: requestOptions?.abortSignal,
179:             fetchFn: this._options?.fetch,
180:             logging: this._options.logging,
181:         });
182:         if (_response.ok) {
183:             return {
184:                 data: serializers.empathicVoice.ReturnChatGroupPagedChats.parseOrThrow(_response.body, {
185:                     unrecognizedObjectKeys: "passthrough",
186:                     allowUnrecognizedUnionMembers: true,
187:                     allowUnrecognizedEnumValues: true,
188:                     skipValidation: true,
189:                     breadcrumbsPrefix: ["response"],
190:                 }),
191:                 rawResponse: _response.rawResponse,
192:             };
193:         }
194: 
195:         if (_response.error.reason === "status-code") {
196:             switch (_response.error.statusCode) {
197:                 case 400:
198:                     throw new Hume.empathicVoice.BadRequestError(
199:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
200:                             unrecognizedObjectKeys: "passthrough",
201:                             allowUnrecognizedUnionMembers: true,
202:                             allowUnrecognizedEnumValues: true,
203:                             skipValidation: true,
204:                             breadcrumbsPrefix: ["response"],
205:                         }),
206:                         _response.rawResponse,
207:                     );
208:                 default:
209:                     throw new errors.HumeError({
210:                         statusCode: _response.error.statusCode,
211:                         body: _response.error.body,
212:                         rawResponse: _response.rawResponse,
213:                     });
214:             }
215:         }
216: 
217:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chat_groups/{id}");
218:     }
219: 
220:     /**
221:      * @param {string} id - Identifier for a chat. Formatted as a UUID.
222:      * @param {Hume.empathicVoice.ChatGroupsGetAudioRequest} request
223:      * @param {ChatGroupsClient.RequestOptions} requestOptions - Request-specific configuration.
224:      *
225:      * @throws {@link Hume.empathicVoice.BadRequestError}
226:      *
227:      * @example
228:      *     await client.empathicVoice.chatGroups.getAudio("369846cf-6ad5-404d-905e-a8acb5cdfc78", {
229:      *         pageNumber: 0,
230:      *         pageSize: 10,
231:      *         ascendingOrder: true
232:      *     })
233:      */
234:     public getAudio(
235:         id: string,
236:         request: Hume.empathicVoice.ChatGroupsGetAudioRequest = {},
237:         requestOptions?: ChatGroupsClient.RequestOptions,
238:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructions> {
239:         return core.HttpResponsePromise.fromPromise(this.__getAudio(id, request, requestOptions));
240:     }
241: 
242:     private async __getAudio(
243:         id: string,
244:         request: Hume.empathicVoice.ChatGroupsGetAudioRequest = {},
245:         requestOptions?: ChatGroupsClient.RequestOptions,
246:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructions>> {
247:         const { pageNumber, pageSize, ascendingOrder } = request;
248:         const _queryParams: Record<string, unknown> = {
249:             page_number: pageNumber,
250:             page_size: pageSize,
251:             ascending_order: ascendingOrder,
252:         };
253:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
254:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
255:             _authRequest.headers,
256:             this._options?.headers,
257:             requestOptions?.headers,
258:         );
259:         const _response = await (this._options.fetcher ?? core.fetcher)({
260:             url: core.url.join(
261:                 (await core.Supplier.get(this._options.baseUrl)) ??
262:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
263:                 `v0/evi/chat_groups/${core.url.encodePathParam(id)}/audio`,
264:             ),
265:             method: "GET",
266:             headers: _headers,
267:             queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
268:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
269:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
270:             abortSignal: requestOptions?.abortSignal,
271:             fetchFn: this._options?.fetch,
272:             logging: this._options.logging,
273:         });
274:         if (_response.ok) {
275:             return {
276:                 data: serializers.empathicVoice.ReturnChatGroupPagedAudioReconstructions.parseOrThrow(_response.body, {
277:                     unrecognizedObjectKeys: "passthrough",
278:                     allowUnrecognizedUnionMembers: true,
279:                     allowUnrecognizedEnumValues: true,
280:                     skipValidation: true,
281:                     breadcrumbsPrefix: ["response"],
282:                 }),
283:                 rawResponse: _response.rawResponse,
284:             };
285:         }
286: 
287:         if (_response.error.reason === "status-code") {
288:             switch (_response.error.statusCode) {
289:                 case 400:
290:                     throw new Hume.empathicVoice.BadRequestError(
291:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
292:                             unrecognizedObjectKeys: "passthrough",
293:                             allowUnrecognizedUnionMembers: true,
294:                             allowUnrecognizedEnumValues: true,
295:                             skipValidation: true,
296:                             breadcrumbsPrefix: ["response"],
297:                         }),
298:                         _response.rawResponse,
299:                     );
300:                 default:
301:                     throw new errors.HumeError({
302:                         statusCode: _response.error.statusCode,
303:                         body: _response.error.body,
304:                         rawResponse: _response.rawResponse,
305:                     });
306:             }
307:         }
308: 
309:         return handleNonStatusCodeError(
310:             _response.error,
311:             _response.rawResponse,
312:             "GET",
313:             "/v0/evi/chat_groups/{id}/audio",
314:         );
315:     }
316: 
317:     /**
318:      * @param {string} id - Identifier for a chat. Formatted as a UUID.
319:      * @param {Hume.empathicVoice.ChatGroupsListChatGroupEventsRequest} request
320:      * @param {ChatGroupsClient.RequestOptions} requestOptions - Request-specific configuration.
321:      *
322:      * @throws {@link Hume.empathicVoice.BadRequestError}
323:      *
324:      * @example
325:      *     await client.empathicVoice.chatGroups.listChatGroupEvents("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
326:      *         pageNumber: 0,
327:      *         pageSize: 3,
328:      *         ascendingOrder: true
329:      *     })
330:      */
331:     public async listChatGroupEvents(
332:         id: string,
333:         request: Hume.empathicVoice.ChatGroupsListChatGroupEventsRequest = {},
334:         requestOptions?: ChatGroupsClient.RequestOptions,
335:     ): Promise<core.Page<Hume.empathicVoice.ReturnChatEvent, Hume.empathicVoice.ReturnChatGroupPagedEvents>> {
336:         const list = core.HttpResponsePromise.interceptFunction(
337:             async (
338:                 request: Hume.empathicVoice.ChatGroupsListChatGroupEventsRequest,
339:             ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatGroupPagedEvents>> => {
340:                 const { pageSize, pageNumber, ascendingOrder } = request;
341:                 const _queryParams: Record<string, unknown> = {
342:                     page_size: pageSize,
343:                     page_number: pageNumber,
344:                     ascending_order: ascendingOrder,
345:                 };
346:                 const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
347:                 const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
348:                     _authRequest.headers,
349:                     this._options?.headers,
350:                     requestOptions?.headers,
351:                 );
352:                 const _response = await (this._options.fetcher ?? core.fetcher)({
353:                     url: core.url.join(
354:                         (await core.Supplier.get(this._options.baseUrl)) ??
355:                             ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
356:                                 .base,
357:                         `v0/evi/chat_groups/${core.url.encodePathParam(id)}/events`,
358:                     ),
359:                     method: "GET",
360:                     headers: _headers,
361:                     queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
362:                     timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
363:                     maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
364:                     abortSignal: requestOptions?.abortSignal,
365:                     fetchFn: this._options?.fetch,
366:                     logging: this._options.logging,
367:                 });
368:                 if (_response.ok) {
369:                     return {
370:                         data: serializers.empathicVoice.ReturnChatGroupPagedEvents.parseOrThrow(_response.body, {
371:                             unrecognizedObjectKeys: "passthrough",
372:                             allowUnrecognizedUnionMembers: true,
373:                             allowUnrecognizedEnumValues: true,
374:                             skipValidation: true,
375:                             breadcrumbsPrefix: ["response"],
376:                         }),
377:                         rawResponse: _response.rawResponse,
378:                     };
379:                 }
380:                 if (_response.error.reason === "status-code") {
381:                     switch (_response.error.statusCode) {
382:                         case 400:
383:                             throw new Hume.empathicVoice.BadRequestError(
384:                                 serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
385:                                     unrecognizedObjectKeys: "passthrough",
386:                                     allowUnrecognizedUnionMembers: true,
387:                                     allowUnrecognizedEnumValues: true,
388:                                     skipValidation: true,
389:                                     breadcrumbsPrefix: ["response"],
390:                                 }),
391:                                 _response.rawResponse,
392:                             );
393:                         default:
394:                             throw new errors.HumeError({
395:                                 statusCode: _response.error.statusCode,
396:                                 body: _response.error.body,
397:                                 rawResponse: _response.rawResponse,
398:                             });
399:                     }
400:                 }
401:                 return handleNonStatusCodeError(
402:                     _response.error,
403:                     _response.rawResponse,
404:                     "GET",
405:                     "/v0/evi/chat_groups/{id}/events",
406:                 );
407:             },
408:         );
409:         let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
410:         const dataWithRawResponse = await list(request).withRawResponse();
411:         return new core.Page<Hume.empathicVoice.ReturnChatEvent, Hume.empathicVoice.ReturnChatGroupPagedEvents>({
412:             response: dataWithRawResponse.data,
413:             rawResponse: dataWithRawResponse.rawResponse,
414:             hasNextPage: (response) => (response?.eventsPage ?? []).length > 0,
415:             getItems: (response) => response?.eventsPage ?? [],
416:             loadPage: (_response) => {
417:                 _offset += 1;
418:                 return list(core.setObjectProperty(request, "pageNumber", _offset));
419:             },
420:         });
421:     }
422: }
````

## File: src/api/resources/empathicVoice/resources/chatGroups/client/index.ts
````typescript
1: export * from "./requests/index.js";
````

## File: src/api/resources/empathicVoice/resources/chatGroups/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/api/resources/empathicVoice/resources/chats/client/requests/ChatsListChatEventsRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         pageNumber: 0,
 7:  *         pageSize: 3,
 8:  *         ascendingOrder: true
 9:  *     }
10:  */
11: export interface ChatsListChatEventsRequest {
12:     /**
13:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
14:      *
15:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
16:      */
17:     pageSize?: number;
18:     /**
19:      * Specifies the page number to retrieve, enabling pagination.
20:      *
21:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
22:      */
23:     pageNumber?: number;
24:     /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
25:     ascendingOrder?: boolean;
26: }
````

## File: src/api/resources/empathicVoice/resources/chats/client/requests/ChatsListChatsRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         pageNumber: 0,
 7:  *         pageSize: 1,
 8:  *         ascendingOrder: true
 9:  *     }
10:  */
11: export interface ChatsListChatsRequest {
12:     /**
13:      * Specifies the page number to retrieve, enabling pagination.
14:      *
15:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
16:      */
17:     pageNumber?: number;
18:     /**
19:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
20:      *
21:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
22:      */
23:     pageSize?: number;
24:     /** Boolean to indicate if the results should be paginated in chronological order or reverse-chronological order. Defaults to true. */
25:     ascendingOrder?: boolean;
26:     /** Filter to only include chats that used this config. */
27:     configId?: string;
28:     /** Chat status to apply to the chat. String from the ChatStatus enum. */
29:     status?: string;
30: }
````

## File: src/api/resources/empathicVoice/resources/chats/client/requests/index.ts
````typescript
1: export type { ChatsListChatEventsRequest } from "./ChatsListChatEventsRequest.js";
2: export type { ChatsListChatsRequest } from "./ChatsListChatsRequest.js";
````

## File: src/api/resources/empathicVoice/resources/chats/client/Client.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
  4: import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
  5: import { mergeHeaders } from "../../../../../../core/headers.js";
  6: import * as core from "../../../../../../core/index.js";
  7: import * as environments from "../../../../../../environments.js";
  8: import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
  9: import * as errors from "../../../../../../errors/index.js";
 10: import * as serializers from "../../../../../../serialization/index.js";
 11: import * as Hume from "../../../../../index.js";
 12: 
 13: export declare namespace ChatsClient {
 14:     export type Options = BaseClientOptions;
 15: 
 16:     export interface RequestOptions extends BaseRequestOptions {}
 17: }
 18: 
 19: export class ChatsClient {
 20:     protected readonly _options: NormalizedClientOptionsWithAuth<ChatsClient.Options>;
 21: 
 22:     constructor(options: ChatsClient.Options = {}) {
 23:         this._options = normalizeClientOptionsWithAuth(options);
 24:     }
 25: 
 26:     /**
 27:      * @param {Hume.empathicVoice.ChatsListChatsRequest} request
 28:      * @param {ChatsClient.RequestOptions} requestOptions - Request-specific configuration.
 29:      *
 30:      * @throws {@link Hume.empathicVoice.BadRequestError}
 31:      *
 32:      * @example
 33:      *     await client.empathicVoice.chats.listChats({
 34:      *         pageNumber: 0,
 35:      *         pageSize: 1,
 36:      *         ascendingOrder: true
 37:      *     })
 38:      */
 39:     public async listChats(
 40:         request: Hume.empathicVoice.ChatsListChatsRequest = {},
 41:         requestOptions?: ChatsClient.RequestOptions,
 42:     ): Promise<core.Page<Hume.empathicVoice.ReturnChat, Hume.empathicVoice.ReturnPagedChats>> {
 43:         const list = core.HttpResponsePromise.interceptFunction(
 44:             async (
 45:                 request: Hume.empathicVoice.ChatsListChatsRequest,
 46:             ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedChats>> => {
 47:                 const { pageNumber, pageSize, ascendingOrder, configId, status } = request;
 48:                 const _queryParams: Record<string, unknown> = {
 49:                     page_number: pageNumber,
 50:                     page_size: pageSize,
 51:                     ascending_order: ascendingOrder,
 52:                     config_id: configId,
 53:                     status,
 54:                 };
 55:                 const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
 56:                 const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
 57:                     _authRequest.headers,
 58:                     this._options?.headers,
 59:                     requestOptions?.headers,
 60:                 );
 61:                 const _response = await (this._options.fetcher ?? core.fetcher)({
 62:                     url: core.url.join(
 63:                         (await core.Supplier.get(this._options.baseUrl)) ??
 64:                             ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
 65:                                 .base,
 66:                         "v0/evi/chats",
 67:                     ),
 68:                     method: "GET",
 69:                     headers: _headers,
 70:                     queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
 71:                     timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
 72:                     maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
 73:                     abortSignal: requestOptions?.abortSignal,
 74:                     fetchFn: this._options?.fetch,
 75:                     logging: this._options.logging,
 76:                 });
 77:                 if (_response.ok) {
 78:                     return {
 79:                         data: serializers.empathicVoice.ReturnPagedChats.parseOrThrow(_response.body, {
 80:                             unrecognizedObjectKeys: "passthrough",
 81:                             allowUnrecognizedUnionMembers: true,
 82:                             allowUnrecognizedEnumValues: true,
 83:                             skipValidation: true,
 84:                             breadcrumbsPrefix: ["response"],
 85:                         }),
 86:                         rawResponse: _response.rawResponse,
 87:                     };
 88:                 }
 89:                 if (_response.error.reason === "status-code") {
 90:                     switch (_response.error.statusCode) {
 91:                         case 400:
 92:                             throw new Hume.empathicVoice.BadRequestError(
 93:                                 serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
 94:                                     unrecognizedObjectKeys: "passthrough",
 95:                                     allowUnrecognizedUnionMembers: true,
 96:                                     allowUnrecognizedEnumValues: true,
 97:                                     skipValidation: true,
 98:                                     breadcrumbsPrefix: ["response"],
 99:                                 }),
100:                                 _response.rawResponse,
101:                             );
102:                         default:
103:                             throw new errors.HumeError({
104:                                 statusCode: _response.error.statusCode,
105:                                 body: _response.error.body,
106:                                 rawResponse: _response.rawResponse,
107:                             });
108:                     }
109:                 }
110:                 return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chats");
111:             },
112:         );
113:         let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
114:         const dataWithRawResponse = await list(request).withRawResponse();
115:         return new core.Page<Hume.empathicVoice.ReturnChat, Hume.empathicVoice.ReturnPagedChats>({
116:             response: dataWithRawResponse.data,
117:             rawResponse: dataWithRawResponse.rawResponse,
118:             hasNextPage: (response) => (response?.chatsPage ?? []).length > 0,
119:             getItems: (response) => response?.chatsPage ?? [],
120:             loadPage: (_response) => {
121:                 _offset += 1;
122:                 return list(core.setObjectProperty(request, "pageNumber", _offset));
123:             },
124:         });
125:     }
126: 
127:     /**
128:      * @param {string} id - Identifier for a chat. Formatted as a UUID.
129:      * @param {Hume.empathicVoice.ChatsListChatEventsRequest} request
130:      * @param {ChatsClient.RequestOptions} requestOptions - Request-specific configuration.
131:      *
132:      * @throws {@link Hume.empathicVoice.BadRequestError}
133:      *
134:      * @example
135:      *     await client.empathicVoice.chats.listChatEvents("470a49f6-1dec-4afe-8b61-035d3b2d63b0", {
136:      *         pageNumber: 0,
137:      *         pageSize: 3,
138:      *         ascendingOrder: true
139:      *     })
140:      */
141:     public async listChatEvents(
142:         id: string,
143:         request: Hume.empathicVoice.ChatsListChatEventsRequest = {},
144:         requestOptions?: ChatsClient.RequestOptions,
145:     ): Promise<core.Page<Hume.empathicVoice.ReturnChatEvent, Hume.empathicVoice.ReturnChatPagedEvents>> {
146:         const list = core.HttpResponsePromise.interceptFunction(
147:             async (
148:                 request: Hume.empathicVoice.ChatsListChatEventsRequest,
149:             ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatPagedEvents>> => {
150:                 const { pageSize, pageNumber, ascendingOrder } = request;
151:                 const _queryParams: Record<string, unknown> = {
152:                     page_size: pageSize,
153:                     page_number: pageNumber,
154:                     ascending_order: ascendingOrder,
155:                 };
156:                 const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
157:                 const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
158:                     _authRequest.headers,
159:                     this._options?.headers,
160:                     requestOptions?.headers,
161:                 );
162:                 const _response = await (this._options.fetcher ?? core.fetcher)({
163:                     url: core.url.join(
164:                         (await core.Supplier.get(this._options.baseUrl)) ??
165:                             ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
166:                                 .base,
167:                         `v0/evi/chats/${core.url.encodePathParam(id)}`,
168:                     ),
169:                     method: "GET",
170:                     headers: _headers,
171:                     queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
172:                     timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
173:                     maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
174:                     abortSignal: requestOptions?.abortSignal,
175:                     fetchFn: this._options?.fetch,
176:                     logging: this._options.logging,
177:                 });
178:                 if (_response.ok) {
179:                     return {
180:                         data: serializers.empathicVoice.ReturnChatPagedEvents.parseOrThrow(_response.body, {
181:                             unrecognizedObjectKeys: "passthrough",
182:                             allowUnrecognizedUnionMembers: true,
183:                             allowUnrecognizedEnumValues: true,
184:                             skipValidation: true,
185:                             breadcrumbsPrefix: ["response"],
186:                         }),
187:                         rawResponse: _response.rawResponse,
188:                     };
189:                 }
190:                 if (_response.error.reason === "status-code") {
191:                     switch (_response.error.statusCode) {
192:                         case 400:
193:                             throw new Hume.empathicVoice.BadRequestError(
194:                                 serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
195:                                     unrecognizedObjectKeys: "passthrough",
196:                                     allowUnrecognizedUnionMembers: true,
197:                                     allowUnrecognizedEnumValues: true,
198:                                     skipValidation: true,
199:                                     breadcrumbsPrefix: ["response"],
200:                                 }),
201:                                 _response.rawResponse,
202:                             );
203:                         default:
204:                             throw new errors.HumeError({
205:                                 statusCode: _response.error.statusCode,
206:                                 body: _response.error.body,
207:                                 rawResponse: _response.rawResponse,
208:                             });
209:                     }
210:                 }
211:                 return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chats/{id}");
212:             },
213:         );
214:         let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
215:         const dataWithRawResponse = await list(request).withRawResponse();
216:         return new core.Page<Hume.empathicVoice.ReturnChatEvent, Hume.empathicVoice.ReturnChatPagedEvents>({
217:             response: dataWithRawResponse.data,
218:             rawResponse: dataWithRawResponse.rawResponse,
219:             hasNextPage: (response) => (response?.eventsPage ?? []).length > 0,
220:             getItems: (response) => response?.eventsPage ?? [],
221:             loadPage: (_response) => {
222:                 _offset += 1;
223:                 return list(core.setObjectProperty(request, "pageNumber", _offset));
224:             },
225:         });
226:     }
227: 
228:     /**
229:      * @param {string} id - Identifier for a chat. Formatted as a UUID.
230:      * @param {ChatsClient.RequestOptions} requestOptions - Request-specific configuration.
231:      *
232:      * @throws {@link Hume.empathicVoice.BadRequestError}
233:      *
234:      * @example
235:      *     await client.empathicVoice.chats.getAudio("470a49f6-1dec-4afe-8b61-035d3b2d63b0")
236:      */
237:     public getAudio(
238:         id: string,
239:         requestOptions?: ChatsClient.RequestOptions,
240:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnChatAudioReconstruction> {
241:         return core.HttpResponsePromise.fromPromise(this.__getAudio(id, requestOptions));
242:     }
243: 
244:     private async __getAudio(
245:         id: string,
246:         requestOptions?: ChatsClient.RequestOptions,
247:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnChatAudioReconstruction>> {
248:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
249:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
250:             _authRequest.headers,
251:             this._options?.headers,
252:             requestOptions?.headers,
253:         );
254:         const _response = await (this._options.fetcher ?? core.fetcher)({
255:             url: core.url.join(
256:                 (await core.Supplier.get(this._options.baseUrl)) ??
257:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
258:                 `v0/evi/chats/${core.url.encodePathParam(id)}/audio`,
259:             ),
260:             method: "GET",
261:             headers: _headers,
262:             queryParameters: requestOptions?.queryParams,
263:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
264:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
265:             abortSignal: requestOptions?.abortSignal,
266:             fetchFn: this._options?.fetch,
267:             logging: this._options.logging,
268:         });
269:         if (_response.ok) {
270:             return {
271:                 data: serializers.empathicVoice.ReturnChatAudioReconstruction.parseOrThrow(_response.body, {
272:                     unrecognizedObjectKeys: "passthrough",
273:                     allowUnrecognizedUnionMembers: true,
274:                     allowUnrecognizedEnumValues: true,
275:                     skipValidation: true,
276:                     breadcrumbsPrefix: ["response"],
277:                 }),
278:                 rawResponse: _response.rawResponse,
279:             };
280:         }
281: 
282:         if (_response.error.reason === "status-code") {
283:             switch (_response.error.statusCode) {
284:                 case 400:
285:                     throw new Hume.empathicVoice.BadRequestError(
286:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
287:                             unrecognizedObjectKeys: "passthrough",
288:                             allowUnrecognizedUnionMembers: true,
289:                             allowUnrecognizedEnumValues: true,
290:                             skipValidation: true,
291:                             breadcrumbsPrefix: ["response"],
292:                         }),
293:                         _response.rawResponse,
294:                     );
295:                 default:
296:                     throw new errors.HumeError({
297:                         statusCode: _response.error.statusCode,
298:                         body: _response.error.body,
299:                         rawResponse: _response.rawResponse,
300:                     });
301:             }
302:         }
303: 
304:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/chats/{id}/audio");
305:     }
306: }
````

## File: src/api/resources/empathicVoice/resources/chats/client/index.ts
````typescript
1: export * from "./requests/index.js";
````

## File: src/api/resources/empathicVoice/resources/chats/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/api/resources/empathicVoice/resources/configs/client/requests/ConfigsListConfigsRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         pageNumber: 0,
 7:  *         pageSize: 1
 8:  *     }
 9:  */
10: export interface ConfigsListConfigsRequest {
11:     /**
12:      * Specifies the page number to retrieve, enabling pagination.
13:      *
14:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
15:      */
16:     pageNumber?: number;
17:     /**
18:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
19:      *
20:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
21:      */
22:     pageSize?: number;
23:     /** By default, `restrict_to_most_recent` is set to true, returning only the latest version of each tool. To include all versions of each tool in the list, set `restrict_to_most_recent` to false. */
24:     restrictToMostRecent?: boolean;
25:     /** Filter to only include configs with this name. */
26:     name?: string;
27: }
````

## File: src/api/resources/empathicVoice/resources/configs/client/requests/ConfigsListConfigVersionsRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {}
 6:  */
 7: export interface ConfigsListConfigVersionsRequest {
 8:     /**
 9:      * Specifies the page number to retrieve, enabling pagination.
10:      *
11:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
12:      */
13:     pageNumber?: number;
14:     /**
15:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
16:      *
17:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
18:      */
19:     pageSize?: number;
20:     /** By default, `restrict_to_most_recent` is set to true, returning only the latest version of each tool. To include all versions of each tool in the list, set `restrict_to_most_recent` to false. */
21:     restrictToMostRecent?: boolean;
22: }
````

## File: src/api/resources/empathicVoice/resources/configs/client/requests/index.ts
````typescript
1: export type { ConfigsListConfigsRequest } from "./ConfigsListConfigsRequest.js";
2: export type { ConfigsListConfigVersionsRequest } from "./ConfigsListConfigVersionsRequest.js";
3: export type { PostedConfig } from "./PostedConfig.js";
4: export type { PostedConfigName } from "./PostedConfigName.js";
5: export type { PostedConfigVersion } from "./PostedConfigVersion.js";
6: export type { PostedConfigVersionDescription } from "./PostedConfigVersionDescription.js";
````

## File: src/api/resources/empathicVoice/resources/configs/client/requests/PostedConfig.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../index.js";
 4: 
 5: /**
 6:  * @example
 7:  *     {
 8:  *         name: "Weather Assistant Config",
 9:  *         prompt: {
10:  *             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
11:  *             version: 0
12:  *         },
13:  *         eviVersion: "3",
14:  *         voice: {
15:  *             provider: "HUME_AI",
16:  *             name: "Ava Song"
17:  *         },
18:  *         languageModel: {
19:  *             modelProvider: "ANTHROPIC",
20:  *             modelResource: "claude-3-7-sonnet-latest",
21:  *             temperature: 1
22:  *         },
23:  *         eventMessages: {
24:  *             onNewChat: {
25:  *                 enabled: false,
26:  *                 text: ""
27:  *             },
28:  *             onInactivityTimeout: {
29:  *                 enabled: false,
30:  *                 text: ""
31:  *             },
32:  *             onMaxDurationTimeout: {
33:  *                 enabled: false,
34:  *                 text: ""
35:  *             }
36:  *         }
37:  *     }
38:  */
39: export interface PostedConfig {
40:     /** Built-in tool specification for a Config. */
41:     builtinTools?: (Hume.empathicVoice.PostedBuiltinTool | undefined)[];
42:     ellmModel?: Hume.empathicVoice.PostedEllmModel;
43:     eventMessages?: Hume.empathicVoice.PostedEventMessageSpecs;
44:     /** The version of the EVI used with this config. */
45:     eviVersion: string;
46:     languageModel?: Hume.empathicVoice.PostedLanguageModel;
47:     /** Name applied to all versions of a particular Config. */
48:     name: string;
49:     nudges?: Hume.empathicVoice.PostedNudgeSpec;
50:     prompt?: Hume.empathicVoice.PostedConfigPromptSpec;
51:     timeouts?: Hume.empathicVoice.PostedTimeoutSpecs;
52:     /** Tool specification for a Config. */
53:     tools?: (Hume.empathicVoice.PostedUserDefinedToolSpec | undefined)[];
54:     /** Description that is appended to a specific version of a Config. */
55:     versionDescription?: string;
56:     voice?: Hume.empathicVoice.VoiceRef;
57:     /** Webhook config specifications for each subscriber. */
58:     webhooks?: (Hume.empathicVoice.PostedWebhookSpec | undefined)[];
59: }
````

## File: src/api/resources/empathicVoice/resources/configs/client/requests/PostedConfigName.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         name: "Updated Weather Assistant Config Name"
 7:  *     }
 8:  */
 9: export interface PostedConfigName {
10:     /** Name applied to all versions of a particular Config. */
11:     name: string;
12: }
````

## File: src/api/resources/empathicVoice/resources/configs/client/requests/PostedConfigVersion.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../index.js";
 4: 
 5: /**
 6:  * @example
 7:  *     {
 8:  *         versionDescription: "This is an updated version of the Weather Assistant Config.",
 9:  *         eviVersion: "3",
10:  *         prompt: {
11:  *             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
12:  *             version: 0
13:  *         },
14:  *         voice: {
15:  *             provider: "HUME_AI",
16:  *             name: "Ava Song"
17:  *         },
18:  *         languageModel: {
19:  *             modelProvider: "ANTHROPIC",
20:  *             modelResource: "claude-3-7-sonnet-latest",
21:  *             temperature: 1
22:  *         },
23:  *         ellmModel: {
24:  *             allowShortResponses: true
25:  *         },
26:  *         eventMessages: {
27:  *             onNewChat: {
28:  *                 enabled: false,
29:  *                 text: ""
30:  *             },
31:  *             onInactivityTimeout: {
32:  *                 enabled: false,
33:  *                 text: ""
34:  *             },
35:  *             onMaxDurationTimeout: {
36:  *                 enabled: false,
37:  *                 text: ""
38:  *             }
39:  *         }
40:  *     }
41:  */
42: export interface PostedConfigVersion {
43:     /** Built-in tool specification for a Config. */
44:     builtinTools?: (Hume.empathicVoice.PostedBuiltinTool | undefined)[];
45:     ellmModel?: Hume.empathicVoice.PostedEllmModel;
46:     eventMessages?: Hume.empathicVoice.PostedEventMessageSpecs;
47:     /** The version of the EVI used with this config. */
48:     eviVersion: string;
49:     languageModel?: Hume.empathicVoice.PostedLanguageModel;
50:     nudges?: Hume.empathicVoice.PostedNudgeSpec;
51:     prompt?: Hume.empathicVoice.PostedConfigPromptSpec;
52:     timeouts?: Hume.empathicVoice.PostedTimeoutSpecs;
53:     /** Tool specification for a Config. */
54:     tools?: (Hume.empathicVoice.PostedUserDefinedToolSpec | undefined)[];
55:     /** Description that is appended to a specific version of a Config. */
56:     versionDescription?: string;
57:     voice?: Hume.empathicVoice.VoiceRef;
58:     /** Webhook config specifications for each subscriber. */
59:     webhooks?: (Hume.empathicVoice.PostedWebhookSpec | undefined)[];
60: }
````

## File: src/api/resources/empathicVoice/resources/configs/client/requests/PostedConfigVersionDescription.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         versionDescription: "This is an updated version_description."
 7:  *     }
 8:  */
 9: export interface PostedConfigVersionDescription {
10:     /** Description that is appended to a specific version of a Config. */
11:     versionDescription?: string;
12: }
````

## File: src/api/resources/empathicVoice/resources/configs/client/Client.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
  4: import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
  5: import { mergeHeaders } from "../../../../../../core/headers.js";
  6: import * as core from "../../../../../../core/index.js";
  7: import * as environments from "../../../../../../environments.js";
  8: import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
  9: import * as errors from "../../../../../../errors/index.js";
 10: import * as serializers from "../../../../../../serialization/index.js";
 11: import * as Hume from "../../../../../index.js";
 12: 
 13: export declare namespace ConfigsClient {
 14:     export type Options = BaseClientOptions;
 15: 
 16:     export interface RequestOptions extends BaseRequestOptions {}
 17: }
 18: 
 19: export class ConfigsClient {
 20:     protected readonly _options: NormalizedClientOptionsWithAuth<ConfigsClient.Options>;
 21: 
 22:     constructor(options: ConfigsClient.Options = {}) {
 23:         this._options = normalizeClientOptionsWithAuth(options);
 24:     }
 25: 
 26:     /**
 27:      * @param {Hume.empathicVoice.ConfigsListConfigsRequest} request
 28:      * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
 29:      *
 30:      * @throws {@link Hume.empathicVoice.BadRequestError}
 31:      *
 32:      * @example
 33:      *     await client.empathicVoice.configs.listConfigs({
 34:      *         pageNumber: 0,
 35:      *         pageSize: 1
 36:      *     })
 37:      */
 38:     public async listConfigs(
 39:         request: Hume.empathicVoice.ConfigsListConfigsRequest = {},
 40:         requestOptions?: ConfigsClient.RequestOptions,
 41:     ): Promise<core.Page<Hume.empathicVoice.ReturnConfig, Hume.empathicVoice.ReturnPagedConfigs>> {
 42:         const list = core.HttpResponsePromise.interceptFunction(
 43:             async (
 44:                 request: Hume.empathicVoice.ConfigsListConfigsRequest,
 45:             ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedConfigs>> => {
 46:                 const { pageNumber, pageSize, restrictToMostRecent, name } = request;
 47:                 const _queryParams: Record<string, unknown> = {
 48:                     page_number: pageNumber,
 49:                     page_size: pageSize,
 50:                     restrict_to_most_recent: restrictToMostRecent,
 51:                     name,
 52:                 };
 53:                 const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
 54:                 const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
 55:                     _authRequest.headers,
 56:                     this._options?.headers,
 57:                     requestOptions?.headers,
 58:                 );
 59:                 const _response = await (this._options.fetcher ?? core.fetcher)({
 60:                     url: core.url.join(
 61:                         (await core.Supplier.get(this._options.baseUrl)) ??
 62:                             ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
 63:                                 .base,
 64:                         "v0/evi/configs",
 65:                     ),
 66:                     method: "GET",
 67:                     headers: _headers,
 68:                     queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
 69:                     timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
 70:                     maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
 71:                     abortSignal: requestOptions?.abortSignal,
 72:                     fetchFn: this._options?.fetch,
 73:                     logging: this._options.logging,
 74:                 });
 75:                 if (_response.ok) {
 76:                     return {
 77:                         data: serializers.empathicVoice.ReturnPagedConfigs.parseOrThrow(_response.body, {
 78:                             unrecognizedObjectKeys: "passthrough",
 79:                             allowUnrecognizedUnionMembers: true,
 80:                             allowUnrecognizedEnumValues: true,
 81:                             skipValidation: true,
 82:                             breadcrumbsPrefix: ["response"],
 83:                         }),
 84:                         rawResponse: _response.rawResponse,
 85:                     };
 86:                 }
 87:                 if (_response.error.reason === "status-code") {
 88:                     switch (_response.error.statusCode) {
 89:                         case 400:
 90:                             throw new Hume.empathicVoice.BadRequestError(
 91:                                 serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
 92:                                     unrecognizedObjectKeys: "passthrough",
 93:                                     allowUnrecognizedUnionMembers: true,
 94:                                     allowUnrecognizedEnumValues: true,
 95:                                     skipValidation: true,
 96:                                     breadcrumbsPrefix: ["response"],
 97:                                 }),
 98:                                 _response.rawResponse,
 99:                             );
100:                         default:
101:                             throw new errors.HumeError({
102:                                 statusCode: _response.error.statusCode,
103:                                 body: _response.error.body,
104:                                 rawResponse: _response.rawResponse,
105:                             });
106:                     }
107:                 }
108:                 return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/configs");
109:             },
110:         );
111:         let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
112:         const dataWithRawResponse = await list(request).withRawResponse();
113:         return new core.Page<Hume.empathicVoice.ReturnConfig, Hume.empathicVoice.ReturnPagedConfigs>({
114:             response: dataWithRawResponse.data,
115:             rawResponse: dataWithRawResponse.rawResponse,
116:             hasNextPage: (response) => (response?.configsPage ?? []).length > 0,
117:             getItems: (response) => response?.configsPage ?? [],
118:             loadPage: (_response) => {
119:                 _offset += 1;
120:                 return list(core.setObjectProperty(request, "pageNumber", _offset));
121:             },
122:         });
123:     }
124: 
125:     /**
126:      * @param {Hume.empathicVoice.PostedConfig} request
127:      * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
128:      *
129:      * @throws {@link Hume.empathicVoice.BadRequestError}
130:      *
131:      * @example
132:      *     await client.empathicVoice.configs.createConfig({
133:      *         name: "Weather Assistant Config",
134:      *         prompt: {
135:      *             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
136:      *             version: 0
137:      *         },
138:      *         eviVersion: "3",
139:      *         voice: {
140:      *             provider: "HUME_AI",
141:      *             name: "Ava Song"
142:      *         },
143:      *         languageModel: {
144:      *             modelProvider: "ANTHROPIC",
145:      *             modelResource: "claude-3-7-sonnet-latest",
146:      *             temperature: 1
147:      *         },
148:      *         eventMessages: {
149:      *             onNewChat: {
150:      *                 enabled: false,
151:      *                 text: ""
152:      *             },
153:      *             onInactivityTimeout: {
154:      *                 enabled: false,
155:      *                 text: ""
156:      *             },
157:      *             onMaxDurationTimeout: {
158:      *                 enabled: false,
159:      *                 text: ""
160:      *             }
161:      *         }
162:      *     })
163:      */
164:     public createConfig(
165:         request: Hume.empathicVoice.PostedConfig,
166:         requestOptions?: ConfigsClient.RequestOptions,
167:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnConfig> {
168:         return core.HttpResponsePromise.fromPromise(this.__createConfig(request, requestOptions));
169:     }
170: 
171:     private async __createConfig(
172:         request: Hume.empathicVoice.PostedConfig,
173:         requestOptions?: ConfigsClient.RequestOptions,
174:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnConfig>> {
175:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
176:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
177:             _authRequest.headers,
178:             this._options?.headers,
179:             requestOptions?.headers,
180:         );
181:         const _response = await (this._options.fetcher ?? core.fetcher)({
182:             url: core.url.join(
183:                 (await core.Supplier.get(this._options.baseUrl)) ??
184:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
185:                 "v0/evi/configs",
186:             ),
187:             method: "POST",
188:             headers: _headers,
189:             contentType: "application/json",
190:             queryParameters: requestOptions?.queryParams,
191:             requestType: "json",
192:             body: serializers.empathicVoice.PostedConfig.jsonOrThrow(request, {
193:                 unrecognizedObjectKeys: "strip",
194:                 omitUndefined: true,
195:             }),
196:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
197:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
198:             abortSignal: requestOptions?.abortSignal,
199:             fetchFn: this._options?.fetch,
200:             logging: this._options.logging,
201:         });
202:         if (_response.ok) {
203:             return {
204:                 data: serializers.empathicVoice.ReturnConfig.parseOrThrow(_response.body, {
205:                     unrecognizedObjectKeys: "passthrough",
206:                     allowUnrecognizedUnionMembers: true,
207:                     allowUnrecognizedEnumValues: true,
208:                     skipValidation: true,
209:                     breadcrumbsPrefix: ["response"],
210:                 }),
211:                 rawResponse: _response.rawResponse,
212:             };
213:         }
214: 
215:         if (_response.error.reason === "status-code") {
216:             switch (_response.error.statusCode) {
217:                 case 400:
218:                     throw new Hume.empathicVoice.BadRequestError(
219:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
220:                             unrecognizedObjectKeys: "passthrough",
221:                             allowUnrecognizedUnionMembers: true,
222:                             allowUnrecognizedEnumValues: true,
223:                             skipValidation: true,
224:                             breadcrumbsPrefix: ["response"],
225:                         }),
226:                         _response.rawResponse,
227:                     );
228:                 default:
229:                     throw new errors.HumeError({
230:                         statusCode: _response.error.statusCode,
231:                         body: _response.error.body,
232:                         rawResponse: _response.rawResponse,
233:                     });
234:             }
235:         }
236: 
237:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/configs");
238:     }
239: 
240:     /**
241:      * @param {string} id - Identifier for a config. Formatted as a UUID.
242:      * @param {Hume.empathicVoice.ConfigsListConfigVersionsRequest} request
243:      * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
244:      *
245:      * @throws {@link Hume.empathicVoice.BadRequestError}
246:      *
247:      * @example
248:      *     await client.empathicVoice.configs.listConfigVersions("1b60e1a0-cc59-424a-8d2c-189d354db3f3")
249:      */
250:     public async listConfigVersions(
251:         id: string,
252:         request: Hume.empathicVoice.ConfigsListConfigVersionsRequest = {},
253:         requestOptions?: ConfigsClient.RequestOptions,
254:     ): Promise<core.Page<Hume.empathicVoice.ReturnConfig, Hume.empathicVoice.ReturnPagedConfigs>> {
255:         const list = core.HttpResponsePromise.interceptFunction(
256:             async (
257:                 request: Hume.empathicVoice.ConfigsListConfigVersionsRequest,
258:             ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedConfigs>> => {
259:                 const { pageNumber, pageSize, restrictToMostRecent } = request;
260:                 const _queryParams: Record<string, unknown> = {
261:                     page_number: pageNumber,
262:                     page_size: pageSize,
263:                     restrict_to_most_recent: restrictToMostRecent,
264:                 };
265:                 const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
266:                 const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
267:                     _authRequest.headers,
268:                     this._options?.headers,
269:                     requestOptions?.headers,
270:                 );
271:                 const _response = await (this._options.fetcher ?? core.fetcher)({
272:                     url: core.url.join(
273:                         (await core.Supplier.get(this._options.baseUrl)) ??
274:                             ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
275:                                 .base,
276:                         `v0/evi/configs/${core.url.encodePathParam(id)}`,
277:                     ),
278:                     method: "GET",
279:                     headers: _headers,
280:                     queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
281:                     timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
282:                     maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
283:                     abortSignal: requestOptions?.abortSignal,
284:                     fetchFn: this._options?.fetch,
285:                     logging: this._options.logging,
286:                 });
287:                 if (_response.ok) {
288:                     return {
289:                         data: serializers.empathicVoice.ReturnPagedConfigs.parseOrThrow(_response.body, {
290:                             unrecognizedObjectKeys: "passthrough",
291:                             allowUnrecognizedUnionMembers: true,
292:                             allowUnrecognizedEnumValues: true,
293:                             skipValidation: true,
294:                             breadcrumbsPrefix: ["response"],
295:                         }),
296:                         rawResponse: _response.rawResponse,
297:                     };
298:                 }
299:                 if (_response.error.reason === "status-code") {
300:                     switch (_response.error.statusCode) {
301:                         case 400:
302:                             throw new Hume.empathicVoice.BadRequestError(
303:                                 serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
304:                                     unrecognizedObjectKeys: "passthrough",
305:                                     allowUnrecognizedUnionMembers: true,
306:                                     allowUnrecognizedEnumValues: true,
307:                                     skipValidation: true,
308:                                     breadcrumbsPrefix: ["response"],
309:                                 }),
310:                                 _response.rawResponse,
311:                             );
312:                         default:
313:                             throw new errors.HumeError({
314:                                 statusCode: _response.error.statusCode,
315:                                 body: _response.error.body,
316:                                 rawResponse: _response.rawResponse,
317:                             });
318:                     }
319:                 }
320:                 return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/configs/{id}");
321:             },
322:         );
323:         let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
324:         const dataWithRawResponse = await list(request).withRawResponse();
325:         return new core.Page<Hume.empathicVoice.ReturnConfig, Hume.empathicVoice.ReturnPagedConfigs>({
326:             response: dataWithRawResponse.data,
327:             rawResponse: dataWithRawResponse.rawResponse,
328:             hasNextPage: (response) => (response?.configsPage ?? []).length > 0,
329:             getItems: (response) => response?.configsPage ?? [],
330:             loadPage: (_response) => {
331:                 _offset += 1;
332:                 return list(core.setObjectProperty(request, "pageNumber", _offset));
333:             },
334:         });
335:     }
336: 
337:     /**
338:      * @param {string} id - Identifier for a config. Formatted as a UUID.
339:      * @param {Hume.empathicVoice.PostedConfigVersion} request
340:      * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
341:      *
342:      * @throws {@link Hume.empathicVoice.BadRequestError}
343:      *
344:      * @example
345:      *     await client.empathicVoice.configs.createConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", {
346:      *         versionDescription: "This is an updated version of the Weather Assistant Config.",
347:      *         eviVersion: "3",
348:      *         prompt: {
349:      *             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
350:      *             version: 0
351:      *         },
352:      *         voice: {
353:      *             provider: "HUME_AI",
354:      *             name: "Ava Song"
355:      *         },
356:      *         languageModel: {
357:      *             modelProvider: "ANTHROPIC",
358:      *             modelResource: "claude-3-7-sonnet-latest",
359:      *             temperature: 1
360:      *         },
361:      *         ellmModel: {
362:      *             allowShortResponses: true
363:      *         },
364:      *         eventMessages: {
365:      *             onNewChat: {
366:      *                 enabled: false,
367:      *                 text: ""
368:      *             },
369:      *             onInactivityTimeout: {
370:      *                 enabled: false,
371:      *                 text: ""
372:      *             },
373:      *             onMaxDurationTimeout: {
374:      *                 enabled: false,
375:      *                 text: ""
376:      *             }
377:      *         }
378:      *     })
379:      */
380:     public createConfigVersion(
381:         id: string,
382:         request: Hume.empathicVoice.PostedConfigVersion,
383:         requestOptions?: ConfigsClient.RequestOptions,
384:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnConfig> {
385:         return core.HttpResponsePromise.fromPromise(this.__createConfigVersion(id, request, requestOptions));
386:     }
387: 
388:     private async __createConfigVersion(
389:         id: string,
390:         request: Hume.empathicVoice.PostedConfigVersion,
391:         requestOptions?: ConfigsClient.RequestOptions,
392:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnConfig>> {
393:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
394:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
395:             _authRequest.headers,
396:             this._options?.headers,
397:             requestOptions?.headers,
398:         );
399:         const _response = await (this._options.fetcher ?? core.fetcher)({
400:             url: core.url.join(
401:                 (await core.Supplier.get(this._options.baseUrl)) ??
402:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
403:                 `v0/evi/configs/${core.url.encodePathParam(id)}`,
404:             ),
405:             method: "POST",
406:             headers: _headers,
407:             contentType: "application/json",
408:             queryParameters: requestOptions?.queryParams,
409:             requestType: "json",
410:             body: serializers.empathicVoice.PostedConfigVersion.jsonOrThrow(request, {
411:                 unrecognizedObjectKeys: "strip",
412:                 omitUndefined: true,
413:             }),
414:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
415:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
416:             abortSignal: requestOptions?.abortSignal,
417:             fetchFn: this._options?.fetch,
418:             logging: this._options.logging,
419:         });
420:         if (_response.ok) {
421:             return {
422:                 data: serializers.empathicVoice.ReturnConfig.parseOrThrow(_response.body, {
423:                     unrecognizedObjectKeys: "passthrough",
424:                     allowUnrecognizedUnionMembers: true,
425:                     allowUnrecognizedEnumValues: true,
426:                     skipValidation: true,
427:                     breadcrumbsPrefix: ["response"],
428:                 }),
429:                 rawResponse: _response.rawResponse,
430:             };
431:         }
432: 
433:         if (_response.error.reason === "status-code") {
434:             switch (_response.error.statusCode) {
435:                 case 400:
436:                     throw new Hume.empathicVoice.BadRequestError(
437:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
438:                             unrecognizedObjectKeys: "passthrough",
439:                             allowUnrecognizedUnionMembers: true,
440:                             allowUnrecognizedEnumValues: true,
441:                             skipValidation: true,
442:                             breadcrumbsPrefix: ["response"],
443:                         }),
444:                         _response.rawResponse,
445:                     );
446:                 default:
447:                     throw new errors.HumeError({
448:                         statusCode: _response.error.statusCode,
449:                         body: _response.error.body,
450:                         rawResponse: _response.rawResponse,
451:                     });
452:             }
453:         }
454: 
455:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/configs/{id}");
456:     }
457: 
458:     /**
459:      * @param {string} id - Identifier for a config. Formatted as a UUID.
460:      * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
461:      *
462:      * @throws {@link Hume.empathicVoice.BadRequestError}
463:      *
464:      * @example
465:      *     await client.empathicVoice.configs.deleteConfig("1b60e1a0-cc59-424a-8d2c-189d354db3f3")
466:      */
467:     public deleteConfig(id: string, requestOptions?: ConfigsClient.RequestOptions): core.HttpResponsePromise<void> {
468:         return core.HttpResponsePromise.fromPromise(this.__deleteConfig(id, requestOptions));
469:     }
470: 
471:     private async __deleteConfig(
472:         id: string,
473:         requestOptions?: ConfigsClient.RequestOptions,
474:     ): Promise<core.WithRawResponse<void>> {
475:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
476:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
477:             _authRequest.headers,
478:             this._options?.headers,
479:             requestOptions?.headers,
480:         );
481:         const _response = await (this._options.fetcher ?? core.fetcher)({
482:             url: core.url.join(
483:                 (await core.Supplier.get(this._options.baseUrl)) ??
484:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
485:                 `v0/evi/configs/${core.url.encodePathParam(id)}`,
486:             ),
487:             method: "DELETE",
488:             headers: _headers,
489:             queryParameters: requestOptions?.queryParams,
490:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
491:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
492:             abortSignal: requestOptions?.abortSignal,
493:             fetchFn: this._options?.fetch,
494:             logging: this._options.logging,
495:         });
496:         if (_response.ok) {
497:             return { data: undefined, rawResponse: _response.rawResponse };
498:         }
499: 
500:         if (_response.error.reason === "status-code") {
501:             switch (_response.error.statusCode) {
502:                 case 400:
503:                     throw new Hume.empathicVoice.BadRequestError(
504:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
505:                             unrecognizedObjectKeys: "passthrough",
506:                             allowUnrecognizedUnionMembers: true,
507:                             allowUnrecognizedEnumValues: true,
508:                             skipValidation: true,
509:                             breadcrumbsPrefix: ["response"],
510:                         }),
511:                         _response.rawResponse,
512:                     );
513:                 default:
514:                     throw new errors.HumeError({
515:                         statusCode: _response.error.statusCode,
516:                         body: _response.error.body,
517:                         rawResponse: _response.rawResponse,
518:                     });
519:             }
520:         }
521: 
522:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v0/evi/configs/{id}");
523:     }
524: 
525:     /**
526:      * @param {string} id - Identifier for a config. Formatted as a UUID.
527:      * @param {Hume.empathicVoice.PostedConfigName} request
528:      * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
529:      *
530:      * @throws {@link Hume.empathicVoice.BadRequestError}
531:      *
532:      * @example
533:      *     await client.empathicVoice.configs.updateConfigName("1b60e1a0-cc59-424a-8d2c-189d354db3f3", {
534:      *         name: "Updated Weather Assistant Config Name"
535:      *     })
536:      */
537:     public updateConfigName(
538:         id: string,
539:         request: Hume.empathicVoice.PostedConfigName,
540:         requestOptions?: ConfigsClient.RequestOptions,
541:     ): core.HttpResponsePromise<string> {
542:         return core.HttpResponsePromise.fromPromise(this.__updateConfigName(id, request, requestOptions));
543:     }
544: 
545:     private async __updateConfigName(
546:         id: string,
547:         request: Hume.empathicVoice.PostedConfigName,
548:         requestOptions?: ConfigsClient.RequestOptions,
549:     ): Promise<core.WithRawResponse<string>> {
550:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
551:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
552:             _authRequest.headers,
553:             this._options?.headers,
554:             requestOptions?.headers,
555:         );
556:         const _response = await (this._options.fetcher ?? core.fetcher)({
557:             url: core.url.join(
558:                 (await core.Supplier.get(this._options.baseUrl)) ??
559:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
560:                 `v0/evi/configs/${core.url.encodePathParam(id)}`,
561:             ),
562:             method: "PATCH",
563:             headers: _headers,
564:             contentType: "application/json",
565:             queryParameters: requestOptions?.queryParams,
566:             requestType: "json",
567:             body: serializers.empathicVoice.PostedConfigName.jsonOrThrow(request, {
568:                 unrecognizedObjectKeys: "strip",
569:                 omitUndefined: true,
570:             }),
571:             responseType: "text",
572:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
573:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
574:             abortSignal: requestOptions?.abortSignal,
575:             fetchFn: this._options?.fetch,
576:             logging: this._options.logging,
577:         });
578:         if (_response.ok) {
579:             return { data: _response.body as string, rawResponse: _response.rawResponse };
580:         }
581: 
582:         if (_response.error.reason === "status-code") {
583:             switch (_response.error.statusCode) {
584:                 case 400:
585:                     throw new Hume.empathicVoice.BadRequestError(
586:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
587:                             unrecognizedObjectKeys: "passthrough",
588:                             allowUnrecognizedUnionMembers: true,
589:                             allowUnrecognizedEnumValues: true,
590:                             skipValidation: true,
591:                             breadcrumbsPrefix: ["response"],
592:                         }),
593:                         _response.rawResponse,
594:                     );
595:                 default:
596:                     throw new errors.HumeError({
597:                         statusCode: _response.error.statusCode,
598:                         body: _response.error.body,
599:                         rawResponse: _response.rawResponse,
600:                     });
601:             }
602:         }
603: 
604:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/v0/evi/configs/{id}");
605:     }
606: 
607:     /**
608:      * @param {string} id - Identifier for a config. Formatted as a UUID.
609:      * @param {number} version - Version number for a config. Version numbers should be integers.
610:      * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
611:      *
612:      * @throws {@link Hume.empathicVoice.BadRequestError}
613:      *
614:      * @example
615:      *     await client.empathicVoice.configs.getConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1)
616:      */
617:     public getConfigVersion(
618:         id: string,
619:         version: number,
620:         requestOptions?: ConfigsClient.RequestOptions,
621:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnConfig> {
622:         return core.HttpResponsePromise.fromPromise(this.__getConfigVersion(id, version, requestOptions));
623:     }
624: 
625:     private async __getConfigVersion(
626:         id: string,
627:         version: number,
628:         requestOptions?: ConfigsClient.RequestOptions,
629:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnConfig>> {
630:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
631:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
632:             _authRequest.headers,
633:             this._options?.headers,
634:             requestOptions?.headers,
635:         );
636:         const _response = await (this._options.fetcher ?? core.fetcher)({
637:             url: core.url.join(
638:                 (await core.Supplier.get(this._options.baseUrl)) ??
639:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
640:                 `v0/evi/configs/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
641:             ),
642:             method: "GET",
643:             headers: _headers,
644:             queryParameters: requestOptions?.queryParams,
645:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
646:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
647:             abortSignal: requestOptions?.abortSignal,
648:             fetchFn: this._options?.fetch,
649:             logging: this._options.logging,
650:         });
651:         if (_response.ok) {
652:             return {
653:                 data: serializers.empathicVoice.ReturnConfig.parseOrThrow(_response.body, {
654:                     unrecognizedObjectKeys: "passthrough",
655:                     allowUnrecognizedUnionMembers: true,
656:                     allowUnrecognizedEnumValues: true,
657:                     skipValidation: true,
658:                     breadcrumbsPrefix: ["response"],
659:                 }),
660:                 rawResponse: _response.rawResponse,
661:             };
662:         }
663: 
664:         if (_response.error.reason === "status-code") {
665:             switch (_response.error.statusCode) {
666:                 case 400:
667:                     throw new Hume.empathicVoice.BadRequestError(
668:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
669:                             unrecognizedObjectKeys: "passthrough",
670:                             allowUnrecognizedUnionMembers: true,
671:                             allowUnrecognizedEnumValues: true,
672:                             skipValidation: true,
673:                             breadcrumbsPrefix: ["response"],
674:                         }),
675:                         _response.rawResponse,
676:                     );
677:                 default:
678:                     throw new errors.HumeError({
679:                         statusCode: _response.error.statusCode,
680:                         body: _response.error.body,
681:                         rawResponse: _response.rawResponse,
682:                     });
683:             }
684:         }
685: 
686:         return handleNonStatusCodeError(
687:             _response.error,
688:             _response.rawResponse,
689:             "GET",
690:             "/v0/evi/configs/{id}/version/{version}",
691:         );
692:     }
693: 
694:     /**
695:      * @param {string} id - Identifier for a config. Formatted as a UUID.
696:      * @param {number} version - Version number for a config. Version numbers should be integers.
697:      * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
698:      *
699:      * @throws {@link Hume.empathicVoice.BadRequestError}
700:      *
701:      * @example
702:      *     await client.empathicVoice.configs.deleteConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1)
703:      */
704:     public deleteConfigVersion(
705:         id: string,
706:         version: number,
707:         requestOptions?: ConfigsClient.RequestOptions,
708:     ): core.HttpResponsePromise<void> {
709:         return core.HttpResponsePromise.fromPromise(this.__deleteConfigVersion(id, version, requestOptions));
710:     }
711: 
712:     private async __deleteConfigVersion(
713:         id: string,
714:         version: number,
715:         requestOptions?: ConfigsClient.RequestOptions,
716:     ): Promise<core.WithRawResponse<void>> {
717:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
718:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
719:             _authRequest.headers,
720:             this._options?.headers,
721:             requestOptions?.headers,
722:         );
723:         const _response = await (this._options.fetcher ?? core.fetcher)({
724:             url: core.url.join(
725:                 (await core.Supplier.get(this._options.baseUrl)) ??
726:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
727:                 `v0/evi/configs/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
728:             ),
729:             method: "DELETE",
730:             headers: _headers,
731:             queryParameters: requestOptions?.queryParams,
732:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
733:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
734:             abortSignal: requestOptions?.abortSignal,
735:             fetchFn: this._options?.fetch,
736:             logging: this._options.logging,
737:         });
738:         if (_response.ok) {
739:             return { data: undefined, rawResponse: _response.rawResponse };
740:         }
741: 
742:         if (_response.error.reason === "status-code") {
743:             switch (_response.error.statusCode) {
744:                 case 400:
745:                     throw new Hume.empathicVoice.BadRequestError(
746:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
747:                             unrecognizedObjectKeys: "passthrough",
748:                             allowUnrecognizedUnionMembers: true,
749:                             allowUnrecognizedEnumValues: true,
750:                             skipValidation: true,
751:                             breadcrumbsPrefix: ["response"],
752:                         }),
753:                         _response.rawResponse,
754:                     );
755:                 default:
756:                     throw new errors.HumeError({
757:                         statusCode: _response.error.statusCode,
758:                         body: _response.error.body,
759:                         rawResponse: _response.rawResponse,
760:                     });
761:             }
762:         }
763: 
764:         return handleNonStatusCodeError(
765:             _response.error,
766:             _response.rawResponse,
767:             "DELETE",
768:             "/v0/evi/configs/{id}/version/{version}",
769:         );
770:     }
771: 
772:     /**
773:      * @param {string} id - Identifier for a config. Formatted as a UUID.
774:      * @param {number} version - Version number for a config. Version numbers should be integers.
775:      * @param {Hume.empathicVoice.PostedConfigVersionDescription} request
776:      * @param {ConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
777:      *
778:      * @throws {@link Hume.empathicVoice.BadRequestError}
779:      *
780:      * @example
781:      *     await client.empathicVoice.configs.updateConfigDescription("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1, {
782:      *         versionDescription: "This is an updated version_description."
783:      *     })
784:      */
785:     public updateConfigDescription(
786:         id: string,
787:         version: number,
788:         request: Hume.empathicVoice.PostedConfigVersionDescription = {},
789:         requestOptions?: ConfigsClient.RequestOptions,
790:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnConfig> {
791:         return core.HttpResponsePromise.fromPromise(
792:             this.__updateConfigDescription(id, version, request, requestOptions),
793:         );
794:     }
795: 
796:     private async __updateConfigDescription(
797:         id: string,
798:         version: number,
799:         request: Hume.empathicVoice.PostedConfigVersionDescription = {},
800:         requestOptions?: ConfigsClient.RequestOptions,
801:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnConfig>> {
802:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
803:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
804:             _authRequest.headers,
805:             this._options?.headers,
806:             requestOptions?.headers,
807:         );
808:         const _response = await (this._options.fetcher ?? core.fetcher)({
809:             url: core.url.join(
810:                 (await core.Supplier.get(this._options.baseUrl)) ??
811:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
812:                 `v0/evi/configs/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
813:             ),
814:             method: "PATCH",
815:             headers: _headers,
816:             contentType: "application/json",
817:             queryParameters: requestOptions?.queryParams,
818:             requestType: "json",
819:             body: serializers.empathicVoice.PostedConfigVersionDescription.jsonOrThrow(request, {
820:                 unrecognizedObjectKeys: "strip",
821:                 omitUndefined: true,
822:             }),
823:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
824:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
825:             abortSignal: requestOptions?.abortSignal,
826:             fetchFn: this._options?.fetch,
827:             logging: this._options.logging,
828:         });
829:         if (_response.ok) {
830:             return {
831:                 data: serializers.empathicVoice.ReturnConfig.parseOrThrow(_response.body, {
832:                     unrecognizedObjectKeys: "passthrough",
833:                     allowUnrecognizedUnionMembers: true,
834:                     allowUnrecognizedEnumValues: true,
835:                     skipValidation: true,
836:                     breadcrumbsPrefix: ["response"],
837:                 }),
838:                 rawResponse: _response.rawResponse,
839:             };
840:         }
841: 
842:         if (_response.error.reason === "status-code") {
843:             switch (_response.error.statusCode) {
844:                 case 400:
845:                     throw new Hume.empathicVoice.BadRequestError(
846:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
847:                             unrecognizedObjectKeys: "passthrough",
848:                             allowUnrecognizedUnionMembers: true,
849:                             allowUnrecognizedEnumValues: true,
850:                             skipValidation: true,
851:                             breadcrumbsPrefix: ["response"],
852:                         }),
853:                         _response.rawResponse,
854:                     );
855:                 default:
856:                     throw new errors.HumeError({
857:                         statusCode: _response.error.statusCode,
858:                         body: _response.error.body,
859:                         rawResponse: _response.rawResponse,
860:                     });
861:             }
862:         }
863: 
864:         return handleNonStatusCodeError(
865:             _response.error,
866:             _response.rawResponse,
867:             "PATCH",
868:             "/v0/evi/configs/{id}/version/{version}",
869:         );
870:     }
871: }
````

## File: src/api/resources/empathicVoice/resources/configs/client/index.ts
````typescript
1: export * from "./requests/index.js";
````

## File: src/api/resources/empathicVoice/resources/configs/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
  4: import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
  5: import * as core from "../../../../../../core/index.js";
  6: import * as environments from "../../../../../../environments.js";
  7: import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
  8: import * as errors from "../../../../../../errors/index.js";
  9: import * as serializers from "../../../../../../serialization/index.js";
 10: import * as Hume from "../../../../../index.js";
 11: import { ControlPlaneSocket } from "./Socket.js";
 12: 
 13: export declare namespace ControlPlaneClient {
 14:     export interface Options extends BaseClientOptions {}
 15: 
 16:     export interface RequestOptions extends BaseRequestOptions {}
 17: 
 18:     export interface ConnectArgs {
 19:         chat_id: string;
 20:         accessToken?: string | undefined;
 21:         /** Arbitrary headers to send with the websocket connect request. */
 22:         headers?: Record<string, string>;
 23:         /** Enable debug mode on the websocket. Defaults to false. */
 24:         debug?: boolean;
 25:         /** Number of reconnect attempts. Defaults to 30. */
 26:         reconnectAttempts?: number;
 27:     }
 28: }
 29: 
 30: export class ControlPlaneClient {
 31:     protected readonly _options: ControlPlaneClient.Options;
 32: 
 33:     constructor(_options: ControlPlaneClient.Options = {}) {
 34:         this._options = _options;
 35:     }
 36: 
 37:     /**
 38:      * Send a message to a specific chat.
 39:      *
 40:      * @param {string} chatId
 41:      * @param {Hume.empathicVoice.ControlPlanePublishEvent} request
 42:      * @param {ControlPlaneClient.RequestOptions} requestOptions - Request-specific configuration.
 43:      *
 44:      * @throws {@link Hume.empathicVoice.UnprocessableEntityError}
 45:      *
 46:      * @example
 47:      *     await client.empathicVoice.controlPlane.send("chat_id", {
 48:      *         type: "session_settings"
 49:      *     })
 50:      */
 51:     public send(
 52:         chatId: string,
 53:         request: Hume.empathicVoice.ControlPlanePublishEvent,
 54:         requestOptions?: ControlPlaneClient.RequestOptions,
 55:     ): core.HttpResponsePromise<void> {
 56:         return core.HttpResponsePromise.fromPromise(this.__send(chatId, request, requestOptions));
 57:     }
 58: 
 59:     private async __send(
 60:         chatId: string,
 61:         request: Hume.empathicVoice.ControlPlanePublishEvent,
 62:         requestOptions?: ControlPlaneClient.RequestOptions,
 63:     ): Promise<core.WithRawResponse<void>> {
 64:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
 65:             this._options?.headers,
 66:             mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
 67:             requestOptions?.headers,
 68:         );
 69:         const _response = await (this._options.fetcher ?? core.fetcher)({
 70:             url: core.url.join(
 71:                 (await core.Supplier.get(this._options.baseUrl)) ??
 72:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
 73:                 `v0/evi/chat/${core.url.encodePathParam(chatId)}/send`,
 74:             ),
 75:             method: "POST",
 76:             headers: _headers,
 77:             contentType: "application/json",
 78:             queryParameters: requestOptions?.queryParams,
 79:             requestType: "json",
 80:             body: serializers.empathicVoice.ControlPlanePublishEvent.jsonOrThrow(request, {
 81:                 unrecognizedObjectKeys: "strip",
 82:                 omitUndefined: true,
 83:             }),
 84:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
 85:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
 86:             abortSignal: requestOptions?.abortSignal,
 87:             fetchFn: this._options?.fetch,
 88:             logging: this._options.logging,
 89:         });
 90:         if (_response.ok) {
 91:             return { data: undefined, rawResponse: _response.rawResponse };
 92:         }
 93: 
 94:         if (_response.error.reason === "status-code") {
 95:             switch (_response.error.statusCode) {
 96:                 case 422:
 97:                     throw new Hume.empathicVoice.UnprocessableEntityError(
 98:                         serializers.empathicVoice.HttpValidationError.parseOrThrow(_response.error.body, {
 99:                             unrecognizedObjectKeys: "passthrough",
100:                             allowUnrecognizedUnionMembers: true,
101:                             allowUnrecognizedEnumValues: true,
102:                             skipValidation: true,
103:                             breadcrumbsPrefix: ["response"],
104:                         }),
105:                         _response.rawResponse,
106:                     );
107:                 default:
108:                     throw new errors.HumeError({
109:                         statusCode: _response.error.statusCode,
110:                         body: _response.error.body,
111:                         rawResponse: _response.rawResponse,
112:                     });
113:             }
114:         }
115: 
116:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/chat/{chat_id}/send");
117:     }
118: 
119:     public async connect(args: ControlPlaneClient.ConnectArgs): Promise<ControlPlaneSocket> {
120:         const { chat_id, accessToken, headers, debug, reconnectAttempts } = args;
121:         const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
122:         if (accessToken != null) {
123:             _queryParams.access_token = accessToken;
124:         }
125: 
126:         const _headers: Record<string, unknown> = mergeHeaders(
127:             mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
128:             headers,
129:         );
130:         const socket = new core.ReconnectingWebSocket({
131:             url: core.url.join(
132:                 (await core.Supplier.get(this._options.baseUrl)) ??
133:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).evi,
134:                 `/chat/${core.url.encodePathParam(chat_id)}/connect`,
135:             ),
136:             protocols: [],
137:             queryParameters: _queryParams,
138:             headers: _headers,
139:             options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
140:         });
141:         return new ControlPlaneSocket({ socket });
142:     }
143:     protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
144:         const apiKeyValue = core.Supplier.get(this._options.apiKey);
145:         // This `authHeaderValue` is manually added as if you don't provide it it will
146:         // be omitted from the headers which means it won't reach the logic in ws.ts that
147:         // extracts values from the headers and adds them to query parameters.
148:         const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
149:         return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
150:     }
151: }
````

## File: src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts.diff
````diff
  1: diff --git a/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts b/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
  2: index 0eec869..b5d6ea0 100644
  3: --- a/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
  4: +++ b/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
  5: @@ -1,7 +1,8 @@
  6:  // This file was auto-generated by Fern from our API Definition.
  7:  
  8:  import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
  9: -import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
 10: +import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
 11: +import { mergeHeaders } from "../../../../../../core/headers.js";
 12:  import * as core from "../../../../../../core/index.js";
 13:  import * as environments from "../../../../../../environments.js";
 14:  import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
 15: @@ -11,13 +12,13 @@ import * as Hume from "../../../../../index.js";
 16:  import { ControlPlaneSocket } from "./Socket.js";
 17:  
 18:  export declare namespace ControlPlaneClient {
 19: -    export interface Options extends BaseClientOptions {}
 20: +    export type Options = BaseClientOptions;
 21:  
 22:      export interface RequestOptions extends BaseRequestOptions {}
 23:  
 24:      export interface ConnectArgs {
 25: -        chat_id: string;
 26: -        accessToken?: string | undefined;
 27: +        chatId: string;
 28: +        accessToken?: string;
 29:          /** Arbitrary headers to send with the websocket connect request. */
 30:          headers?: Record<string, string>;
 31:          /** Enable debug mode on the websocket. Defaults to false. */
 32: @@ -28,16 +29,16 @@ export declare namespace ControlPlaneClient {
 33:  }
 34:  
 35:  export class ControlPlaneClient {
 36: -    protected readonly _options: ControlPlaneClient.Options;
 37: +    protected readonly _options: NormalizedClientOptionsWithAuth<ControlPlaneClient.Options>;
 38:  
 39: -    constructor(_options: ControlPlaneClient.Options = {}) {
 40: -        this._options = _options;
 41: +    constructor(options: ControlPlaneClient.Options = {}) {
 42: +        this._options = normalizeClientOptionsWithAuth(options);
 43:      }
 44:  
 45:      /**
 46:       * Send a message to a specific chat.
 47:       *
 48: -     * @param {string} chatId
 49: +     * @param {string} chat_id
 50:       * @param {Hume.empathicVoice.ControlPlanePublishEvent} request
 51:       * @param {ControlPlaneClient.RequestOptions} requestOptions - Request-specific configuration.
 52:       *
 53: @@ -49,28 +50,29 @@ export class ControlPlaneClient {
 54:       *     })
 55:       */
 56:      public send(
 57: -        chatId: string,
 58: +        chat_id: string,
 59:          request: Hume.empathicVoice.ControlPlanePublishEvent,
 60:          requestOptions?: ControlPlaneClient.RequestOptions,
 61:      ): core.HttpResponsePromise<void> {
 62: -        return core.HttpResponsePromise.fromPromise(this.__send(chatId, request, requestOptions));
 63: +        return core.HttpResponsePromise.fromPromise(this.__send(chat_id, request, requestOptions));
 64:      }
 65:  
 66:      private async __send(
 67: -        chatId: string,
 68: +        chat_id: string,
 69:          request: Hume.empathicVoice.ControlPlanePublishEvent,
 70:          requestOptions?: ControlPlaneClient.RequestOptions,
 71:      ): Promise<core.WithRawResponse<void>> {
 72: +        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
 73:          const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
 74: +            _authRequest.headers,
 75:              this._options?.headers,
 76: -            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
 77:              requestOptions?.headers,
 78:          );
 79:          const _response = await (this._options.fetcher ?? core.fetcher)({
 80:              url: core.url.join(
 81:                  (await core.Supplier.get(this._options.baseUrl)) ??
 82:                      ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
 83: -                `v0/evi/chat/${core.url.encodePathParam(chatId)}/send`,
 84: +                `v0/evi/chat/${core.url.encodePathParam(chat_id)}/send`,
 85:              ),
 86:              method: "POST",
 87:              headers: _headers,
 88: @@ -117,21 +119,16 @@ export class ControlPlaneClient {
 89:      }
 90:  
 91:      public async connect(args: ControlPlaneClient.ConnectArgs): Promise<ControlPlaneSocket> {
 92: -        const { chat_id, accessToken, headers, debug, reconnectAttempts } = args;
 93: -        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
 94: -        if (accessToken != null) {
 95: -            _queryParams.access_token = accessToken;
 96: -        }
 97: -
 98: -        const _headers: Record<string, unknown> = mergeHeaders(
 99: -            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
100: -            headers,
101: -        );
102: +        const { chatId, accessToken, headers, debug, reconnectAttempts } = args;
103: +        const _queryParams: Record<string, unknown> = {
104: +            access_token: accessToken,
105: +        };
106: +        const _headers: Record<string, unknown> = { ...headers };
107:          const socket = new core.ReconnectingWebSocket({
108:              url: core.url.join(
109:                  (await core.Supplier.get(this._options.baseUrl)) ??
110:                      ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).evi,
111: -                `/chat/${core.url.encodePathParam(chat_id)}/connect`,
112: +                `/chat/${core.url.encodePathParam(chatId)}/connect`,
113:              ),
114:              protocols: [],
115:              queryParameters: _queryParams,
116: @@ -140,12 +137,4 @@ export class ControlPlaneClient {
117:          });
118:          return new ControlPlaneSocket({ socket });
119:      }
120: -    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
121: -        const apiKeyValue = core.Supplier.get(this._options.apiKey);
122: -        // This `authHeaderValue` is manually added as if you don't provide it it will
123: -        // be omitted from the headers which means it won't reach the logic in ws.ts that
124: -        // extracts values from the headers and adds them to query parameters.
125: -        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
126: -        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
127: -    }
128:  }
````

## File: src/api/resources/empathicVoice/resources/controlPlane/client/index.ts
````typescript
1: export {};
````

## File: src/api/resources/empathicVoice/resources/controlPlane/client/Socket.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import * as core from "../../../../../../core/index.js";
  4: import { fromJson } from "../../../../../../core/json.js";
  5: import * as serializers from "../../../../../../serialization/index.js";
  6: import { ControlPlanePublishEvent } from "../../../../../../serialization/resources/empathicVoice/types/ControlPlanePublishEvent.js";
  7: import type * as Hume from "../../../../../index.js";
  8: 
  9: export declare namespace ControlPlaneSocket {
 10:     export interface Args {
 11:         socket: core.ReconnectingWebSocket;
 12:     }
 13: 
 14:     export type Response = Hume.empathicVoice.SubscribeEvent;
 15:     type EventHandlers = {
 16:         open?: () => void;
 17:         message?: (message: Response) => void;
 18:         close?: (event: core.CloseEvent) => void;
 19:         error?: (error: Error) => void;
 20:     };
 21: }
 22: 
 23: export class ControlPlaneSocket {
 24:     public readonly socket: core.ReconnectingWebSocket;
 25:     protected readonly eventHandlers: ControlPlaneSocket.EventHandlers = {};
 26:     private handleOpen: () => void = () => {
 27:         this.eventHandlers.open?.();
 28:     };
 29:     private handleMessage: (event: { data: string }) => void = (event) => {
 30:         const data = fromJson(event.data);
 31: 
 32:         const parsedResponse = serializers.empathicVoice.ControlPlaneSocketResponse.parse(data, {
 33:             unrecognizedObjectKeys: "passthrough",
 34:             allowUnrecognizedUnionMembers: true,
 35:             allowUnrecognizedEnumValues: true,
 36:             skipValidation: true,
 37:             omitUndefined: true,
 38:         });
 39:         if (parsedResponse.ok) {
 40:             this.eventHandlers.message?.(parsedResponse.value);
 41:         } else {
 42:             this.eventHandlers.error?.(new Error("Received unknown message type"));
 43:         }
 44:     };
 45:     private handleClose: (event: core.CloseEvent) => void = (event) => {
 46:         this.eventHandlers.close?.(event);
 47:     };
 48:     private handleError: (event: core.ErrorEvent) => void = (event) => {
 49:         const message = event.message;
 50:         this.eventHandlers.error?.(new Error(message));
 51:     };
 52: 
 53:     constructor(args: ControlPlaneSocket.Args) {
 54:         this.socket = args.socket;
 55:         this.socket.addEventListener("open", this.handleOpen);
 56:         this.socket.addEventListener("message", this.handleMessage);
 57:         this.socket.addEventListener("close", this.handleClose);
 58:         this.socket.addEventListener("error", this.handleError);
 59:     }
 60: 
 61:     /** The current state of the connection; this is one of the readyState constants. */
 62:     get readyState(): number {
 63:         return this.socket.readyState;
 64:     }
 65: 
 66:     /**
 67:      * @param event - The event to attach to.
 68:      * @param callback - The callback to run when the event is triggered.
 69:      * Usage:
 70:      * ```typescript
 71:      * this.on('open', () => {
 72:      *     console.log('The websocket is open');
 73:      * });
 74:      * ```
 75:      */
 76:     public on<T extends keyof ControlPlaneSocket.EventHandlers>(
 77:         event: T,
 78:         callback: ControlPlaneSocket.EventHandlers[T],
 79:     ): void {
 80:         this.eventHandlers[event] = callback;
 81:     }
 82: 
 83:     public sendPublish(message: Hume.empathicVoice.ControlPlanePublishEvent): void {
 84:         this.assertSocketIsOpen();
 85:         const jsonPayload = ControlPlanePublishEvent.jsonOrThrow(message, {
 86:             unrecognizedObjectKeys: "passthrough",
 87:             allowUnrecognizedUnionMembers: true,
 88:             allowUnrecognizedEnumValues: true,
 89:             skipValidation: true,
 90:             omitUndefined: true,
 91:         });
 92:         this.socket.send(JSON.stringify(jsonPayload));
 93:     }
 94: 
 95:     /** Connect to the websocket and register event handlers. */
 96:     public connect(): ControlPlaneSocket {
 97:         this.socket.reconnect();
 98: 
 99:         this.socket.addEventListener("open", this.handleOpen);
100:         this.socket.addEventListener("message", this.handleMessage);
101:         this.socket.addEventListener("close", this.handleClose);
102:         this.socket.addEventListener("error", this.handleError);
103: 
104:         return this;
105:     }
106: 
107:     /** Close the websocket and unregister event handlers. */
108:     public close(): void {
109:         this.socket.close();
110: 
111:         this.handleClose({ code: 1000 } as CloseEvent);
112: 
113:         this.socket.removeEventListener("open", this.handleOpen);
114:         this.socket.removeEventListener("message", this.handleMessage);
115:         this.socket.removeEventListener("close", this.handleClose);
116:         this.socket.removeEventListener("error", this.handleError);
117:     }
118: 
119:     /** Returns a promise that resolves when the websocket is open. */
120:     public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
121:         if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
122:             return this.socket;
123:         }
124: 
125:         return new Promise((resolve, reject) => {
126:             this.socket.addEventListener("open", () => {
127:                 resolve(this.socket);
128:             });
129: 
130:             this.socket.addEventListener("error", (event: unknown) => {
131:                 reject(event);
132:             });
133:         });
134:     }
135: 
136:     /** Asserts that the websocket is open. */
137:     private assertSocketIsOpen(): void {
138:         if (!this.socket) {
139:             throw new Error("Socket is not connected.");
140:         }
141: 
142:         if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
143:             throw new Error("Socket is not open.");
144:         }
145:     }
146: 
147:     /** Send a binary payload to the websocket. */
148:     protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
149:         this.socket.send(payload);
150:     }
151: }
````

## File: src/api/resources/empathicVoice/resources/controlPlane/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/api/resources/empathicVoice/resources/prompts/client/requests/index.ts
````typescript
1: export type { PostedPrompt } from "./PostedPrompt.js";
2: export type { PostedPromptName } from "./PostedPromptName.js";
3: export type { PostedPromptVersion } from "./PostedPromptVersion.js";
4: export type { PostedPromptVersionDescription } from "./PostedPromptVersionDescription.js";
5: export type { PromptsListPromptsRequest } from "./PromptsListPromptsRequest.js";
6: export type { PromptsListPromptVersionsRequest } from "./PromptsListPromptVersionsRequest.js";
````

## File: src/api/resources/empathicVoice/resources/prompts/client/requests/PostedPrompt.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         name: "Weather Assistant Prompt",
 7:  *         text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>"
 8:  *     }
 9:  */
10: export interface PostedPrompt {
11:     /** Name applied to all versions of a particular Prompt. */
12:     name: string;
13:     /** Text used for this version of the Prompt. */
14:     text: string;
15:     /** Description that is appended to a specific version of a Prompt. */
16:     versionDescription?: string;
17: }
````

## File: src/api/resources/empathicVoice/resources/prompts/client/requests/PostedPromptName.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         name: "Updated Weather Assistant Prompt Name"
 7:  *     }
 8:  */
 9: export interface PostedPromptName {
10:     /** Name applied to all versions of a particular Prompt. */
11:     name: string;
12: }
````

## File: src/api/resources/empathicVoice/resources/prompts/client/requests/PostedPromptVersion.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 7:  *         versionDescription: "This is an updated version of the Weather Assistant Prompt."
 8:  *     }
 9:  */
10: export interface PostedPromptVersion {
11:     /** Text used for this version of the Prompt. */
12:     text: string;
13:     /** Description that is appended to a specific version of a Prompt. */
14:     versionDescription?: string;
15: }
````

## File: src/api/resources/empathicVoice/resources/prompts/client/requests/PostedPromptVersionDescription.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         versionDescription: "This is an updated version_description."
 7:  *     }
 8:  */
 9: export interface PostedPromptVersionDescription {
10:     /** Description that is appended to a specific version of a Prompt. */
11:     versionDescription?: string;
12: }
````

## File: src/api/resources/empathicVoice/resources/prompts/client/requests/PromptsListPromptsRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         pageNumber: 0,
 7:  *         pageSize: 2
 8:  *     }
 9:  */
10: export interface PromptsListPromptsRequest {
11:     /**
12:      * Specifies the page number to retrieve, enabling pagination.
13:      *
14:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
15:      */
16:     pageNumber?: number;
17:     /**
18:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
19:      *
20:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
21:      */
22:     pageSize?: number;
23:     /** Only include the most recent version of each prompt in the list. */
24:     restrictToMostRecent?: boolean;
25:     /** Filter to only include prompts with name. */
26:     name?: string;
27: }
````

## File: src/api/resources/empathicVoice/resources/prompts/client/requests/PromptsListPromptVersionsRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {}
 6:  */
 7: export interface PromptsListPromptVersionsRequest {
 8:     /**
 9:      * Specifies the page number to retrieve, enabling pagination.
10:      *
11:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
12:      */
13:     pageNumber?: number;
14:     /**
15:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
16:      *
17:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
18:      */
19:     pageSize?: number;
20:     /** Only include the most recent version of each prompt in the list. */
21:     restrictToMostRecent?: boolean;
22: }
````

## File: src/api/resources/empathicVoice/resources/prompts/client/Client.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
  4: import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
  5: import { mergeHeaders } from "../../../../../../core/headers.js";
  6: import * as core from "../../../../../../core/index.js";
  7: import * as environments from "../../../../../../environments.js";
  8: import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
  9: import * as errors from "../../../../../../errors/index.js";
 10: import * as serializers from "../../../../../../serialization/index.js";
 11: import * as Hume from "../../../../../index.js";
 12: 
 13: export declare namespace PromptsClient {
 14:     export type Options = BaseClientOptions;
 15: 
 16:     export interface RequestOptions extends BaseRequestOptions {}
 17: }
 18: 
 19: export class PromptsClient {
 20:     protected readonly _options: NormalizedClientOptionsWithAuth<PromptsClient.Options>;
 21: 
 22:     constructor(options: PromptsClient.Options = {}) {
 23:         this._options = normalizeClientOptionsWithAuth(options);
 24:     }
 25: 
 26:     /**
 27:      * @param {Hume.empathicVoice.PromptsListPromptsRequest} request
 28:      * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
 29:      *
 30:      * @throws {@link Hume.empathicVoice.BadRequestError}
 31:      *
 32:      * @example
 33:      *     await client.empathicVoice.prompts.listPrompts({
 34:      *         pageNumber: 0,
 35:      *         pageSize: 2
 36:      *     })
 37:      */
 38:     public async listPrompts(
 39:         request: Hume.empathicVoice.PromptsListPromptsRequest = {},
 40:         requestOptions?: PromptsClient.RequestOptions,
 41:     ): Promise<core.Page<Hume.empathicVoice.ReturnPrompt | undefined, Hume.empathicVoice.ReturnPagedPrompts>> {
 42:         const list = core.HttpResponsePromise.interceptFunction(
 43:             async (
 44:                 request: Hume.empathicVoice.PromptsListPromptsRequest,
 45:             ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedPrompts>> => {
 46:                 const { pageNumber, pageSize, restrictToMostRecent, name } = request;
 47:                 const _queryParams: Record<string, unknown> = {
 48:                     page_number: pageNumber,
 49:                     page_size: pageSize,
 50:                     restrict_to_most_recent: restrictToMostRecent,
 51:                     name,
 52:                 };
 53:                 const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
 54:                 const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
 55:                     _authRequest.headers,
 56:                     this._options?.headers,
 57:                     requestOptions?.headers,
 58:                 );
 59:                 const _response = await (this._options.fetcher ?? core.fetcher)({
 60:                     url: core.url.join(
 61:                         (await core.Supplier.get(this._options.baseUrl)) ??
 62:                             ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
 63:                                 .base,
 64:                         "v0/evi/prompts",
 65:                     ),
 66:                     method: "GET",
 67:                     headers: _headers,
 68:                     queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
 69:                     timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
 70:                     maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
 71:                     abortSignal: requestOptions?.abortSignal,
 72:                     fetchFn: this._options?.fetch,
 73:                     logging: this._options.logging,
 74:                 });
 75:                 if (_response.ok) {
 76:                     return {
 77:                         data: serializers.empathicVoice.ReturnPagedPrompts.parseOrThrow(_response.body, {
 78:                             unrecognizedObjectKeys: "passthrough",
 79:                             allowUnrecognizedUnionMembers: true,
 80:                             allowUnrecognizedEnumValues: true,
 81:                             skipValidation: true,
 82:                             breadcrumbsPrefix: ["response"],
 83:                         }),
 84:                         rawResponse: _response.rawResponse,
 85:                     };
 86:                 }
 87:                 if (_response.error.reason === "status-code") {
 88:                     switch (_response.error.statusCode) {
 89:                         case 400:
 90:                             throw new Hume.empathicVoice.BadRequestError(
 91:                                 serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
 92:                                     unrecognizedObjectKeys: "passthrough",
 93:                                     allowUnrecognizedUnionMembers: true,
 94:                                     allowUnrecognizedEnumValues: true,
 95:                                     skipValidation: true,
 96:                                     breadcrumbsPrefix: ["response"],
 97:                                 }),
 98:                                 _response.rawResponse,
 99:                             );
100:                         default:
101:                             throw new errors.HumeError({
102:                                 statusCode: _response.error.statusCode,
103:                                 body: _response.error.body,
104:                                 rawResponse: _response.rawResponse,
105:                             });
106:                     }
107:                 }
108:                 return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/prompts");
109:             },
110:         );
111:         let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
112:         const dataWithRawResponse = await list(request).withRawResponse();
113:         return new core.Page<Hume.empathicVoice.ReturnPrompt | undefined, Hume.empathicVoice.ReturnPagedPrompts>({
114:             response: dataWithRawResponse.data,
115:             rawResponse: dataWithRawResponse.rawResponse,
116:             hasNextPage: (response) => (response?.promptsPage ?? []).length > 0,
117:             getItems: (response) => response?.promptsPage ?? [],
118:             loadPage: (_response) => {
119:                 _offset += 1;
120:                 return list(core.setObjectProperty(request, "pageNumber", _offset));
121:             },
122:         });
123:     }
124: 
125:     /**
126:      * @param {Hume.empathicVoice.PostedPrompt} request
127:      * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
128:      *
129:      * @throws {@link Hume.empathicVoice.BadRequestError}
130:      *
131:      * @example
132:      *     await client.empathicVoice.prompts.createPrompt({
133:      *         name: "Weather Assistant Prompt",
134:      *         text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>"
135:      *     })
136:      */
137:     public createPrompt(
138:         request: Hume.empathicVoice.PostedPrompt,
139:         requestOptions?: PromptsClient.RequestOptions,
140:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | undefined> {
141:         return core.HttpResponsePromise.fromPromise(this.__createPrompt(request, requestOptions));
142:     }
143: 
144:     private async __createPrompt(
145:         request: Hume.empathicVoice.PostedPrompt,
146:         requestOptions?: PromptsClient.RequestOptions,
147:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | undefined>> {
148:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
149:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
150:             _authRequest.headers,
151:             this._options?.headers,
152:             requestOptions?.headers,
153:         );
154:         const _response = await (this._options.fetcher ?? core.fetcher)({
155:             url: core.url.join(
156:                 (await core.Supplier.get(this._options.baseUrl)) ??
157:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
158:                 "v0/evi/prompts",
159:             ),
160:             method: "POST",
161:             headers: _headers,
162:             contentType: "application/json",
163:             queryParameters: requestOptions?.queryParams,
164:             requestType: "json",
165:             body: serializers.empathicVoice.PostedPrompt.jsonOrThrow(request, {
166:                 unrecognizedObjectKeys: "strip",
167:                 omitUndefined: true,
168:             }),
169:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
170:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
171:             abortSignal: requestOptions?.abortSignal,
172:             fetchFn: this._options?.fetch,
173:             logging: this._options.logging,
174:         });
175:         if (_response.ok) {
176:             return {
177:                 data: serializers.empathicVoice.prompts.createPrompt.Response.parseOrThrow(_response.body, {
178:                     unrecognizedObjectKeys: "passthrough",
179:                     allowUnrecognizedUnionMembers: true,
180:                     allowUnrecognizedEnumValues: true,
181:                     skipValidation: true,
182:                     breadcrumbsPrefix: ["response"],
183:                 }),
184:                 rawResponse: _response.rawResponse,
185:             };
186:         }
187: 
188:         if (_response.error.reason === "status-code") {
189:             switch (_response.error.statusCode) {
190:                 case 400:
191:                     throw new Hume.empathicVoice.BadRequestError(
192:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
193:                             unrecognizedObjectKeys: "passthrough",
194:                             allowUnrecognizedUnionMembers: true,
195:                             allowUnrecognizedEnumValues: true,
196:                             skipValidation: true,
197:                             breadcrumbsPrefix: ["response"],
198:                         }),
199:                         _response.rawResponse,
200:                     );
201:                 default:
202:                     throw new errors.HumeError({
203:                         statusCode: _response.error.statusCode,
204:                         body: _response.error.body,
205:                         rawResponse: _response.rawResponse,
206:                     });
207:             }
208:         }
209: 
210:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/prompts");
211:     }
212: 
213:     /**
214:      * @param {string} id
215:      * @param {Hume.empathicVoice.PromptsListPromptVersionsRequest} request
216:      * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
217:      *
218:      * @throws {@link Hume.empathicVoice.BadRequestError}
219:      *
220:      * @example
221:      *     await client.empathicVoice.prompts.listPromptVersions("af699d45-2985-42cc-91b9-af9e5da3bac5")
222:      */
223:     public listPromptVersions(
224:         id: string,
225:         request: Hume.empathicVoice.PromptsListPromptVersionsRequest = {},
226:         requestOptions?: PromptsClient.RequestOptions,
227:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPagedPrompts> {
228:         return core.HttpResponsePromise.fromPromise(this.__listPromptVersions(id, request, requestOptions));
229:     }
230: 
231:     private async __listPromptVersions(
232:         id: string,
233:         request: Hume.empathicVoice.PromptsListPromptVersionsRequest = {},
234:         requestOptions?: PromptsClient.RequestOptions,
235:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedPrompts>> {
236:         const { pageNumber, pageSize, restrictToMostRecent } = request;
237:         const _queryParams: Record<string, unknown> = {
238:             page_number: pageNumber,
239:             page_size: pageSize,
240:             restrict_to_most_recent: restrictToMostRecent,
241:         };
242:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
243:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
244:             _authRequest.headers,
245:             this._options?.headers,
246:             requestOptions?.headers,
247:         );
248:         const _response = await (this._options.fetcher ?? core.fetcher)({
249:             url: core.url.join(
250:                 (await core.Supplier.get(this._options.baseUrl)) ??
251:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
252:                 `v0/evi/prompts/${core.url.encodePathParam(id)}`,
253:             ),
254:             method: "GET",
255:             headers: _headers,
256:             queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
257:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
258:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
259:             abortSignal: requestOptions?.abortSignal,
260:             fetchFn: this._options?.fetch,
261:             logging: this._options.logging,
262:         });
263:         if (_response.ok) {
264:             return {
265:                 data: serializers.empathicVoice.ReturnPagedPrompts.parseOrThrow(_response.body, {
266:                     unrecognizedObjectKeys: "passthrough",
267:                     allowUnrecognizedUnionMembers: true,
268:                     allowUnrecognizedEnumValues: true,
269:                     skipValidation: true,
270:                     breadcrumbsPrefix: ["response"],
271:                 }),
272:                 rawResponse: _response.rawResponse,
273:             };
274:         }
275: 
276:         if (_response.error.reason === "status-code") {
277:             switch (_response.error.statusCode) {
278:                 case 400:
279:                     throw new Hume.empathicVoice.BadRequestError(
280:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
281:                             unrecognizedObjectKeys: "passthrough",
282:                             allowUnrecognizedUnionMembers: true,
283:                             allowUnrecognizedEnumValues: true,
284:                             skipValidation: true,
285:                             breadcrumbsPrefix: ["response"],
286:                         }),
287:                         _response.rawResponse,
288:                     );
289:                 default:
290:                     throw new errors.HumeError({
291:                         statusCode: _response.error.statusCode,
292:                         body: _response.error.body,
293:                         rawResponse: _response.rawResponse,
294:                     });
295:             }
296:         }
297: 
298:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/prompts/{id}");
299:     }
300: 
301:     /**
302:      * @param {string} id - Identifier for a prompt. Formatted as a UUID.
303:      * @param {Hume.empathicVoice.PostedPromptVersion} request
304:      * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
305:      *
306:      * @throws {@link Hume.empathicVoice.BadRequestError}
307:      *
308:      * @example
309:      *     await client.empathicVoice.prompts.createPromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", {
310:      *         text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
311:      *         versionDescription: "This is an updated version of the Weather Assistant Prompt."
312:      *     })
313:      */
314:     public createPromptVersion(
315:         id: string,
316:         request: Hume.empathicVoice.PostedPromptVersion,
317:         requestOptions?: PromptsClient.RequestOptions,
318:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | undefined> {
319:         return core.HttpResponsePromise.fromPromise(this.__createPromptVersion(id, request, requestOptions));
320:     }
321: 
322:     private async __createPromptVersion(
323:         id: string,
324:         request: Hume.empathicVoice.PostedPromptVersion,
325:         requestOptions?: PromptsClient.RequestOptions,
326:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | undefined>> {
327:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
328:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
329:             _authRequest.headers,
330:             this._options?.headers,
331:             requestOptions?.headers,
332:         );
333:         const _response = await (this._options.fetcher ?? core.fetcher)({
334:             url: core.url.join(
335:                 (await core.Supplier.get(this._options.baseUrl)) ??
336:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
337:                 `v0/evi/prompts/${core.url.encodePathParam(id)}`,
338:             ),
339:             method: "POST",
340:             headers: _headers,
341:             contentType: "application/json",
342:             queryParameters: requestOptions?.queryParams,
343:             requestType: "json",
344:             body: serializers.empathicVoice.PostedPromptVersion.jsonOrThrow(request, {
345:                 unrecognizedObjectKeys: "strip",
346:                 omitUndefined: true,
347:             }),
348:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
349:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
350:             abortSignal: requestOptions?.abortSignal,
351:             fetchFn: this._options?.fetch,
352:             logging: this._options.logging,
353:         });
354:         if (_response.ok) {
355:             return {
356:                 data: serializers.empathicVoice.prompts.createPromptVersion.Response.parseOrThrow(_response.body, {
357:                     unrecognizedObjectKeys: "passthrough",
358:                     allowUnrecognizedUnionMembers: true,
359:                     allowUnrecognizedEnumValues: true,
360:                     skipValidation: true,
361:                     breadcrumbsPrefix: ["response"],
362:                 }),
363:                 rawResponse: _response.rawResponse,
364:             };
365:         }
366: 
367:         if (_response.error.reason === "status-code") {
368:             switch (_response.error.statusCode) {
369:                 case 400:
370:                     throw new Hume.empathicVoice.BadRequestError(
371:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
372:                             unrecognizedObjectKeys: "passthrough",
373:                             allowUnrecognizedUnionMembers: true,
374:                             allowUnrecognizedEnumValues: true,
375:                             skipValidation: true,
376:                             breadcrumbsPrefix: ["response"],
377:                         }),
378:                         _response.rawResponse,
379:                     );
380:                 default:
381:                     throw new errors.HumeError({
382:                         statusCode: _response.error.statusCode,
383:                         body: _response.error.body,
384:                         rawResponse: _response.rawResponse,
385:                     });
386:             }
387:         }
388: 
389:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/prompts/{id}");
390:     }
391: 
392:     /**
393:      * @param {string} id - Identifier for a prompt. Formatted as a UUID.
394:      * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
395:      *
396:      * @throws {@link Hume.empathicVoice.BadRequestError}
397:      *
398:      * @example
399:      *     await client.empathicVoice.prompts.deletePrompt("af699d45-2985-42cc-91b9-af9e5da3bac5")
400:      */
401:     public deletePrompt(id: string, requestOptions?: PromptsClient.RequestOptions): core.HttpResponsePromise<void> {
402:         return core.HttpResponsePromise.fromPromise(this.__deletePrompt(id, requestOptions));
403:     }
404: 
405:     private async __deletePrompt(
406:         id: string,
407:         requestOptions?: PromptsClient.RequestOptions,
408:     ): Promise<core.WithRawResponse<void>> {
409:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
410:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
411:             _authRequest.headers,
412:             this._options?.headers,
413:             requestOptions?.headers,
414:         );
415:         const _response = await (this._options.fetcher ?? core.fetcher)({
416:             url: core.url.join(
417:                 (await core.Supplier.get(this._options.baseUrl)) ??
418:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
419:                 `v0/evi/prompts/${core.url.encodePathParam(id)}`,
420:             ),
421:             method: "DELETE",
422:             headers: _headers,
423:             queryParameters: requestOptions?.queryParams,
424:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
425:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
426:             abortSignal: requestOptions?.abortSignal,
427:             fetchFn: this._options?.fetch,
428:             logging: this._options.logging,
429:         });
430:         if (_response.ok) {
431:             return { data: undefined, rawResponse: _response.rawResponse };
432:         }
433: 
434:         if (_response.error.reason === "status-code") {
435:             switch (_response.error.statusCode) {
436:                 case 400:
437:                     throw new Hume.empathicVoice.BadRequestError(
438:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
439:                             unrecognizedObjectKeys: "passthrough",
440:                             allowUnrecognizedUnionMembers: true,
441:                             allowUnrecognizedEnumValues: true,
442:                             skipValidation: true,
443:                             breadcrumbsPrefix: ["response"],
444:                         }),
445:                         _response.rawResponse,
446:                     );
447:                 default:
448:                     throw new errors.HumeError({
449:                         statusCode: _response.error.statusCode,
450:                         body: _response.error.body,
451:                         rawResponse: _response.rawResponse,
452:                     });
453:             }
454:         }
455: 
456:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v0/evi/prompts/{id}");
457:     }
458: 
459:     /**
460:      * @param {string} id - Identifier for a prompt. Formatted as a UUID.
461:      * @param {Hume.empathicVoice.PostedPromptName} request
462:      * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
463:      *
464:      * @throws {@link Hume.empathicVoice.BadRequestError}
465:      *
466:      * @example
467:      *     await client.empathicVoice.prompts.updatePromptName("af699d45-2985-42cc-91b9-af9e5da3bac5", {
468:      *         name: "Updated Weather Assistant Prompt Name"
469:      *     })
470:      */
471:     public updatePromptName(
472:         id: string,
473:         request: Hume.empathicVoice.PostedPromptName,
474:         requestOptions?: PromptsClient.RequestOptions,
475:     ): core.HttpResponsePromise<string> {
476:         return core.HttpResponsePromise.fromPromise(this.__updatePromptName(id, request, requestOptions));
477:     }
478: 
479:     private async __updatePromptName(
480:         id: string,
481:         request: Hume.empathicVoice.PostedPromptName,
482:         requestOptions?: PromptsClient.RequestOptions,
483:     ): Promise<core.WithRawResponse<string>> {
484:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
485:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
486:             _authRequest.headers,
487:             this._options?.headers,
488:             requestOptions?.headers,
489:         );
490:         const _response = await (this._options.fetcher ?? core.fetcher)({
491:             url: core.url.join(
492:                 (await core.Supplier.get(this._options.baseUrl)) ??
493:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
494:                 `v0/evi/prompts/${core.url.encodePathParam(id)}`,
495:             ),
496:             method: "PATCH",
497:             headers: _headers,
498:             contentType: "application/json",
499:             queryParameters: requestOptions?.queryParams,
500:             requestType: "json",
501:             body: serializers.empathicVoice.PostedPromptName.jsonOrThrow(request, {
502:                 unrecognizedObjectKeys: "strip",
503:                 omitUndefined: true,
504:             }),
505:             responseType: "text",
506:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
507:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
508:             abortSignal: requestOptions?.abortSignal,
509:             fetchFn: this._options?.fetch,
510:             logging: this._options.logging,
511:         });
512:         if (_response.ok) {
513:             return { data: _response.body as string, rawResponse: _response.rawResponse };
514:         }
515: 
516:         if (_response.error.reason === "status-code") {
517:             switch (_response.error.statusCode) {
518:                 case 400:
519:                     throw new Hume.empathicVoice.BadRequestError(
520:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
521:                             unrecognizedObjectKeys: "passthrough",
522:                             allowUnrecognizedUnionMembers: true,
523:                             allowUnrecognizedEnumValues: true,
524:                             skipValidation: true,
525:                             breadcrumbsPrefix: ["response"],
526:                         }),
527:                         _response.rawResponse,
528:                     );
529:                 default:
530:                     throw new errors.HumeError({
531:                         statusCode: _response.error.statusCode,
532:                         body: _response.error.body,
533:                         rawResponse: _response.rawResponse,
534:                     });
535:             }
536:         }
537: 
538:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/v0/evi/prompts/{id}");
539:     }
540: 
541:     /**
542:      * @param {string} id - Identifier for a prompt. Formatted as a UUID.
543:      * @param {number} version - Version number for a prompt. Version numbers should be integers.
544:      * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
545:      *
546:      * @throws {@link Hume.empathicVoice.BadRequestError}
547:      *
548:      * @example
549:      *     await client.empathicVoice.prompts.getPromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", 0)
550:      */
551:     public getPromptVersion(
552:         id: string,
553:         version: number,
554:         requestOptions?: PromptsClient.RequestOptions,
555:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | undefined> {
556:         return core.HttpResponsePromise.fromPromise(this.__getPromptVersion(id, version, requestOptions));
557:     }
558: 
559:     private async __getPromptVersion(
560:         id: string,
561:         version: number,
562:         requestOptions?: PromptsClient.RequestOptions,
563:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | undefined>> {
564:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
565:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
566:             _authRequest.headers,
567:             this._options?.headers,
568:             requestOptions?.headers,
569:         );
570:         const _response = await (this._options.fetcher ?? core.fetcher)({
571:             url: core.url.join(
572:                 (await core.Supplier.get(this._options.baseUrl)) ??
573:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
574:                 `v0/evi/prompts/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
575:             ),
576:             method: "GET",
577:             headers: _headers,
578:             queryParameters: requestOptions?.queryParams,
579:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
580:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
581:             abortSignal: requestOptions?.abortSignal,
582:             fetchFn: this._options?.fetch,
583:             logging: this._options.logging,
584:         });
585:         if (_response.ok) {
586:             return {
587:                 data: serializers.empathicVoice.prompts.getPromptVersion.Response.parseOrThrow(_response.body, {
588:                     unrecognizedObjectKeys: "passthrough",
589:                     allowUnrecognizedUnionMembers: true,
590:                     allowUnrecognizedEnumValues: true,
591:                     skipValidation: true,
592:                     breadcrumbsPrefix: ["response"],
593:                 }),
594:                 rawResponse: _response.rawResponse,
595:             };
596:         }
597: 
598:         if (_response.error.reason === "status-code") {
599:             switch (_response.error.statusCode) {
600:                 case 400:
601:                     throw new Hume.empathicVoice.BadRequestError(
602:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
603:                             unrecognizedObjectKeys: "passthrough",
604:                             allowUnrecognizedUnionMembers: true,
605:                             allowUnrecognizedEnumValues: true,
606:                             skipValidation: true,
607:                             breadcrumbsPrefix: ["response"],
608:                         }),
609:                         _response.rawResponse,
610:                     );
611:                 default:
612:                     throw new errors.HumeError({
613:                         statusCode: _response.error.statusCode,
614:                         body: _response.error.body,
615:                         rawResponse: _response.rawResponse,
616:                     });
617:             }
618:         }
619: 
620:         return handleNonStatusCodeError(
621:             _response.error,
622:             _response.rawResponse,
623:             "GET",
624:             "/v0/evi/prompts/{id}/version/{version}",
625:         );
626:     }
627: 
628:     /**
629:      * @param {string} id - Identifier for a prompt. Formatted as a UUID.
630:      * @param {number} version - Version number for a prompt. Version numbers should be integers.
631:      * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
632:      *
633:      * @throws {@link Hume.empathicVoice.BadRequestError}
634:      *
635:      * @example
636:      *     await client.empathicVoice.prompts.deletePromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", 1)
637:      */
638:     public deletePromptVersion(
639:         id: string,
640:         version: number,
641:         requestOptions?: PromptsClient.RequestOptions,
642:     ): core.HttpResponsePromise<void> {
643:         return core.HttpResponsePromise.fromPromise(this.__deletePromptVersion(id, version, requestOptions));
644:     }
645: 
646:     private async __deletePromptVersion(
647:         id: string,
648:         version: number,
649:         requestOptions?: PromptsClient.RequestOptions,
650:     ): Promise<core.WithRawResponse<void>> {
651:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
652:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
653:             _authRequest.headers,
654:             this._options?.headers,
655:             requestOptions?.headers,
656:         );
657:         const _response = await (this._options.fetcher ?? core.fetcher)({
658:             url: core.url.join(
659:                 (await core.Supplier.get(this._options.baseUrl)) ??
660:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
661:                 `v0/evi/prompts/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
662:             ),
663:             method: "DELETE",
664:             headers: _headers,
665:             queryParameters: requestOptions?.queryParams,
666:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
667:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
668:             abortSignal: requestOptions?.abortSignal,
669:             fetchFn: this._options?.fetch,
670:             logging: this._options.logging,
671:         });
672:         if (_response.ok) {
673:             return { data: undefined, rawResponse: _response.rawResponse };
674:         }
675: 
676:         if (_response.error.reason === "status-code") {
677:             switch (_response.error.statusCode) {
678:                 case 400:
679:                     throw new Hume.empathicVoice.BadRequestError(
680:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
681:                             unrecognizedObjectKeys: "passthrough",
682:                             allowUnrecognizedUnionMembers: true,
683:                             allowUnrecognizedEnumValues: true,
684:                             skipValidation: true,
685:                             breadcrumbsPrefix: ["response"],
686:                         }),
687:                         _response.rawResponse,
688:                     );
689:                 default:
690:                     throw new errors.HumeError({
691:                         statusCode: _response.error.statusCode,
692:                         body: _response.error.body,
693:                         rawResponse: _response.rawResponse,
694:                     });
695:             }
696:         }
697: 
698:         return handleNonStatusCodeError(
699:             _response.error,
700:             _response.rawResponse,
701:             "DELETE",
702:             "/v0/evi/prompts/{id}/version/{version}",
703:         );
704:     }
705: 
706:     /**
707:      * @param {string} id - Identifier for a prompt. Formatted as a UUID.
708:      * @param {number} version - Version number for a prompt. Version numbers should be integers.
709:      * @param {Hume.empathicVoice.PostedPromptVersionDescription} request
710:      * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
711:      *
712:      * @throws {@link Hume.empathicVoice.BadRequestError}
713:      *
714:      * @example
715:      *     await client.empathicVoice.prompts.updatePromptDescription("af699d45-2985-42cc-91b9-af9e5da3bac5", 1, {
716:      *         versionDescription: "This is an updated version_description."
717:      *     })
718:      */
719:     public updatePromptDescription(
720:         id: string,
721:         version: number,
722:         request: Hume.empathicVoice.PostedPromptVersionDescription = {},
723:         requestOptions?: PromptsClient.RequestOptions,
724:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | undefined> {
725:         return core.HttpResponsePromise.fromPromise(
726:             this.__updatePromptDescription(id, version, request, requestOptions),
727:         );
728:     }
729: 
730:     private async __updatePromptDescription(
731:         id: string,
732:         version: number,
733:         request: Hume.empathicVoice.PostedPromptVersionDescription = {},
734:         requestOptions?: PromptsClient.RequestOptions,
735:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | undefined>> {
736:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
737:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
738:             _authRequest.headers,
739:             this._options?.headers,
740:             requestOptions?.headers,
741:         );
742:         const _response = await (this._options.fetcher ?? core.fetcher)({
743:             url: core.url.join(
744:                 (await core.Supplier.get(this._options.baseUrl)) ??
745:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
746:                 `v0/evi/prompts/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
747:             ),
748:             method: "PATCH",
749:             headers: _headers,
750:             contentType: "application/json",
751:             queryParameters: requestOptions?.queryParams,
752:             requestType: "json",
753:             body: serializers.empathicVoice.PostedPromptVersionDescription.jsonOrThrow(request, {
754:                 unrecognizedObjectKeys: "strip",
755:                 omitUndefined: true,
756:             }),
757:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
758:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
759:             abortSignal: requestOptions?.abortSignal,
760:             fetchFn: this._options?.fetch,
761:             logging: this._options.logging,
762:         });
763:         if (_response.ok) {
764:             return {
765:                 data: serializers.empathicVoice.prompts.updatePromptDescription.Response.parseOrThrow(_response.body, {
766:                     unrecognizedObjectKeys: "passthrough",
767:                     allowUnrecognizedUnionMembers: true,
768:                     allowUnrecognizedEnumValues: true,
769:                     skipValidation: true,
770:                     breadcrumbsPrefix: ["response"],
771:                 }),
772:                 rawResponse: _response.rawResponse,
773:             };
774:         }
775: 
776:         if (_response.error.reason === "status-code") {
777:             switch (_response.error.statusCode) {
778:                 case 400:
779:                     throw new Hume.empathicVoice.BadRequestError(
780:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
781:                             unrecognizedObjectKeys: "passthrough",
782:                             allowUnrecognizedUnionMembers: true,
783:                             allowUnrecognizedEnumValues: true,
784:                             skipValidation: true,
785:                             breadcrumbsPrefix: ["response"],
786:                         }),
787:                         _response.rawResponse,
788:                     );
789:                 default:
790:                     throw new errors.HumeError({
791:                         statusCode: _response.error.statusCode,
792:                         body: _response.error.body,
793:                         rawResponse: _response.rawResponse,
794:                     });
795:             }
796:         }
797: 
798:         return handleNonStatusCodeError(
799:             _response.error,
800:             _response.rawResponse,
801:             "PATCH",
802:             "/v0/evi/prompts/{id}/version/{version}",
803:         );
804:     }
805: }
````

## File: src/api/resources/empathicVoice/resources/prompts/client/index.ts
````typescript
1: export * from "./requests/index.js";
````

## File: src/api/resources/empathicVoice/resources/prompts/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/api/resources/empathicVoice/resources/tools/client/requests/index.ts
````typescript
1: export type { PostedUserDefinedTool } from "./PostedUserDefinedTool.js";
2: export type { PostedUserDefinedToolName } from "./PostedUserDefinedToolName.js";
3: export type { PostedUserDefinedToolVersion } from "./PostedUserDefinedToolVersion.js";
4: export type { PostedUserDefinedToolVersionDescription } from "./PostedUserDefinedToolVersionDescription.js";
5: export type { ToolsListToolsRequest } from "./ToolsListToolsRequest.js";
6: export type { ToolsListToolVersionsRequest } from "./ToolsListToolVersionsRequest.js";
````

## File: src/api/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedTool.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         name: "get_current_weather",
 7:  *         parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
 8:  *         versionDescription: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
 9:  *         description: "This tool is for getting the current weather.",
10:  *         fallbackContent: "Unable to fetch current weather."
11:  *     }
12:  */
13: export interface PostedUserDefinedTool {
14:     /** Text describing what the tool does. */
15:     description?: string;
16:     /** Text to use if the tool fails to generate content. */
17:     fallbackContent?: string;
18:     /** Name applied to all versions of a particular Tool. */
19:     name: string;
20:     /** Stringified JSON defining the parameters used by this version of the Tool. */
21:     parameters: string;
22:     /** Description that is appended to a specific version of a Tool. */
23:     versionDescription?: string;
24: }
````

## File: src/api/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolName.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         name: "get_current_temperature"
 7:  *     }
 8:  */
 9: export interface PostedUserDefinedToolName {
10:     /** Name applied to all versions of a particular Tool. */
11:     name: string;
12: }
````

## File: src/api/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolVersion.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\", \"kelvin\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
 7:  *         versionDescription: "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
 8:  *         fallbackContent: "Unable to fetch current weather.",
 9:  *         description: "This tool is for getting the current weather."
10:  *     }
11:  */
12: export interface PostedUserDefinedToolVersion {
13:     /** Text describing what the tool does. */
14:     description?: string;
15:     /** Text to use if the tool fails to generate content. */
16:     fallbackContent?: string;
17:     /** Stringified JSON defining the parameters used by this version of the Tool. */
18:     parameters: string;
19:     /** Description that is appended to a specific version of a Tool. */
20:     versionDescription?: string;
21: }
````

## File: src/api/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolVersionDescription.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         versionDescription: "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region."
 7:  *     }
 8:  */
 9: export interface PostedUserDefinedToolVersionDescription {
10:     /** Description that is appended to a specific version of a Tool. */
11:     versionDescription?: string;
12: }
````

## File: src/api/resources/empathicVoice/resources/tools/client/requests/ToolsListToolsRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         pageNumber: 0,
 7:  *         pageSize: 2
 8:  *     }
 9:  */
10: export interface ToolsListToolsRequest {
11:     /**
12:      * Specifies the page number to retrieve, enabling pagination.
13:      *
14:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
15:      */
16:     pageNumber?: number;
17:     /**
18:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
19:      *
20:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
21:      */
22:     pageSize?: number;
23:     /** By default, `restrict_to_most_recent` is set to true, returning only the latest version of each tool. To include all versions of each tool in the list, set `restrict_to_most_recent` to false. */
24:     restrictToMostRecent?: boolean;
25:     /** Filter to only include tools with name. */
26:     name?: string;
27: }
````

## File: src/api/resources/empathicVoice/resources/tools/client/requests/ToolsListToolVersionsRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {}
 6:  */
 7: export interface ToolsListToolVersionsRequest {
 8:     /**
 9:      * Specifies the page number to retrieve, enabling pagination.
10:      *
11:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
12:      */
13:     pageNumber?: number;
14:     /**
15:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
16:      *
17:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
18:      */
19:     pageSize?: number;
20:     /** By default, `restrict_to_most_recent` is set to true, returning only the latest version of each tool. To include all versions of each tool in the list, set `restrict_to_most_recent` to false. */
21:     restrictToMostRecent?: boolean;
22: }
````

## File: src/api/resources/empathicVoice/resources/tools/client/Client.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
  4: import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
  5: import { mergeHeaders } from "../../../../../../core/headers.js";
  6: import * as core from "../../../../../../core/index.js";
  7: import * as environments from "../../../../../../environments.js";
  8: import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
  9: import * as errors from "../../../../../../errors/index.js";
 10: import * as serializers from "../../../../../../serialization/index.js";
 11: import * as Hume from "../../../../../index.js";
 12: 
 13: export declare namespace ToolsClient {
 14:     export type Options = BaseClientOptions;
 15: 
 16:     export interface RequestOptions extends BaseRequestOptions {}
 17: }
 18: 
 19: export class ToolsClient {
 20:     protected readonly _options: NormalizedClientOptionsWithAuth<ToolsClient.Options>;
 21: 
 22:     constructor(options: ToolsClient.Options = {}) {
 23:         this._options = normalizeClientOptionsWithAuth(options);
 24:     }
 25: 
 26:     /**
 27:      * @param {Hume.empathicVoice.ToolsListToolsRequest} request
 28:      * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
 29:      *
 30:      * @throws {@link Hume.empathicVoice.BadRequestError}
 31:      *
 32:      * @example
 33:      *     await client.empathicVoice.tools.listTools({
 34:      *         pageNumber: 0,
 35:      *         pageSize: 2
 36:      *     })
 37:      */
 38:     public async listTools(
 39:         request: Hume.empathicVoice.ToolsListToolsRequest = {},
 40:         requestOptions?: ToolsClient.RequestOptions,
 41:     ): Promise<
 42:         core.Page<Hume.empathicVoice.ReturnUserDefinedTool | undefined, Hume.empathicVoice.ReturnPagedUserDefinedTools>
 43:     > {
 44:         const list = core.HttpResponsePromise.interceptFunction(
 45:             async (
 46:                 request: Hume.empathicVoice.ToolsListToolsRequest,
 47:             ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedUserDefinedTools>> => {
 48:                 const { pageNumber, pageSize, restrictToMostRecent, name } = request;
 49:                 const _queryParams: Record<string, unknown> = {
 50:                     page_number: pageNumber,
 51:                     page_size: pageSize,
 52:                     restrict_to_most_recent: restrictToMostRecent,
 53:                     name,
 54:                 };
 55:                 const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
 56:                 const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
 57:                     _authRequest.headers,
 58:                     this._options?.headers,
 59:                     requestOptions?.headers,
 60:                 );
 61:                 const _response = await (this._options.fetcher ?? core.fetcher)({
 62:                     url: core.url.join(
 63:                         (await core.Supplier.get(this._options.baseUrl)) ??
 64:                             ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
 65:                                 .base,
 66:                         "v0/evi/tools",
 67:                     ),
 68:                     method: "GET",
 69:                     headers: _headers,
 70:                     queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
 71:                     timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
 72:                     maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
 73:                     abortSignal: requestOptions?.abortSignal,
 74:                     fetchFn: this._options?.fetch,
 75:                     logging: this._options.logging,
 76:                 });
 77:                 if (_response.ok) {
 78:                     return {
 79:                         data: serializers.empathicVoice.ReturnPagedUserDefinedTools.parseOrThrow(_response.body, {
 80:                             unrecognizedObjectKeys: "passthrough",
 81:                             allowUnrecognizedUnionMembers: true,
 82:                             allowUnrecognizedEnumValues: true,
 83:                             skipValidation: true,
 84:                             breadcrumbsPrefix: ["response"],
 85:                         }),
 86:                         rawResponse: _response.rawResponse,
 87:                     };
 88:                 }
 89:                 if (_response.error.reason === "status-code") {
 90:                     switch (_response.error.statusCode) {
 91:                         case 400:
 92:                             throw new Hume.empathicVoice.BadRequestError(
 93:                                 serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
 94:                                     unrecognizedObjectKeys: "passthrough",
 95:                                     allowUnrecognizedUnionMembers: true,
 96:                                     allowUnrecognizedEnumValues: true,
 97:                                     skipValidation: true,
 98:                                     breadcrumbsPrefix: ["response"],
 99:                                 }),
100:                                 _response.rawResponse,
101:                             );
102:                         default:
103:                             throw new errors.HumeError({
104:                                 statusCode: _response.error.statusCode,
105:                                 body: _response.error.body,
106:                                 rawResponse: _response.rawResponse,
107:                             });
108:                     }
109:                 }
110:                 return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/tools");
111:             },
112:         );
113:         let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
114:         const dataWithRawResponse = await list(request).withRawResponse();
115:         return new core.Page<
116:             Hume.empathicVoice.ReturnUserDefinedTool | undefined,
117:             Hume.empathicVoice.ReturnPagedUserDefinedTools
118:         >({
119:             response: dataWithRawResponse.data,
120:             rawResponse: dataWithRawResponse.rawResponse,
121:             hasNextPage: (response) => (response?.toolsPage ?? []).length > 0,
122:             getItems: (response) => response?.toolsPage ?? [],
123:             loadPage: (_response) => {
124:                 _offset += 1;
125:                 return list(core.setObjectProperty(request, "pageNumber", _offset));
126:             },
127:         });
128:     }
129: 
130:     /**
131:      * @param {Hume.empathicVoice.PostedUserDefinedTool} request
132:      * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
133:      *
134:      * @throws {@link Hume.empathicVoice.BadRequestError}
135:      *
136:      * @example
137:      *     await client.empathicVoice.tools.createTool({
138:      *         name: "get_current_weather",
139:      *         parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
140:      *         versionDescription: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
141:      *         description: "This tool is for getting the current weather.",
142:      *         fallbackContent: "Unable to fetch current weather."
143:      *     })
144:      */
145:     public createTool(
146:         request: Hume.empathicVoice.PostedUserDefinedTool,
147:         requestOptions?: ToolsClient.RequestOptions,
148:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnUserDefinedTool | undefined> {
149:         return core.HttpResponsePromise.fromPromise(this.__createTool(request, requestOptions));
150:     }
151: 
152:     private async __createTool(
153:         request: Hume.empathicVoice.PostedUserDefinedTool,
154:         requestOptions?: ToolsClient.RequestOptions,
155:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnUserDefinedTool | undefined>> {
156:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
157:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
158:             _authRequest.headers,
159:             this._options?.headers,
160:             requestOptions?.headers,
161:         );
162:         const _response = await (this._options.fetcher ?? core.fetcher)({
163:             url: core.url.join(
164:                 (await core.Supplier.get(this._options.baseUrl)) ??
165:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
166:                 "v0/evi/tools",
167:             ),
168:             method: "POST",
169:             headers: _headers,
170:             contentType: "application/json",
171:             queryParameters: requestOptions?.queryParams,
172:             requestType: "json",
173:             body: serializers.empathicVoice.PostedUserDefinedTool.jsonOrThrow(request, {
174:                 unrecognizedObjectKeys: "strip",
175:                 omitUndefined: true,
176:             }),
177:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
178:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
179:             abortSignal: requestOptions?.abortSignal,
180:             fetchFn: this._options?.fetch,
181:             logging: this._options.logging,
182:         });
183:         if (_response.ok) {
184:             return {
185:                 data: serializers.empathicVoice.tools.createTool.Response.parseOrThrow(_response.body, {
186:                     unrecognizedObjectKeys: "passthrough",
187:                     allowUnrecognizedUnionMembers: true,
188:                     allowUnrecognizedEnumValues: true,
189:                     skipValidation: true,
190:                     breadcrumbsPrefix: ["response"],
191:                 }),
192:                 rawResponse: _response.rawResponse,
193:             };
194:         }
195: 
196:         if (_response.error.reason === "status-code") {
197:             switch (_response.error.statusCode) {
198:                 case 400:
199:                     throw new Hume.empathicVoice.BadRequestError(
200:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
201:                             unrecognizedObjectKeys: "passthrough",
202:                             allowUnrecognizedUnionMembers: true,
203:                             allowUnrecognizedEnumValues: true,
204:                             skipValidation: true,
205:                             breadcrumbsPrefix: ["response"],
206:                         }),
207:                         _response.rawResponse,
208:                     );
209:                 default:
210:                     throw new errors.HumeError({
211:                         statusCode: _response.error.statusCode,
212:                         body: _response.error.body,
213:                         rawResponse: _response.rawResponse,
214:                     });
215:             }
216:         }
217: 
218:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/tools");
219:     }
220: 
221:     /**
222:      * @param {string} id
223:      * @param {Hume.empathicVoice.ToolsListToolVersionsRequest} request
224:      * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
225:      *
226:      * @throws {@link Hume.empathicVoice.BadRequestError}
227:      *
228:      * @example
229:      *     await client.empathicVoice.tools.listToolVersions("00183a3f-79ba-413d-9f3b-609864268bea")
230:      */
231:     public async listToolVersions(
232:         id: string,
233:         request: Hume.empathicVoice.ToolsListToolVersionsRequest = {},
234:         requestOptions?: ToolsClient.RequestOptions,
235:     ): Promise<
236:         core.Page<Hume.empathicVoice.ReturnUserDefinedTool | undefined, Hume.empathicVoice.ReturnPagedUserDefinedTools>
237:     > {
238:         const list = core.HttpResponsePromise.interceptFunction(
239:             async (
240:                 request: Hume.empathicVoice.ToolsListToolVersionsRequest,
241:             ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedUserDefinedTools>> => {
242:                 const { pageNumber, pageSize, restrictToMostRecent } = request;
243:                 const _queryParams: Record<string, unknown> = {
244:                     page_number: pageNumber,
245:                     page_size: pageSize,
246:                     restrict_to_most_recent: restrictToMostRecent,
247:                 };
248:                 const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
249:                 const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
250:                     _authRequest.headers,
251:                     this._options?.headers,
252:                     requestOptions?.headers,
253:                 );
254:                 const _response = await (this._options.fetcher ?? core.fetcher)({
255:                     url: core.url.join(
256:                         (await core.Supplier.get(this._options.baseUrl)) ??
257:                             ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
258:                                 .base,
259:                         `v0/evi/tools/${core.url.encodePathParam(id)}`,
260:                     ),
261:                     method: "GET",
262:                     headers: _headers,
263:                     queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
264:                     timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
265:                     maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
266:                     abortSignal: requestOptions?.abortSignal,
267:                     fetchFn: this._options?.fetch,
268:                     logging: this._options.logging,
269:                 });
270:                 if (_response.ok) {
271:                     return {
272:                         data: serializers.empathicVoice.ReturnPagedUserDefinedTools.parseOrThrow(_response.body, {
273:                             unrecognizedObjectKeys: "passthrough",
274:                             allowUnrecognizedUnionMembers: true,
275:                             allowUnrecognizedEnumValues: true,
276:                             skipValidation: true,
277:                             breadcrumbsPrefix: ["response"],
278:                         }),
279:                         rawResponse: _response.rawResponse,
280:                     };
281:                 }
282:                 if (_response.error.reason === "status-code") {
283:                     switch (_response.error.statusCode) {
284:                         case 400:
285:                             throw new Hume.empathicVoice.BadRequestError(
286:                                 serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
287:                                     unrecognizedObjectKeys: "passthrough",
288:                                     allowUnrecognizedUnionMembers: true,
289:                                     allowUnrecognizedEnumValues: true,
290:                                     skipValidation: true,
291:                                     breadcrumbsPrefix: ["response"],
292:                                 }),
293:                                 _response.rawResponse,
294:                             );
295:                         default:
296:                             throw new errors.HumeError({
297:                                 statusCode: _response.error.statusCode,
298:                                 body: _response.error.body,
299:                                 rawResponse: _response.rawResponse,
300:                             });
301:                     }
302:                 }
303:                 return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/evi/tools/{id}");
304:             },
305:         );
306:         let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
307:         const dataWithRawResponse = await list(request).withRawResponse();
308:         return new core.Page<
309:             Hume.empathicVoice.ReturnUserDefinedTool | undefined,
310:             Hume.empathicVoice.ReturnPagedUserDefinedTools
311:         >({
312:             response: dataWithRawResponse.data,
313:             rawResponse: dataWithRawResponse.rawResponse,
314:             hasNextPage: (response) => (response?.toolsPage ?? []).length > 0,
315:             getItems: (response) => response?.toolsPage ?? [],
316:             loadPage: (_response) => {
317:                 _offset += 1;
318:                 return list(core.setObjectProperty(request, "pageNumber", _offset));
319:             },
320:         });
321:     }
322: 
323:     /**
324:      * @param {string} id - Identifier for a tool. Formatted as a UUID.
325:      * @param {Hume.empathicVoice.PostedUserDefinedToolVersion} request
326:      * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
327:      *
328:      * @throws {@link Hume.empathicVoice.BadRequestError}
329:      *
330:      * @example
331:      *     await client.empathicVoice.tools.createToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", {
332:      *         parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\", \"kelvin\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
333:      *         versionDescription: "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
334:      *         fallbackContent: "Unable to fetch current weather.",
335:      *         description: "This tool is for getting the current weather."
336:      *     })
337:      */
338:     public createToolVersion(
339:         id: string,
340:         request: Hume.empathicVoice.PostedUserDefinedToolVersion,
341:         requestOptions?: ToolsClient.RequestOptions,
342:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnUserDefinedTool | undefined> {
343:         return core.HttpResponsePromise.fromPromise(this.__createToolVersion(id, request, requestOptions));
344:     }
345: 
346:     private async __createToolVersion(
347:         id: string,
348:         request: Hume.empathicVoice.PostedUserDefinedToolVersion,
349:         requestOptions?: ToolsClient.RequestOptions,
350:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnUserDefinedTool | undefined>> {
351:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
352:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
353:             _authRequest.headers,
354:             this._options?.headers,
355:             requestOptions?.headers,
356:         );
357:         const _response = await (this._options.fetcher ?? core.fetcher)({
358:             url: core.url.join(
359:                 (await core.Supplier.get(this._options.baseUrl)) ??
360:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
361:                 `v0/evi/tools/${core.url.encodePathParam(id)}`,
362:             ),
363:             method: "POST",
364:             headers: _headers,
365:             contentType: "application/json",
366:             queryParameters: requestOptions?.queryParams,
367:             requestType: "json",
368:             body: serializers.empathicVoice.PostedUserDefinedToolVersion.jsonOrThrow(request, {
369:                 unrecognizedObjectKeys: "strip",
370:                 omitUndefined: true,
371:             }),
372:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
373:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
374:             abortSignal: requestOptions?.abortSignal,
375:             fetchFn: this._options?.fetch,
376:             logging: this._options.logging,
377:         });
378:         if (_response.ok) {
379:             return {
380:                 data: serializers.empathicVoice.tools.createToolVersion.Response.parseOrThrow(_response.body, {
381:                     unrecognizedObjectKeys: "passthrough",
382:                     allowUnrecognizedUnionMembers: true,
383:                     allowUnrecognizedEnumValues: true,
384:                     skipValidation: true,
385:                     breadcrumbsPrefix: ["response"],
386:                 }),
387:                 rawResponse: _response.rawResponse,
388:             };
389:         }
390: 
391:         if (_response.error.reason === "status-code") {
392:             switch (_response.error.statusCode) {
393:                 case 400:
394:                     throw new Hume.empathicVoice.BadRequestError(
395:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
396:                             unrecognizedObjectKeys: "passthrough",
397:                             allowUnrecognizedUnionMembers: true,
398:                             allowUnrecognizedEnumValues: true,
399:                             skipValidation: true,
400:                             breadcrumbsPrefix: ["response"],
401:                         }),
402:                         _response.rawResponse,
403:                     );
404:                 default:
405:                     throw new errors.HumeError({
406:                         statusCode: _response.error.statusCode,
407:                         body: _response.error.body,
408:                         rawResponse: _response.rawResponse,
409:                     });
410:             }
411:         }
412: 
413:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/evi/tools/{id}");
414:     }
415: 
416:     /**
417:      * @param {string} id - Identifier for a tool. Formatted as a UUID.
418:      * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
419:      *
420:      * @throws {@link Hume.empathicVoice.BadRequestError}
421:      *
422:      * @example
423:      *     await client.empathicVoice.tools.deleteTool("00183a3f-79ba-413d-9f3b-609864268bea")
424:      */
425:     public deleteTool(id: string, requestOptions?: ToolsClient.RequestOptions): core.HttpResponsePromise<void> {
426:         return core.HttpResponsePromise.fromPromise(this.__deleteTool(id, requestOptions));
427:     }
428: 
429:     private async __deleteTool(
430:         id: string,
431:         requestOptions?: ToolsClient.RequestOptions,
432:     ): Promise<core.WithRawResponse<void>> {
433:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
434:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
435:             _authRequest.headers,
436:             this._options?.headers,
437:             requestOptions?.headers,
438:         );
439:         const _response = await (this._options.fetcher ?? core.fetcher)({
440:             url: core.url.join(
441:                 (await core.Supplier.get(this._options.baseUrl)) ??
442:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
443:                 `v0/evi/tools/${core.url.encodePathParam(id)}`,
444:             ),
445:             method: "DELETE",
446:             headers: _headers,
447:             queryParameters: requestOptions?.queryParams,
448:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
449:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
450:             abortSignal: requestOptions?.abortSignal,
451:             fetchFn: this._options?.fetch,
452:             logging: this._options.logging,
453:         });
454:         if (_response.ok) {
455:             return { data: undefined, rawResponse: _response.rawResponse };
456:         }
457: 
458:         if (_response.error.reason === "status-code") {
459:             switch (_response.error.statusCode) {
460:                 case 400:
461:                     throw new Hume.empathicVoice.BadRequestError(
462:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
463:                             unrecognizedObjectKeys: "passthrough",
464:                             allowUnrecognizedUnionMembers: true,
465:                             allowUnrecognizedEnumValues: true,
466:                             skipValidation: true,
467:                             breadcrumbsPrefix: ["response"],
468:                         }),
469:                         _response.rawResponse,
470:                     );
471:                 default:
472:                     throw new errors.HumeError({
473:                         statusCode: _response.error.statusCode,
474:                         body: _response.error.body,
475:                         rawResponse: _response.rawResponse,
476:                     });
477:             }
478:         }
479: 
480:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v0/evi/tools/{id}");
481:     }
482: 
483:     /**
484:      * @param {string} id - Identifier for a tool. Formatted as a UUID.
485:      * @param {Hume.empathicVoice.PostedUserDefinedToolName} request
486:      * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
487:      *
488:      * @throws {@link Hume.empathicVoice.BadRequestError}
489:      *
490:      * @example
491:      *     await client.empathicVoice.tools.updateToolName("00183a3f-79ba-413d-9f3b-609864268bea", {
492:      *         name: "get_current_temperature"
493:      *     })
494:      */
495:     public updateToolName(
496:         id: string,
497:         request: Hume.empathicVoice.PostedUserDefinedToolName,
498:         requestOptions?: ToolsClient.RequestOptions,
499:     ): core.HttpResponsePromise<string> {
500:         return core.HttpResponsePromise.fromPromise(this.__updateToolName(id, request, requestOptions));
501:     }
502: 
503:     private async __updateToolName(
504:         id: string,
505:         request: Hume.empathicVoice.PostedUserDefinedToolName,
506:         requestOptions?: ToolsClient.RequestOptions,
507:     ): Promise<core.WithRawResponse<string>> {
508:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
509:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
510:             _authRequest.headers,
511:             this._options?.headers,
512:             requestOptions?.headers,
513:         );
514:         const _response = await (this._options.fetcher ?? core.fetcher)({
515:             url: core.url.join(
516:                 (await core.Supplier.get(this._options.baseUrl)) ??
517:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
518:                 `v0/evi/tools/${core.url.encodePathParam(id)}`,
519:             ),
520:             method: "PATCH",
521:             headers: _headers,
522:             contentType: "application/json",
523:             queryParameters: requestOptions?.queryParams,
524:             requestType: "json",
525:             body: serializers.empathicVoice.PostedUserDefinedToolName.jsonOrThrow(request, {
526:                 unrecognizedObjectKeys: "strip",
527:                 omitUndefined: true,
528:             }),
529:             responseType: "text",
530:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
531:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
532:             abortSignal: requestOptions?.abortSignal,
533:             fetchFn: this._options?.fetch,
534:             logging: this._options.logging,
535:         });
536:         if (_response.ok) {
537:             return { data: _response.body as string, rawResponse: _response.rawResponse };
538:         }
539: 
540:         if (_response.error.reason === "status-code") {
541:             switch (_response.error.statusCode) {
542:                 case 400:
543:                     throw new Hume.empathicVoice.BadRequestError(
544:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
545:                             unrecognizedObjectKeys: "passthrough",
546:                             allowUnrecognizedUnionMembers: true,
547:                             allowUnrecognizedEnumValues: true,
548:                             skipValidation: true,
549:                             breadcrumbsPrefix: ["response"],
550:                         }),
551:                         _response.rawResponse,
552:                     );
553:                 default:
554:                     throw new errors.HumeError({
555:                         statusCode: _response.error.statusCode,
556:                         body: _response.error.body,
557:                         rawResponse: _response.rawResponse,
558:                     });
559:             }
560:         }
561: 
562:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/v0/evi/tools/{id}");
563:     }
564: 
565:     /**
566:      * @param {string} id - Identifier for a tool. Formatted as a UUID.
567:      * @param {number} version - Version number for a tool. Version numbers should be integers.
568:      * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
569:      *
570:      * @throws {@link Hume.empathicVoice.BadRequestError}
571:      *
572:      * @example
573:      *     await client.empathicVoice.tools.getToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1)
574:      */
575:     public getToolVersion(
576:         id: string,
577:         version: number,
578:         requestOptions?: ToolsClient.RequestOptions,
579:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnUserDefinedTool | undefined> {
580:         return core.HttpResponsePromise.fromPromise(this.__getToolVersion(id, version, requestOptions));
581:     }
582: 
583:     private async __getToolVersion(
584:         id: string,
585:         version: number,
586:         requestOptions?: ToolsClient.RequestOptions,
587:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnUserDefinedTool | undefined>> {
588:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
589:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
590:             _authRequest.headers,
591:             this._options?.headers,
592:             requestOptions?.headers,
593:         );
594:         const _response = await (this._options.fetcher ?? core.fetcher)({
595:             url: core.url.join(
596:                 (await core.Supplier.get(this._options.baseUrl)) ??
597:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
598:                 `v0/evi/tools/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
599:             ),
600:             method: "GET",
601:             headers: _headers,
602:             queryParameters: requestOptions?.queryParams,
603:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
604:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
605:             abortSignal: requestOptions?.abortSignal,
606:             fetchFn: this._options?.fetch,
607:             logging: this._options.logging,
608:         });
609:         if (_response.ok) {
610:             return {
611:                 data: serializers.empathicVoice.tools.getToolVersion.Response.parseOrThrow(_response.body, {
612:                     unrecognizedObjectKeys: "passthrough",
613:                     allowUnrecognizedUnionMembers: true,
614:                     allowUnrecognizedEnumValues: true,
615:                     skipValidation: true,
616:                     breadcrumbsPrefix: ["response"],
617:                 }),
618:                 rawResponse: _response.rawResponse,
619:             };
620:         }
621: 
622:         if (_response.error.reason === "status-code") {
623:             switch (_response.error.statusCode) {
624:                 case 400:
625:                     throw new Hume.empathicVoice.BadRequestError(
626:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
627:                             unrecognizedObjectKeys: "passthrough",
628:                             allowUnrecognizedUnionMembers: true,
629:                             allowUnrecognizedEnumValues: true,
630:                             skipValidation: true,
631:                             breadcrumbsPrefix: ["response"],
632:                         }),
633:                         _response.rawResponse,
634:                     );
635:                 default:
636:                     throw new errors.HumeError({
637:                         statusCode: _response.error.statusCode,
638:                         body: _response.error.body,
639:                         rawResponse: _response.rawResponse,
640:                     });
641:             }
642:         }
643: 
644:         return handleNonStatusCodeError(
645:             _response.error,
646:             _response.rawResponse,
647:             "GET",
648:             "/v0/evi/tools/{id}/version/{version}",
649:         );
650:     }
651: 
652:     /**
653:      * @param {string} id - Identifier for a tool. Formatted as a UUID.
654:      * @param {number} version - Version number for a tool. Version numbers should be integers.
655:      * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
656:      *
657:      * @throws {@link Hume.empathicVoice.BadRequestError}
658:      *
659:      * @example
660:      *     await client.empathicVoice.tools.deleteToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1)
661:      */
662:     public deleteToolVersion(
663:         id: string,
664:         version: number,
665:         requestOptions?: ToolsClient.RequestOptions,
666:     ): core.HttpResponsePromise<void> {
667:         return core.HttpResponsePromise.fromPromise(this.__deleteToolVersion(id, version, requestOptions));
668:     }
669: 
670:     private async __deleteToolVersion(
671:         id: string,
672:         version: number,
673:         requestOptions?: ToolsClient.RequestOptions,
674:     ): Promise<core.WithRawResponse<void>> {
675:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
676:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
677:             _authRequest.headers,
678:             this._options?.headers,
679:             requestOptions?.headers,
680:         );
681:         const _response = await (this._options.fetcher ?? core.fetcher)({
682:             url: core.url.join(
683:                 (await core.Supplier.get(this._options.baseUrl)) ??
684:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
685:                 `v0/evi/tools/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
686:             ),
687:             method: "DELETE",
688:             headers: _headers,
689:             queryParameters: requestOptions?.queryParams,
690:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
691:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
692:             abortSignal: requestOptions?.abortSignal,
693:             fetchFn: this._options?.fetch,
694:             logging: this._options.logging,
695:         });
696:         if (_response.ok) {
697:             return { data: undefined, rawResponse: _response.rawResponse };
698:         }
699: 
700:         if (_response.error.reason === "status-code") {
701:             switch (_response.error.statusCode) {
702:                 case 400:
703:                     throw new Hume.empathicVoice.BadRequestError(
704:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
705:                             unrecognizedObjectKeys: "passthrough",
706:                             allowUnrecognizedUnionMembers: true,
707:                             allowUnrecognizedEnumValues: true,
708:                             skipValidation: true,
709:                             breadcrumbsPrefix: ["response"],
710:                         }),
711:                         _response.rawResponse,
712:                     );
713:                 default:
714:                     throw new errors.HumeError({
715:                         statusCode: _response.error.statusCode,
716:                         body: _response.error.body,
717:                         rawResponse: _response.rawResponse,
718:                     });
719:             }
720:         }
721: 
722:         return handleNonStatusCodeError(
723:             _response.error,
724:             _response.rawResponse,
725:             "DELETE",
726:             "/v0/evi/tools/{id}/version/{version}",
727:         );
728:     }
729: 
730:     /**
731:      * @param {string} id - Identifier for a tool. Formatted as a UUID.
732:      * @param {number} version - Version number for a tool. Version numbers should be integers.
733:      * @param {Hume.empathicVoice.PostedUserDefinedToolVersionDescription} request
734:      * @param {ToolsClient.RequestOptions} requestOptions - Request-specific configuration.
735:      *
736:      * @throws {@link Hume.empathicVoice.BadRequestError}
737:      *
738:      * @example
739:      *     await client.empathicVoice.tools.updateToolDescription("00183a3f-79ba-413d-9f3b-609864268bea", 1, {
740:      *         versionDescription: "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region."
741:      *     })
742:      */
743:     public updateToolDescription(
744:         id: string,
745:         version: number,
746:         request: Hume.empathicVoice.PostedUserDefinedToolVersionDescription = {},
747:         requestOptions?: ToolsClient.RequestOptions,
748:     ): core.HttpResponsePromise<Hume.empathicVoice.ReturnUserDefinedTool | undefined> {
749:         return core.HttpResponsePromise.fromPromise(this.__updateToolDescription(id, version, request, requestOptions));
750:     }
751: 
752:     private async __updateToolDescription(
753:         id: string,
754:         version: number,
755:         request: Hume.empathicVoice.PostedUserDefinedToolVersionDescription = {},
756:         requestOptions?: ToolsClient.RequestOptions,
757:     ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnUserDefinedTool | undefined>> {
758:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
759:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
760:             _authRequest.headers,
761:             this._options?.headers,
762:             requestOptions?.headers,
763:         );
764:         const _response = await (this._options.fetcher ?? core.fetcher)({
765:             url: core.url.join(
766:                 (await core.Supplier.get(this._options.baseUrl)) ??
767:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
768:                 `v0/evi/tools/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
769:             ),
770:             method: "PATCH",
771:             headers: _headers,
772:             contentType: "application/json",
773:             queryParameters: requestOptions?.queryParams,
774:             requestType: "json",
775:             body: serializers.empathicVoice.PostedUserDefinedToolVersionDescription.jsonOrThrow(request, {
776:                 unrecognizedObjectKeys: "strip",
777:                 omitUndefined: true,
778:             }),
779:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
780:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
781:             abortSignal: requestOptions?.abortSignal,
782:             fetchFn: this._options?.fetch,
783:             logging: this._options.logging,
784:         });
785:         if (_response.ok) {
786:             return {
787:                 data: serializers.empathicVoice.tools.updateToolDescription.Response.parseOrThrow(_response.body, {
788:                     unrecognizedObjectKeys: "passthrough",
789:                     allowUnrecognizedUnionMembers: true,
790:                     allowUnrecognizedEnumValues: true,
791:                     skipValidation: true,
792:                     breadcrumbsPrefix: ["response"],
793:                 }),
794:                 rawResponse: _response.rawResponse,
795:             };
796:         }
797: 
798:         if (_response.error.reason === "status-code") {
799:             switch (_response.error.statusCode) {
800:                 case 400:
801:                     throw new Hume.empathicVoice.BadRequestError(
802:                         serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
803:                             unrecognizedObjectKeys: "passthrough",
804:                             allowUnrecognizedUnionMembers: true,
805:                             allowUnrecognizedEnumValues: true,
806:                             skipValidation: true,
807:                             breadcrumbsPrefix: ["response"],
808:                         }),
809:                         _response.rawResponse,
810:                     );
811:                 default:
812:                     throw new errors.HumeError({
813:                         statusCode: _response.error.statusCode,
814:                         body: _response.error.body,
815:                         rawResponse: _response.rawResponse,
816:                     });
817:             }
818:         }
819: 
820:         return handleNonStatusCodeError(
821:             _response.error,
822:             _response.rawResponse,
823:             "PATCH",
824:             "/v0/evi/tools/{id}/version/{version}",
825:         );
826:     }
827: }
````

## File: src/api/resources/empathicVoice/resources/tools/client/index.ts
````typescript
1: export * from "./requests/index.js";
````

## File: src/api/resources/empathicVoice/resources/tools/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/api/resources/empathicVoice/resources/index.ts
````typescript
 1: export * as chat from "./chat/index.js";
 2: export * from "./chat/types/index.js";
 3: export * from "./chatGroups/client/requests/index.js";
 4: export * as chatGroups from "./chatGroups/index.js";
 5: export * from "./chats/client/requests/index.js";
 6: export * as chats from "./chats/index.js";
 7: export * from "./configs/client/requests/index.js";
 8: export * as configs from "./configs/index.js";
 9: export * as controlPlane from "./controlPlane/index.js";
10: export * from "./prompts/client/requests/index.js";
11: export * as prompts from "./prompts/index.js";
12: export * from "./tools/client/requests/index.js";
13: export * as tools from "./tools/index.js";
````

## File: src/api/resources/empathicVoice/types/AssistantEnd.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * When provided, the output is an assistant end message.
 5:  */
 6: export interface AssistantEnd {
 7:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
 8:     customSessionId?: string;
 9:     /**
10:      * The type of message sent through the socket; for an Assistant End message, this must be `assistant_end`.
11:      *
12:      * This message indicates the conclusion of the assistant's response, signaling that the assistant has finished speaking for the current conversational turn.
13:      */
14:     type: "assistant_end";
15: }
````

## File: src/api/resources/empathicVoice/types/AssistantInput.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * When provided, the input is spoken by EVI.
 5:  */
 6: export interface AssistantInput {
 7:     customSessionId?: string;
 8:     /**
 9:      * Assistant text to synthesize into spoken audio and insert into the conversation.
10:      *
11:      * EVI uses this text to generate spoken audio using our proprietary expressive text-to-speech model. Our model adds appropriate emotional inflections and tones to the text based on the user's expressions and the context of the conversation. The synthesized audio is streamed back to the user as an [Assistant Message](/reference/empathic-voice-interface-evi/chat/chat#receive.Assistant%20Message.type).
12:      */
13:     text: string;
14:     /** The type of message sent through the socket; must be `assistant_input` for our server to correctly identify and process it as an Assistant Input message. */
15:     type: "assistant_input";
16: }
````

## File: src/api/resources/empathicVoice/types/AssistantMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * When provided, the output is an assistant message.
 7:  */
 8: export interface AssistantMessage {
 9:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
10:     customSessionId?: string;
11:     /** Indicates if this message was inserted into the conversation as text from an [Assistant Input message](/reference/empathic-voice-interface-evi/chat/chat#send.Assistant%20Input.text). */
12:     fromText: boolean;
13:     /** ID of the assistant message. Allows the Assistant Message to be tracked and referenced. */
14:     id?: string;
15:     /** Indicates if this message is a quick response or not. */
16:     isQuickResponse: boolean;
17:     /** Detected language of the message text. */
18:     language?: string;
19:     /** Transcript of the message. */
20:     message: Hume.empathicVoice.ChatMessage;
21:     /** Inference model results. */
22:     models: Hume.empathicVoice.Inference;
23:     /**
24:      * The type of message sent through the socket; for an Assistant Message, this must be `assistant_message`.
25:      *
26:      * This message contains both a transcript of the assistant's response and the expression measurement predictions of the assistant's audio output.
27:      */
28:     type: "assistant_message";
29: }
````

## File: src/api/resources/empathicVoice/types/AssistantProsody.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * When provided, the output is an Assistant Prosody message.
 7:  */
 8: export interface AssistantProsody {
 9:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
10:     customSessionId?: string;
11:     /** Unique identifier for the segment. */
12:     id?: string;
13:     /** Inference model results. */
14:     models: Hume.empathicVoice.Inference;
15:     /**
16:      * The type of message sent through the socket; for an Assistant Prosody message, this must be `assistant_PROSODY`.
17:      *
18:      * This message the expression measurement predictions of the assistant's audio output.
19:      */
20:     type: "assistant_prosody";
21: }
````

## File: src/api/resources/empathicVoice/types/AudioConfiguration.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface AudioConfiguration {
 6:     /** Number of audio channels. */
 7:     channels: number;
 8:     /** Optional codec information. */
 9:     codec?: string;
10:     /** Encoding format of the audio input, such as `linear16`. */
11:     encoding: Hume.empathicVoice.Encoding;
12:     /** Audio sample rate. Number of samples per second in the audio input, measured in Hertz. */
13:     sampleRate: number;
14: }
````

## File: src/api/resources/empathicVoice/types/AudioInput.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * When provided, the input is audio.
 5:  */
 6: export interface AudioInput {
 7:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
 8:     customSessionId?: string;
 9:     /**
10:      * Base64 encoded audio input to insert into the conversation.
11:      *
12:      * The content of an Audio Input message is treated as the user's speech to EVI and must be streamed continuously. Pre-recorded audio files are not supported.
13:      *
14:      * For optimal transcription quality, the audio data should be transmitted in small chunks.
15:      *
16:      * Hume recommends streaming audio with a buffer window of 20 milliseconds (ms), or 100 milliseconds (ms) for web applications.
17:      */
18:     data: string;
19:     /**
20:      * The type of message sent through the socket; must be `audio_input` for our server to correctly identify and process it as an Audio Input message.
21:      *
22:      * This message is used for sending audio input data to EVI for processing and expression measurement. Audio data should be sent as a continuous stream, encoded in Base64.
23:      */
24:     type: "audio_input";
25: }
````

## File: src/api/resources/empathicVoice/types/AudioOutput.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * The type of message sent through the socket; for an Audio Output message, this must be `audio_output`.
 5:  */
 6: export interface AudioOutput {
 7:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
 8:     customSessionId?: string;
 9:     /** Base64 encoded audio output. This encoded audio is transmitted to the client, where it can be decoded and played back as part of the user interaction. */
10:     data: string;
11:     /** ID of the audio output. Allows the Audio Output message to be tracked and referenced. */
12:     id: string;
13:     /** Index of the chunk of audio relative to the whole audio segment. */
14:     index: number;
15:     type: "audio_output";
16: }
````

## File: src/api/resources/empathicVoice/types/BuiltInTool.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const BuiltInTool = {
4:     WebSearch: "web_search",
5:     HangUp: "hang_up",
6: } as const;
7: export type BuiltInTool = (typeof BuiltInTool)[keyof typeof BuiltInTool];
````

## File: src/api/resources/empathicVoice/types/BuiltinToolConfig.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: export interface BuiltinToolConfig {
6:     /** Optional text passed to the supplemental LLM if the tool call fails. The LLM then uses this text to generate a response back to the user, ensuring continuity in the conversation. */
7:     fallbackContent?: string;
8:     name: Hume.empathicVoice.BuiltInTool;
9: }
````

## File: src/api/resources/empathicVoice/types/ChatMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface ChatMessage {
 6:     /** Transcript of the message. */
 7:     content?: string;
 8:     /** Role of who is providing the message. */
 9:     role: Hume.empathicVoice.Role;
10:     /** Function call name and arguments. */
11:     toolCall?: Hume.empathicVoice.ToolCallMessage;
12:     /** Function call response from client. */
13:     toolResult?: Hume.empathicVoice.ChatMessageToolResult;
14: }
````

## File: src/api/resources/empathicVoice/types/ChatMessageToolResult.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: /**
6:  * Function call response from client.
7:  */
8: export type ChatMessageToolResult = Hume.empathicVoice.ToolResponseMessage | Hume.empathicVoice.ToolErrorMessage;
````

## File: src/api/resources/empathicVoice/types/ChatMetadata.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * When provided, the output is a chat metadata message.
 5:  */
 6: export interface ChatMetadata {
 7:     /**
 8:      * ID of the Chat Group.
 9:      *
10:      * Used to resume a Chat when passed in the [resumed_chat_group_id](/reference/empathic-voice-interface-evi/chat/chat#request.query.resumed_chat_group_id) query parameter of a subsequent connection request. This allows EVI to continue the conversation from where it left off within the Chat Group.
11:      *
12:      * Learn more about [supporting chat resumability](/docs/empathic-voice-interface-evi/faq#does-evi-support-chat-resumability) from the EVI FAQ.
13:      */
14:     chatGroupId: string;
15:     /** ID of the Chat session. Allows the Chat session to be tracked and referenced. */
16:     chatId: string;
17:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
18:     customSessionId?: string;
19:     /** ID of the initiating request. */
20:     requestId?: string;
21:     /**
22:      * The type of message sent through the socket; for a Chat Metadata message, this must be `chat_metadata`.
23:      *
24:      * The Chat Metadata message is the first message you receive after establishing a connection with EVI and contains important identifiers for the current Chat session.
25:      */
26:     type: "chat_metadata";
27: }
````

## File: src/api/resources/empathicVoice/types/ConnectSessionSettings.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface ConnectSessionSettings {
 6:     /**
 7:      * Configuration details for the audio input used during the session. Ensures the audio is being correctly set up for processing.
 8:      *
 9:      * This optional field is only required when the audio input is encoded in PCM Linear 16 (16-bit, little-endian, signed PCM WAV data). For detailed instructions on how to configure session settings for PCM Linear 16 audio, please refer to the [Session Settings section](/docs/empathic-voice-interface-evi/configuration#session-settings) on the EVI Configuration page.
10:      */
11:     audio?: Hume.empathicVoice.ConnectSessionSettingsAudio;
12:     /**
13:      * Allows developers to inject additional context into the conversation, which is appended to the end of user messages for the session.
14:      *
15:      * When included in a Session Settings message, the provided context can be used to remind the LLM of its role in every user message, prevent it from forgetting important details, or add new relevant information to the conversation.
16:      *
17:      * Set to `null` to disable context injection.
18:      */
19:     context?: Hume.empathicVoice.ConnectSessionSettingsContext;
20:     /**
21:      * Unique identifier for the session. Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions.
22:      *
23:      * If included, the response sent from Hume to your backend will include this ID. This allows you to correlate frontend users with their incoming messages.
24:      *
25:      * It is recommended to pass a `custom_session_id` if you are using a Custom Language Model. Please see our guide to [using a custom language model](/docs/empathic-voice-interface-evi/custom-language-model) with EVI to learn more.
26:      */
27:     customSessionId?: string;
28:     eventLimit?: number;
29:     /**
30:      * Third party API key for the supplemental language model.
31:      *
32:      * When provided, EVI will use this key instead of Hume's API key for the supplemental LLM. This allows you to bypass rate limits and utilize your own API key as needed.
33:      */
34:     languageModelApiKey?: string;
35:     /**
36:      * Instructions used to shape EVI's behavior, responses, and style for the session.
37:      *
38:      * When included in a Session Settings message, the provided Prompt overrides the existing one specified in the EVI configuration. If no Prompt was defined in the configuration, this Prompt will be the one used for the session.
39:      *
40:      * You can use the Prompt to define a specific goal or role for EVI, specifying how it should act or what it should focus on during the conversation. For example, EVI can be instructed to act as a customer support representative, a fitness coach, or a travel advisor, each with its own set of behaviors and response styles.
41:      *
42:      * For help writing a system prompt, see our [Prompting Guide](/docs/empathic-voice-interface-evi/prompting).
43:      */
44:     systemPrompt?: string;
45:     voiceId?: string;
46:     /**
47:      * This field allows you to assign values to dynamic variables referenced in your system prompt.
48:      *
49:      * Each key represents the variable name, and the corresponding value is the specific content you wish to assign to that variable within the session. While the values for variables can be strings, numbers, or booleans, the value will ultimately be converted to a string when injected into your system prompt.
50:      *
51:      * When used in query parameters, specify each variable using bracket notation: `session_settings[variables][key]=value`. For example: `session_settings[variables][name]=John&session_settings[variables][age]=30`.
52:      *
53:      * Using this field, you can personalize responses based on session-specific details. For more guidance, see our [guide on using dynamic variables](/docs/speech-to-speech-evi/features/dynamic-variables).
54:      */
55:     variables?: Record<string, Hume.empathicVoice.ConnectSessionSettingsVariablesValue>;
56: }
````

## File: src/api/resources/empathicVoice/types/ConnectSessionSettingsAudio.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * Configuration details for the audio input used during the session. Ensures the audio is being correctly set up for processing.
 7:  *
 8:  * This optional field is only required when the audio input is encoded in PCM Linear 16 (16-bit, little-endian, signed PCM WAV data). For detailed instructions on how to configure session settings for PCM Linear 16 audio, please refer to the [Session Settings section](/docs/empathic-voice-interface-evi/configuration#session-settings) on the EVI Configuration page.
 9:  */
10: export interface ConnectSessionSettingsAudio {
11:     /** Number of audio channels. */
12:     channels?: number;
13:     /** Encoding format of the audio input, such as `linear16`. */
14:     encoding?: Hume.empathicVoice.Encoding;
15:     /** Audio sample rate. Number of samples per second in the audio input, measured in Hertz. */
16:     sampleRate?: number;
17: }
````

## File: src/api/resources/empathicVoice/types/ConnectSessionSettingsContext.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * Allows developers to inject additional context into the conversation, which is appended to the end of user messages for the session.
 7:  *
 8:  * When included in a Session Settings message, the provided context can be used to remind the LLM of its role in every user message, prevent it from forgetting important details, or add new relevant information to the conversation.
 9:  *
10:  * Set to `null` to disable context injection.
11:  */
12: export interface ConnectSessionSettingsContext {
13:     /**
14:      * The context to be injected into the conversation. Helps inform the LLM's response by providing relevant information about the ongoing conversation.
15:      *
16:      * This text will be appended to the end of user messages based on the chosen persistence level. For example, if you want to remind EVI of its role as a helpful weather assistant, the context you insert will be appended to the end of user messages as `{Context: You are a helpful weather assistant}`.
17:      */
18:     text?: string;
19:     /**
20:      * The persistence level of the injected context. Specifies how long the injected context will remain active in the session.
21:      *
22:      * There are three possible context types:
23:      *
24:      * - **Persistent**: The context is appended to all user messages for the duration of the session.
25:      *
26:      * - **Temporary**: The context is appended only to the next user message.
27:      *
28:      *  - **Editable**: The original context is updated to reflect the new context.
29:      *
30:      *  If the type is not specified, it will default to `temporary`.
31:      */
32:     type?: Hume.empathicVoice.ContextType;
33: }
````

## File: src/api/resources/empathicVoice/types/ConnectSessionSettingsVariablesValue.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type ConnectSessionSettingsVariablesValue = string | number | boolean;
````

## File: src/api/resources/empathicVoice/types/Context.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface Context {
 6:     /**
 7:      * The context to be injected into the conversation. Helps inform the LLM's response by providing relevant information about the ongoing conversation.
 8:      *
 9:      * This text will be appended to the end of user messages based on the chosen persistence level. For example, if you want to remind EVI of its role as a helpful weather assistant, the context you insert will be appended to the end of user messages as `{Context: You are a helpful weather assistant}`.
10:      */
11:     text: string;
12:     /**
13:      * The persistence level of the injected context. Specifies how long the injected context will remain active in the session.
14:      *
15:      * There are three possible context types:
16:      *
17:      * - **Persistent**: The context is appended to all user messages for the duration of the session.
18:      *
19:      * - **Temporary**: The context is appended only to the next user message.
20:      *
21:      *  - **Editable**: The original context is updated to reflect the new context.
22:      *
23:      *  If the type is not specified, it will default to `temporary`.
24:      */
25:     type?: Hume.empathicVoice.ContextType;
26: }
````

## File: src/api/resources/empathicVoice/types/ContextType.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ContextType = {
4:     Persistent: "persistent",
5:     Temporary: "temporary",
6: } as const;
7: export type ContextType = (typeof ContextType)[keyof typeof ContextType];
````

## File: src/api/resources/empathicVoice/types/ControlPlanePublishEvent.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export type ControlPlanePublishEvent =
 6:     | Hume.empathicVoice.SessionSettings
 7:     | Hume.empathicVoice.UserInput
 8:     | Hume.empathicVoice.AssistantInput
 9:     | Hume.empathicVoice.ToolResponseMessage
10:     | Hume.empathicVoice.ToolErrorMessage
11:     | Hume.empathicVoice.PauseAssistantMessage
12:     | Hume.empathicVoice.ResumeAssistantMessage;
````

## File: src/api/resources/empathicVoice/types/EmotionScores.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export interface EmotionScores {
 4:     admiration: number;
 5:     adoration: number;
 6:     aestheticAppreciation: number;
 7:     amusement: number;
 8:     anger: number;
 9:     anxiety: number;
10:     awe: number;
11:     awkwardness: number;
12:     boredom: number;
13:     calmness: number;
14:     concentration: number;
15:     confusion: number;
16:     contemplation: number;
17:     contempt: number;
18:     contentment: number;
19:     craving: number;
20:     desire: number;
21:     determination: number;
22:     disappointment: number;
23:     disgust: number;
24:     distress: number;
25:     doubt: number;
26:     ecstasy: number;
27:     embarrassment: number;
28:     empathicPain: number;
29:     entrancement: number;
30:     envy: number;
31:     excitement: number;
32:     fear: number;
33:     guilt: number;
34:     horror: number;
35:     interest: number;
36:     joy: number;
37:     love: number;
38:     nostalgia: number;
39:     pain: number;
40:     pride: number;
41:     realization: number;
42:     relief: number;
43:     romance: number;
44:     sadness: number;
45:     satisfaction: number;
46:     shame: number;
47:     surpriseNegative: number;
48:     surprisePositive: number;
49:     sympathy: number;
50:     tiredness: number;
51:     triumph: number;
52: }
````

## File: src/api/resources/empathicVoice/types/Encoding.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type Encoding = "linear16";
````

## File: src/api/resources/empathicVoice/types/ErrorLevel.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type ErrorLevel = "warn";
````

## File: src/api/resources/empathicVoice/types/ErrorResponse.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface ErrorResponse {
4:     code?: string;
5:     error?: string;
6:     message?: string;
7: }
````

## File: src/api/resources/empathicVoice/types/HttpValidationError.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: export interface HttpValidationError {
6:     detail?: Hume.empathicVoice.ValidationError[];
7: }
````

## File: src/api/resources/empathicVoice/types/index.ts
````typescript
  1: export * from "./AssistantEnd.js";
  2: export * from "./AssistantInput.js";
  3: export * from "./AssistantMessage.js";
  4: export * from "./AssistantProsody.js";
  5: export * from "./AudioConfiguration.js";
  6: export * from "./AudioInput.js";
  7: export * from "./AudioOutput.js";
  8: export * from "./BuiltInTool.js";
  9: export * from "./BuiltinToolConfig.js";
 10: export * from "./ChatMessage.js";
 11: export * from "./ChatMessageToolResult.js";
 12: export * from "./ChatMetadata.js";
 13: export * from "./ConnectSessionSettings.js";
 14: export * from "./ConnectSessionSettingsAudio.js";
 15: export * from "./ConnectSessionSettingsContext.js";
 16: export * from "./ConnectSessionSettingsVariablesValue.js";
 17: export * from "./Context.js";
 18: export * from "./ContextType.js";
 19: export * from "./ControlPlanePublishEvent.js";
 20: export * from "./EmotionScores.js";
 21: export * from "./Encoding.js";
 22: export * from "./ErrorLevel.js";
 23: export * from "./ErrorResponse.js";
 24: export * from "./HttpValidationError.js";
 25: export * from "./Inference.js";
 26: export * from "./JsonMessage.js";
 27: export * from "./LanguageModelType.js";
 28: export * from "./MillisecondInterval.js";
 29: export * from "./ModelProviderEnum.js";
 30: export * from "./PauseAssistantMessage.js";
 31: export * from "./PostedBuiltinTool.js";
 32: export * from "./PostedBuiltinToolName.js";
 33: export * from "./PostedConfigPromptSpec.js";
 34: export * from "./PostedEllmModel.js";
 35: export * from "./PostedEventMessageSpec.js";
 36: export * from "./PostedEventMessageSpecs.js";
 37: export * from "./PostedLanguageModel.js";
 38: export * from "./PostedNudgeSpec.js";
 39: export * from "./PostedTimeoutSpec.js";
 40: export * from "./PostedTimeoutSpecs.js";
 41: export * from "./PostedTimeoutSpecsInactivity.js";
 42: export * from "./PostedTimeoutSpecsMaxDuration.js";
 43: export * from "./PostedUserDefinedToolSpec.js";
 44: export * from "./PostedWebhookEventType.js";
 45: export * from "./PostedWebhookSpec.js";
 46: export * from "./ProsodyInference.js";
 47: export * from "./ResumeAssistantMessage.js";
 48: export * from "./ReturnBuiltinTool.js";
 49: export * from "./ReturnBuiltinToolToolType.js";
 50: export * from "./ReturnChat.js";
 51: export * from "./ReturnChatAudioReconstruction.js";
 52: export * from "./ReturnChatAudioReconstructionStatus.js";
 53: export * from "./ReturnChatEvent.js";
 54: export * from "./ReturnChatEventRole.js";
 55: export * from "./ReturnChatEventType.js";
 56: export * from "./ReturnChatGroup.js";
 57: export * from "./ReturnChatGroupPagedAudioReconstructions.js";
 58: export * from "./ReturnChatGroupPagedAudioReconstructionsPaginationDirection.js";
 59: export * from "./ReturnChatGroupPagedChats.js";
 60: export * from "./ReturnChatGroupPagedChatsPaginationDirection.js";
 61: export * from "./ReturnChatGroupPagedEvents.js";
 62: export * from "./ReturnChatGroupPagedEventsPaginationDirection.js";
 63: export * from "./ReturnChatPagedEvents.js";
 64: export * from "./ReturnChatPagedEventsPaginationDirection.js";
 65: export * from "./ReturnChatPagedEventsStatus.js";
 66: export * from "./ReturnChatStatus.js";
 67: export * from "./ReturnConfig.js";
 68: export * from "./ReturnConfigSpec.js";
 69: export * from "./ReturnEllmModel.js";
 70: export * from "./ReturnEventMessageSpec.js";
 71: export * from "./ReturnEventMessageSpecs.js";
 72: export * from "./ReturnLanguageModel.js";
 73: export * from "./ReturnNudgeSpec.js";
 74: export * from "./ReturnPagedChatGroups.js";
 75: export * from "./ReturnPagedChatGroupsPaginationDirection.js";
 76: export * from "./ReturnPagedChats.js";
 77: export * from "./ReturnPagedChatsPaginationDirection.js";
 78: export * from "./ReturnPagedConfigs.js";
 79: export * from "./ReturnPagedPrompts.js";
 80: export * from "./ReturnPagedUserDefinedTools.js";
 81: export * from "./ReturnPrompt.js";
 82: export * from "./ReturnPromptVersionType.js";
 83: export * from "./ReturnTimeoutSpec.js";
 84: export * from "./ReturnTimeoutSpecs.js";
 85: export * from "./ReturnUserDefinedTool.js";
 86: export * from "./ReturnUserDefinedToolToolType.js";
 87: export * from "./ReturnUserDefinedToolVersionType.js";
 88: export * from "./ReturnVoice.js";
 89: export * from "./ReturnWebhookEventType.js";
 90: export * from "./ReturnWebhookSpec.js";
 91: export * from "./Role.js";
 92: export * from "./SessionSettings.js";
 93: export * from "./SessionSettingsVariablesValue.js";
 94: export * from "./SubscribeEvent.js";
 95: export * from "./Tool.js";
 96: export * from "./ToolCallMessage.js";
 97: export * from "./ToolErrorMessage.js";
 98: export * from "./ToolResponseMessage.js";
 99: export * from "./ToolType.js";
100: export * from "./UserInput.js";
101: export * from "./UserInterruption.js";
102: export * from "./UserMessage.js";
103: export * from "./ValidationError.js";
104: export * from "./ValidationErrorLocItem.js";
105: export * from "./VoiceId.js";
106: export * from "./VoiceName.js";
107: export * from "./VoiceProvider.js";
108: export * from "./VoiceRef.js";
109: export * from "./WebhookEvent.js";
110: export * from "./WebhookEventBase.js";
111: export * from "./WebhookEventChatEnded.js";
112: export * from "./WebhookEventChatStarted.js";
113: export * from "./WebhookEventChatStartType.js";
114: export * from "./WebhookEventChatStatus.js";
115: export * from "./WebhookEventToolCall.js";
116: export * from "./WebSocketError.js";
````

## File: src/api/resources/empathicVoice/types/Inference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface Inference {
 6:     /**
 7:      * Prosody model inference results.
 8:      *
 9:      * EVI uses the prosody model to measure 48 emotions related to speech and vocal characteristics within a given expression.
10:      */
11:     prosody?: Hume.empathicVoice.ProsodyInference;
12: }
````

## File: src/api/resources/empathicVoice/types/JsonMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export type JsonMessage =
 6:     | Hume.empathicVoice.AssistantEnd
 7:     | Hume.empathicVoice.AssistantMessage
 8:     | Hume.empathicVoice.AssistantProsody
 9:     | Hume.empathicVoice.ChatMetadata
10:     | Hume.empathicVoice.WebSocketError
11:     | Hume.empathicVoice.UserInterruption
12:     | Hume.empathicVoice.UserMessage
13:     | Hume.empathicVoice.ToolCallMessage
14:     | Hume.empathicVoice.ToolResponseMessage
15:     | Hume.empathicVoice.ToolErrorMessage
16:     | Hume.empathicVoice.SessionSettings;
````

## File: src/api/resources/empathicVoice/types/LanguageModelType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export const LanguageModelType = {
 4:     Claude37SonnetLatest: "claude-3-7-sonnet-latest",
 5:     Claude35SonnetLatest: "claude-3-5-sonnet-latest",
 6:     Claude35HaikuLatest: "claude-3-5-haiku-latest",
 7:     Claude35Sonnet20240620: "claude-3-5-sonnet-20240620",
 8:     Claude3Opus20240229: "claude-3-opus-20240229",
 9:     Claude3Sonnet20240229: "claude-3-sonnet-20240229",
10:     Claude3Haiku20240307: "claude-3-haiku-20240307",
11:     ClaudeSonnet420250514: "claude-sonnet-4-20250514",
12:     ClaudeSonnet4520250929: "claude-sonnet-4-5-20250929",
13:     ClaudeHaiku4520251001: "claude-haiku-4-5-20251001",
14:     UsAnthropicClaude35Haiku20241022V10: "us.anthropic.claude-3-5-haiku-20241022-v1:0",
15:     UsAnthropicClaude35Sonnet20240620V10: "us.anthropic.claude-3-5-sonnet-20240620-v1:0",
16:     UsAnthropicClaude3Haiku20240307V10: "us.anthropic.claude-3-haiku-20240307-v1:0",
17:     GptOss120B: "gpt-oss-120b",
18:     Qwen3235Ba22B: "qwen-3-235b-a22b",
19:     Qwen3235Ba22BInstruct2507: "qwen-3-235b-a22b-instruct-2507",
20:     Qwen3235Ba22BThinking2507: "qwen-3-235b-a22b-thinking-2507",
21:     Gemini15Pro: "gemini-1.5-pro",
22:     Gemini15Flash: "gemini-1.5-flash",
23:     Gemini15Pro002: "gemini-1.5-pro-002",
24:     Gemini15Flash002: "gemini-1.5-flash-002",
25:     Gemini20Flash: "gemini-2.0-flash",
26:     Gemini25Flash: "gemini-2.5-flash",
27:     Gemini25FlashPreview0417: "gemini-2.5-flash-preview-04-17",
28:     Gpt4Turbo: "gpt-4-turbo",
29:     Gpt4TurboPreview: "gpt-4-turbo-preview",
30:     Gpt35Turbo0125: "gpt-3.5-turbo-0125",
31:     Gpt35Turbo: "gpt-3.5-turbo",
32:     Gpt4O: "gpt-4o",
33:     Gpt4OMini: "gpt-4o-mini",
34:     Gpt41: "gpt-4.1",
35:     Gpt5: "gpt-5",
36:     Gpt5Mini: "gpt-5-mini",
37:     Gpt5Nano: "gpt-5-nano",
38:     Gpt4OPriority: "gpt-4o-priority",
39:     Gpt4OMiniPriority: "gpt-4o-mini-priority",
40:     Gpt41Priority: "gpt-4.1-priority",
41:     Gpt5Priority: "gpt-5-priority",
42:     Gpt5MiniPriority: "gpt-5-mini-priority",
43:     Gpt5NanoPriority: "gpt-5-nano-priority",
44:     Gemma7BIt: "gemma-7b-it",
45:     Llama38B8192: "llama3-8b-8192",
46:     Llama370B8192: "llama3-70b-8192",
47:     Llama3170BVersatile: "llama-3.1-70b-versatile",
48:     Llama3370BVersatile: "llama-3.3-70b-versatile",
49:     Llama318BInstant: "llama-3.1-8b-instant",
50:     MoonshotaiKimiK2Instruct: "moonshotai/kimi-k2-instruct",
51:     AccountsFireworksModelsMixtral8X7BInstruct: "accounts/fireworks/models/mixtral-8x7b-instruct",
52:     AccountsFireworksModelsLlamaV3P1405BInstruct: "accounts/fireworks/models/llama-v3p1-405b-instruct",
53:     AccountsFireworksModelsLlamaV3P170BInstruct: "accounts/fireworks/models/llama-v3p1-70b-instruct",
54:     AccountsFireworksModelsLlamaV3P18BInstruct: "accounts/fireworks/models/llama-v3p1-8b-instruct",
55:     Sonar: "sonar",
56:     SonarPro: "sonar-pro",
57:     Sambanova: "sambanova",
58:     DeepSeekR1DistillLlama70B: "DeepSeek-R1-Distill-Llama-70B",
59:     Llama4Maverick17B128EInstruct: "Llama-4-Maverick-17B-128E-Instruct",
60:     Qwen332B: "Qwen3-32B",
61:     Grok4FastNonReasoningLatest: "grok-4-fast-non-reasoning-latest",
62:     Ellm: "ellm",
63:     CustomLanguageModel: "custom-language-model",
64:     HumeEvi3WebSearch: "hume-evi-3-web-search",
65: } as const;
66: export type LanguageModelType = (typeof LanguageModelType)[keyof typeof LanguageModelType];
````

## File: src/api/resources/empathicVoice/types/MillisecondInterval.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface MillisecondInterval {
4:     /** Start time of the interval in milliseconds. */
5:     begin: number;
6:     /** End time of the interval in milliseconds. */
7:     end: number;
8: }
````

## File: src/api/resources/empathicVoice/types/ModelProviderEnum.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export const ModelProviderEnum = {
 4:     Groq: "GROQ",
 5:     OpenAi: "OPEN_AI",
 6:     Fireworks: "FIREWORKS",
 7:     Anthropic: "ANTHROPIC",
 8:     CustomLanguageModel: "CUSTOM_LANGUAGE_MODEL",
 9:     Google: "GOOGLE",
10:     HumeAi: "HUME_AI",
11:     AmazonBedrock: "AMAZON_BEDROCK",
12:     Perplexity: "PERPLEXITY",
13:     Sambanova: "SAMBANOVA",
14:     Cerebras: "CEREBRAS",
15: } as const;
16: export type ModelProviderEnum = (typeof ModelProviderEnum)[keyof typeof ModelProviderEnum];
````

## File: src/api/resources/empathicVoice/types/PauseAssistantMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * Pause responses from EVI. Chat history is still saved and sent after resuming.
 5:  */
 6: export interface PauseAssistantMessage {
 7:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
 8:     customSessionId?: string;
 9:     /**
10:      * The type of message sent through the socket; must be `pause_assistant_message` for our server to correctly identify and process it as a Pause Assistant message.
11:      *
12:      * Once this message is sent, EVI will not respond until a [Resume Assistant message](/reference/empathic-voice-interface-evi/chat/chat#send.Resume%20Assistant%20Message.type) is sent. When paused, EVI won't respond, but transcriptions of your audio inputs will still be recorded.
13:      */
14:     type: "pause_assistant_message";
15: }
````

## File: src/api/resources/empathicVoice/types/PostedBuiltinTool.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A configuration of a built-in tool to be posted to the server
 7:  */
 8: export interface PostedBuiltinTool {
 9:     /** Text to use if the tool fails to generate content. */
10:     fallbackContent?: string;
11:     name: Hume.empathicVoice.PostedBuiltinToolName;
12: }
````

## File: src/api/resources/empathicVoice/types/PostedBuiltinToolName.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const PostedBuiltinToolName = {
4:     WebSearch: "web_search",
5:     HangUp: "hang_up",
6: } as const;
7: export type PostedBuiltinToolName = (typeof PostedBuiltinToolName)[keyof typeof PostedBuiltinToolName];
````

## File: src/api/resources/empathicVoice/types/PostedConfigPromptSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * Identifies which prompt to use in a a config OR how to create a new prompt to use in the config
 5:  */
 6: export interface PostedConfigPromptSpec {
 7:     /** Identifier for a Prompt. Formatted as a UUID. */
 8:     id?: string;
 9:     /** Text used to create a new prompt for a particular config. */
10:     text?: string;
11:     /** Version number for a Prompt. Version numbers should be integers. The combination of configId and version number is unique. */
12:     version?: number;
13: }
````

## File: src/api/resources/empathicVoice/types/PostedEllmModel.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: /**
4:  * A eLLM model configuration to be posted to the server
5:  */
6: export interface PostedEllmModel {
7:     /** Boolean indicating if the model is allowed to generate short responses. */
8:     allowShortResponses?: boolean;
9: }
````

## File: src/api/resources/empathicVoice/types/PostedEventMessageSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * Settings for a specific event_message to be posted to the server
 5:  */
 6: export interface PostedEventMessageSpec {
 7:     /** Boolean indicating if this event message is enabled. */
 8:     enabled: boolean;
 9:     /** Optional text that will be used as a verbatim event message. If the text is null and the event message is enabled, the system will generate a message based using the language model. */
10:     text?: string;
11: }
````

## File: src/api/resources/empathicVoice/types/PostedEventMessageSpecs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * Collection of event_message specs to be posted to the server
 7:  */
 8: export interface PostedEventMessageSpecs {
 9:     onInactivityTimeout?: Hume.empathicVoice.PostedEventMessageSpec;
10:     onMaxDurationTimeout?: Hume.empathicVoice.PostedEventMessageSpec;
11:     onNewChat?: Hume.empathicVoice.PostedEventMessageSpec;
12: }
````

## File: src/api/resources/empathicVoice/types/PostedLanguageModel.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A LanguageModel to be posted to the server
 7:  */
 8: export interface PostedLanguageModel {
 9:     modelProvider?: Hume.empathicVoice.ModelProviderEnum;
10:     modelResource?: Hume.empathicVoice.LanguageModelType;
11:     /** Model temperature. */
12:     temperature?: number;
13: }
````

## File: src/api/resources/empathicVoice/types/PostedNudgeSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * A nudge specification posted to the server
 5:  */
 6: export interface PostedNudgeSpec {
 7:     /** EVI will nudge user after inactivity */
 8:     enabled?: boolean;
 9:     /** Time interval in seconds after which the nudge will be sent. */
10:     intervalSecs?: number;
11: }
````

## File: src/api/resources/empathicVoice/types/PostedTimeoutSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * Settings for a specific timeout to be posted to the server
 5:  */
 6: export interface PostedTimeoutSpec {
 7:     /** Duration in seconds for the timeout. */
 8:     durationSecs?: number;
 9:     /** Boolean indicating if this event message is enabled. */
10:     enabled: boolean;
11: }
````

## File: src/api/resources/empathicVoice/types/PostedTimeoutSpecs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * Collection of timeout specs to be posted to the server
 7:  */
 8: export interface PostedTimeoutSpecs {
 9:     inactivity?: Hume.empathicVoice.PostedTimeoutSpecsInactivity;
10:     maxDuration?: Hume.empathicVoice.PostedTimeoutSpecsMaxDuration;
11: }
````

## File: src/api/resources/empathicVoice/types/PostedTimeoutSpecsInactivity.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface PostedTimeoutSpecsInactivity {
4:     durationSecs?: number;
5:     enabled: boolean;
6: }
````

## File: src/api/resources/empathicVoice/types/PostedTimeoutSpecsMaxDuration.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface PostedTimeoutSpecsMaxDuration {
4:     durationSecs?: number;
5:     enabled: boolean;
6: }
````

## File: src/api/resources/empathicVoice/types/PostedUserDefinedToolSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * A specific tool identifier to be posted to the server
 5:  */
 6: export interface PostedUserDefinedToolSpec {
 7:     /** Identifier for a Tool. Formatted as a UUID. */
 8:     id: string;
 9:     /** Version number for a Tool. Version numbers should be integers. The combination of configId and version number is unique. */
10:     version?: number;
11: }
````

## File: src/api/resources/empathicVoice/types/PostedWebhookEventType.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: /** Events this URL is subscribed to */
4: export const PostedWebhookEventType = {
5:     ChatStarted: "chat_started",
6:     ChatEnded: "chat_ended",
7:     ToolCall: "tool_call",
8: } as const;
9: export type PostedWebhookEventType = (typeof PostedWebhookEventType)[keyof typeof PostedWebhookEventType];
````

## File: src/api/resources/empathicVoice/types/PostedWebhookSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * URL and settings for a specific webhook to be posted to the server
 7:  */
 8: export interface PostedWebhookSpec {
 9:     /** Events this URL is subscribed to */
10:     events: Hume.empathicVoice.PostedWebhookEventType[];
11:     /** URL to send the webhook to */
12:     url: string;
13: }
````

## File: src/api/resources/empathicVoice/types/ProsodyInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface ProsodyInference {
 6:     /**
 7:      * The confidence scores for 48 emotions within the detected expression of an audio sample.
 8:      *
 9:      * Scores typically range from 0 to 1, with higher values indicating a stronger confidence level in the measured attribute.
10:      *
11:      * See our guide on [interpreting expression measurement results](/docs/expression-measurement/faq#how-do-i-interpret-my-results) to learn more.
12:      */
13:     scores: Hume.empathicVoice.EmotionScores;
14: }
````

## File: src/api/resources/empathicVoice/types/ResumeAssistantMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * Resume responses from EVI. Chat history sent while paused will now be sent.
 5:  */
 6: export interface ResumeAssistantMessage {
 7:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
 8:     customSessionId?: string;
 9:     /**
10:      * The type of message sent through the socket; must be `resume_assistant_message` for our server to correctly identify and process it as a Resume Assistant message.
11:      *
12:      * Upon resuming, if any audio input was sent during the pause, EVI will retain context from all messages sent but only respond to the last user message. (e.g., If you ask EVI two questions while paused and then send a `resume_assistant_message`, EVI will respond to the second question and have added the first question to its conversation context.)
13:      */
14:     type: "resume_assistant_message";
15: }
````

## File: src/api/resources/empathicVoice/types/ReturnBuiltinTool.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A specific builtin tool version returned from the server
 7:  */
 8: export interface ReturnBuiltinTool {
 9:     /** Text to use if the tool fails to generate content. */
10:     fallbackContent?: string;
11:     /** Name applied to all versions of a particular Tool. */
12:     name: string;
13:     toolType: Hume.empathicVoice.ReturnBuiltinToolToolType;
14: }
````

## File: src/api/resources/empathicVoice/types/ReturnBuiltinToolToolType.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ReturnBuiltinToolToolType = {
4:     Builtin: "BUILTIN",
5:     Function: "FUNCTION",
6: } as const;
7: export type ReturnBuiltinToolToolType = (typeof ReturnBuiltinToolToolType)[keyof typeof ReturnBuiltinToolToolType];
````

## File: src/api/resources/empathicVoice/types/ReturnChat.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A description of chat and its status
 7:  */
 8: export interface ReturnChat {
 9:     /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
10:     chatGroupId: string;
11:     config?: Hume.empathicVoice.ReturnConfigSpec;
12:     /** The timestamp when the chat ended, formatted as a Unix epoch milliseconds. */
13:     endTimestamp?: number;
14:     /** The total number of events currently in this chat. */
15:     eventCount?: number;
16:     /** Identifier for a chat. Formatted as a UUID. */
17:     id: string;
18:     /** Stringified JSON with additional metadata about the chat. */
19:     metadata?: string;
20:     /** The timestamp when the chat started, formatted as a Unix epoch milliseconds. */
21:     startTimestamp: number;
22:     status: Hume.empathicVoice.ReturnChatStatus;
23: }
````

## File: src/api/resources/empathicVoice/types/ReturnChatAudioReconstruction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * List of chat audio reconstructions returned for the specified page number and page size.
 7:  */
 8: export interface ReturnChatAudioReconstruction {
 9:     /** Name of the chat audio reconstruction file. */
10:     filename?: string;
11:     /** Identifier for the chat. Formatted as a UUID. */
12:     id: string;
13:     /** The timestamp of the most recent status change for this audio reconstruction, formatted milliseconds since the Unix epoch. */
14:     modifiedAt?: number;
15:     /** Signed URL used to download the chat audio reconstruction file. */
16:     signedAudioUrl?: string;
17:     /** The timestamp when the signed URL will expire, formatted as a Unix epoch milliseconds. */
18:     signedUrlExpirationTimestampMillis?: number;
19:     status: Hume.empathicVoice.ReturnChatAudioReconstructionStatus;
20:     /** Identifier for the user that owns this chat. Formatted as a UUID. */
21:     userId: string;
22: }
````

## File: src/api/resources/empathicVoice/types/ReturnChatAudioReconstructionStatus.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export const ReturnChatAudioReconstructionStatus = {
 4:     Queued: "QUEUED",
 5:     InProgress: "IN_PROGRESS",
 6:     Complete: "COMPLETE",
 7:     Error: "ERROR",
 8:     Cancelled: "CANCELLED",
 9: } as const;
10: export type ReturnChatAudioReconstructionStatus =
11:     (typeof ReturnChatAudioReconstructionStatus)[keyof typeof ReturnChatAudioReconstructionStatus];
````

## File: src/api/resources/empathicVoice/types/ReturnChatEvent.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A description of a single event in a chat returned from the server
 7:  */
 8: export interface ReturnChatEvent {
 9:     /** Identifier for the chat this event occurred in. Formatted as a UUID. */
10:     chatId: string;
11:     /** Stringified JSON with data about emotional content/prosody of the event. */
12:     emotionFeatures?: string;
13:     /** Identifier for a chat event. Formatted as a UUID. */
14:     id: string;
15:     /** The text of the chat message, either transcribed from speaker audio or generated by the agent. */
16:     messageText?: string;
17:     /** Stringified JSON with additional metadata about the chat event. */
18:     metadata?: string;
19:     /** Identifier for a related chat event. Currently only seen on ASSISTANT_PROSODY events, to point back to the ASSISTANT_MESSAGE that generated these prosody scores */
20:     relatedEventId?: string;
21:     role: Hume.empathicVoice.ReturnChatEventRole;
22:     /** The timestamp when the chat event occurred, formatted as a Unix epoch milliseconds. */
23:     timestamp: number;
24:     type: Hume.empathicVoice.ReturnChatEventType;
25: }
````

## File: src/api/resources/empathicVoice/types/ReturnChatEventRole.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ReturnChatEventRole = {
4:     User: "USER",
5:     Agent: "AGENT",
6:     System: "SYSTEM",
7:     Tool: "TOOL",
8: } as const;
9: export type ReturnChatEventRole = (typeof ReturnChatEventRole)[keyof typeof ReturnChatEventRole];
````

## File: src/api/resources/empathicVoice/types/ReturnChatEventType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export const ReturnChatEventType = {
 4:     FunctionCall: "FUNCTION_CALL",
 5:     FunctionCallResponse: "FUNCTION_CALL_RESPONSE",
 6:     ChatEndMessage: "CHAT_END_MESSAGE",
 7:     AgentMessage: "AGENT_MESSAGE",
 8:     SystemPrompt: "SYSTEM_PROMPT",
 9:     UserRecordingStartMessage: "USER_RECORDING_START_MESSAGE",
10:     ResumeOnset: "RESUME_ONSET",
11:     UserInterruption: "USER_INTERRUPTION",
12:     ChatStartMessage: "CHAT_START_MESSAGE",
13:     PauseOnset: "PAUSE_ONSET",
14:     UserMessage: "USER_MESSAGE",
15: } as const;
16: export type ReturnChatEventType = (typeof ReturnChatEventType)[keyof typeof ReturnChatEventType];
````

## File: src/api/resources/empathicVoice/types/ReturnChatGroup.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A description of chat_group and its status
 7:  */
 8: export interface ReturnChatGroup {
 9:     active?: boolean;
10:     /** The timestamp when the first chat in this chat group started, formatted as a Unix epoch milliseconds. */
11:     firstStartTimestamp: number;
12:     /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
13:     id: string;
14:     /** The chat_id of the most recent chat in this chat group. Formatted as a UUID. */
15:     mostRecentChatId?: string;
16:     mostRecentConfig?: Hume.empathicVoice.ReturnConfigSpec;
17:     /** The timestamp when the most recent chat in this chat group started, formatted as a Unix epoch milliseconds. */
18:     mostRecentStartTimestamp: number;
19:     /** The total number of chats in this chat group. */
20:     numChats: number;
21: }
````

## File: src/api/resources/empathicVoice/types/ReturnChatGroupPagedAudioReconstructions.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A paginated list of chat reconstructions for a particular chatgroup
 7:  */
 8: export interface ReturnChatGroupPagedAudioReconstructions {
 9:     /** List of chat audio reconstructions returned for the specified page number and page size. */
10:     audioReconstructionsPage: Hume.empathicVoice.ReturnChatAudioReconstruction[];
11:     /** Identifier for the chat group. Formatted as a UUID. */
12:     id: string;
13:     /** Total number of chats in this chatgroup */
14:     numChats: number;
15:     /** The page number of the returned results. */
16:     pageNumber: number;
17:     /**
18:      * The maximum number of items returned per page.
19:      *
20:      * This value corresponds to the `page_size` parameter specified in the request.
21:      */
22:     pageSize: number;
23:     paginationDirection: Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructionsPaginationDirection;
24:     /** The total number of pages in the collection. */
25:     totalPages: number;
26:     /** Identifier for the user that owns this chat. Formatted as a UUID. */
27:     userId: string;
28: }
````

## File: src/api/resources/empathicVoice/types/ReturnChatGroupPagedAudioReconstructionsPaginationDirection.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ReturnChatGroupPagedAudioReconstructionsPaginationDirection = {
4:     Asc: "ASC",
5:     Desc: "DESC",
6: } as const;
7: export type ReturnChatGroupPagedAudioReconstructionsPaginationDirection =
8:     (typeof ReturnChatGroupPagedAudioReconstructionsPaginationDirection)[keyof typeof ReturnChatGroupPagedAudioReconstructionsPaginationDirection];
````

## File: src/api/resources/empathicVoice/types/ReturnChatGroupPagedChats.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A description of chat_group and its status with a paginated list of each chat in the chat_group
 7:  */
 8: export interface ReturnChatGroupPagedChats {
 9:     active?: boolean;
10:     /** List of chats and their metadata returned for the specified page number and page size. */
11:     chatsPage: Hume.empathicVoice.ReturnChat[];
12:     /** The timestamp when the first chat in this chat group started, formatted as a Unix epoch milliseconds. */
13:     firstStartTimestamp: number;
14:     /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
15:     id: string;
16:     /** The timestamp when the most recent chat in this chat group started, formatted as a Unix epoch milliseconds. */
17:     mostRecentStartTimestamp: number;
18:     /** The total number of chats in this chat group. */
19:     numChats: number;
20:     /** The page number of the returned results. */
21:     pageNumber: number;
22:     /**
23:      * The maximum number of items returned per page.
24:      *
25:      * This value corresponds to the `page_size` parameter specified in the request.
26:      */
27:     pageSize: number;
28:     paginationDirection: Hume.empathicVoice.ReturnChatGroupPagedChatsPaginationDirection;
29:     /** The total number of pages in the collection. */
30:     totalPages: number;
31: }
````

## File: src/api/resources/empathicVoice/types/ReturnChatGroupPagedChatsPaginationDirection.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ReturnChatGroupPagedChatsPaginationDirection = {
4:     Asc: "ASC",
5:     Desc: "DESC",
6: } as const;
7: export type ReturnChatGroupPagedChatsPaginationDirection =
8:     (typeof ReturnChatGroupPagedChatsPaginationDirection)[keyof typeof ReturnChatGroupPagedChatsPaginationDirection];
````

## File: src/api/resources/empathicVoice/types/ReturnChatGroupPagedEvents.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A paginated list of chat events that occurred across chats in this chat_group from the server
 7:  */
 8: export interface ReturnChatGroupPagedEvents {
 9:     /** List of chat_events returned for the specified page number and page size. */
10:     eventsPage: Hume.empathicVoice.ReturnChatEvent[];
11:     /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
12:     id: string;
13:     /** The page number of the returned results. */
14:     pageNumber: number;
15:     /**
16:      * The maximum number of items returned per page.
17:      *
18:      * This value corresponds to the `page_size` parameter specified in the request.
19:      */
20:     pageSize: number;
21:     paginationDirection: Hume.empathicVoice.ReturnChatGroupPagedEventsPaginationDirection;
22:     /** The total number of pages in the collection. */
23:     totalPages: number;
24: }
````

## File: src/api/resources/empathicVoice/types/ReturnChatGroupPagedEventsPaginationDirection.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ReturnChatGroupPagedEventsPaginationDirection = {
4:     Asc: "ASC",
5:     Desc: "DESC",
6: } as const;
7: export type ReturnChatGroupPagedEventsPaginationDirection =
8:     (typeof ReturnChatGroupPagedEventsPaginationDirection)[keyof typeof ReturnChatGroupPagedEventsPaginationDirection];
````

## File: src/api/resources/empathicVoice/types/ReturnChatPagedEvents.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A description of chat status with a paginated list of chat events returned from the server
 7:  */
 8: export interface ReturnChatPagedEvents {
 9:     /** Identifier for the chat group. Any chat resumed from this chat will have the same chat_group_id. Formatted as a UUID. */
10:     chatGroupId: string;
11:     config?: Hume.empathicVoice.ReturnConfigSpec;
12:     /** The timestamp when the chat ended, formatted as a Unix epoch milliseconds. */
13:     endTimestamp?: number;
14:     /** List of chat events with the specified page number and page size. */
15:     eventsPage: Hume.empathicVoice.ReturnChatEvent[];
16:     /** Identifier for a chat. Formatted as a UUID. */
17:     id: string;
18:     /** Stringified JSON with additional metadata about the chat. */
19:     metadata?: string;
20:     /** The page number of the returned results. */
21:     pageNumber: number;
22:     /**
23:      * The maximum number of items returned per page.
24:      *
25:      * This value corresponds to the `page_size` parameter specified in the request.
26:      */
27:     pageSize: number;
28:     paginationDirection: Hume.empathicVoice.ReturnChatPagedEventsPaginationDirection;
29:     /** The timestamp when the chat started, formatted as a Unix epoch milliseconds. */
30:     startTimestamp: number;
31:     status: Hume.empathicVoice.ReturnChatPagedEventsStatus;
32:     /** The total number of pages in the collection. */
33:     totalPages: number;
34: }
````

## File: src/api/resources/empathicVoice/types/ReturnChatPagedEventsPaginationDirection.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ReturnChatPagedEventsPaginationDirection = {
4:     Asc: "ASC",
5:     Desc: "DESC",
6: } as const;
7: export type ReturnChatPagedEventsPaginationDirection =
8:     (typeof ReturnChatPagedEventsPaginationDirection)[keyof typeof ReturnChatPagedEventsPaginationDirection];
````

## File: src/api/resources/empathicVoice/types/ReturnChatPagedEventsStatus.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export const ReturnChatPagedEventsStatus = {
 4:     Active: "ACTIVE",
 5:     UserEnded: "USER_ENDED",
 6:     UserTimeout: "USER_TIMEOUT",
 7:     MaxDurationTimeout: "MAX_DURATION_TIMEOUT",
 8:     InactivityTimeout: "INACTIVITY_TIMEOUT",
 9:     Error: "ERROR",
10: } as const;
11: export type ReturnChatPagedEventsStatus =
12:     (typeof ReturnChatPagedEventsStatus)[keyof typeof ReturnChatPagedEventsStatus];
````

## File: src/api/resources/empathicVoice/types/ReturnChatStatus.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export const ReturnChatStatus = {
 4:     Active: "ACTIVE",
 5:     UserEnded: "USER_ENDED",
 6:     UserTimeout: "USER_TIMEOUT",
 7:     MaxDurationTimeout: "MAX_DURATION_TIMEOUT",
 8:     InactivityTimeout: "INACTIVITY_TIMEOUT",
 9:     Error: "ERROR",
10: } as const;
11: export type ReturnChatStatus = (typeof ReturnChatStatus)[keyof typeof ReturnChatStatus];
````

## File: src/api/resources/empathicVoice/types/ReturnConfig.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A specific config version returned from the server
 7:  */
 8: export interface ReturnConfig {
 9:     /** List of built-in tools associated with this config */
10:     builtinTools?: (Hume.empathicVoice.ReturnBuiltinTool | undefined)[];
11:     /** The timestamp when the first version of this config was created. */
12:     createdOn?: number;
13:     ellmModel?: Hume.empathicVoice.ReturnEllmModel;
14:     eventMessages?: Hume.empathicVoice.ReturnEventMessageSpecs;
15:     /** The version of the EVI used with this config. */
16:     eviVersion?: string;
17:     /** Identifier for a Config. Formatted as a UUID. */
18:     id?: string;
19:     languageModel?: Hume.empathicVoice.ReturnLanguageModel;
20:     /** The timestamp when this version of the config was created. */
21:     modifiedOn?: number;
22:     /** Name applied to all versions of a particular Config. */
23:     name?: string;
24:     nudges?: Hume.empathicVoice.ReturnNudgeSpec;
25:     prompt?: Hume.empathicVoice.ReturnPrompt;
26:     timeouts?: Hume.empathicVoice.ReturnTimeoutSpecs;
27:     /** List of user-defined tools associated with this config. */
28:     tools?: (Hume.empathicVoice.ReturnUserDefinedTool | undefined)[];
29:     /** Version number for a Config. Version numbers should be integers. The combination of configId and version number is unique. */
30:     version?: number;
31:     /** Description that is appended to a specific version of a Config. */
32:     versionDescription?: string;
33:     voice?: Hume.empathicVoice.ReturnVoice;
34:     /** Map of webhooks associated with this config. */
35:     webhooks?: (Hume.empathicVoice.ReturnWebhookSpec | undefined)[];
36: }
````

## File: src/api/resources/empathicVoice/types/ReturnConfigSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * An id/version number for a specific config version
 5:  */
 6: export interface ReturnConfigSpec {
 7:     /** Identifier for a Config. Formatted as a UUID. */
 8:     id: string;
 9:     /** Version number for a Config. Version numbers should be integers. The combination of configId and version number is unique. */
10:     version?: number;
11: }
````

## File: src/api/resources/empathicVoice/types/ReturnEllmModel.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: /**
4:  * A specific eLLM Model configuration
5:  */
6: export interface ReturnEllmModel {
7:     /** Boolean indicating if the model is allowed to generate short responses. */
8:     allowShortResponses: boolean;
9: }
````

## File: src/api/resources/empathicVoice/types/ReturnEventMessageSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * A specific event message configuration to be returned from the server
 5:  */
 6: export interface ReturnEventMessageSpec {
 7:     /** Boolean indicating if this event message is enabled. */
 8:     enabled: boolean;
 9:     /** Optional text that will be used as a verbatim event message. If the text is null and the event message is enabled, the system will generate a message based using the language model. */
10:     text?: string;
11: }
````

## File: src/api/resources/empathicVoice/types/ReturnEventMessageSpecs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * Collection of event_message specs to be returned from the server
 7:  */
 8: export interface ReturnEventMessageSpecs {
 9:     onInactivityTimeout?: Hume.empathicVoice.ReturnEventMessageSpec;
10:     onMaxDurationTimeout?: Hume.empathicVoice.ReturnEventMessageSpec;
11:     onNewChat?: Hume.empathicVoice.ReturnEventMessageSpec;
12: }
````

## File: src/api/resources/empathicVoice/types/ReturnLanguageModel.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A specific LanguageModel
 7:  */
 8: export interface ReturnLanguageModel {
 9:     modelProvider?: Hume.empathicVoice.ModelProviderEnum;
10:     modelResource?: Hume.empathicVoice.LanguageModelType;
11:     /** Model temperature. */
12:     temperature?: number;
13: }
````

## File: src/api/resources/empathicVoice/types/ReturnNudgeSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * A specific nudge configuration returned from the server
 5:  */
 6: export interface ReturnNudgeSpec {
 7:     /** EVI will nudge user after inactivity */
 8:     enabled: boolean;
 9:     /** Time interval in seconds after which the nudge will be sent. */
10:     intervalSecs?: number;
11: }
````

## File: src/api/resources/empathicVoice/types/ReturnPagedChatGroups.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A paginated list of chat_groups returned from the server
 7:  */
 8: export interface ReturnPagedChatGroups {
 9:     /** List of chat_groups and their metadata returned for the specified page number and page size. */
10:     chatGroupsPage: Hume.empathicVoice.ReturnChatGroup[];
11:     /** The page number of the returned results. */
12:     pageNumber: number;
13:     /**
14:      * The maximum number of items returned per page.
15:      *
16:      * This value corresponds to the `page_size` parameter specified in the request.
17:      */
18:     pageSize: number;
19:     paginationDirection: Hume.empathicVoice.ReturnPagedChatGroupsPaginationDirection;
20:     /** The total number of pages in the collection. */
21:     totalPages: number;
22: }
````

## File: src/api/resources/empathicVoice/types/ReturnPagedChatGroupsPaginationDirection.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ReturnPagedChatGroupsPaginationDirection = {
4:     Asc: "ASC",
5:     Desc: "DESC",
6: } as const;
7: export type ReturnPagedChatGroupsPaginationDirection =
8:     (typeof ReturnPagedChatGroupsPaginationDirection)[keyof typeof ReturnPagedChatGroupsPaginationDirection];
````

## File: src/api/resources/empathicVoice/types/ReturnPagedChats.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A paginated list of chats returned from the server
 7:  */
 8: export interface ReturnPagedChats {
 9:     /** List of chats and their metadata returned for the specified page number and page size. */
10:     chatsPage: Hume.empathicVoice.ReturnChat[];
11:     /** The page number of the returned results. */
12:     pageNumber: number;
13:     /**
14:      * The maximum number of items returned per page.
15:      *
16:      * This value corresponds to the `page_size` parameter specified in the request.
17:      */
18:     pageSize: number;
19:     paginationDirection: Hume.empathicVoice.ReturnPagedChatsPaginationDirection;
20:     /** The total number of pages in the collection. */
21:     totalPages: number;
22: }
````

## File: src/api/resources/empathicVoice/types/ReturnPagedChatsPaginationDirection.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ReturnPagedChatsPaginationDirection = {
4:     Asc: "ASC",
5:     Desc: "DESC",
6: } as const;
7: export type ReturnPagedChatsPaginationDirection =
8:     (typeof ReturnPagedChatsPaginationDirection)[keyof typeof ReturnPagedChatsPaginationDirection];
````

## File: src/api/resources/empathicVoice/types/ReturnPagedConfigs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A paginated list of config versions returned from the server
 7:  */
 8: export interface ReturnPagedConfigs {
 9:     /** List of prompts returned for the specified page number and page size. */
10:     configsPage?: Hume.empathicVoice.ReturnConfig[];
11:     /** The page number of the returned results. */
12:     pageNumber?: number;
13:     /**
14:      * The maximum number of items returned per page.
15:      *
16:      * This value corresponds to the `page_size` parameter specified in the request.
17:      */
18:     pageSize?: number;
19:     /** The total number of pages in the collection. */
20:     totalPages: number;
21: }
````

## File: src/api/resources/empathicVoice/types/ReturnPagedPrompts.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A paginated list of prompt versions returned from the server
 7:  */
 8: export interface ReturnPagedPrompts {
 9:     /** The page number of the returned results. */
10:     pageNumber: number;
11:     /**
12:      * The maximum number of items returned per page.
13:      *
14:      * This value corresponds to the `page_size` parameter specified in the request.
15:      */
16:     pageSize: number;
17:     /** List of prompts returned for the specified page number and page size. */
18:     promptsPage: (Hume.empathicVoice.ReturnPrompt | undefined)[];
19:     /** The total number of pages in the collection. */
20:     totalPages: number;
21: }
````

## File: src/api/resources/empathicVoice/types/ReturnPagedUserDefinedTools.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A paginated list of user defined tool versions returned from the server
 7:  */
 8: export interface ReturnPagedUserDefinedTools {
 9:     /** The page number of the returned results. */
10:     pageNumber: number;
11:     /**
12:      * The maximum number of items returned per page.
13:      *
14:      * This value corresponds to the `page_size` parameter specified in the request.
15:      */
16:     pageSize: number;
17:     /** List of tools returned for the specified page number and page size. */
18:     toolsPage: (Hume.empathicVoice.ReturnUserDefinedTool | undefined)[];
19:     /** The total number of pages in the collection. */
20:     totalPages: number;
21: }
````

## File: src/api/resources/empathicVoice/types/ReturnPrompt.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * A specific prompt version returned from the server
 5:  */
 6: export interface ReturnPrompt {
 7:     /** The timestamp when the first version of this prompt was created. */
 8:     createdOn: number;
 9:     /** Identifier for a Prompt. Formatted as a UUID. */
10:     id: string;
11:     /** The timestamp when this version of the prompt was created. */
12:     modifiedOn: number;
13:     /** Name applied to all versions of a particular Prompt. */
14:     name: string;
15:     /** Text used for this version of the Prompt. */
16:     text: string;
17:     /** Version number for a Prompt. Version numbers should be integers. The combination of configId and version number is unique. */
18:     version: number;
19:     /** Description that is appended to a specific version of a Prompt. */
20:     versionDescription?: string;
21:     /** Indicates whether this prompt is using a fixed version number or auto-updating to the latest version. Values from the VersionType enum. */
22:     versionType: string;
23: }
````

## File: src/api/resources/empathicVoice/types/ReturnPromptVersionType.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ReturnPromptVersionType = {
4:     Fixed: "FIXED",
5:     Latest: "LATEST",
6: } as const;
7: export type ReturnPromptVersionType = (typeof ReturnPromptVersionType)[keyof typeof ReturnPromptVersionType];
````

## File: src/api/resources/empathicVoice/types/ReturnTimeoutSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * A specific timeout configuration to be returned from the server
 5:  */
 6: export interface ReturnTimeoutSpec {
 7:     /** Duration in seconds for the timeout. */
 8:     durationSecs?: number;
 9:     /** Boolean indicating if this event message is enabled. */
10:     enabled: boolean;
11: }
````

## File: src/api/resources/empathicVoice/types/ReturnTimeoutSpecs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * Collection of timeout specs to be returned from the server
 7:  */
 8: export interface ReturnTimeoutSpecs {
 9:     inactivity: Hume.empathicVoice.ReturnTimeoutSpec;
10:     maxDuration: Hume.empathicVoice.ReturnTimeoutSpec;
11: }
````

## File: src/api/resources/empathicVoice/types/ReturnUserDefinedTool.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A specific tool version returned from the server
 7:  */
 8: export interface ReturnUserDefinedTool {
 9:     /** The timestamp when the first version of this tool was created. */
10:     createdOn: number;
11:     /** Text describing what the tool does. */
12:     description?: string;
13:     /** Text to use if the tool fails to generate content. */
14:     fallbackContent?: string;
15:     /** Identifier for a Tool. Formatted as a UUID. */
16:     id: string;
17:     /** The timestamp when this version of the tool was created. */
18:     modifiedOn: number;
19:     /** Name applied to all versions of a particular Tool. */
20:     name: string;
21:     /** Stringified JSON defining the parameters used by this version of the Tool. */
22:     parameters: string;
23:     toolType: Hume.empathicVoice.ReturnUserDefinedToolToolType;
24:     /** Version number for a Tool. Version numbers should be integers. The combination of configId and version number is unique. */
25:     version: number;
26:     /** Description that is appended to a specific version of a Tool. */
27:     versionDescription?: string;
28:     versionType: Hume.empathicVoice.ReturnUserDefinedToolVersionType;
29: }
````

## File: src/api/resources/empathicVoice/types/ReturnUserDefinedToolToolType.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ReturnUserDefinedToolToolType = {
4:     Builtin: "BUILTIN",
5:     Function: "FUNCTION",
6: } as const;
7: export type ReturnUserDefinedToolToolType =
8:     (typeof ReturnUserDefinedToolToolType)[keyof typeof ReturnUserDefinedToolToolType];
````

## File: src/api/resources/empathicVoice/types/ReturnUserDefinedToolVersionType.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ReturnUserDefinedToolVersionType = {
4:     Fixed: "FIXED",
5:     Latest: "LATEST",
6: } as const;
7: export type ReturnUserDefinedToolVersionType =
8:     (typeof ReturnUserDefinedToolVersionType)[keyof typeof ReturnUserDefinedToolVersionType];
````

## File: src/api/resources/empathicVoice/types/ReturnVoice.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * An Octave voice available for text-to-speech
 7:  */
 8: export interface ReturnVoice {
 9:     compatibleOctaveModels?: string[];
10:     /** ID of the voice in the `Voice Library`. */
11:     id: string;
12:     /** Name of the voice in the `Voice Library`. */
13:     name: string;
14:     provider: Hume.empathicVoice.VoiceProvider;
15: }
````

## File: src/api/resources/empathicVoice/types/ReturnWebhookEventType.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: /** Events this URL is subscribed to */
4: export const ReturnWebhookEventType = {
5:     ChatStarted: "chat_started",
6:     ChatEnded: "chat_ended",
7:     ToolCall: "tool_call",
8: } as const;
9: export type ReturnWebhookEventType = (typeof ReturnWebhookEventType)[keyof typeof ReturnWebhookEventType];
````

## File: src/api/resources/empathicVoice/types/ReturnWebhookSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * Collection of webhook URL endpoints to be returned from the server
 7:  */
 8: export interface ReturnWebhookSpec {
 9:     /** Events this URL is subscribed to */
10:     events: Hume.empathicVoice.ReturnWebhookEventType[];
11:     /** Webhook URL to send the event updates to */
12:     url: string;
13: }
````

## File: src/api/resources/empathicVoice/types/Role.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export const Role = {
 4:     Assistant: "assistant",
 5:     System: "system",
 6:     User: "user",
 7:     All: "all",
 8:     Tool: "tool",
 9:     Context: "context",
10: } as const;
11: export type Role = (typeof Role)[keyof typeof Role];
````

## File: src/api/resources/empathicVoice/types/SessionSettings.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * Settings for this chat session.
 7:  */
 8: export interface SessionSettings {
 9:     /**
10:      * Configuration details for the audio input used during the session. Ensures the audio is being correctly set up for processing.
11:      *
12:      * This optional field is only required when the audio input is encoded in PCM Linear 16 (16-bit, little-endian, signed PCM WAV data). For detailed instructions on how to configure session settings for PCM Linear 16 audio, please refer to the [Session Settings section](/docs/empathic-voice-interface-evi/configuration#session-settings) on the EVI Configuration page.
13:      */
14:     audio?: Hume.empathicVoice.AudioConfiguration;
15:     /**
16:      * List of built-in tools to enable for the session.
17:      *
18:      * Tools are resources used by EVI to perform various tasks, such as searching the web or calling external APIs. Built-in tools, like web search, are natively integrated, while user-defined tools are created and invoked by the user. To learn more, see our [Tool Use Guide](/docs/empathic-voice-interface-evi/tool-use).
19:      *
20:      * Currently, the only built-in tool Hume provides is **Web Search**. When enabled, Web Search equips EVI with the ability to search the web for up-to-date information.
21:      */
22:     builtinTools?: Hume.empathicVoice.BuiltinToolConfig[];
23:     /**
24:      * Allows developers to inject additional context into the conversation, which is appended to the end of user messages for the session.
25:      *
26:      * When included in a Session Settings message, the provided context can be used to remind the LLM of its role in every user message, prevent it from forgetting important details, or add new relevant information to the conversation.
27:      *
28:      * Set to `null` to disable context injection.
29:      */
30:     context?: Hume.empathicVoice.Context;
31:     /**
32:      * Unique identifier for the session. Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions.
33:      *
34:      * If included, the response sent from Hume to your backend will include this ID. This allows you to correlate frontend users with their incoming messages.
35:      *
36:      * It is recommended to pass a `custom_session_id` if you are using a Custom Language Model. Please see our guide to [using a custom language model](/docs/empathic-voice-interface-evi/custom-language-model) with EVI to learn more.
37:      */
38:     customSessionId?: string;
39:     /**
40:      * Third party API key for the supplemental language model.
41:      *
42:      * When provided, EVI will use this key instead of Hume's API key for the supplemental LLM. This allows you to bypass rate limits and utilize your own API key as needed.
43:      */
44:     languageModelApiKey?: string;
45:     metadata?: Record<string, unknown>;
46:     /**
47:      * Instructions used to shape EVI's behavior, responses, and style for the session.
48:      *
49:      * When included in a Session Settings message, the provided Prompt overrides the existing one specified in the EVI configuration. If no Prompt was defined in the configuration, this Prompt will be the one used for the session.
50:      *
51:      * You can use the Prompt to define a specific goal or role for EVI, specifying how it should act or what it should focus on during the conversation. For example, EVI can be instructed to act as a customer support representative, a fitness coach, or a travel advisor, each with its own set of behaviors and response styles.
52:      *
53:      * For help writing a system prompt, see our [Prompting Guide](/docs/empathic-voice-interface-evi/prompting).
54:      */
55:     systemPrompt?: string;
56:     /**
57:      * List of user-defined tools to enable for the session.
58:      *
59:      * Tools are resources used by EVI to perform various tasks, such as searching the web or calling external APIs. Built-in tools, like web search, are natively integrated, while user-defined tools are created and invoked by the user. To learn more, see our [Tool Use Guide](/docs/empathic-voice-interface-evi/tool-use).
60:      */
61:     tools?: Hume.empathicVoice.Tool[];
62:     /**
63:      * The type of message sent through the socket; must be `session_settings` for our server to correctly identify and process it as a Session Settings message.
64:      *
65:      * Session settings are temporary and apply only to the current Chat session. These settings can be adjusted dynamically based on the requirements of each session to ensure optimal performance and user experience.
66:      *
67:      * For more information, please refer to the [Session Settings section](/docs/empathic-voice-interface-evi/configuration#session-settings) on the EVI Configuration page.
68:      */
69:     type: "session_settings";
70:     /** Dynamic values that can be used to populate EVI prompts. */
71:     variables?: Record<string, Hume.empathicVoice.SessionSettingsVariablesValue>;
72:     voiceId?: string;
73: }
````

## File: src/api/resources/empathicVoice/types/SessionSettingsVariablesValue.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type SessionSettingsVariablesValue = string | number | boolean;
````

## File: src/api/resources/empathicVoice/types/SubscribeEvent.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export type SubscribeEvent =
 6:     | Hume.empathicVoice.AssistantEnd
 7:     | Hume.empathicVoice.AssistantMessage
 8:     | Hume.empathicVoice.AssistantProsody
 9:     | Hume.empathicVoice.AudioOutput
10:     | Hume.empathicVoice.ChatMetadata
11:     | Hume.empathicVoice.WebSocketError
12:     | Hume.empathicVoice.UserInterruption
13:     | Hume.empathicVoice.UserMessage
14:     | Hume.empathicVoice.ToolCallMessage
15:     | Hume.empathicVoice.ToolResponseMessage
16:     | Hume.empathicVoice.ToolErrorMessage
17:     | Hume.empathicVoice.SessionSettings;
````

## File: src/api/resources/empathicVoice/types/Tool.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface Tool {
 6:     /** An optional description of what the tool does, used by the supplemental LLM to choose when and how to call the function. */
 7:     description?: string;
 8:     /** Optional text passed to the supplemental LLM if the tool call fails. The LLM then uses this text to generate a response back to the user, ensuring continuity in the conversation. */
 9:     fallbackContent?: string;
10:     /** Name of the user-defined tool to be enabled. */
11:     name: string;
12:     /**
13:      * Parameters of the tool. Is a stringified JSON schema.
14:      *
15:      * These parameters define the inputs needed for the tool's execution, including the expected data type and description for each input field. Structured as a JSON schema, this format ensures the tool receives data in the expected format.
16:      */
17:     parameters: string;
18:     /** Type of tool. Set to `function` for user-defined tools. */
19:     type: Hume.empathicVoice.ToolType;
20: }
````

## File: src/api/resources/empathicVoice/types/ToolCallMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * When provided, the output is a tool call.
 7:  */
 8: export interface ToolCallMessage {
 9:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
10:     customSessionId?: string;
11:     /** Name of the tool called. */
12:     name: string;
13:     /** Parameters of the tool call. Is a stringified JSON schema. */
14:     parameters: string;
15:     /** Indicates whether a response to the tool call is required from the developer, either in the form of a [Tool Response message](/reference/empathic-voice-interface-evi/chat/chat#send.Tool%20Response%20Message.type) or a [Tool Error message](/reference/empathic-voice-interface-evi/chat/chat#send.Tool%20Error%20Message.type). */
16:     responseRequired: boolean;
17:     /**
18:      * The unique identifier for a specific tool call instance.
19:      *
20:      * This ID is used to track the request and response of a particular tool invocation, ensuring that the correct response is linked to the appropriate request.
21:      */
22:     toolCallId: string;
23:     /** Type of tool called. Either `builtin` for natively implemented tools, like web search, or `function` for user-defined tools. */
24:     toolType: Hume.empathicVoice.ToolType;
25:     /**
26:      * The type of message sent through the socket; for a Tool Call message, this must be `tool_call`.
27:      *
28:      * This message indicates that the supplemental LLM has detected a need to invoke the specified tool.
29:      */
30:     type: "tool_call";
31: }
````

## File: src/api/resources/empathicVoice/types/ToolErrorMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * When provided, the output is a function call error.
 7:  */
 8: export interface ToolErrorMessage {
 9:     /** Error code. Identifies the type of error encountered. */
10:     code?: string;
11:     /** Optional text passed to the supplemental LLM in place of the tool call result. The LLM then uses this text to generate a response back to the user, ensuring continuity in the conversation if the tool errors. */
12:     content?: string;
13:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
14:     customSessionId?: string;
15:     /** Error message from the tool call, not exposed to the LLM or user. */
16:     error: string;
17:     /** Indicates the severity of an error; for a Tool Error message, this must be `warn` to signal an unexpected event. */
18:     level?: Hume.empathicVoice.ErrorLevel;
19:     /**
20:      * The unique identifier for a specific tool call instance.
21:      *
22:      * This ID is used to track the request and response of a particular tool invocation, ensuring that the Tool Error message is linked to the appropriate tool call request. The specified `tool_call_id` must match the one received in the [Tool Call message](/reference/empathic-voice-interface-evi/chat/chat#receive.Tool%20Call%20Message.type).
23:      */
24:     toolCallId: string;
25:     /** Type of tool called. Either `builtin` for natively implemented tools, like web search, or `function` for user-defined tools. */
26:     toolType?: Hume.empathicVoice.ToolType;
27:     /**
28:      * The type of message sent through the socket; for a Tool Error message, this must be `tool_error`.
29:      *
30:      * Upon receiving a [Tool Call message](/reference/empathic-voice-interface-evi/chat/chat#receive.Tool%20Call%20Message.type) and failing to invoke the function, this message is sent to notify EVI of the tool's failure.
31:      */
32:     type: "tool_error";
33: }
````

## File: src/api/resources/empathicVoice/types/ToolResponseMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * When provided, the output is a function call response.
 7:  */
 8: export interface ToolResponseMessage {
 9:     /** Return value of the tool call. Contains the output generated by the tool to pass back to EVI. */
10:     content: string;
11:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
12:     customSessionId?: string;
13:     /**
14:      * The unique identifier for a specific tool call instance.
15:      *
16:      * This ID is used to track the request and response of a particular tool invocation, ensuring that the correct response is linked to the appropriate request. The specified `tool_call_id` must match the one received in the [Tool Call message](/reference/empathic-voice-interface-evi/chat/chat#receive.Tool%20Call%20Message.tool_call_id).
17:      */
18:     toolCallId: string;
19:     toolName?: string;
20:     toolType?: Hume.empathicVoice.ToolType;
21:     /**
22:      * The type of message sent through the socket; for a Tool Response message, this must be `tool_response`.
23:      *
24:      * Upon receiving a [Tool Call message](/reference/empathic-voice-interface-evi/chat/chat#receive.Tool%20Call%20Message.type) and successfully invoking the function, this message is sent to convey the result of the function call back to EVI.
25:      */
26:     type: "tool_response";
27: }
````

## File: src/api/resources/empathicVoice/types/ToolType.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const ToolType = {
4:     Builtin: "builtin",
5:     Function: "function",
6: } as const;
7: export type ToolType = (typeof ToolType)[keyof typeof ToolType];
````

## File: src/api/resources/empathicVoice/types/UserInput.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * User text to insert into the conversation. Text sent through a User Input message is treated as the user's speech to EVI. EVI processes this input and provides a corresponding response.
 5:  *
 6:  * Expression measurement results are not available for User Input messages, as the prosody model relies on audio input and cannot process text alone.
 7:  */
 8: export interface UserInput {
 9:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
10:     customSessionId?: string;
11:     /**
12:      * User text to insert into the conversation. Text sent through a User Input message is treated as the user's speech to EVI. EVI processes this input and provides a corresponding response.
13:      *
14:      * Expression measurement results are not available for User Input messages, as the prosody model relies on audio input and cannot process text alone.
15:      */
16:     text: string;
17:     /** The type of message sent through the socket; must be `user_input` for our server to correctly identify and process it as a User Input message. */
18:     type: "user_input";
19: }
````

## File: src/api/resources/empathicVoice/types/UserInterruption.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * When provided, the output is an interruption.
 5:  */
 6: export interface UserInterruption {
 7:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
 8:     customSessionId?: string;
 9:     /** Unix timestamp of the detected user interruption. */
10:     time: number;
11:     /**
12:      * The type of message sent through the socket; for a User Interruption message, this must be `user_interruption`.
13:      *
14:      * This message indicates the user has interrupted the assistant's response. EVI detects the interruption in real-time and sends this message to signal the interruption event. This message allows the system to stop the current audio playback, clear the audio queue, and prepare to handle new user input.
15:      */
16:     type: "user_interruption";
17: }
````

## File: src/api/resources/empathicVoice/types/UserMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * When provided, the output is a user message.
 7:  */
 8: export interface UserMessage {
 9:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
10:     customSessionId?: string;
11:     /** Indicates if this message was inserted into the conversation as text from a [User Input](/reference/empathic-voice-interface-evi/chat/chat#send.User%20Input.text) message. */
12:     fromText: boolean;
13:     /** Indicates if this message contains an immediate and unfinalized transcript of the user's audio input. If it does, words may be repeated across successive UserMessage messages as our transcription model becomes more confident about what was said with additional context. Interim messages are useful to detect if the user is interrupting during audio playback on the client. Even without a finalized transcription, along with `UserInterrupt` messages, interim `UserMessages` are useful for detecting if the user is interrupting during audio playback on the client, signaling to stop playback in your application. */
14:     interim: boolean;
15:     /** Detected language of the message text. */
16:     language?: string;
17:     /** Transcript of the message. */
18:     message: Hume.empathicVoice.ChatMessage;
19:     /** Inference model results. */
20:     models: Hume.empathicVoice.Inference;
21:     /** Start and End time of user message. */
22:     time: Hume.empathicVoice.MillisecondInterval;
23:     type: "user_message";
24: }
````

## File: src/api/resources/empathicVoice/types/ValidationError.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: export interface ValidationError {
6:     loc: Hume.empathicVoice.ValidationErrorLocItem[];
7:     msg: string;
8:     type: string;
9: }
````

## File: src/api/resources/empathicVoice/types/ValidationErrorLocItem.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type ValidationErrorLocItem = string | number;
````

## File: src/api/resources/empathicVoice/types/VoiceId.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface VoiceId {
 6:     /** The unique ID associated with the **Voice**. */
 7:     id: string;
 8:     /**
 9:      * Specifies the source provider associated with the chosen voice.
10:      *
11:      * - **`HUME_AI`**: Select voices from Hume's [Voice Library](https://app.hume.ai/voices), containing a variety of preset, shared voices.
12:      * - **`CUSTOM_VOICE`**: Select from voices you've personally generated and saved in your account.
13:      *
14:      * If no provider is explicitly set, the default provider is `CUSTOM_VOICE`. When using voices from Hume's **Voice Library**, you must explicitly set the provider to `HUME_AI`.
15:      *
16:      * Preset voices from Hume's **Voice Library** are accessible by all users. In contrast, your custom voices are private and accessible only via requests authenticated with your API key.
17:      */
18:     provider?: Hume.empathicVoice.VoiceProvider;
19: }
````

## File: src/api/resources/empathicVoice/types/VoiceName.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface VoiceName {
 6:     /** The name of a **Voice**. */
 7:     name: string;
 8:     /**
 9:      * Specifies the source provider associated with the chosen voice.
10:      *
11:      * - **`HUME_AI`**: Select voices from Hume's [Voice Library](https://app.hume.ai/voices), containing a variety of preset, shared voices.
12:      * - **`CUSTOM_VOICE`**: Select from voices you've personally generated and saved in your account.
13:      *
14:      * If no provider is explicitly set, the default provider is `CUSTOM_VOICE`. When using voices from Hume's **Voice Library**, you must explicitly set the provider to `HUME_AI`.
15:      *
16:      * Preset voices from Hume's **Voice Library** are accessible by all users. In contrast, your custom voices are private and accessible only via requests authenticated with your API key.
17:      */
18:     provider?: Hume.empathicVoice.VoiceProvider;
19: }
````

## File: src/api/resources/empathicVoice/types/VoiceProvider.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const VoiceProvider = {
4:     HumeAi: "HUME_AI",
5:     CustomVoice: "CUSTOM_VOICE",
6: } as const;
7: export type VoiceProvider = (typeof VoiceProvider)[keyof typeof VoiceProvider];
````

## File: src/api/resources/empathicVoice/types/VoiceRef.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: export type VoiceRef = Hume.empathicVoice.VoiceId | Hume.empathicVoice.VoiceName;
````

## File: src/api/resources/empathicVoice/types/WebhookEvent.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: export type WebhookEvent =
6:     | Hume.empathicVoice.WebhookEventChatStarted
7:     | Hume.empathicVoice.WebhookEventChatEnded
8:     | Hume.empathicVoice.WebhookEventToolCall;
````

## File: src/api/resources/empathicVoice/types/WebhookEventBase.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * Represents the fields common to all webhook events.
 5:  */
 6: export interface WebhookEventBase {
 7:     /** Unique ID of the **Chat Group** associated with the **Chat** session. */
 8:     chatGroupId: string;
 9:     /** Unique ID of the **Chat** session. */
10:     chatId: string;
11:     /** Unique ID of the EVI **Config** used for the session. */
12:     configId?: string;
13: }
````

## File: src/api/resources/empathicVoice/types/WebhookEventChatEnded.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface WebhookEventChatEnded extends Hume.empathicVoice.WebhookEventBase {
 6:     /** Phone number of the caller in E.164 format (e.g., `+12223333333`). This field is included only if the Chat was created via the [Twilio phone calling](/docs/empathic-voice-interface-evi/phone-calling) integration. */
 7:     callerNumber?: string;
 8:     /** User-defined session ID. Relevant only when employing a [custom language model](/docs/empathic-voice-interface-evi/custom-language-model) in the EVI Config. */
 9:     customSessionId?: string;
10:     /** Total duration of the session in seconds. */
11:     durationSeconds: number;
12:     /** Reason for the session's termination. */
13:     endReason: Hume.empathicVoice.WebhookEventChatStatus;
14:     /** Unix timestamp (in milliseconds) indicating when the session ended. */
15:     endTime: number;
16:     /** Always `chat_ended`. */
17:     eventName?: "chat_ended";
18: }
````

## File: src/api/resources/empathicVoice/types/WebhookEventChatStarted.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface WebhookEventChatStarted extends Hume.empathicVoice.WebhookEventBase {
 6:     /** Phone number of the caller in E.164 format (e.g., `+12223333333`). This field is included only if the Chat was created via the [Twilio phone calling](/docs/empathic-voice-interface-evi/phone-calling) integration. */
 7:     callerNumber?: string;
 8:     /** Indicates whether the chat is the first in a new Chat Group (`new_chat_group`) or the continuation of an existing chat group (`resumed_chat_group`). */
 9:     chatStartType: Hume.empathicVoice.WebhookEventChatStartType;
10:     /** User-defined session ID. Relevant only when employing a [custom language model](/docs/empathic-voice-interface-evi/custom-language-model) in the EVI Config. */
11:     customSessionId?: string;
12:     /** Always `chat_started`. */
13:     eventName?: "chat_started";
14:     /** Unix timestamp (in milliseconds) indicating when the session started. */
15:     startTime: number;
16: }
````

## File: src/api/resources/empathicVoice/types/WebhookEventChatStartType.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const WebhookEventChatStartType = {
4:     NewChatGroup: "new_chat_group",
5:     ResumedChatGroup: "resumed_chat_group",
6: } as const;
7: export type WebhookEventChatStartType = (typeof WebhookEventChatStartType)[keyof typeof WebhookEventChatStartType];
````

## File: src/api/resources/empathicVoice/types/WebhookEventChatStatus.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export const WebhookEventChatStatus = {
 4:     Active: "ACTIVE",
 5:     UserEnded: "USER_ENDED",
 6:     UserTimeout: "USER_TIMEOUT",
 7:     InactivityTimeout: "INACTIVITY_TIMEOUT",
 8:     MaxDurationTimeout: "MAX_DURATION_TIMEOUT",
 9:     SilenceTimeout: "SILENCE_TIMEOUT",
10:     Error: "ERROR",
11: } as const;
12: export type WebhookEventChatStatus = (typeof WebhookEventChatStatus)[keyof typeof WebhookEventChatStatus];
````

## File: src/api/resources/empathicVoice/types/WebhookEventToolCall.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface WebhookEventToolCall extends Hume.empathicVoice.WebhookEventBase {
 6:     /** Phone number of the caller in E.164 format (e.g., `+12223333333`). This field is included only if the Chat was created via the [Twilio phone calling](/docs/empathic-voice-interface-evi/phone-calling) integration. */
 7:     callerNumber?: string;
 8:     /** User-defined session ID. Relevant only when employing a [custom language model](/docs/empathic-voice-interface-evi/custom-language-model) in the EVI Config. */
 9:     customSessionId?: string;
10:     /** Always `tool_call`. */
11:     eventName?: "tool_call";
12:     /** Unix timestamp (in milliseconds) indicating when the tool call was triggered. */
13:     timestamp: number;
14:     /** The tool call. */
15:     toolCallMessage: Hume.empathicVoice.ToolCallMessage;
16: }
````

## File: src/api/resources/empathicVoice/types/WebSocketError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * When provided, the output is an error message.
 5:  */
 6: export interface WebSocketError {
 7:     /** Error code. Identifies the type of error encountered. */
 8:     code: string;
 9:     /** Used to manage conversational state, correlate frontend and backend data, and persist conversations across EVI sessions. */
10:     customSessionId?: string;
11:     /** Detailed description of the error. */
12:     message: string;
13:     /** ID of the initiating request. */
14:     requestId?: string;
15:     /** Short, human-readable identifier and description for the error. See a complete list of error slugs on the [Errors page](/docs/resources/errors). */
16:     slug: string;
17:     /**
18:      * The type of message sent through the socket; for a Web Socket Error message, this must be `error`.
19:      *
20:      * This message indicates a disruption in the WebSocket connection, such as an unexpected disconnection, protocol error, or data transmission issue.
21:      */
22:     type: "error";
23: }
````

## File: src/api/resources/empathicVoice/index.ts
````typescript
1: export * from "./client/index.js";
2: export * from "./errors/index.js";
3: export * from "./resources/index.js";
4: export * from "./types/index.js";
````

## File: src/api/resources/expressionMeasurement/client/Client.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type { BaseClientOptions } from "../../../../BaseClient.js";
 4: import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
 5: import { BatchClient } from "../resources/batch/client/Client.js";
 6: 
 7: export declare namespace ExpressionMeasurementClient {
 8:     export type Options = BaseClientOptions;
 9: }
10: 
11: export class ExpressionMeasurementClient {
12:     protected readonly _options: NormalizedClientOptionsWithAuth<ExpressionMeasurementClient.Options>;
13:     protected _batch: BatchClient | undefined;
14: 
15:     constructor(options: ExpressionMeasurementClient.Options = {}) {
16:         this._options = normalizeClientOptionsWithAuth(options);
17:     }
18: 
19:     public get batch(): BatchClient {
20:         return (this._batch ??= new BatchClient(this._options));
21:     }
22: }
````

## File: src/api/resources/expressionMeasurement/client/index.ts
````typescript
1: export {};
````

## File: src/api/resources/expressionMeasurement/resources/batch/client/requests/BatchListJobsRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../index.js";
 4: 
 5: /**
 6:  * @example
 7:  *     {}
 8:  */
 9: export interface BatchListJobsRequest {
10:     /** The maximum number of jobs to include in the response. */
11:     limit?: number;
12:     /**
13:      * Include only jobs of this status in the response. There are four possible statuses:
14:      *
15:      * - `QUEUED`: The job has been received and is waiting to be processed.
16:      *
17:      * - `IN_PROGRESS`: The job is currently being processed.
18:      *
19:      * - `COMPLETED`: The job has finished processing.
20:      *
21:      * - `FAILED`: The job encountered an error and could not be completed successfully.
22:      */
23:     status?: Hume.expressionMeasurement.batch.Status | Hume.expressionMeasurement.batch.Status[];
24:     /** Specify whether to include jobs created before or after a given `timestamp_ms`. */
25:     when?: Hume.expressionMeasurement.batch.When;
26:     /**
27:      * Provide a timestamp in milliseconds to filter jobs.
28:      *
29:      *  When combined with the `when` parameter, you can filter jobs before or after the given timestamp. Defaults to the current Unix timestamp if one is not provided.
30:      */
31:     timestampMs?: number;
32:     /**
33:      * Specify which timestamp to sort the jobs by.
34:      *
35:      * - `created`: Sort jobs by the time of creation, indicated by `created_timestamp_ms`.
36:      *
37:      * - `started`: Sort jobs by the time processing started, indicated by `started_timestamp_ms`.
38:      *
39:      * - `ended`: Sort jobs by the time processing ended, indicated by `ended_timestamp_ms`.
40:      */
41:     sortBy?: Hume.expressionMeasurement.batch.SortBy;
42:     /**
43:      * Specify the order in which to sort the jobs. Defaults to descending order.
44:      *
45:      * - `asc`: Sort in ascending order (chronological, with the oldest records first).
46:      *
47:      * - `desc`: Sort in descending order (reverse-chronological, with the newest records first).
48:      */
49:     direction?: Hume.expressionMeasurement.batch.Direction;
50: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/client/requests/BatchStartInferenceJobFromLocalFileRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as core from "../../../../../../../core/index.js";
 4: import type * as Hume from "../../../../../../index.js";
 5: 
 6: /**
 7:  * @example
 8:  *     {
 9:  *         file: [fs.createReadStream("/path/to/your/file")]
10:  *     }
11:  */
12: export interface BatchStartInferenceJobFromLocalFileRequest {
13:     /** Stringified JSON object containing the inference job configuration. */
14:     json?: Hume.expressionMeasurement.batch.InferenceBaseRequest;
15:     /**
16:      * Local media files (see recommended input filetypes) to be processed.
17:      *
18:      * If you wish to supply more than 100 files, consider providing them as an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`).
19:      */
20:     file: core.file.Uploadable[];
21: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/client/requests/index.ts
````typescript
1: export type { BatchListJobsRequest } from "./BatchListJobsRequest.js";
2: export type { BatchStartInferenceJobFromLocalFileRequest } from "./BatchStartInferenceJobFromLocalFileRequest.js";
````

## File: src/api/resources/expressionMeasurement/resources/batch/client/Client.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
  4: import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
  5: import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
  6: import * as core from "../../../../../../core/index.js";
  7: import { toJson } from "../../../../../../core/json.js";
  8: import * as environments from "../../../../../../environments.js";
  9: import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
 10: import * as errors from "../../../../../../errors/index.js";
 11: import * as serializers from "../../../../../../serialization/index.js";
 12: import type * as Hume from "../../../../../index.js";
 13: 
 14: export declare namespace BatchClient {
 15:     export type Options = BaseClientOptions;
 16: 
 17:     export interface RequestOptions extends BaseRequestOptions {}
 18: }
 19: 
 20: export class BatchClient {
 21:     protected readonly _options: NormalizedClientOptionsWithAuth<BatchClient.Options>;
 22: 
 23:     constructor(options: BatchClient.Options = {}) {
 24:         this._options = normalizeClientOptionsWithAuth(options);
 25:     }
 26: 
 27:     /**
 28:      * Sort and filter jobs.
 29:      *
 30:      * @param {Hume.expressionMeasurement.batch.BatchListJobsRequest} request
 31:      * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
 32:      *
 33:      * @example
 34:      *     await client.expressionMeasurement.batch.listJobs()
 35:      */
 36:     public listJobs(
 37:         request: Hume.expressionMeasurement.batch.BatchListJobsRequest = {},
 38:         requestOptions?: BatchClient.RequestOptions,
 39:     ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.UnionJob[]> {
 40:         return core.HttpResponsePromise.fromPromise(this.__listJobs(request, requestOptions));
 41:     }
 42: 
 43:     private async __listJobs(
 44:         request: Hume.expressionMeasurement.batch.BatchListJobsRequest = {},
 45:         requestOptions?: BatchClient.RequestOptions,
 46:     ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.UnionJob[]>> {
 47:         const { limit, status, when, timestampMs, sortBy, direction } = request;
 48:         const _queryParams: Record<string, unknown> = {
 49:             limit,
 50:             status: Array.isArray(status)
 51:                 ? status.map((item) =>
 52:                       serializers.expressionMeasurement.batch.Status.jsonOrThrow(item, {
 53:                           unrecognizedObjectKeys: "strip",
 54:                           omitUndefined: true,
 55:                       }),
 56:                   )
 57:                 : status != null
 58:                   ? serializers.expressionMeasurement.batch.Status.jsonOrThrow(status, {
 59:                         unrecognizedObjectKeys: "strip",
 60:                         omitUndefined: true,
 61:                     })
 62:                   : undefined,
 63:             when:
 64:                 when != null
 65:                     ? serializers.expressionMeasurement.batch.When.jsonOrThrow(when, {
 66:                           unrecognizedObjectKeys: "strip",
 67:                           omitUndefined: true,
 68:                       })
 69:                     : undefined,
 70:             timestamp_ms: timestampMs,
 71:             sort_by:
 72:                 sortBy != null
 73:                     ? serializers.expressionMeasurement.batch.SortBy.jsonOrThrow(sortBy, {
 74:                           unrecognizedObjectKeys: "strip",
 75:                           omitUndefined: true,
 76:                       })
 77:                     : undefined,
 78:             direction:
 79:                 direction != null
 80:                     ? serializers.expressionMeasurement.batch.Direction.jsonOrThrow(direction, {
 81:                           unrecognizedObjectKeys: "strip",
 82:                           omitUndefined: true,
 83:                       })
 84:                     : undefined,
 85:         };
 86:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
 87:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
 88:             _authRequest.headers,
 89:             this._options?.headers,
 90:             requestOptions?.headers,
 91:         );
 92:         const _response = await (this._options.fetcher ?? core.fetcher)({
 93:             url: core.url.join(
 94:                 (await core.Supplier.get(this._options.baseUrl)) ??
 95:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
 96:                 "v0/batch/jobs",
 97:             ),
 98:             method: "GET",
 99:             headers: _headers,
100:             queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
101:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
102:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
103:             abortSignal: requestOptions?.abortSignal,
104:             fetchFn: this._options?.fetch,
105:             logging: this._options.logging,
106:         });
107:         if (_response.ok) {
108:             return {
109:                 data: serializers.expressionMeasurement.batch.listJobs.Response.parseOrThrow(_response.body, {
110:                     unrecognizedObjectKeys: "passthrough",
111:                     allowUnrecognizedUnionMembers: true,
112:                     allowUnrecognizedEnumValues: true,
113:                     skipValidation: true,
114:                     breadcrumbsPrefix: ["response"],
115:                 }),
116:                 rawResponse: _response.rawResponse,
117:             };
118:         }
119: 
120:         if (_response.error.reason === "status-code") {
121:             throw new errors.HumeError({
122:                 statusCode: _response.error.statusCode,
123:                 body: _response.error.body,
124:                 rawResponse: _response.rawResponse,
125:             });
126:         }
127: 
128:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/batch/jobs");
129:     }
130: 
131:     /**
132:      * Start a new measurement inference job.
133:      *
134:      * @param {Hume.expressionMeasurement.batch.InferenceBaseRequest} request
135:      * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
136:      *
137:      * @example
138:      *     await client.expressionMeasurement.batch.startInferenceJob({
139:      *         urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
140:      *         notify: true
141:      *     })
142:      */
143:     public startInferenceJob(
144:         request: Hume.expressionMeasurement.batch.InferenceBaseRequest,
145:         requestOptions?: BatchClient.RequestOptions,
146:     ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.JobId> {
147:         return core.HttpResponsePromise.fromPromise(this.__startInferenceJob(request, requestOptions));
148:     }
149: 
150:     private async __startInferenceJob(
151:         request: Hume.expressionMeasurement.batch.InferenceBaseRequest,
152:         requestOptions?: BatchClient.RequestOptions,
153:     ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.JobId>> {
154:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
155:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
156:             _authRequest.headers,
157:             this._options?.headers,
158:             requestOptions?.headers,
159:         );
160:         const _response = await (this._options.fetcher ?? core.fetcher)({
161:             url: core.url.join(
162:                 (await core.Supplier.get(this._options.baseUrl)) ??
163:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
164:                 "v0/batch/jobs",
165:             ),
166:             method: "POST",
167:             headers: _headers,
168:             contentType: "application/json",
169:             queryParameters: requestOptions?.queryParams,
170:             requestType: "json",
171:             body: serializers.expressionMeasurement.batch.InferenceBaseRequest.jsonOrThrow(request, {
172:                 unrecognizedObjectKeys: "strip",
173:                 omitUndefined: true,
174:             }),
175:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
176:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
177:             abortSignal: requestOptions?.abortSignal,
178:             fetchFn: this._options?.fetch,
179:             logging: this._options.logging,
180:         });
181:         if (_response.ok) {
182:             return {
183:                 data: serializers.expressionMeasurement.batch.JobId.parseOrThrow(_response.body, {
184:                     unrecognizedObjectKeys: "passthrough",
185:                     allowUnrecognizedUnionMembers: true,
186:                     allowUnrecognizedEnumValues: true,
187:                     skipValidation: true,
188:                     breadcrumbsPrefix: ["response"],
189:                 }),
190:                 rawResponse: _response.rawResponse,
191:             };
192:         }
193: 
194:         if (_response.error.reason === "status-code") {
195:             throw new errors.HumeError({
196:                 statusCode: _response.error.statusCode,
197:                 body: _response.error.body,
198:                 rawResponse: _response.rawResponse,
199:             });
200:         }
201: 
202:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/batch/jobs");
203:     }
204: 
205:     /**
206:      * Get the request details and state of a given job.
207:      *
208:      * @param {string} id - The unique identifier for the job.
209:      * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
210:      *
211:      * @example
212:      *     await client.expressionMeasurement.batch.getJobDetails("job_id")
213:      */
214:     public getJobDetails(
215:         id: string,
216:         requestOptions?: BatchClient.RequestOptions,
217:     ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.UnionJob> {
218:         return core.HttpResponsePromise.fromPromise(this.__getJobDetails(id, requestOptions));
219:     }
220: 
221:     private async __getJobDetails(
222:         id: string,
223:         requestOptions?: BatchClient.RequestOptions,
224:     ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.UnionJob>> {
225:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
226:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
227:             _authRequest.headers,
228:             this._options?.headers,
229:             requestOptions?.headers,
230:         );
231:         const _response = await (this._options.fetcher ?? core.fetcher)({
232:             url: core.url.join(
233:                 (await core.Supplier.get(this._options.baseUrl)) ??
234:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
235:                 `v0/batch/jobs/${core.url.encodePathParam(id)}`,
236:             ),
237:             method: "GET",
238:             headers: _headers,
239:             queryParameters: requestOptions?.queryParams,
240:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
241:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
242:             abortSignal: requestOptions?.abortSignal,
243:             fetchFn: this._options?.fetch,
244:             logging: this._options.logging,
245:         });
246:         if (_response.ok) {
247:             return {
248:                 data: serializers.expressionMeasurement.batch.UnionJob.parseOrThrow(_response.body, {
249:                     unrecognizedObjectKeys: "passthrough",
250:                     allowUnrecognizedUnionMembers: true,
251:                     allowUnrecognizedEnumValues: true,
252:                     skipValidation: true,
253:                     breadcrumbsPrefix: ["response"],
254:                 }),
255:                 rawResponse: _response.rawResponse,
256:             };
257:         }
258: 
259:         if (_response.error.reason === "status-code") {
260:             throw new errors.HumeError({
261:                 statusCode: _response.error.statusCode,
262:                 body: _response.error.body,
263:                 rawResponse: _response.rawResponse,
264:             });
265:         }
266: 
267:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/batch/jobs/{id}");
268:     }
269: 
270:     /**
271:      * Get the JSON predictions of a completed inference job.
272:      *
273:      * @param {string} id - The unique identifier for the job.
274:      * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
275:      *
276:      * @example
277:      *     await client.expressionMeasurement.batch.getJobPredictions("job_id")
278:      */
279:     public getJobPredictions(
280:         id: string,
281:         requestOptions?: BatchClient.RequestOptions,
282:     ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.UnionPredictResult[]> {
283:         return core.HttpResponsePromise.fromPromise(this.__getJobPredictions(id, requestOptions));
284:     }
285: 
286:     private async __getJobPredictions(
287:         id: string,
288:         requestOptions?: BatchClient.RequestOptions,
289:     ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.UnionPredictResult[]>> {
290:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
291:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
292:             _authRequest.headers,
293:             this._options?.headers,
294:             requestOptions?.headers,
295:         );
296:         const _response = await (this._options.fetcher ?? core.fetcher)({
297:             url: core.url.join(
298:                 (await core.Supplier.get(this._options.baseUrl)) ??
299:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
300:                 `v0/batch/jobs/${core.url.encodePathParam(id)}/predictions`,
301:             ),
302:             method: "GET",
303:             headers: _headers,
304:             queryParameters: requestOptions?.queryParams,
305:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
306:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
307:             abortSignal: requestOptions?.abortSignal,
308:             fetchFn: this._options?.fetch,
309:             logging: this._options.logging,
310:         });
311:         if (_response.ok) {
312:             return {
313:                 data: serializers.expressionMeasurement.batch.getJobPredictions.Response.parseOrThrow(_response.body, {
314:                     unrecognizedObjectKeys: "passthrough",
315:                     allowUnrecognizedUnionMembers: true,
316:                     allowUnrecognizedEnumValues: true,
317:                     skipValidation: true,
318:                     breadcrumbsPrefix: ["response"],
319:                 }),
320:                 rawResponse: _response.rawResponse,
321:             };
322:         }
323: 
324:         if (_response.error.reason === "status-code") {
325:             throw new errors.HumeError({
326:                 statusCode: _response.error.statusCode,
327:                 body: _response.error.body,
328:                 rawResponse: _response.rawResponse,
329:             });
330:         }
331: 
332:         return handleNonStatusCodeError(
333:             _response.error,
334:             _response.rawResponse,
335:             "GET",
336:             "/v0/batch/jobs/{id}/predictions",
337:         );
338:     }
339: 
340:     /**
341:      * Get the artifacts ZIP of a completed inference job.
342:      */
343:     public getJobArtifacts(
344:         id: string,
345:         requestOptions?: BatchClient.RequestOptions,
346:     ): core.HttpResponsePromise<core.BinaryResponse> {
347:         return core.HttpResponsePromise.fromPromise(this.__getJobArtifacts(id, requestOptions));
348:     }
349: 
350:     private async __getJobArtifacts(
351:         id: string,
352:         requestOptions?: BatchClient.RequestOptions,
353:     ): Promise<core.WithRawResponse<core.BinaryResponse>> {
354:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
355:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
356:             _authRequest.headers,
357:             this._options?.headers,
358:             requestOptions?.headers,
359:         );
360:         const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
361:             url: core.url.join(
362:                 (await core.Supplier.get(this._options.baseUrl)) ??
363:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
364:                 `v0/batch/jobs/${core.url.encodePathParam(id)}/artifacts`,
365:             ),
366:             method: "GET",
367:             headers: _headers,
368:             queryParameters: requestOptions?.queryParams,
369:             responseType: "binary-response",
370:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
371:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
372:             abortSignal: requestOptions?.abortSignal,
373:             fetchFn: this._options?.fetch,
374:             logging: this._options.logging,
375:         });
376:         if (_response.ok) {
377:             return { data: _response.body, rawResponse: _response.rawResponse };
378:         }
379: 
380:         if (_response.error.reason === "status-code") {
381:             throw new errors.HumeError({
382:                 statusCode: _response.error.statusCode,
383:                 body: _response.error.body,
384:                 rawResponse: _response.rawResponse,
385:             });
386:         }
387: 
388:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/batch/jobs/{id}/artifacts");
389:     }
390: 
391:     /**
392:      * Start a new batch inference job.
393:      *
394:      * @param {Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest} request
395:      * @param {BatchClient.RequestOptions} requestOptions - Request-specific configuration.
396:      *
397:      * @example
398:      *     import { createReadStream } from "fs";
399:      *     await client.expressionMeasurement.batch.startInferenceJobFromLocalFile({
400:      *         file: [fs.createReadStream("/path/to/your/file")]
401:      *     })
402:      */
403:     public startInferenceJobFromLocalFile(
404:         request: Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest,
405:         requestOptions?: BatchClient.RequestOptions,
406:     ): core.HttpResponsePromise<Hume.expressionMeasurement.batch.JobId> {
407:         return core.HttpResponsePromise.fromPromise(this.__startInferenceJobFromLocalFile(request, requestOptions));
408:     }
409: 
410:     private async __startInferenceJobFromLocalFile(
411:         request: Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest,
412:         requestOptions?: BatchClient.RequestOptions,
413:     ): Promise<core.WithRawResponse<Hume.expressionMeasurement.batch.JobId>> {
414:         const _body = await core.newFormData();
415:         if (request.json != null) {
416:             _body.append(
417:                 "json",
418:                 toJson(
419:                     serializers.expressionMeasurement.batch.InferenceBaseRequest.jsonOrThrow(request.json, {
420:                         unrecognizedObjectKeys: "strip",
421:                         omitUndefined: true,
422:                     }),
423:                 ),
424:             );
425:         }
426: 
427:         for (const _file of request.file) {
428:             await _body.appendFile("file", _file);
429:         }
430: 
431:         const _maybeEncodedRequest = await _body.getRequest();
432:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
433:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
434:             _authRequest.headers,
435:             this._options?.headers,
436:             mergeOnlyDefinedHeaders({ ..._maybeEncodedRequest.headers }),
437:             requestOptions?.headers,
438:         );
439:         const _response = await (this._options.fetcher ?? core.fetcher)({
440:             url: core.url.join(
441:                 (await core.Supplier.get(this._options.baseUrl)) ??
442:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
443:                 "v0/batch/jobs",
444:             ),
445:             method: "POST",
446:             headers: _headers,
447:             queryParameters: requestOptions?.queryParams,
448:             requestType: "file",
449:             duplex: _maybeEncodedRequest.duplex,
450:             body: _maybeEncodedRequest.body,
451:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
452:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
453:             abortSignal: requestOptions?.abortSignal,
454:             fetchFn: this._options?.fetch,
455:             logging: this._options.logging,
456:         });
457:         if (_response.ok) {
458:             return {
459:                 data: serializers.expressionMeasurement.batch.JobId.parseOrThrow(_response.body, {
460:                     unrecognizedObjectKeys: "passthrough",
461:                     allowUnrecognizedUnionMembers: true,
462:                     allowUnrecognizedEnumValues: true,
463:                     skipValidation: true,
464:                     breadcrumbsPrefix: ["response"],
465:                 }),
466:                 rawResponse: _response.rawResponse,
467:             };
468:         }
469: 
470:         if (_response.error.reason === "status-code") {
471:             throw new errors.HumeError({
472:                 statusCode: _response.error.statusCode,
473:                 body: _response.error.body,
474:                 rawResponse: _response.rawResponse,
475:             });
476:         }
477: 
478:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/batch/jobs");
479:     }
480: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/client/index.ts
````typescript
1: export * from "./requests/index.js";
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Alternative.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type Alternative = "language_only";
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Bcp47Tag.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export const Bcp47Tag = {
 4:     Zh: "zh",
 5:     Da: "da",
 6:     Nl: "nl",
 7:     En: "en",
 8:     EnAu: "en-AU",
 9:     EnIn: "en-IN",
10:     EnNz: "en-NZ",
11:     EnGb: "en-GB",
12:     Fr: "fr",
13:     FrCa: "fr-CA",
14:     De: "de",
15:     Hi: "hi",
16:     HiLatn: "hi-Latn",
17:     Id: "id",
18:     It: "it",
19:     Ja: "ja",
20:     Ko: "ko",
21:     No: "no",
22:     Pl: "pl",
23:     Pt: "pt",
24:     PtBr: "pt-BR",
25:     PtPt: "pt-PT",
26:     Ru: "ru",
27:     Es: "es",
28:     Es419: "es-419",
29:     Sv: "sv",
30:     Ta: "ta",
31:     Tr: "tr",
32:     Uk: "uk",
33: } as const;
34: export type Bcp47Tag = (typeof Bcp47Tag)[keyof typeof Bcp47Tag];
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/BoundingBox.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * A bounding box around a face.
 5:  */
 6: export interface BoundingBox {
 7:     /** x-coordinate of bounding box top left corner. */
 8:     x: number;
 9:     /** y-coordinate of bounding box top left corner. */
10:     y: number;
11:     /** Bounding box width. */
12:     w: number;
13:     /** Bounding box height. */
14:     h: number;
15: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/BurstPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface BurstPrediction {
 6:     time: Hume.expressionMeasurement.batch.TimeInterval;
 7:     /** A high-dimensional embedding in emotion space. */
 8:     emotions: Hume.expressionMeasurement.batch.EmotionScore[];
 9:     /** Modality-specific descriptive features and their scores. */
10:     descriptions: Hume.expressionMeasurement.batch.DescriptionsScore[];
11: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Classification.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type Classification = Record<string, unknown>;
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/CompletedEmbeddingGeneration.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export interface CompletedEmbeddingGeneration {
 4:     /** When this job was created (Unix timestamp in milliseconds). */
 5:     createdTimestampMs: number;
 6:     /** When this job started (Unix timestamp in milliseconds). */
 7:     startedTimestampMs: number;
 8:     /** When this job ended (Unix timestamp in milliseconds). */
 9:     endedTimestampMs: number;
10: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/CompletedInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export interface CompletedInference {
 4:     /** When this job was created (Unix timestamp in milliseconds). */
 5:     createdTimestampMs: number;
 6:     /** When this job started (Unix timestamp in milliseconds). */
 7:     startedTimestampMs: number;
 8:     /** When this job ended (Unix timestamp in milliseconds). */
 9:     endedTimestampMs: number;
10:     /** The number of predictions that were generated by this job. */
11:     numPredictions: number;
12:     /** The number of errors that occurred while running this job. */
13:     numErrors: number;
14: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/CompletedState.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface CompletedState extends Hume.expressionMeasurement.batch.CompletedInference {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/CompletedTlInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export interface CompletedTlInference {
 4:     /** When this job was created (Unix timestamp in milliseconds). */
 5:     createdTimestampMs: number;
 6:     /** When this job started (Unix timestamp in milliseconds). */
 7:     startedTimestampMs: number;
 8:     /** When this job ended (Unix timestamp in milliseconds). */
 9:     endedTimestampMs: number;
10:     /** The number of predictions that were generated by this job. */
11:     numPredictions: number;
12:     /** The number of errors that occurred while running this job. */
13:     numErrors: number;
14: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/CompletedTraining.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface CompletedTraining {
 6:     /** When this job was created (Unix timestamp in milliseconds). */
 7:     createdTimestampMs: number;
 8:     /** When this job started (Unix timestamp in milliseconds). */
 9:     startedTimestampMs: number;
10:     /** When this job ended (Unix timestamp in milliseconds). */
11:     endedTimestampMs: number;
12:     customModel: Hume.expressionMeasurement.batch.TrainingCustomModel;
13:     alternatives?: Record<string, Hume.expressionMeasurement.batch.TrainingCustomModel>;
14: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModel.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export type CustomModel =
6:     | Hume.expressionMeasurement.batch.CustomModelId
7:     | Hume.expressionMeasurement.batch.CustomModelVersionId;
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModelId.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface CustomModelId {
4:     id: string;
5: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModelPrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface CustomModelPrediction {
4:     output: Record<string, number>;
5:     error: string;
6:     taskType: string;
7: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModelRequest.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface CustomModelRequest {
6:     name: string;
7:     description?: string;
8:     tags?: Hume.expressionMeasurement.batch.Tag[];
9: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModelsInferenceJob.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface CustomModelsInferenceJob extends Hume.expressionMeasurement.batch.JobTlInference {
6:     type: string;
7: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModelsTrainingJob.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface CustomModelsTrainingJob extends Hume.expressionMeasurement.batch.JobTraining {
6:     type: string;
7: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/CustomModelVersionId.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface CustomModelVersionId {
4:     versionId: string;
5: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Dataset.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export type Dataset = Hume.expressionMeasurement.batch.DatasetId | Hume.expressionMeasurement.batch.DatasetVersionId;
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/DatasetId.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface DatasetId {
4:     id: string;
5: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/DatasetVersionId.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface DatasetVersionId {
4:     versionId: string;
5: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/DescriptionsScore.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface DescriptionsScore {
4:     /** Name of the descriptive feature being expressed. */
5:     name: string;
6:     /** Embedding value for the descriptive feature being expressed. */
7:     score: number;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Direction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const Direction = {
4:     Asc: "asc",
5:     Desc: "desc",
6: } as const;
7: export type Direction = (typeof Direction)[keyof typeof Direction];
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/EmbeddingGenerationBaseRequest.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface EmbeddingGenerationBaseRequest {
6:     /** File ID and File URL pairs for an asset registry file */
7:     registryFileDetails?: Hume.expressionMeasurement.batch.RegistryFileDetail[];
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/EmbeddingGenerationJob.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface EmbeddingGenerationJob extends Hume.expressionMeasurement.batch.JobEmbeddingGeneration {
6:     type: string;
7: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/EmotionScore.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface EmotionScore {
4:     /** Name of the emotion being expressed. */
5:     name: string;
6:     /** Embedding value for the emotion being expressed. */
7:     score: number;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Error_.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface Error_ {
4:     /** An error message. */
5:     message: string;
6:     /** A file path relative to the top level source URL or file. */
7:     file: string;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/EvaluationArgs.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface EvaluationArgs {
6:     validation?: Hume.expressionMeasurement.batch.ValidationArgs;
7: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Face.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: /**
 6:  * The Facial Emotional Expression model analyzes human facial expressions in images and videos. Results will be provided per frame for video files.
 7:  *
 8:  * Recommended input file types: `.png`, `.jpeg`, `.mp4`
 9:  */
10: export interface Face {
11:     /** Number of frames per second to process. Other frames will be omitted from the response. Set to `0` to process every frame. */
12:     fpsPred?: number;
13:     /** Face detection probability threshold. Faces detected with a probability less than this threshold will be omitted from the response. */
14:     probThreshold?: number;
15:     /** Whether to return identifiers for faces across frames. If `true`, unique identifiers will be assigned to face bounding boxes to differentiate different faces. If `false`, all faces will be tagged with an `unknown` ID. */
16:     identifyFaces?: boolean;
17:     /** Minimum bounding box side length in pixels to treat as a face. Faces detected with a bounding box side length in pixels less than this threshold will be omitted from the response. */
18:     minFaceSize?: number;
19:     facs?: Hume.expressionMeasurement.batch.Unconfigurable;
20:     descriptions?: Hume.expressionMeasurement.batch.Unconfigurable;
21:     /** Whether to extract and save the detected faces in the artifacts zip created by each job. */
22:     saveFaces?: boolean;
23: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/FacemeshPrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface FacemeshPrediction {
6:     /** A high-dimensional embedding in emotion space. */
7:     emotions: Hume.expressionMeasurement.batch.EmotionScore[];
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/FacePrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface FacePrediction {
 6:     /** Frame number */
 7:     frame: number;
 8:     /** Time in seconds when face detection occurred. */
 9:     time: number;
10:     /** The predicted probability that a detected face was actually a face. */
11:     prob: number;
12:     box: Hume.expressionMeasurement.batch.BoundingBox;
13:     /** A high-dimensional embedding in emotion space. */
14:     emotions: Hume.expressionMeasurement.batch.EmotionScore[];
15:     /** FACS 2.0 features and their scores. */
16:     facs?: Hume.expressionMeasurement.batch.FacsScore[];
17:     /** Modality-specific descriptive features and their scores. */
18:     descriptions?: Hume.expressionMeasurement.batch.DescriptionsScore[];
19: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/FacsScore.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface FacsScore {
4:     /** Name of the FACS 2.0 feature being expressed. */
5:     name: string;
6:     /** Embedding value for the FACS 2.0 feature being expressed. */
7:     score: number;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Failed.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export interface Failed {
 4:     /** When this job was created (Unix timestamp in milliseconds). */
 5:     createdTimestampMs: number;
 6:     /** When this job started (Unix timestamp in milliseconds). */
 7:     startedTimestampMs: number;
 8:     /** When this job ended (Unix timestamp in milliseconds). */
 9:     endedTimestampMs: number;
10:     /** An error message. */
11:     message: string;
12: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/FailedState.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface FailedState extends Hume.expressionMeasurement.batch.Failed {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/File_.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * The list of files submitted for analysis.
 5:  */
 6: export interface File_ {
 7:     /** The name of the file. */
 8:     filename?: string;
 9:     /** The content type of the file. */
10:     contentType?: string;
11:     /** The MD5 checksum of the file. */
12:     md5Sum: string;
13: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Granularity.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * The granularity at which to generate predictions. The `granularity` field is ignored if transcription is not enabled or if the `window` field has been set.
 5:  *
 6:  * - `word`: At the word level, our model provides a separate output for each word, offering the most granular insight into emotional expression during speech.
 7:  *
 8:  * - `sentence`: At the sentence level of granularity, we annotate the emotional tone of each spoken sentence with our Prosody and Emotional Language models.
 9:  *
10:  * - `utterance`: Utterance-level granularity is between word- and sentence-level. It takes into account natural pauses or breaks in speech, providing more rapidly updated measures of emotional expression within a flowing conversation. For text inputs, utterance-level granularity will produce results identical to sentence-level granularity.
11:  *
12:  * - `conversational_turn`: Conversational turn-level granularity provides a distinct output for each change in speaker. It captures the full sequence of words and sentences spoken uninterrupted by each person. This approach provides a higher-level view of the emotional dynamics in a multi-participant dialogue. For text inputs, specifying conversational turn-level granularity for our Emotional Language model will produce results for the entire passage.
13:  */
14: export const Granularity = {
15:     Word: "word",
16:     Sentence: "sentence",
17:     Utterance: "utterance",
18:     ConversationalTurn: "conversational_turn",
19: } as const;
20: export type Granularity = (typeof Granularity)[keyof typeof Granularity];
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsBurstPrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface GroupedPredictionsBurstPrediction {
6:     /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
7:     id: string;
8:     predictions: Hume.expressionMeasurement.batch.BurstPrediction[];
9: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsFacemeshPrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface GroupedPredictionsFacemeshPrediction {
6:     /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
7:     id: string;
8:     predictions: Hume.expressionMeasurement.batch.FacemeshPrediction[];
9: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsFacePrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface GroupedPredictionsFacePrediction {
6:     /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
7:     id: string;
8:     predictions: Hume.expressionMeasurement.batch.FacePrediction[];
9: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsLanguagePrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface GroupedPredictionsLanguagePrediction {
6:     /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
7:     id: string;
8:     predictions: Hume.expressionMeasurement.batch.LanguagePrediction[];
9: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsNerPrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface GroupedPredictionsNerPrediction {
6:     /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
7:     id: string;
8:     predictions: Hume.expressionMeasurement.batch.NerPrediction[];
9: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsProsodyPrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface GroupedPredictionsProsodyPrediction {
6:     /** An automatically generated label to identify individuals in your media file. Will be `unknown` if you have chosen to disable identification, or if the model is unable to distinguish between individuals. */
7:     id: string;
8:     predictions: Hume.expressionMeasurement.batch.ProsodyPrediction[];
9: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/index.ts
````typescript
  1: export * from "./Alternative.js";
  2: export * from "./Bcp47Tag.js";
  3: export * from "./BoundingBox.js";
  4: export * from "./BurstPrediction.js";
  5: export * from "./Classification.js";
  6: export * from "./CompletedEmbeddingGeneration.js";
  7: export * from "./CompletedInference.js";
  8: export * from "./CompletedState.js";
  9: export * from "./CompletedTlInference.js";
 10: export * from "./CompletedTraining.js";
 11: export * from "./CustomModel.js";
 12: export * from "./CustomModelId.js";
 13: export * from "./CustomModelPrediction.js";
 14: export * from "./CustomModelRequest.js";
 15: export * from "./CustomModelsInferenceJob.js";
 16: export * from "./CustomModelsTrainingJob.js";
 17: export * from "./CustomModelVersionId.js";
 18: export * from "./Dataset.js";
 19: export * from "./DatasetId.js";
 20: export * from "./DatasetVersionId.js";
 21: export * from "./DescriptionsScore.js";
 22: export * from "./Direction.js";
 23: export * from "./EmbeddingGenerationBaseRequest.js";
 24: export * from "./EmbeddingGenerationJob.js";
 25: export * from "./EmotionScore.js";
 26: export * from "./Error_.js";
 27: export * from "./EvaluationArgs.js";
 28: export * from "./Face.js";
 29: export * from "./FacemeshPrediction.js";
 30: export * from "./FacePrediction.js";
 31: export * from "./FacsScore.js";
 32: export * from "./Failed.js";
 33: export * from "./FailedState.js";
 34: export * from "./File_.js";
 35: export * from "./Granularity.js";
 36: export * from "./GroupedPredictionsBurstPrediction.js";
 37: export * from "./GroupedPredictionsFacemeshPrediction.js";
 38: export * from "./GroupedPredictionsFacePrediction.js";
 39: export * from "./GroupedPredictionsLanguagePrediction.js";
 40: export * from "./GroupedPredictionsNerPrediction.js";
 41: export * from "./GroupedPredictionsProsodyPrediction.js";
 42: export * from "./InferenceBaseRequest.js";
 43: export * from "./InferenceJob.js";
 44: export * from "./InferencePrediction.js";
 45: export * from "./InferenceRequest.js";
 46: export * from "./InferenceResults.js";
 47: export * from "./InferenceSourcePredictResult.js";
 48: export * from "./InProgress.js";
 49: export * from "./InProgressState.js";
 50: export * from "./JobEmbeddingGeneration.js";
 51: export * from "./JobId.js";
 52: export * from "./JobInference.js";
 53: export * from "./JobTlInference.js";
 54: export * from "./JobTraining.js";
 55: export * from "./Language.js";
 56: export * from "./LanguagePrediction.js";
 57: export * from "./Models.js";
 58: export * from "./ModelsPredictions.js";
 59: export * from "./Ner.js";
 60: export * from "./NerPrediction.js";
 61: export * from "./Null.js";
 62: export * from "./PositionInterval.js";
 63: export * from "./PredictionsOptionalNullBurstPrediction.js";
 64: export * from "./PredictionsOptionalNullFacemeshPrediction.js";
 65: export * from "./PredictionsOptionalNullFacePrediction.js";
 66: export * from "./PredictionsOptionalTranscriptionMetadataLanguagePrediction.js";
 67: export * from "./PredictionsOptionalTranscriptionMetadataNerPrediction.js";
 68: export * from "./PredictionsOptionalTranscriptionMetadataProsodyPrediction.js";
 69: export * from "./Prosody.js";
 70: export * from "./ProsodyPrediction.js";
 71: export * from "./Queued.js";
 72: export * from "./QueuedState.js";
 73: export * from "./RegistryFileDetail.js";
 74: export * from "./Regression.js";
 75: export * from "./SentimentScore.js";
 76: export * from "./SortBy.js";
 77: export * from "./Source.js";
 78: export * from "./SourceFile.js";
 79: export * from "./SourceTextSource.js";
 80: export * from "./SourceUrl.js";
 81: export * from "./StateEmbeddingGeneration.js";
 82: export * from "./StateEmbeddingGenerationCompletedEmbeddingGeneration.js";
 83: export * from "./StateEmbeddingGenerationFailed.js";
 84: export * from "./StateEmbeddingGenerationInProgress.js";
 85: export * from "./StateEmbeddingGenerationQueued.js";
 86: export * from "./StateInference.js";
 87: export * from "./StateTlInference.js";
 88: export * from "./StateTlInferenceCompletedTlInference.js";
 89: export * from "./StateTlInferenceFailed.js";
 90: export * from "./StateTlInferenceInProgress.js";
 91: export * from "./StateTlInferenceQueued.js";
 92: export * from "./StateTraining.js";
 93: export * from "./StateTrainingCompletedTraining.js";
 94: export * from "./StateTrainingFailed.js";
 95: export * from "./StateTrainingInProgress.js";
 96: export * from "./StateTrainingQueued.js";
 97: export * from "./Status.js";
 98: export * from "./Tag.js";
 99: export * from "./Target.js";
100: export * from "./Task.js";
101: export * from "./TaskClassification.js";
102: export * from "./TaskRegression.js";
103: export * from "./TextSource.js";
104: export * from "./TimeInterval.js";
105: export * from "./TlInferenceBaseRequest.js";
106: export * from "./TlInferencePrediction.js";
107: export * from "./TlInferenceResults.js";
108: export * from "./TlInferenceSourcePredictResult.js";
109: export * from "./ToxicityScore.js";
110: export * from "./TrainingBaseRequest.js";
111: export * from "./TrainingCustomModel.js";
112: export * from "./Transcription.js";
113: export * from "./TranscriptionMetadata.js";
114: export * from "./Type.js";
115: export * from "./Unconfigurable.js";
116: export * from "./UnionJob.js";
117: export * from "./UnionPredictResult.js";
118: export * from "./Url.js";
119: export * from "./ValidationArgs.js";
120: export * from "./When.js";
121: export * from "./Window.js";
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/InferenceBaseRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface InferenceBaseRequest {
 6:     /**
 7:      * Specify the models to use for inference.
 8:      *
 9:      * If this field is not explicitly set, then all models will run by default.
10:      */
11:     models?: Hume.expressionMeasurement.batch.Models;
12:     transcription?: Hume.expressionMeasurement.batch.Transcription;
13:     /**
14:      * URLs to the media files to be processed. Each must be a valid public URL to a media file (see recommended input filetypes) or an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`) of media files.
15:      *
16:      * If you wish to supply more than 100 URLs, consider providing them as an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`).
17:      */
18:     urls?: string[];
19:     /** Text supplied directly to our Emotional Language and NER models for analysis. */
20:     text?: string[];
21:     /** If provided, a `POST` request will be made to the URL with the generated predictions on completion or the error message on failure. */
22:     callbackUrl?: string;
23:     /** Whether to send an email notification to the user upon job completion/failure. */
24:     notify?: boolean;
25: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/InferenceJob.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface InferenceJob extends Hume.expressionMeasurement.batch.JobInference {
 6:     /**
 7:      * Denotes the job type.
 8:      *
 9:      * Jobs created with the Expression Measurement API will have this field set to `INFERENCE`.
10:      */
11:     type: string;
12: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/InferencePrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface InferencePrediction {
6:     /** A file path relative to the top level source URL or file. */
7:     file: string;
8:     models: Hume.expressionMeasurement.batch.ModelsPredictions;
9: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/InferenceRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface InferenceRequest {
 6:     models?: Hume.expressionMeasurement.batch.Models;
 7:     transcription?: Hume.expressionMeasurement.batch.Transcription;
 8:     /**
 9:      * URLs to the media files to be processed. Each must be a valid public URL to a media file (see recommended input filetypes) or an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`) of media files.
10:      *
11:      * If you wish to supply more than 100 URLs, consider providing them as an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`).
12:      */
13:     urls?: string[];
14:     /** Text to supply directly to our language and NER models. */
15:     text?: string[];
16:     /** If provided, a `POST` request will be made to the URL with the generated predictions on completion or the error message on failure. */
17:     callbackUrl?: string;
18:     /** Whether to send an email notification to the user upon job completion/failure. */
19:     notify?: boolean;
20:     files: Hume.expressionMeasurement.batch.File_[];
21: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/InferenceResults.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface InferenceResults {
6:     predictions: Hume.expressionMeasurement.batch.InferencePrediction[];
7:     errors: Hume.expressionMeasurement.batch.Error_[];
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/InferenceSourcePredictResult.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface InferenceSourcePredictResult {
 6:     source: Hume.expressionMeasurement.batch.Source;
 7:     results?: Hume.expressionMeasurement.batch.InferenceResults;
 8:     /** An error message. */
 9:     error?: string;
10: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/InProgress.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface InProgress {
4:     /** When this job was created (Unix timestamp in milliseconds). */
5:     createdTimestampMs: number;
6:     /** When this job started (Unix timestamp in milliseconds). */
7:     startedTimestampMs: number;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/InProgressState.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface InProgressState extends Hume.expressionMeasurement.batch.InProgress {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/JobEmbeddingGeneration.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface JobEmbeddingGeneration {
 6:     /** The ID associated with this job. */
 7:     jobId: string;
 8:     userId: string;
 9:     request: Hume.expressionMeasurement.batch.EmbeddingGenerationBaseRequest;
10:     state: Hume.expressionMeasurement.batch.StateEmbeddingGeneration;
11: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/JobId.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface JobId {
4:     /** The ID of the started job. */
5:     jobId: string;
6: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/JobInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface JobInference {
 6:     /** The ID associated with this job. */
 7:     jobId: string;
 8:     /** The request that initiated the job. */
 9:     request: Hume.expressionMeasurement.batch.InferenceRequest;
10:     /** The current state of the job. */
11:     state: Hume.expressionMeasurement.batch.StateInference;
12: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/JobTlInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface JobTlInference {
 6:     /** The ID associated with this job. */
 7:     jobId: string;
 8:     userId: string;
 9:     request: Hume.expressionMeasurement.batch.TlInferenceBaseRequest;
10:     state: Hume.expressionMeasurement.batch.StateTlInference;
11: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/JobTraining.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface JobTraining {
 6:     /** The ID associated with this job. */
 7:     jobId: string;
 8:     userId: string;
 9:     request: Hume.expressionMeasurement.batch.TrainingBaseRequest;
10:     state: Hume.expressionMeasurement.batch.StateTraining;
11: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Language.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: /**
 6:  * The Emotional Language model analyzes passages of text. This also supports audio and video files by transcribing and then directly analyzing the transcribed text.
 7:  *
 8:  * Recommended input filetypes: `.txt`, `.mp3`, `.wav`, `.mp4`
 9:  */
10: export interface Language {
11:     granularity?: Hume.expressionMeasurement.batch.Granularity;
12:     sentiment?: Hume.expressionMeasurement.batch.Unconfigurable;
13:     toxicity?: Hume.expressionMeasurement.batch.Unconfigurable;
14:     /** Whether to return identifiers for speakers over time. If `true`, unique identifiers will be assigned to spoken words to differentiate different speakers. If `false`, all speakers will be tagged with an `unknown` ID. */
15:     identifySpeakers?: boolean;
16: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/LanguagePrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface LanguagePrediction {
 6:     /** A segment of text (like a word or a sentence). */
 7:     text: string;
 8:     position: Hume.expressionMeasurement.batch.PositionInterval;
 9:     time?: Hume.expressionMeasurement.batch.TimeInterval;
10:     /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence in this text. */
11:     confidence?: number;
12:     /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence that this text was spoken by this speaker. */
13:     speakerConfidence?: number;
14:     /** A high-dimensional embedding in emotion space. */
15:     emotions: Hume.expressionMeasurement.batch.EmotionScore[];
16:     /**
17:      * Sentiment predictions returned as a distribution. This model predicts the probability that a given text could be interpreted as having each sentiment level from `1` (negative) to `9` (positive).
18:      *
19:      * Compared to returning one estimate of sentiment, this enables a more nuanced analysis of a text's meaning. For example, a text with very neutral sentiment would have an average rating of `5`. But also a text that could be interpreted as having very positive sentiment or very negative sentiment would also have an average rating of `5`. The average sentiment is less informative than the distribution over sentiment, so this API returns a value for each sentiment level.
20:      */
21:     sentiment?: Hume.expressionMeasurement.batch.SentimentScore[];
22:     /** Toxicity predictions returned as probabilities that the text can be classified into the following categories: `toxic`, `severe_toxic`, `obscene`, `threat`, `insult`, and `identity_hate`. */
23:     toxicity?: Hume.expressionMeasurement.batch.ToxicityScore[];
24: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Models.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: /**
 6:  * The models used for inference.
 7:  */
 8: export interface Models {
 9:     face?: Hume.expressionMeasurement.batch.Face;
10:     burst?: Hume.expressionMeasurement.batch.Unconfigurable;
11:     prosody?: Hume.expressionMeasurement.batch.Prosody;
12:     language?: Hume.expressionMeasurement.batch.Language;
13:     ner?: Hume.expressionMeasurement.batch.Ner;
14:     facemesh?: Hume.expressionMeasurement.batch.Unconfigurable;
15: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/ModelsPredictions.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface ModelsPredictions {
 6:     face?: Hume.expressionMeasurement.batch.PredictionsOptionalNullFacePrediction;
 7:     burst?: Hume.expressionMeasurement.batch.PredictionsOptionalNullBurstPrediction;
 8:     prosody?: Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataProsodyPrediction;
 9:     language?: Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataLanguagePrediction;
10:     ner?: Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataNerPrediction;
11:     facemesh?: Hume.expressionMeasurement.batch.PredictionsOptionalNullFacemeshPrediction;
12: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Ner.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * The NER (Named-entity Recognition) model identifies real-world objects and concepts in passages of text. This also supports audio and video files by transcribing and then directly analyzing the transcribed text.
 5:  *
 6:  * Recommended input filetypes: `.txt`, `.mp3`, `.wav`, `.mp4`
 7:  */
 8: export interface Ner {
 9:     /** Whether to return identifiers for speakers over time. If `true`, unique identifiers will be assigned to spoken words to differentiate different speakers. If `false`, all speakers will be tagged with an `unknown` ID. */
10:     identifySpeakers?: boolean;
11: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/NerPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface NerPrediction {
 6:     /** The recognized topic or entity. */
 7:     entity: string;
 8:     position: Hume.expressionMeasurement.batch.PositionInterval;
 9:     /** Our NER model's relative confidence in the recognized topic or entity. */
10:     entityConfidence: number;
11:     /** A measure of how often the entity is linked to by other entities. */
12:     support: number;
13:     /** A URL which provides more information about the recognized topic or entity. */
14:     uri: string;
15:     /** The specific word to which the emotion predictions are linked. */
16:     linkWord: string;
17:     time?: Hume.expressionMeasurement.batch.TimeInterval;
18:     /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence in this text. */
19:     confidence?: number;
20:     /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence that this text was spoken by this speaker. */
21:     speakerConfidence?: number;
22:     /** A high-dimensional embedding in emotion space. */
23:     emotions: Hume.expressionMeasurement.batch.EmotionScore[];
24: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Null.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: /**
4:  * No associated metadata for this model. Value will be `null`.
5:  */
6: export type Null = Record<string, unknown>;
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/PositionInterval.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * Position of a segment of text within a larger document, measured in characters. Uses zero-based indexing. The beginning index is inclusive and the end index is exclusive.
 5:  */
 6: export interface PositionInterval {
 7:     /** The index of the first character in the text segment, inclusive. */
 8:     begin: number;
 9:     /** The index of the last character in the text segment, exclusive. */
10:     end: number;
11: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullBurstPrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface PredictionsOptionalNullBurstPrediction {
6:     metadata?: Hume.expressionMeasurement.batch.Null;
7:     groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsBurstPrediction[];
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullFacemeshPrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface PredictionsOptionalNullFacemeshPrediction {
6:     metadata?: Hume.expressionMeasurement.batch.Null;
7:     groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsFacemeshPrediction[];
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullFacePrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface PredictionsOptionalNullFacePrediction {
6:     metadata?: Hume.expressionMeasurement.batch.Null;
7:     groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsFacePrediction[];
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataLanguagePrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface PredictionsOptionalTranscriptionMetadataLanguagePrediction {
6:     metadata?: Hume.expressionMeasurement.batch.TranscriptionMetadata;
7:     groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsLanguagePrediction[];
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataNerPrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface PredictionsOptionalTranscriptionMetadataNerPrediction {
6:     metadata?: Hume.expressionMeasurement.batch.TranscriptionMetadata;
7:     groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsNerPrediction[];
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataProsodyPrediction.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface PredictionsOptionalTranscriptionMetadataProsodyPrediction {
6:     metadata?: Hume.expressionMeasurement.batch.TranscriptionMetadata;
7:     groupedPredictions: Hume.expressionMeasurement.batch.GroupedPredictionsProsodyPrediction[];
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Prosody.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: /**
 6:  * The Speech Prosody model analyzes the intonation, stress, and rhythm of spoken word.
 7:  *
 8:  * Recommended input file types: `.wav`, `.mp3`, `.mp4`
 9:  */
10: export interface Prosody {
11:     granularity?: Hume.expressionMeasurement.batch.Granularity;
12:     window?: Hume.expressionMeasurement.batch.Window;
13:     /** Whether to return identifiers for speakers over time. If `true`, unique identifiers will be assigned to spoken words to differentiate different speakers. If `false`, all speakers will be tagged with an `unknown` ID. */
14:     identifySpeakers?: boolean;
15: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/ProsodyPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface ProsodyPrediction {
 6:     /** A segment of text (like a word or a sentence). */
 7:     text?: string;
 8:     time: Hume.expressionMeasurement.batch.TimeInterval;
 9:     /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence in this text. */
10:     confidence?: number;
11:     /** Value between `0.0` and `1.0` that indicates our transcription model's relative confidence that this text was spoken by this speaker. */
12:     speakerConfidence?: number;
13:     /** A high-dimensional embedding in emotion space. */
14:     emotions: Hume.expressionMeasurement.batch.EmotionScore[];
15: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Queued.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface Queued {
4:     /** When this job was created (Unix timestamp in milliseconds). */
5:     createdTimestampMs: number;
6: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/QueuedState.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface QueuedState extends Hume.expressionMeasurement.batch.Queued {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/RegistryFileDetail.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface RegistryFileDetail {
4:     /** File ID in the Asset Registry */
5:     fileId: string;
6:     /** URL to the file in the Asset Registry */
7:     fileUrl: string;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Regression.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type Regression = Record<string, unknown>;
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/SentimentScore.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface SentimentScore {
4:     /** Level of sentiment, ranging from `1` (negative) to `9` (positive) */
5:     name: string;
6:     /** Prediction for this level of sentiment */
7:     score: number;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/SortBy.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const SortBy = {
4:     Created: "created",
5:     Started: "started",
6:     Ended: "ended",
7: } as const;
8: export type SortBy = (typeof SortBy)[keyof typeof SortBy];
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Source.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export type Source =
 6:     | Hume.expressionMeasurement.batch.Source.Url
 7:     | Hume.expressionMeasurement.batch.Source.File_
 8:     | Hume.expressionMeasurement.batch.Source.Text;
 9: 
10: export namespace Source {
11:     export interface Url extends Hume.expressionMeasurement.batch.SourceUrl {
12:         type: "url";
13:     }
14: 
15:     export interface File_ extends Hume.expressionMeasurement.batch.SourceFile {
16:         type: "file";
17:     }
18: 
19:     export interface Text extends Hume.expressionMeasurement.batch.SourceTextSource {
20:         type: "text";
21:     }
22: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/SourceFile.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface SourceFile extends Hume.expressionMeasurement.batch.File_ {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/SourceTextSource.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type SourceTextSource = {};
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/SourceUrl.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface SourceUrl extends Hume.expressionMeasurement.batch.Url {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGeneration.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export type StateEmbeddingGeneration =
 6:     | Hume.expressionMeasurement.batch.StateEmbeddingGeneration.Queued
 7:     | Hume.expressionMeasurement.batch.StateEmbeddingGeneration.InProgress
 8:     | Hume.expressionMeasurement.batch.StateEmbeddingGeneration.Completed
 9:     | Hume.expressionMeasurement.batch.StateEmbeddingGeneration.Failed;
10: 
11: export namespace StateEmbeddingGeneration {
12:     export interface Queued extends Hume.expressionMeasurement.batch.StateEmbeddingGenerationQueued {
13:         status: "QUEUED";
14:     }
15: 
16:     export interface InProgress extends Hume.expressionMeasurement.batch.StateEmbeddingGenerationInProgress {
17:         status: "IN_PROGRESS";
18:     }
19: 
20:     export interface Completed
21:         extends Hume.expressionMeasurement.batch.StateEmbeddingGenerationCompletedEmbeddingGeneration {
22:         status: "COMPLETED";
23:     }
24: 
25:     export interface Failed extends Hume.expressionMeasurement.batch.StateEmbeddingGenerationFailed {
26:         status: "FAILED";
27:     }
28: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationCompletedEmbeddingGeneration.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface StateEmbeddingGenerationCompletedEmbeddingGeneration
6:     extends Hume.expressionMeasurement.batch.CompletedEmbeddingGeneration {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationFailed.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface StateEmbeddingGenerationFailed extends Hume.expressionMeasurement.batch.Failed {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationInProgress.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface StateEmbeddingGenerationInProgress extends Hume.expressionMeasurement.batch.InProgress {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationQueued.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface StateEmbeddingGenerationQueued extends Hume.expressionMeasurement.batch.Queued {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export type StateInference =
 6:     | Hume.expressionMeasurement.batch.StateInference.Queued
 7:     | Hume.expressionMeasurement.batch.StateInference.InProgress
 8:     | Hume.expressionMeasurement.batch.StateInference.Completed
 9:     | Hume.expressionMeasurement.batch.StateInference.Failed;
10: 
11: export namespace StateInference {
12:     export interface Queued extends Hume.expressionMeasurement.batch.QueuedState {
13:         status: "QUEUED";
14:     }
15: 
16:     export interface InProgress extends Hume.expressionMeasurement.batch.InProgressState {
17:         status: "IN_PROGRESS";
18:     }
19: 
20:     export interface Completed extends Hume.expressionMeasurement.batch.CompletedState {
21:         status: "COMPLETED";
22:     }
23: 
24:     export interface Failed extends Hume.expressionMeasurement.batch.FailedState {
25:         status: "FAILED";
26:     }
27: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateTlInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export type StateTlInference =
 6:     | Hume.expressionMeasurement.batch.StateTlInference.Queued
 7:     | Hume.expressionMeasurement.batch.StateTlInference.InProgress
 8:     | Hume.expressionMeasurement.batch.StateTlInference.Completed
 9:     | Hume.expressionMeasurement.batch.StateTlInference.Failed;
10: 
11: export namespace StateTlInference {
12:     export interface Queued extends Hume.expressionMeasurement.batch.StateTlInferenceQueued {
13:         status: "QUEUED";
14:     }
15: 
16:     export interface InProgress extends Hume.expressionMeasurement.batch.StateTlInferenceInProgress {
17:         status: "IN_PROGRESS";
18:     }
19: 
20:     export interface Completed extends Hume.expressionMeasurement.batch.StateTlInferenceCompletedTlInference {
21:         status: "COMPLETED";
22:     }
23: 
24:     export interface Failed extends Hume.expressionMeasurement.batch.StateTlInferenceFailed {
25:         status: "FAILED";
26:     }
27: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateTlInferenceCompletedTlInference.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface StateTlInferenceCompletedTlInference extends Hume.expressionMeasurement.batch.CompletedTlInference {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateTlInferenceFailed.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface StateTlInferenceFailed extends Hume.expressionMeasurement.batch.Failed {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateTlInferenceInProgress.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface StateTlInferenceInProgress extends Hume.expressionMeasurement.batch.InProgress {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateTlInferenceQueued.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface StateTlInferenceQueued extends Hume.expressionMeasurement.batch.Queued {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateTraining.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export type StateTraining =
 6:     | Hume.expressionMeasurement.batch.StateTraining.Queued
 7:     | Hume.expressionMeasurement.batch.StateTraining.InProgress
 8:     | Hume.expressionMeasurement.batch.StateTraining.Completed
 9:     | Hume.expressionMeasurement.batch.StateTraining.Failed;
10: 
11: export namespace StateTraining {
12:     export interface Queued extends Hume.expressionMeasurement.batch.StateTrainingQueued {
13:         status: "QUEUED";
14:     }
15: 
16:     export interface InProgress extends Hume.expressionMeasurement.batch.StateTrainingInProgress {
17:         status: "IN_PROGRESS";
18:     }
19: 
20:     export interface Completed extends Hume.expressionMeasurement.batch.StateTrainingCompletedTraining {
21:         status: "COMPLETED";
22:     }
23: 
24:     export interface Failed extends Hume.expressionMeasurement.batch.StateTrainingFailed {
25:         status: "FAILED";
26:     }
27: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateTrainingCompletedTraining.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface StateTrainingCompletedTraining extends Hume.expressionMeasurement.batch.CompletedTraining {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateTrainingFailed.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface StateTrainingFailed extends Hume.expressionMeasurement.batch.Failed {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateTrainingInProgress.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface StateTrainingInProgress extends Hume.expressionMeasurement.batch.InProgress {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/StateTrainingQueued.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface StateTrainingQueued extends Hume.expressionMeasurement.batch.Queued {}
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Status.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const Status = {
4:     Queued: "QUEUED",
5:     InProgress: "IN_PROGRESS",
6:     Completed: "COMPLETED",
7:     Failed: "FAILED",
8: } as const;
9: export type Status = (typeof Status)[keyof typeof Status];
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Tag.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface Tag {
4:     key: string;
5:     value: string;
6: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Target.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type Target = number | number | string;
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Task.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export type Task =
 6:     | Hume.expressionMeasurement.batch.Task.Classification
 7:     | Hume.expressionMeasurement.batch.Task.Regression;
 8: 
 9: export namespace Task {
10:     export interface Classification extends Hume.expressionMeasurement.batch.TaskClassification {
11:         type: "classification";
12:     }
13: 
14:     export interface Regression extends Hume.expressionMeasurement.batch.TaskRegression {
15:         type: "regression";
16:     }
17: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/TaskClassification.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type TaskClassification = {};
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/TaskRegression.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type TaskRegression = {};
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/TextSource.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type TextSource = Record<string, unknown>;
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/TimeInterval.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * A time range with a beginning and end, measured in seconds.
 5:  */
 6: export interface TimeInterval {
 7:     /** Beginning of time range in seconds. */
 8:     begin: number;
 9:     /** End of time range in seconds. */
10:     end: number;
11: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/TlInferenceBaseRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface TlInferenceBaseRequest {
 6:     customModel: Hume.expressionMeasurement.batch.CustomModel;
 7:     /**
 8:      * URLs to the media files to be processed. Each must be a valid public URL to a media file (see recommended input filetypes) or an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`) of media files.
 9:      *
10:      * If you wish to supply more than 100 URLs, consider providing them as an archive (`.zip`, `.tar.gz`, `.tar.bz2`, `.tar.xz`).
11:      */
12:     urls?: string[];
13:     /** If provided, a `POST` request will be made to the URL with the generated predictions on completion or the error message on failure. */
14:     callbackUrl?: string;
15:     /** Whether to send an email notification to the user upon job completion/failure. */
16:     notify?: boolean;
17: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/TlInferencePrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface TlInferencePrediction {
 6:     /** A file path relative to the top level source URL or file. */
 7:     file: string;
 8:     fileType: string;
 9:     customModels: Record<string, Hume.expressionMeasurement.batch.CustomModelPrediction>;
10: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/TlInferenceResults.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface TlInferenceResults {
6:     predictions: Hume.expressionMeasurement.batch.TlInferencePrediction[];
7:     errors: Hume.expressionMeasurement.batch.Error_[];
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/TlInferenceSourcePredictResult.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface TlInferenceSourcePredictResult {
 6:     source: Hume.expressionMeasurement.batch.Source;
 7:     results?: Hume.expressionMeasurement.batch.TlInferenceResults;
 8:     /** An error message. */
 9:     error?: string;
10: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/ToxicityScore.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface ToxicityScore {
4:     /** Category of toxicity. */
5:     name: string;
6:     /** Prediction for this category of toxicity */
7:     score: number;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/TrainingBaseRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: export interface TrainingBaseRequest {
 6:     customModel: Hume.expressionMeasurement.batch.CustomModelRequest;
 7:     dataset: Hume.expressionMeasurement.batch.Dataset;
 8:     targetFeature?: string;
 9:     task?: Hume.expressionMeasurement.batch.Task;
10:     evaluation?: Hume.expressionMeasurement.batch.EvaluationArgs;
11:     alternatives?: Hume.expressionMeasurement.batch.Alternative[];
12:     callbackUrl?: string;
13:     notify?: boolean;
14: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/TrainingCustomModel.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface TrainingCustomModel {
4:     id: string;
5:     versionId?: string;
6: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Transcription.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: /**
 6:  * Transcription-related configuration options.
 7:  *
 8:  * To disable transcription, explicitly set this field to `null`.
 9:  */
10: export interface Transcription {
11:     /**
12:      * By default, we use an automated language detection method for our Speech Prosody, Language, and NER models. However, if you know what language is being spoken in your media samples, you can specify it via its BCP-47 tag and potentially obtain more accurate results.
13:      *
14:      * You can specify any of the following languages:
15:      * - Chinese: `zh`
16:      * - Danish: `da`
17:      * - Dutch: `nl`
18:      * - English: `en`
19:      * - English (Australia): `en-AU`
20:      * - English (India): `en-IN`
21:      * - English (New Zealand): `en-NZ`
22:      * - English (United Kingdom): `en-GB`
23:      * - French: `fr`
24:      * - French (Canada): `fr-CA`
25:      * - German: `de`
26:      * - Hindi: `hi`
27:      * - Hindi (Roman Script): `hi-Latn`
28:      * - Indonesian: `id`
29:      * - Italian: `it`
30:      * - Japanese: `ja`
31:      * - Korean: `ko`
32:      * - Norwegian: `no`
33:      * - Polish: `pl`
34:      * - Portuguese: `pt`
35:      * - Portuguese (Brazil): `pt-BR`
36:      * - Portuguese (Portugal): `pt-PT`
37:      * - Russian: `ru`
38:      * - Spanish: `es`
39:      * - Spanish (Latin America): `es-419`
40:      * - Swedish: `sv`
41:      * - Tamil: `ta`
42:      * - Turkish: `tr`
43:      * - Ukrainian: `uk`
44:      */
45:     language?: Hume.expressionMeasurement.batch.Bcp47Tag;
46:     /** Whether to return identifiers for speakers over time. If `true`, unique identifiers will be assigned to spoken words to differentiate different speakers. If `false`, all speakers will be tagged with an `unknown` ID. */
47:     identifySpeakers?: boolean;
48:     /** Transcript confidence threshold. Transcripts generated with a confidence less than this threshold will be considered invalid and not used as an input for model inference. */
49:     confidenceThreshold?: number;
50: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/TranscriptionMetadata.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: /**
 6:  * Transcription metadata for your media file.
 7:  */
 8: export interface TranscriptionMetadata {
 9:     /** Value between `0.0` and `1.0` indicating our transcription model's relative confidence in the transcription of your media file. */
10:     confidence: number;
11:     detectedLanguage?: Hume.expressionMeasurement.batch.Bcp47Tag;
12: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Type.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const Type = {
4:     EmbeddingGeneration: "EMBEDDING_GENERATION",
5:     Inference: "INFERENCE",
6:     TlInference: "TL_INFERENCE",
7:     Training: "TRAINING",
8: } as const;
9: export type Type = (typeof Type)[keyof typeof Type];
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Unconfigurable.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: /**
4:  * To include predictions for this model type, set this field to `{}`. It is currently not configurable further.
5:  */
6: export type Unconfigurable = Record<string, unknown>;
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/UnionJob.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export type UnionJob = Hume.expressionMeasurement.batch.InferenceJob;
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/UnionPredictResult.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export type UnionPredictResult = Hume.expressionMeasurement.batch.InferenceSourcePredictResult;
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Url.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface Url {
4:     /** The URL of the source media file. */
5:     url: string;
6: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/ValidationArgs.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: export interface ValidationArgs {
6:     positiveLabel?: Hume.expressionMeasurement.batch.Target;
7: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/When.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const When = {
4:     CreatedBefore: "created_before",
5:     CreatedAfter: "created_after",
6: } as const;
7: export type When = (typeof When)[keyof typeof When];
````

## File: src/api/resources/expressionMeasurement/resources/batch/types/Window.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * Generate predictions based on time.
 5:  *
 6:  * Setting the `window` field allows for a 'sliding window' approach, where a fixed-size window moves across the audio or video file in defined steps. This enables continuous analysis of prosody within subsets of the file, providing dynamic and localized insights into emotional expression.
 7:  */
 8: export interface Window {
 9:     /** The length of the sliding window. */
10:     length?: number;
11:     /** The step size of the sliding window. */
12:     step?: number;
13: }
````

## File: src/api/resources/expressionMeasurement/resources/batch/index.ts
````typescript
1: export * from "./client/index.js";
2: export * from "./types/index.js";
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/client/Client.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type { BaseClientOptions } from "../../../../../../../../BaseClient.js";
 4: import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../../../BaseClient.js";
 5: import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../../../core/headers.js";
 6: import * as core from "../../../../../../../../core/index.js";
 7: import * as environments from "../../../../../../../../environments.js";
 8: import { StreamSocket } from "./Socket.js";
 9: 
10: export declare namespace StreamClient {
11:     export type Options = BaseClientOptions;
12: 
13:     export interface ConnectArgs {
14:         "X-Hume-Api-Key": string;
15:         /** Arbitrary headers to send with the websocket connect request. */
16:         headers?: Record<string, string>;
17:         /** Enable debug mode on the websocket. Defaults to false. */
18:         debug?: boolean;
19:         /** Number of reconnect attempts. Defaults to 30. */
20:         reconnectAttempts?: number;
21:     }
22: }
23: 
24: export class StreamClient {
25:     protected readonly _options: NormalizedClientOptions<StreamClient.Options>;
26: 
27:     constructor(options: StreamClient.Options = {}) {
28:         this._options = normalizeClientOptions(options);
29:     }
30: 
31:     public async connect(args: StreamClient.ConnectArgs): Promise<StreamSocket> {
32:         const { headers, debug, reconnectAttempts } = args;
33:         const _headers: Record<string, unknown> = mergeHeaders(
34:             mergeOnlyDefinedHeaders({ "X-Hume-Api-Key": args["X-Hume-Api-Key"] }),
35:             headers,
36:         );
37:         const socket = new core.ReconnectingWebSocket({
38:             url: core.url.join(
39:                 (await core.Supplier.get(this._options.baseUrl)) ??
40:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).stream,
41:                 "/models",
42:             ),
43:             protocols: [],
44:             queryParameters: {},
45:             headers: _headers,
46:             options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
47:         });
48:         return new StreamSocket({ socket });
49:     }
50: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/client/index.ts
````typescript
1: export {};
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/client/Socket.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import * as core from "../../../../../../../../core/index.js";
  4: import { fromJson } from "../../../../../../../../core/json.js";
  5: import * as serializers from "../../../../../../../../serialization/index.js";
  6: import { StreamModelsEndpointPayload } from "../../../../../../../../serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelsEndpointPayload.js";
  7: import type * as Hume from "../../../../../../../index.js";
  8: 
  9: export declare namespace StreamSocket {
 10:     export interface Args {
 11:         socket: core.ReconnectingWebSocket;
 12:     }
 13: 
 14:     export type Response = Hume.expressionMeasurement.stream.SubscribeEvent;
 15:     type EventHandlers = {
 16:         open?: () => void;
 17:         message?: (message: Response) => void;
 18:         close?: (event: core.CloseEvent) => void;
 19:         error?: (error: Error) => void;
 20:     };
 21: }
 22: 
 23: export class StreamSocket {
 24:     public readonly socket: core.ReconnectingWebSocket;
 25:     protected readonly eventHandlers: StreamSocket.EventHandlers = {};
 26:     private handleOpen: () => void = () => {
 27:         this.eventHandlers.open?.();
 28:     };
 29:     private handleMessage: (event: { data: string }) => void = (event) => {
 30:         const data = fromJson(event.data);
 31: 
 32:         const parsedResponse = serializers.expressionMeasurement.stream.StreamSocketResponse.parse(data, {
 33:             unrecognizedObjectKeys: "passthrough",
 34:             allowUnrecognizedUnionMembers: true,
 35:             allowUnrecognizedEnumValues: true,
 36:             skipValidation: true,
 37:             omitUndefined: true,
 38:         });
 39:         if (parsedResponse.ok) {
 40:             this.eventHandlers.message?.(parsedResponse.value);
 41:         } else {
 42:             this.eventHandlers.error?.(new Error("Received unknown message type"));
 43:         }
 44:     };
 45:     private handleClose: (event: core.CloseEvent) => void = (event) => {
 46:         this.eventHandlers.close?.(event);
 47:     };
 48:     private handleError: (event: core.ErrorEvent) => void = (event) => {
 49:         const message = event.message;
 50:         this.eventHandlers.error?.(new Error(message));
 51:     };
 52: 
 53:     constructor(args: StreamSocket.Args) {
 54:         this.socket = args.socket;
 55:         this.socket.addEventListener("open", this.handleOpen);
 56:         this.socket.addEventListener("message", this.handleMessage);
 57:         this.socket.addEventListener("close", this.handleClose);
 58:         this.socket.addEventListener("error", this.handleError);
 59:     }
 60: 
 61:     /** The current state of the connection; this is one of the readyState constants. */
 62:     get readyState(): number {
 63:         return this.socket.readyState;
 64:     }
 65: 
 66:     /**
 67:      * @param event - The event to attach to.
 68:      * @param callback - The callback to run when the event is triggered.
 69:      * Usage:
 70:      * ```typescript
 71:      * this.on('open', () => {
 72:      *     console.log('The websocket is open');
 73:      * });
 74:      * ```
 75:      */
 76:     public on<T extends keyof StreamSocket.EventHandlers>(event: T, callback: StreamSocket.EventHandlers[T]): void {
 77:         this.eventHandlers[event] = callback;
 78:     }
 79: 
 80:     public sendPublish(message: Hume.expressionMeasurement.stream.StreamModelsEndpointPayload): void {
 81:         this.assertSocketIsOpen();
 82:         const jsonPayload = StreamModelsEndpointPayload.jsonOrThrow(message, {
 83:             unrecognizedObjectKeys: "passthrough",
 84:             allowUnrecognizedUnionMembers: true,
 85:             allowUnrecognizedEnumValues: true,
 86:             skipValidation: true,
 87:             omitUndefined: true,
 88:         });
 89:         this.socket.send(JSON.stringify(jsonPayload));
 90:     }
 91: 
 92:     /** Connect to the websocket and register event handlers. */
 93:     public connect(): StreamSocket {
 94:         this.socket.reconnect();
 95: 
 96:         this.socket.addEventListener("open", this.handleOpen);
 97:         this.socket.addEventListener("message", this.handleMessage);
 98:         this.socket.addEventListener("close", this.handleClose);
 99:         this.socket.addEventListener("error", this.handleError);
100: 
101:         return this;
102:     }
103: 
104:     /** Close the websocket and unregister event handlers. */
105:     public close(): void {
106:         this.socket.close();
107: 
108:         this.handleClose({ code: 1000 } as CloseEvent);
109: 
110:         this.socket.removeEventListener("open", this.handleOpen);
111:         this.socket.removeEventListener("message", this.handleMessage);
112:         this.socket.removeEventListener("close", this.handleClose);
113:         this.socket.removeEventListener("error", this.handleError);
114:     }
115: 
116:     /** Returns a promise that resolves when the websocket is open. */
117:     public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
118:         if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
119:             return this.socket;
120:         }
121: 
122:         return new Promise((resolve, reject) => {
123:             this.socket.addEventListener("open", () => {
124:                 resolve(this.socket);
125:             });
126: 
127:             this.socket.addEventListener("error", (event: unknown) => {
128:                 reject(event);
129:             });
130:         });
131:     }
132: 
133:     /** Asserts that the websocket is open. */
134:     private assertSocketIsOpen(): void {
135:         if (!this.socket) {
136:             throw new Error("Socket is not connected.");
137:         }
138: 
139:         if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
140:             throw new Error("Socket is not open.");
141:         }
142:     }
143: 
144:     /** Send a binary payload to the websocket. */
145:     protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
146:         this.socket.send(payload);
147:     }
148: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/Config.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: /**
 6:  * Configuration used to specify which models should be used and with what settings.
 7:  */
 8: export interface Config {
 9:     /**
10:      * Configuration for the vocal burst emotion model.
11:      *
12:      * Note: Model configuration is not currently available in streaming.
13:      *
14:      * Please use the default configuration by passing an empty object `{}`.
15:      */
16:     burst?: Record<string, unknown>;
17:     /**
18:      * Configuration for the facial expression emotion model.
19:      *
20:      * Note: Using the `reset_stream` parameter does not have any effect on face identification. A single face identifier cache is maintained over a full session whether `reset_stream` is used or not.
21:      */
22:     face?: Hume.expressionMeasurement.stream.StreamFace;
23:     /**
24:      * Configuration for the facemesh emotion model.
25:      *
26:      * Note: Model configuration is not currently available in streaming.
27:      *
28:      * Please use the default configuration by passing an empty object `{}`.
29:      */
30:     facemesh?: Record<string, unknown>;
31:     /** Configuration for the language emotion model. */
32:     language?: Hume.expressionMeasurement.stream.StreamLanguage;
33:     /**
34:      * Configuration for the speech prosody emotion model.
35:      *
36:      * Note: Model configuration is not currently available in streaming.
37:      *
38:      * Please use the default configuration by passing an empty object `{}`.
39:      */
40:     prosody?: Record<string, unknown>;
41: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/index.ts
````typescript
 1: export * from "./Config.js";
 2: export * from "./JobDetails.js";
 3: export * from "./StreamErrorMessage.js";
 4: export * from "./StreamFace.js";
 5: export * from "./StreamLanguage.js";
 6: export * from "./StreamModelPredictions.js";
 7: export * from "./StreamModelPredictionsBurst.js";
 8: export * from "./StreamModelPredictionsBurstPredictionsItem.js";
 9: export * from "./StreamModelPredictionsFace.js";
10: export * from "./StreamModelPredictionsFacemesh.js";
11: export * from "./StreamModelPredictionsFacemeshPredictionsItem.js";
12: export * from "./StreamModelPredictionsFacePredictionsItem.js";
13: export * from "./StreamModelPredictionsJobDetails.js";
14: export * from "./StreamModelPredictionsLanguage.js";
15: export * from "./StreamModelPredictionsLanguagePredictionsItem.js";
16: export * from "./StreamModelPredictionsProsody.js";
17: export * from "./StreamModelPredictionsProsodyPredictionsItem.js";
18: export * from "./StreamModelsEndpointPayload.js";
19: export * from "./StreamWarningMessage.js";
20: export * from "./StreamWarningMessageJobDetails.js";
21: export * from "./SubscribeEvent.js";
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/JobDetails.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: /**
4:  * If the job_details flag was set in the request, details about the current streaming job will be returned in the response body.
5:  */
6: export interface JobDetails {
7:     /** ID of the current streaming job. */
8:     jobId?: string;
9: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamErrorMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: /**
 6:  * Error message
 7:  */
 8: export interface StreamErrorMessage {
 9:     /** Error message text. */
10:     error?: string;
11:     /** Unique identifier for the error. */
12:     code?: string;
13:     /** If a payload ID was passed in the request, the same payload ID will be sent back in the response body. */
14:     payloadId?: string;
15:     /** If the job_details flag was set in the request, details about the current streaming job will be returned in the response body. */
16:     jobDetails?: Hume.expressionMeasurement.stream.JobDetails;
17: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamFace.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * Configuration for the facial expression emotion model.
 5:  *
 6:  * Note: Using the `reset_stream` parameter does not have any effect on face identification. A single face identifier cache is maintained over a full session whether `reset_stream` is used or not.
 7:  */
 8: export interface StreamFace {
 9:     /** Configuration for FACS predictions. If missing or null, no FACS predictions will be generated. */
10:     facs?: Record<string, unknown>;
11:     /** Configuration for Descriptions predictions. If missing or null, no Descriptions predictions will be generated. */
12:     descriptions?: Record<string, unknown>;
13:     /** Whether to return identifiers for faces across frames. If true, unique identifiers will be assigned to face bounding boxes to differentiate different faces. If false, all faces will be tagged with an "unknown" ID. */
14:     identifyFaces?: boolean;
15:     /** Number of frames per second to process. Other frames will be omitted from the response. */
16:     fpsPred?: number;
17:     /** Face detection probability threshold. Faces detected with a probability less than this threshold will be omitted from the response. */
18:     probThreshold?: number;
19:     /** Minimum bounding box side length in pixels to treat as a face. Faces detected with a bounding box side length in pixels less than this threshold will be omitted from the response. */
20:     minFaceSize?: number;
21: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamLanguage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * Configuration for the language emotion model.
 5:  */
 6: export interface StreamLanguage {
 7:     /** Configuration for sentiment predictions. If missing or null, no sentiment predictions will be generated. */
 8:     sentiment?: Record<string, unknown>;
 9:     /** Configuration for toxicity predictions. If missing or null, no toxicity predictions will be generated. */
10:     toxicity?: Record<string, unknown>;
11:     /** The granularity at which to generate predictions. Values are `word`, `sentence`, `utterance`, or `passage`. To get a single prediction for the entire text of your streaming payload use `passage`. Default value is `word`. */
12:     granularity?: string;
13: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictions.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: /**
 6:  * Model predictions
 7:  */
 8: export interface StreamModelPredictions {
 9:     /** If a payload ID was passed in the request, the same payload ID will be sent back in the response body. */
10:     payloadId?: string;
11:     /** If the job_details flag was set in the request, details about the current streaming job will be returned in the response body. */
12:     jobDetails?: Hume.expressionMeasurement.stream.StreamModelPredictionsJobDetails;
13:     /** Response for the vocal burst emotion model. */
14:     burst?: Hume.expressionMeasurement.stream.StreamModelPredictionsBurst;
15:     /** Response for the facial expression emotion model. */
16:     face?: Hume.expressionMeasurement.stream.StreamModelPredictionsFace;
17:     /** Response for the facemesh emotion model. */
18:     facemesh?: Hume.expressionMeasurement.stream.StreamModelPredictionsFacemesh;
19:     /** Response for the language emotion model. */
20:     language?: Hume.expressionMeasurement.stream.StreamModelPredictionsLanguage;
21:     /** Response for the speech prosody emotion model. */
22:     prosody?: Hume.expressionMeasurement.stream.StreamModelPredictionsProsody;
23: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsBurst.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: /**
 6:  * Response for the vocal burst emotion model.
 7:  */
 8: export interface StreamModelPredictionsBurst {
 9:     predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsBurstPredictionsItem[];
10: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsBurstPredictionsItem.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../../../index.js";
4: 
5: export interface StreamModelPredictionsBurstPredictionsItem {
6:     time?: Hume.expressionMeasurement.stream.TimeRange;
7:     emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFace.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: /**
 6:  * Response for the facial expression emotion model.
 7:  */
 8: export interface StreamModelPredictionsFace {
 9:     predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsFacePredictionsItem[];
10: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacemesh.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: /**
 6:  * Response for the facemesh emotion model.
 7:  */
 8: export interface StreamModelPredictionsFacemesh {
 9:     predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsFacemeshPredictionsItem[];
10: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacemeshPredictionsItem.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../../../index.js";
4: 
5: export interface StreamModelPredictionsFacemeshPredictionsItem {
6:     emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
7: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacePredictionsItem.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: export interface StreamModelPredictionsFacePredictionsItem {
 6:     /** Frame number */
 7:     frame?: number;
 8:     /** Time in seconds when face detection occurred. */
 9:     time?: number;
10:     bbox?: Hume.expressionMeasurement.stream.StreamBoundingBox;
11:     /** The predicted probability that a detected face was actually a face. */
12:     prob?: number;
13:     /** Identifier for a face. Not that this defaults to `unknown` unless face identification is enabled in the face model configuration. */
14:     faceId?: string;
15:     emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
16:     facs?: Hume.expressionMeasurement.stream.EmotionEmbedding;
17:     descriptions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
18: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsJobDetails.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: /**
4:  * If the job_details flag was set in the request, details about the current streaming job will be returned in the response body.
5:  */
6: export interface StreamModelPredictionsJobDetails {
7:     /** ID of the current streaming job. */
8:     jobId?: string;
9: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsLanguage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: /**
 6:  * Response for the language emotion model.
 7:  */
 8: export interface StreamModelPredictionsLanguage {
 9:     predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsLanguagePredictionsItem[];
10: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsLanguagePredictionsItem.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: export interface StreamModelPredictionsLanguagePredictionsItem {
 6:     /** A segment of text (like a word or a sentence). */
 7:     text?: string;
 8:     position?: Hume.expressionMeasurement.stream.TextPosition;
 9:     emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
10:     sentiment?: Hume.expressionMeasurement.stream.Sentiment;
11:     toxicity?: Hume.expressionMeasurement.stream.Toxicity;
12: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsProsody.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: /**
 6:  * Response for the speech prosody emotion model.
 7:  */
 8: export interface StreamModelPredictionsProsody {
 9:     predictions?: Hume.expressionMeasurement.stream.StreamModelPredictionsProsodyPredictionsItem[];
10: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsProsodyPredictionsItem.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../../../index.js";
4: 
5: export interface StreamModelPredictionsProsodyPredictionsItem {
6:     time?: Hume.expressionMeasurement.stream.TimeRange;
7:     emotions?: Hume.expressionMeasurement.stream.EmotionEmbedding;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelsEndpointPayload.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: /**
 6:  * Models endpoint payload
 7:  */
 8: export interface StreamModelsEndpointPayload {
 9:     data?: string;
10:     /** Configuration used to specify which models should be used and with what settings. */
11:     models?: Hume.expressionMeasurement.stream.Config;
12:     /**
13:      * Length in milliseconds of streaming sliding window.
14:      *
15:      * Extending the length of this window will prepend media context from past payloads into the current payload.
16:      *
17:      * For example, if on the first payload you send 500ms of data and on the second payload you send an additional 500ms of data, a window of at least 1000ms will allow the model to process all 1000ms of stream data.
18:      *
19:      * A window of 600ms would append the full 500ms of the second payload to the last 100ms of the first payload.
20:      *
21:      * Note: This feature is currently only supported for audio data and audio models. For other file types and models this parameter will be ignored.
22:      */
23:     streamWindowMs?: number;
24:     /**
25:      * Whether to reset the streaming sliding window before processing the current payload.
26:      *
27:      * If this parameter is set to `true` then past context will be deleted before processing the current payload.
28:      *
29:      * Use reset_stream when one audio file is done being processed and you do not want context to leak across files.
30:      */
31:     resetStream?: boolean;
32:     /**
33:      * Set to `true` to enable the data parameter to be parsed as raw text rather than base64 encoded bytes.
34:      * This parameter is useful if you want to send text to be processed by the language model, but it cannot be used with other file types like audio, image, or video.
35:      */
36:     rawText?: boolean;
37:     /**
38:      * Set to `true` to get details about the job.
39:      *
40:      * This parameter can be set in the same payload as data or it can be set without data and models configuration to get the job details between payloads.
41:      *
42:      * This parameter is useful to get the unique job ID.
43:      */
44:     jobDetails?: boolean;
45:     /**
46:      * Pass an arbitrary string as the payload ID and get it back at the top level of the socket response.
47:      *
48:      * This can be useful if you have multiple requests running asynchronously and want to disambiguate responses as they are received.
49:      */
50:     payloadId?: string;
51: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamWarningMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: /**
 6:  * Warning message
 7:  */
 8: export interface StreamWarningMessage {
 9:     /** Warning message text. */
10:     warning?: string;
11:     /** Unique identifier for the error. */
12:     code?: string;
13:     /** If a payload ID was passed in the request, the same payload ID will be sent back in the response body. */
14:     payloadId?: string;
15:     /** If the job_details flag was set in the request, details about the current streaming job will be returned in the response body. */
16:     jobDetails?: Hume.expressionMeasurement.stream.StreamWarningMessageJobDetails;
17: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamWarningMessageJobDetails.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: /**
4:  * If the job_details flag was set in the request, details about the current streaming job will be returned in the response body.
5:  */
6: export interface StreamWarningMessageJobDetails {
7:     /** ID of the current streaming job. */
8:     jobId?: string;
9: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/types/SubscribeEvent.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../index.js";
 4: 
 5: export type SubscribeEvent =
 6:     /**
 7:      * Model predictions */
 8:     | Hume.expressionMeasurement.stream.StreamModelPredictions
 9:     /**
10:      * Error message */
11:     | Hume.expressionMeasurement.stream.StreamErrorMessage
12:     /**
13:      * Warning message */
14:     | Hume.expressionMeasurement.stream.StreamWarningMessage;
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/stream/index.ts
````typescript
1: export * from "./client/index.js";
2: export * from "./types/index.js";
````

## File: src/api/resources/expressionMeasurement/resources/stream/resources/index.ts
````typescript
1: export * as stream from "./stream/index.js";
2: export * from "./stream/types/index.js";
````

## File: src/api/resources/expressionMeasurement/resources/stream/types/EmotionEmbedding.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: /**
6:  * A high-dimensional embedding in emotion space.
7:  */
8: export type EmotionEmbedding = Hume.expressionMeasurement.stream.EmotionEmbeddingItem[];
````

## File: src/api/resources/expressionMeasurement/resources/stream/types/EmotionEmbeddingItem.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface EmotionEmbeddingItem {
4:     /** Name of the emotion being expressed. */
5:     name?: string;
6:     /** Embedding value for the emotion being expressed. */
7:     score?: number;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/types/index.ts
````typescript
1: export * from "./EmotionEmbedding.js";
2: export * from "./EmotionEmbeddingItem.js";
3: export * from "./Sentiment.js";
4: export * from "./SentimentItem.js";
5: export * from "./StreamBoundingBox.js";
6: export * from "./TextPosition.js";
7: export * from "./TimeRange.js";
8: export * from "./Toxicity.js";
9: export * from "./ToxicityItem.js";
````

## File: src/api/resources/expressionMeasurement/resources/stream/types/Sentiment.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../index.js";
 4: 
 5: /**
 6:  * Sentiment predictions returned as a distribution. This model predicts the probability that a given text could be interpreted as having each sentiment level from 1 (negative) to 9 (positive).
 7:  *
 8:  * Compared to returning one estimate of sentiment, this enables a more nuanced analysis of a text's meaning. For example, a text with very neutral sentiment would have an average rating of 5. But also a text that could be interpreted as having very positive sentiment or very negative sentiment would also have an average rating of 5. The average sentiment is less informative than the distribution over sentiment, so this API returns a value for each sentiment level.
 9:  */
10: export type Sentiment = Hume.expressionMeasurement.stream.SentimentItem[];
````

## File: src/api/resources/expressionMeasurement/resources/stream/types/SentimentItem.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface SentimentItem {
4:     /** Level of sentiment, ranging from 1 (negative) to 9 (positive) */
5:     name?: string;
6:     /** Prediction for this level of sentiment */
7:     score?: number;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/types/StreamBoundingBox.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * A bounding box around a face.
 5:  */
 6: export interface StreamBoundingBox {
 7:     /** x-coordinate of bounding box top left corner. */
 8:     x?: number;
 9:     /** y-coordinate of bounding box top left corner. */
10:     y?: number;
11:     /** Bounding box width. */
12:     w?: number;
13:     /** Bounding box height. */
14:     h?: number;
15: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/types/TextPosition.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * Position of a segment of text within a larger document, measured in characters. Uses zero-based indexing. The beginning index is inclusive and the end index is exclusive.
 5:  */
 6: export interface TextPosition {
 7:     /** The index of the first character in the text segment, inclusive. */
 8:     begin?: number;
 9:     /** The index of the last character in the text segment, exclusive. */
10:     end?: number;
11: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/types/TimeRange.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * A time range with a beginning and end, measured in seconds.
 5:  */
 6: export interface TimeRange {
 7:     /** Beginning of time range in seconds. */
 8:     begin?: number;
 9:     /** End of time range in seconds. */
10:     end?: number;
11: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/types/Toxicity.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../../../index.js";
4: 
5: /**
6:  * Toxicity predictions returned as probabilities that the text can be classified into the following categories: toxic, severe_toxic, obscene, threat, insult, and identity_hate.
7:  */
8: export type Toxicity = Hume.expressionMeasurement.stream.ToxicityItem[];
````

## File: src/api/resources/expressionMeasurement/resources/stream/types/ToxicityItem.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface ToxicityItem {
4:     /** Category of toxicity. */
5:     name?: string;
6:     /** Prediction for this category of toxicity */
7:     score?: number;
8: }
````

## File: src/api/resources/expressionMeasurement/resources/stream/index.ts
````typescript
1: export * from "./resources/index.js";
2: export * from "./types/index.js";
````

## File: src/api/resources/expressionMeasurement/resources/index.ts
````typescript
1: export * as batch from "./batch/index.js";
2: export * as stream from "./stream/index.js";
````

## File: src/api/resources/expressionMeasurement/index.ts
````typescript
1: export * from "./client/index.js";
2: export * from "./resources/index.js";
````

## File: src/api/resources/tts/client/requests/ConvertVoiceFileRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as core from "../../../../../core/index.js";
 4: import type * as Hume from "../../../../index.js";
 5: 
 6: export interface ConvertVoiceFileRequest {
 7:     /** If enabled, the audio for all the chunks of a generation, once concatenated together, will constitute a single audio file. Otherwise, if disabled, each chunk's audio will be its own audio file, each with its own headers (if applicable). */
 8:     stripHeaders?: boolean;
 9:     audio: core.file.Uploadable;
10:     /** Utterances to use as context for generating consistent speech style and prosody across multiple requests. These will not be converted to speech output. */
11:     context?: Hume.tts.PostedContext;
12:     voice?: Hume.tts.PostedUtteranceVoice;
13:     /** Specifies the output audio file format. */
14:     format?: Hume.tts.Format;
15:     /** The set of timestamp types to include in the response. When used in multipart/form-data, specify each value using bracket notation: `include_timestamp_types[0]=word&include_timestamp_types[1]=phoneme`. Only supported for Octave 2 requests. */
16:     includeTimestampTypes?: Hume.tts.TimestampType[];
17: }
````

## File: src/api/resources/tts/client/requests/ConvertVoiceJsonRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as core from "../../../../../core/index.js";
 4: import type * as Hume from "../../../../index.js";
 5: 
 6: /**
 7:  * @example
 8:  *     {}
 9:  */
10: export interface ConvertVoiceJsonRequest {
11:     /** If enabled, the audio for all the chunks of a generation, once concatenated together, will constitute a single audio file. Otherwise, if disabled, each chunk's audio will be its own audio file, each with its own headers (if applicable). */
12:     stripHeaders?: boolean;
13:     audio?: core.file.Uploadable | undefined;
14:     /** Utterances to use as context for generating consistent speech style and prosody across multiple requests. These will not be converted to speech output. */
15:     context?: Hume.tts.PostedContext;
16:     voice?: Hume.tts.PostedUtteranceVoice;
17:     /** Specifies the output audio file format. */
18:     format?: Hume.tts.Format;
19:     /** The set of timestamp types to include in the response. When used in multipart/form-data, specify each value using bracket notation: `include_timestamp_types[0]=word&include_timestamp_types[1]=phoneme`. Only supported for Octave 2 requests. */
20:     includeTimestampTypes?: Hume.tts.TimestampType[];
21: }
````

## File: src/api/resources/tts/client/requests/index.ts
````typescript
1: export type { ConvertVoiceFileRequest } from "./ConvertVoiceFileRequest.js";
2: export type { ConvertVoiceJsonRequest } from "./ConvertVoiceJsonRequest.js";
````

## File: src/api/resources/tts/client/Client.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
  4: import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
  5: import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
  6: import * as core from "../../../../core/index.js";
  7: import { toJson } from "../../../../core/json.js";
  8: import * as environments from "../../../../environments.js";
  9: import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
 10: import * as errors from "../../../../errors/index.js";
 11: import * as serializers from "../../../../serialization/index.js";
 12: import * as Hume from "../../../index.js";
 13: import { StreamInputClient } from "../resources/streamInput/client/Client.js";
 14: import { VoicesClient } from "../resources/voices/client/Client.js";
 15: 
 16: export declare namespace TtsClient {
 17:     export type Options = BaseClientOptions;
 18: 
 19:     export interface RequestOptions extends BaseRequestOptions {}
 20: }
 21: 
 22: export class TtsClient {
 23:     protected readonly _options: NormalizedClientOptionsWithAuth<TtsClient.Options>;
 24:     protected _voices: VoicesClient | undefined;
 25:     protected _streamInput: StreamInputClient | undefined;
 26: 
 27:     constructor(options: TtsClient.Options = {}) {
 28:         this._options = normalizeClientOptionsWithAuth(options);
 29:     }
 30: 
 31:     public get voices(): VoicesClient {
 32:         return (this._voices ??= new VoicesClient(this._options));
 33:     }
 34: 
 35:     public get streamInput(): StreamInputClient {
 36:         return (this._streamInput ??= new StreamInputClient(this._options));
 37:     }
 38: 
 39:     /**
 40:      * Synthesizes one or more input texts into speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
 41:      *
 42:      * The response includes the base64-encoded audio and metadata in JSON format.
 43:      *
 44:      * @param {Hume.tts.PostedTts} request
 45:      * @param {TtsClient.RequestOptions} requestOptions - Request-specific configuration.
 46:      *
 47:      * @throws {@link Hume.tts.UnprocessableEntityError}
 48:      *
 49:      * @example
 50:      *     await client.tts.synthesizeJson({
 51:      *         context: {
 52:      *             utterances: [{
 53:      *                     text: "How can people see beauty so differently?",
 54:      *                     description: "A curious student with a clear and respectful tone, seeking clarification on Hume's ideas with a straightforward question."
 55:      *                 }]
 56:      *         },
 57:      *         format: {
 58:      *             type: "mp3"
 59:      *         },
 60:      *         numGenerations: 1,
 61:      *         utterances: [{
 62:      *                 text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
 63:      *                 description: "Middle-aged masculine voice with a clear, rhythmic Scots lilt, rounded vowels, and a warm, steady tone with an articulate, academic quality."
 64:      *             }]
 65:      *     })
 66:      */
 67:     public synthesizeJson(
 68:         request: Hume.tts.PostedTts,
 69:         requestOptions?: TtsClient.RequestOptions,
 70:     ): core.HttpResponsePromise<Hume.tts.ReturnTts> {
 71:         return core.HttpResponsePromise.fromPromise(this.__synthesizeJson(request, requestOptions));
 72:     }
 73: 
 74:     private async __synthesizeJson(
 75:         request: Hume.tts.PostedTts,
 76:         requestOptions?: TtsClient.RequestOptions,
 77:     ): Promise<core.WithRawResponse<Hume.tts.ReturnTts>> {
 78:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
 79:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
 80:             _authRequest.headers,
 81:             this._options?.headers,
 82:             requestOptions?.headers,
 83:         );
 84:         const _response = await (this._options.fetcher ?? core.fetcher)({
 85:             url: core.url.join(
 86:                 (await core.Supplier.get(this._options.baseUrl)) ??
 87:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
 88:                 "v0/tts",
 89:             ),
 90:             method: "POST",
 91:             headers: _headers,
 92:             contentType: "application/json",
 93:             queryParameters: requestOptions?.queryParams,
 94:             requestType: "json",
 95:             body: serializers.tts.PostedTts.jsonOrThrow(request, {
 96:                 unrecognizedObjectKeys: "strip",
 97:                 omitUndefined: true,
 98:             }),
 99:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
100:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
101:             abortSignal: requestOptions?.abortSignal,
102:             fetchFn: this._options?.fetch,
103:             logging: this._options.logging,
104:         });
105:         if (_response.ok) {
106:             return {
107:                 data: serializers.tts.ReturnTts.parseOrThrow(_response.body, {
108:                     unrecognizedObjectKeys: "passthrough",
109:                     allowUnrecognizedUnionMembers: true,
110:                     allowUnrecognizedEnumValues: true,
111:                     skipValidation: true,
112:                     breadcrumbsPrefix: ["response"],
113:                 }),
114:                 rawResponse: _response.rawResponse,
115:             };
116:         }
117: 
118:         if (_response.error.reason === "status-code") {
119:             switch (_response.error.statusCode) {
120:                 case 422:
121:                     throw new Hume.tts.UnprocessableEntityError(
122:                         serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
123:                             unrecognizedObjectKeys: "passthrough",
124:                             allowUnrecognizedUnionMembers: true,
125:                             allowUnrecognizedEnumValues: true,
126:                             skipValidation: true,
127:                             breadcrumbsPrefix: ["response"],
128:                         }),
129:                         _response.rawResponse,
130:                     );
131:                 default:
132:                     throw new errors.HumeError({
133:                         statusCode: _response.error.statusCode,
134:                         body: _response.error.body,
135:                         rawResponse: _response.rawResponse,
136:                     });
137:             }
138:         }
139: 
140:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts");
141:     }
142: 
143:     /**
144:      * Synthesizes one or more input texts into speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
145:      *
146:      * The response contains the generated audio file in the requested format.
147:      * @throws {@link Hume.tts.UnprocessableEntityError}
148:      */
149:     public synthesizeFile(
150:         request: Hume.tts.PostedTts,
151:         requestOptions?: TtsClient.RequestOptions,
152:     ): core.HttpResponsePromise<core.BinaryResponse> {
153:         return core.HttpResponsePromise.fromPromise(this.__synthesizeFile(request, requestOptions));
154:     }
155: 
156:     private async __synthesizeFile(
157:         request: Hume.tts.PostedTts,
158:         requestOptions?: TtsClient.RequestOptions,
159:     ): Promise<core.WithRawResponse<core.BinaryResponse>> {
160:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
161:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
162:             _authRequest.headers,
163:             this._options?.headers,
164:             requestOptions?.headers,
165:         );
166:         const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
167:             url: core.url.join(
168:                 (await core.Supplier.get(this._options.baseUrl)) ??
169:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
170:                 "v0/tts/file",
171:             ),
172:             method: "POST",
173:             headers: _headers,
174:             contentType: "application/json",
175:             queryParameters: requestOptions?.queryParams,
176:             requestType: "json",
177:             body: serializers.tts.PostedTts.jsonOrThrow(request, {
178:                 unrecognizedObjectKeys: "strip",
179:                 omitUndefined: true,
180:             }),
181:             responseType: "binary-response",
182:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
183:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
184:             abortSignal: requestOptions?.abortSignal,
185:             fetchFn: this._options?.fetch,
186:             logging: this._options.logging,
187:         });
188:         if (_response.ok) {
189:             return { data: _response.body, rawResponse: _response.rawResponse };
190:         }
191: 
192:         if (_response.error.reason === "status-code") {
193:             switch (_response.error.statusCode) {
194:                 case 422:
195:                     throw new Hume.tts.UnprocessableEntityError(
196:                         serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
197:                             unrecognizedObjectKeys: "passthrough",
198:                             allowUnrecognizedUnionMembers: true,
199:                             allowUnrecognizedEnumValues: true,
200:                             skipValidation: true,
201:                             breadcrumbsPrefix: ["response"],
202:                         }),
203:                         _response.rawResponse,
204:                     );
205:                 default:
206:                     throw new errors.HumeError({
207:                         statusCode: _response.error.statusCode,
208:                         body: _response.error.body,
209:                         rawResponse: _response.rawResponse,
210:                     });
211:             }
212:         }
213: 
214:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts/file");
215:     }
216: 
217:     /**
218:      * Streams synthesized speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
219:      * @throws {@link Hume.tts.UnprocessableEntityError}
220:      */
221:     public synthesizeFileStreaming(
222:         request: Hume.tts.PostedTts,
223:         requestOptions?: TtsClient.RequestOptions,
224:     ): core.HttpResponsePromise<core.BinaryResponse> {
225:         return core.HttpResponsePromise.fromPromise(this.__synthesizeFileStreaming(request, requestOptions));
226:     }
227: 
228:     private async __synthesizeFileStreaming(
229:         request: Hume.tts.PostedTts,
230:         requestOptions?: TtsClient.RequestOptions,
231:     ): Promise<core.WithRawResponse<core.BinaryResponse>> {
232:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
233:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
234:             _authRequest.headers,
235:             this._options?.headers,
236:             requestOptions?.headers,
237:         );
238:         const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
239:             url: core.url.join(
240:                 (await core.Supplier.get(this._options.baseUrl)) ??
241:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
242:                 "v0/tts/stream/file",
243:             ),
244:             method: "POST",
245:             headers: _headers,
246:             contentType: "application/json",
247:             queryParameters: requestOptions?.queryParams,
248:             requestType: "json",
249:             body: serializers.tts.PostedTts.jsonOrThrow(request, {
250:                 unrecognizedObjectKeys: "strip",
251:                 omitUndefined: true,
252:             }),
253:             responseType: "binary-response",
254:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
255:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
256:             abortSignal: requestOptions?.abortSignal,
257:             fetchFn: this._options?.fetch,
258:             logging: this._options.logging,
259:         });
260:         if (_response.ok) {
261:             return { data: _response.body, rawResponse: _response.rawResponse };
262:         }
263: 
264:         if (_response.error.reason === "status-code") {
265:             switch (_response.error.statusCode) {
266:                 case 422:
267:                     throw new Hume.tts.UnprocessableEntityError(
268:                         serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
269:                             unrecognizedObjectKeys: "passthrough",
270:                             allowUnrecognizedUnionMembers: true,
271:                             allowUnrecognizedEnumValues: true,
272:                             skipValidation: true,
273:                             breadcrumbsPrefix: ["response"],
274:                         }),
275:                         _response.rawResponse,
276:                     );
277:                 default:
278:                     throw new errors.HumeError({
279:                         statusCode: _response.error.statusCode,
280:                         body: _response.error.body,
281:                         rawResponse: _response.rawResponse,
282:                     });
283:             }
284:         }
285: 
286:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts/stream/file");
287:     }
288: 
289:     /**
290:      * Streams synthesized speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
291:      *
292:      * The response is a stream of JSON objects including audio encoded in base64.
293:      */
294:     public synthesizeJsonStreaming(
295:         request: Hume.tts.PostedTts,
296:         requestOptions?: TtsClient.RequestOptions,
297:     ): core.HttpResponsePromise<core.Stream<Hume.tts.TtsOutput>> {
298:         return core.HttpResponsePromise.fromPromise(this.__synthesizeJsonStreaming(request, requestOptions));
299:     }
300: 
301:     private async __synthesizeJsonStreaming(
302:         request: Hume.tts.PostedTts,
303:         requestOptions?: TtsClient.RequestOptions,
304:     ): Promise<core.WithRawResponse<core.Stream<Hume.tts.TtsOutput>>> {
305:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
306:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
307:             _authRequest.headers,
308:             this._options?.headers,
309:             requestOptions?.headers,
310:         );
311:         const _response = await (this._options.fetcher ?? core.fetcher)<ReadableStream>({
312:             url: core.url.join(
313:                 (await core.Supplier.get(this._options.baseUrl)) ??
314:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
315:                 "v0/tts/stream/json",
316:             ),
317:             method: "POST",
318:             headers: _headers,
319:             contentType: "application/json",
320:             queryParameters: requestOptions?.queryParams,
321:             requestType: "json",
322:             body: serializers.tts.PostedTts.jsonOrThrow(request, {
323:                 unrecognizedObjectKeys: "strip",
324:                 omitUndefined: true,
325:             }),
326:             responseType: "sse",
327:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
328:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
329:             abortSignal: requestOptions?.abortSignal,
330:             fetchFn: this._options?.fetch,
331:             logging: this._options.logging,
332:         });
333:         if (_response.ok) {
334:             return {
335:                 data: new core.Stream({
336:                     stream: _response.body,
337:                     parse: async (data) => {
338:                         return serializers.tts.TtsOutput.parseOrThrow(data, {
339:                             unrecognizedObjectKeys: "passthrough",
340:                             allowUnrecognizedUnionMembers: true,
341:                             allowUnrecognizedEnumValues: true,
342:                             skipValidation: true,
343:                             breadcrumbsPrefix: ["response"],
344:                         });
345:                     },
346:                     signal: requestOptions?.abortSignal,
347:                     eventShape: {
348:                         type: "json",
349:                         messageTerminator: "\n",
350:                     },
351:                 }),
352:                 rawResponse: _response.rawResponse,
353:             };
354:         }
355: 
356:         if (_response.error.reason === "status-code") {
357:             switch (_response.error.statusCode) {
358:                 case 422:
359:                     throw new Hume.tts.UnprocessableEntityError(
360:                         serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
361:                             unrecognizedObjectKeys: "passthrough",
362:                             allowUnrecognizedUnionMembers: true,
363:                             allowUnrecognizedEnumValues: true,
364:                             skipValidation: true,
365:                             breadcrumbsPrefix: ["response"],
366:                         }),
367:                         _response.rawResponse,
368:                     );
369:                 default:
370:                     throw new errors.HumeError({
371:                         statusCode: _response.error.statusCode,
372:                         body: _response.error.body,
373:                         rawResponse: _response.rawResponse,
374:                     });
375:             }
376:         }
377: 
378:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts/stream/json");
379:     }
380: 
381:     /**
382:      * @throws {@link Hume.tts.UnprocessableEntityError}
383:      */
384:     public convertVoiceFile(
385:         request: Hume.tts.ConvertVoiceFileRequest,
386:         requestOptions?: TtsClient.RequestOptions,
387:     ): core.HttpResponsePromise<core.BinaryResponse> {
388:         return core.HttpResponsePromise.fromPromise(this.__convertVoiceFile(request, requestOptions));
389:     }
390: 
391:     private async __convertVoiceFile(
392:         request: Hume.tts.ConvertVoiceFileRequest,
393:         requestOptions?: TtsClient.RequestOptions,
394:     ): Promise<core.WithRawResponse<core.BinaryResponse>> {
395:         const _body = await core.newFormData();
396:         if (request.stripHeaders != null) {
397:             _body.append("strip_headers", request.stripHeaders?.toString());
398:         }
399: 
400:         await _body.appendFile("audio", request.audio);
401:         if (request.context != null) {
402:             _body.append(
403:                 "context",
404:                 (() => {
405:                     const mapped = serializers.tts.PostedContext.jsonOrThrow(request.context, {
406:                         unrecognizedObjectKeys: "strip",
407:                         omitUndefined: true,
408:                     });
409:                     return typeof mapped === "string" ? mapped : toJson(mapped);
410:                 })(),
411:             );
412:         }
413: 
414:         if (request.voice != null) {
415:             _body.append(
416:                 "voice",
417:                 (() => {
418:                     const mapped = serializers.tts.PostedUtteranceVoice.jsonOrThrow(request.voice, {
419:                         unrecognizedObjectKeys: "strip",
420:                         omitUndefined: true,
421:                     });
422:                     return typeof mapped === "string" ? mapped : toJson(mapped);
423:                 })(),
424:             );
425:         }
426: 
427:         if (request.format != null) {
428:             _body.append(
429:                 "format",
430:                 (() => {
431:                     const mapped = serializers.tts.Format.jsonOrThrow(request.format, {
432:                         unrecognizedObjectKeys: "strip",
433:                         omitUndefined: true,
434:                     });
435:                     return typeof mapped === "string" ? mapped : toJson(mapped);
436:                 })(),
437:             );
438:         }
439: 
440:         if (request.includeTimestampTypes != null) {
441:             for (const _item of request.includeTimestampTypes) {
442:                 _body.append(
443:                     "include_timestamp_types",
444:                     serializers.tts.TimestampType.jsonOrThrow(_item, {
445:                         unrecognizedObjectKeys: "strip",
446:                         omitUndefined: true,
447:                     }),
448:                 );
449:             }
450:         }
451: 
452:         const _maybeEncodedRequest = await _body.getRequest();
453:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
454:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
455:             _authRequest.headers,
456:             this._options?.headers,
457:             mergeOnlyDefinedHeaders({ ..._maybeEncodedRequest.headers }),
458:             requestOptions?.headers,
459:         );
460:         const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
461:             url: core.url.join(
462:                 (await core.Supplier.get(this._options.baseUrl)) ??
463:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
464:                 "v0/tts/voice_conversion/file",
465:             ),
466:             method: "POST",
467:             headers: _headers,
468:             queryParameters: requestOptions?.queryParams,
469:             requestType: "file",
470:             duplex: _maybeEncodedRequest.duplex,
471:             body: _maybeEncodedRequest.body,
472:             responseType: "binary-response",
473:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
474:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
475:             abortSignal: requestOptions?.abortSignal,
476:             fetchFn: this._options?.fetch,
477:             logging: this._options.logging,
478:         });
479:         if (_response.ok) {
480:             return { data: _response.body, rawResponse: _response.rawResponse };
481:         }
482: 
483:         if (_response.error.reason === "status-code") {
484:             switch (_response.error.statusCode) {
485:                 case 422:
486:                     throw new Hume.tts.UnprocessableEntityError(
487:                         serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
488:                             unrecognizedObjectKeys: "passthrough",
489:                             allowUnrecognizedUnionMembers: true,
490:                             allowUnrecognizedEnumValues: true,
491:                             skipValidation: true,
492:                             breadcrumbsPrefix: ["response"],
493:                         }),
494:                         _response.rawResponse,
495:                     );
496:                 default:
497:                     throw new errors.HumeError({
498:                         statusCode: _response.error.statusCode,
499:                         body: _response.error.body,
500:                         rawResponse: _response.rawResponse,
501:                     });
502:             }
503:         }
504: 
505:         return handleNonStatusCodeError(
506:             _response.error,
507:             _response.rawResponse,
508:             "POST",
509:             "/v0/tts/voice_conversion/file",
510:         );
511:     }
512: 
513:     public convertVoiceJson(
514:         request: Hume.tts.ConvertVoiceJsonRequest,
515:         requestOptions?: TtsClient.RequestOptions,
516:     ): core.HttpResponsePromise<core.Stream<Hume.tts.TtsOutput>> {
517:         return core.HttpResponsePromise.fromPromise(this.__convertVoiceJson(request, requestOptions));
518:     }
519: 
520:     private async __convertVoiceJson(
521:         request: Hume.tts.ConvertVoiceJsonRequest,
522:         requestOptions?: TtsClient.RequestOptions,
523:     ): Promise<core.WithRawResponse<core.Stream<Hume.tts.TtsOutput>>> {
524:         const _body = await core.newFormData();
525:         if (request.stripHeaders != null) {
526:             _body.append("strip_headers", request.stripHeaders?.toString());
527:         }
528: 
529:         if (request.audio != null) {
530:             await _body.appendFile("audio", request.audio);
531:         }
532: 
533:         if (request.context != null) {
534:             _body.append(
535:                 "context",
536:                 (() => {
537:                     const mapped = serializers.tts.PostedContext.jsonOrThrow(request.context, {
538:                         unrecognizedObjectKeys: "strip",
539:                         omitUndefined: true,
540:                     });
541:                     return typeof mapped === "string" ? mapped : toJson(mapped);
542:                 })(),
543:             );
544:         }
545: 
546:         if (request.voice != null) {
547:             _body.append(
548:                 "voice",
549:                 (() => {
550:                     const mapped = serializers.tts.PostedUtteranceVoice.jsonOrThrow(request.voice, {
551:                         unrecognizedObjectKeys: "strip",
552:                         omitUndefined: true,
553:                     });
554:                     return typeof mapped === "string" ? mapped : toJson(mapped);
555:                 })(),
556:             );
557:         }
558: 
559:         if (request.format != null) {
560:             _body.append(
561:                 "format",
562:                 (() => {
563:                     const mapped = serializers.tts.Format.jsonOrThrow(request.format, {
564:                         unrecognizedObjectKeys: "strip",
565:                         omitUndefined: true,
566:                     });
567:                     return typeof mapped === "string" ? mapped : toJson(mapped);
568:                 })(),
569:             );
570:         }
571: 
572:         if (request.includeTimestampTypes != null) {
573:             for (const _item of request.includeTimestampTypes) {
574:                 _body.append(
575:                     "include_timestamp_types",
576:                     serializers.tts.TimestampType.jsonOrThrow(_item, {
577:                         unrecognizedObjectKeys: "strip",
578:                         omitUndefined: true,
579:                     }),
580:                 );
581:             }
582:         }
583: 
584:         const _maybeEncodedRequest = await _body.getRequest();
585:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
586:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
587:             _authRequest.headers,
588:             this._options?.headers,
589:             mergeOnlyDefinedHeaders({ ..._maybeEncodedRequest.headers }),
590:             requestOptions?.headers,
591:         );
592:         const _response = await (this._options.fetcher ?? core.fetcher)<ReadableStream>({
593:             url: core.url.join(
594:                 (await core.Supplier.get(this._options.baseUrl)) ??
595:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
596:                 "v0/tts/voice_conversion/json",
597:             ),
598:             method: "POST",
599:             headers: _headers,
600:             queryParameters: requestOptions?.queryParams,
601:             requestType: "file",
602:             duplex: _maybeEncodedRequest.duplex,
603:             body: _maybeEncodedRequest.body,
604:             responseType: "sse",
605:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
606:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
607:             abortSignal: requestOptions?.abortSignal,
608:             fetchFn: this._options?.fetch,
609:             logging: this._options.logging,
610:         });
611:         if (_response.ok) {
612:             return {
613:                 data: new core.Stream({
614:                     stream: _response.body,
615:                     parse: async (data) => {
616:                         return serializers.tts.TtsOutput.parseOrThrow(data, {
617:                             unrecognizedObjectKeys: "passthrough",
618:                             allowUnrecognizedUnionMembers: true,
619:                             allowUnrecognizedEnumValues: true,
620:                             skipValidation: true,
621:                             breadcrumbsPrefix: ["response"],
622:                         });
623:                     },
624:                     signal: requestOptions?.abortSignal,
625:                     eventShape: {
626:                         type: "json",
627:                         messageTerminator: "\n",
628:                     },
629:                 }),
630:                 rawResponse: _response.rawResponse,
631:             };
632:         }
633: 
634:         if (_response.error.reason === "status-code") {
635:             switch (_response.error.statusCode) {
636:                 case 422:
637:                     throw new Hume.tts.UnprocessableEntityError(
638:                         serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
639:                             unrecognizedObjectKeys: "passthrough",
640:                             allowUnrecognizedUnionMembers: true,
641:                             allowUnrecognizedEnumValues: true,
642:                             skipValidation: true,
643:                             breadcrumbsPrefix: ["response"],
644:                         }),
645:                         _response.rawResponse,
646:                     );
647:                 default:
648:                     throw new errors.HumeError({
649:                         statusCode: _response.error.statusCode,
650:                         body: _response.error.body,
651:                         rawResponse: _response.rawResponse,
652:                     });
653:             }
654:         }
655: 
656:         return handleNonStatusCodeError(
657:             _response.error,
658:             _response.rawResponse,
659:             "POST",
660:             "/v0/tts/voice_conversion/json",
661:         );
662:     }
663: }
````

## File: src/api/resources/tts/client/index.ts
````typescript
1: export * from "./requests/index.js";
````

## File: src/api/resources/tts/errors/BadRequestError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as core from "../../../../core/index.js";
 4: import * as errors from "../../../../errors/index.js";
 5: import type * as Hume from "../../../index.js";
 6: 
 7: export class BadRequestError extends errors.HumeError {
 8:     constructor(body: Hume.tts.ErrorResponse, rawResponse?: core.RawResponse) {
 9:         super({
10:             message: "BadRequestError",
11:             statusCode: 400,
12:             body: body,
13:             rawResponse: rawResponse,
14:         });
15:         Object.setPrototypeOf(this, new.target.prototype);
16:         if (Error.captureStackTrace) {
17:             Error.captureStackTrace(this, this.constructor);
18:         }
19: 
20:         this.name = this.constructor.name;
21:     }
22: }
````

## File: src/api/resources/tts/errors/index.ts
````typescript
1: export * from "./BadRequestError.js";
2: export * from "./UnprocessableEntityError.js";
````

## File: src/api/resources/tts/errors/UnprocessableEntityError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as core from "../../../../core/index.js";
 4: import * as errors from "../../../../errors/index.js";
 5: import type * as Hume from "../../../index.js";
 6: 
 7: export class UnprocessableEntityError extends errors.HumeError {
 8:     constructor(body: Hume.tts.HttpValidationError, rawResponse?: core.RawResponse) {
 9:         super({
10:             message: "UnprocessableEntityError",
11:             statusCode: 422,
12:             body: body,
13:             rawResponse: rawResponse,
14:         });
15:         Object.setPrototypeOf(this, new.target.prototype);
16:         if (Error.captureStackTrace) {
17:             Error.captureStackTrace(this, this.constructor);
18:         }
19: 
20:         this.name = this.constructor.name;
21:     }
22: }
````

## File: src/api/resources/tts/resources/streamInput/client/Client.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import type { BaseClientOptions } from "../../../../../../BaseClient.js";
  4: import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
  5: import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
  6: import * as core from "../../../../../../core/index.js";
  7: import * as environments from "../../../../../../environments.js";
  8: import * as serializers from "../../../../../../serialization/index.js";
  9: import type * as Hume from "../../../../../index.js";
 10: import { StreamInputSocket } from "./Socket.js";
 11: 
 12: export declare namespace StreamInputClient {
 13:     export interface Options extends BaseClientOptions {}
 14: 
 15:     export interface ConnectArgs {
 16:         accessToken?: string;
 17:         contextGenerationId?: string;
 18:         formatType?: Hume.tts.AudioFormatType;
 19:         includeTimestampTypes?: Hume.tts.TimestampType | Hume.tts.TimestampType[];
 20:         instantMode?: boolean;
 21:         noBinary?: boolean;
 22:         stripHeaders?: boolean;
 23:         version?: Hume.tts.OctaveVersion;
 24:         apiKey?: string;
 25:         /** Arbitrary headers to send with the websocket connect request. */
 26:         headers?: Record<string, string>;
 27:         /** Enable debug mode on the websocket. Defaults to false. */
 28:         debug?: boolean;
 29:         /** Number of reconnect attempts. Defaults to 30. */
 30:         reconnectAttempts?: number;
 31:     }
 32: }
 33: 
 34: export class StreamInputClient {
 35:     protected readonly _options: NormalizedClientOptions<StreamInputClient.Options>;
 36: 
 37:     constructor(options: StreamInputClient.Options = {}) {
 38:         this._options = normalizeClientOptions(options);
 39:     }
 40: 
 41:     public async connect(args: StreamInputClient.ConnectArgs = {}): Promise<StreamInputSocket> {
 42:         const {
 43:             accessToken,
 44:             contextGenerationId,
 45:             formatType,
 46:             includeTimestampTypes,
 47:             instantMode,
 48:             noBinary,
 49:             stripHeaders,
 50:             version,
 51:             apiKey,
 52:             headers,
 53:             debug,
 54:             reconnectAttempts,
 55:         } = args;
 56:         const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
 57:         if (accessToken != null) {
 58:             _queryParams.access_token = accessToken;
 59:         }
 60: 
 61:         if (contextGenerationId != null) {
 62:             _queryParams.context_generation_id = contextGenerationId;
 63:         }
 64: 
 65:         if (formatType != null) {
 66:             _queryParams.format_type = serializers.tts.AudioFormatType.jsonOrThrow(formatType, {
 67:                 unrecognizedObjectKeys: "strip",
 68:                 omitUndefined: true,
 69:             });
 70:         }
 71: 
 72:         if (includeTimestampTypes != null) {
 73:             if (Array.isArray(includeTimestampTypes)) {
 74:                 _queryParams.include_timestamp_types = includeTimestampTypes.map((item) =>
 75:                     serializers.tts.TimestampType.jsonOrThrow(item, {
 76:                         unrecognizedObjectKeys: "strip",
 77:                         omitUndefined: true,
 78:                     }),
 79:                 );
 80:             } else {
 81:                 _queryParams.include_timestamp_types = serializers.tts.TimestampType.jsonOrThrow(
 82:                     includeTimestampTypes,
 83:                     {
 84:                         unrecognizedObjectKeys: "strip",
 85:                         omitUndefined: true,
 86:                     },
 87:                 );
 88:             }
 89:         }
 90: 
 91:         if (instantMode != null) {
 92:             _queryParams.instant_mode = instantMode.toString();
 93:         }
 94: 
 95:         if (noBinary != null) {
 96:             _queryParams.no_binary = noBinary.toString();
 97:         }
 98: 
 99:         if (stripHeaders != null) {
100:             _queryParams.strip_headers = stripHeaders.toString();
101:         }
102: 
103:         if (version != null) {
104:             _queryParams.version = serializers.tts.OctaveVersion.jsonOrThrow(version, {
105:                 unrecognizedObjectKeys: "strip",
106:                 omitUndefined: true,
107:             });
108:         }
109: 
110:         if (apiKey != null) {
111:             _queryParams.api_key = apiKey;
112:         }
113: 
114:         const _headers: Record<string, unknown> = mergeHeaders(
115:             mergeOnlyDefinedHeaders({
116:                 ...(await this._getCustomAuthorizationHeaders()),
117:             }),
118:             headers,
119:         );
120:         const socket = new core.ReconnectingWebSocket({
121:             url: core.url.join(
122:                 (await core.Supplier.get(this._options.baseUrl)) ??
123:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).tts,
124:                 "/stream/input",
125:             ),
126:             protocols: [],
127:             queryParameters: _queryParams,
128:             headers: _headers,
129:             options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
130:         });
131:         return new StreamInputSocket({ socket });
132:     }
133: 
134:     protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
135:         const apiKeyValue = core.Supplier.get(this._options.apiKey);
136:         // This `authHeaderValue` is manually added as if you don't provide it it will
137:         // be omitted from the headers which means it won't reach the logic in ws.ts that
138:         // extracts values from the headers and adds them to query parameters.
139:         const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
140:         return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
141:     }
142: }
````

## File: src/api/resources/tts/resources/streamInput/client/Client.ts.diff
````diff
  1: diff --git a/src/api/resources/tts/resources/streamInput/client/Client.ts b/src/api/resources/tts/resources/streamInput/client/Client.ts
  2: index e8477c1..4e3ef08 100644
  3: --- a/src/api/resources/tts/resources/streamInput/client/Client.ts
  4: +++ b/src/api/resources/tts/resources/streamInput/client/Client.ts
  5: @@ -2,7 +2,6 @@
  6:  
  7:  import type { BaseClientOptions } from "../../../../../../BaseClient.js";
  8:  import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
  9: -import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
 10:  import * as core from "../../../../../../core/index.js";
 11:  import * as environments from "../../../../../../environments.js";
 12:  import * as serializers from "../../../../../../serialization/index.js";
 13: @@ -10,7 +9,7 @@ import type * as Hume from "../../../../../index.js";
 14:  import { StreamInputSocket } from "./Socket.js";
 15:  
 16:  export declare namespace StreamInputClient {
 17: -    export interface Options extends BaseClientOptions {}
 18: +    export type Options = BaseClientOptions;
 19:  
 20:      export interface ConnectArgs {
 21:          accessToken?: string;
 22: @@ -53,70 +52,42 @@ export class StreamInputClient {
 23:              debug,
 24:              reconnectAttempts,
 25:          } = args;
 26: -        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
 27: -        if (accessToken != null) {
 28: -            _queryParams.access_token = accessToken;
 29: -        }
 30: -
 31: -        if (contextGenerationId != null) {
 32: -            _queryParams.context_generation_id = contextGenerationId;
 33: -        }
 34: -
 35: -        if (formatType != null) {
 36: -            _queryParams.format_type = serializers.tts.AudioFormatType.jsonOrThrow(formatType, {
 37: -                unrecognizedObjectKeys: "strip",
 38: -                omitUndefined: true,
 39: -            });
 40: -        }
 41: -
 42: -        if (includeTimestampTypes != null) {
 43: -            if (Array.isArray(includeTimestampTypes)) {
 44: -                _queryParams.include_timestamp_types = includeTimestampTypes.map((item) =>
 45: -                    serializers.tts.TimestampType.jsonOrThrow(item, {
 46: +        const _queryParams: Record<string, unknown> = {
 47: +            access_token: accessToken,
 48: +            context_generation_id: contextGenerationId,
 49: +            format_type:
 50: +                formatType != null
 51: +                    ? serializers.tts.AudioFormatType.jsonOrThrow(formatType, {
 52: +                          unrecognizedObjectKeys: "strip",
 53: +                          omitUndefined: true,
 54: +                      })
 55: +                    : undefined,
 56: +            include_timestamp_types: Array.isArray(includeTimestampTypes)
 57: +                ? includeTimestampTypes.map((item) =>
 58: +                      serializers.tts.TimestampType.jsonOrThrow(item, {
 59: +                          unrecognizedObjectKeys: "strip",
 60: +                          omitUndefined: true,
 61: +                      }),
 62: +                  )
 63: +                : includeTimestampTypes != null
 64: +                  ? serializers.tts.TimestampType.jsonOrThrow(includeTimestampTypes, {
 65:                          unrecognizedObjectKeys: "strip",
 66:                          omitUndefined: true,
 67: -                    }),
 68: -                );
 69: -            } else {
 70: -                _queryParams.include_timestamp_types = serializers.tts.TimestampType.jsonOrThrow(
 71: -                    includeTimestampTypes,
 72: -                    {
 73: -                        unrecognizedObjectKeys: "strip",
 74: -                        omitUndefined: true,
 75: -                    },
 76: -                );
 77: -            }
 78: -        }
 79: -
 80: -        if (instantMode != null) {
 81: -            _queryParams.instant_mode = instantMode.toString();
 82: -        }
 83: -
 84: -        if (noBinary != null) {
 85: -            _queryParams.no_binary = noBinary.toString();
 86: -        }
 87: -
 88: -        if (stripHeaders != null) {
 89: -            _queryParams.strip_headers = stripHeaders.toString();
 90: -        }
 91: -
 92: -        if (version != null) {
 93: -            _queryParams.version = serializers.tts.OctaveVersion.jsonOrThrow(version, {
 94: -                unrecognizedObjectKeys: "strip",
 95: -                omitUndefined: true,
 96: -            });
 97: -        }
 98: -
 99: -        if (apiKey != null) {
100: -            _queryParams.api_key = apiKey;
101: -        }
102: -
103: -        const _headers: Record<string, unknown> = mergeHeaders(
104: -            mergeOnlyDefinedHeaders({
105: -                ...(await this._getCustomAuthorizationHeaders()),
106: -            }),
107: -            headers,
108: -        );
109: +                    })
110: +                  : undefined,
111: +            instant_mode: instantMode,
112: +            no_binary: noBinary,
113: +            strip_headers: stripHeaders,
114: +            version:
115: +                version != null
116: +                    ? serializers.tts.OctaveVersion.jsonOrThrow(version, {
117: +                          unrecognizedObjectKeys: "strip",
118: +                          omitUndefined: true,
119: +                      })
120: +                    : undefined,
121: +            api_key: apiKey,
122: +        };
123: +        const _headers: Record<string, unknown> = { ...headers };
124:          const socket = new core.ReconnectingWebSocket({
125:              url: core.url.join(
126:                  (await core.Supplier.get(this._options.baseUrl)) ??
127: @@ -130,13 +101,4 @@ export class StreamInputClient {
128:          });
129:          return new StreamInputSocket({ socket });
130:      }
131: -
132: -    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
133: -        const apiKeyValue = core.Supplier.get(this._options.apiKey);
134: -        // This `authHeaderValue` is manually added as if you don't provide it it will
135: -        // be omitted from the headers which means it won't reach the logic in ws.ts that
136: -        // extracts values from the headers and adds them to query parameters.
137: -        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
138: -        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
139: -    }
140:  }
````

## File: src/api/resources/tts/resources/streamInput/client/index.ts
````typescript
1: export {};
````

## File: src/api/resources/tts/resources/streamInput/client/Socket.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import * as core from "../../../../../../core/index.js";
  4: import { fromJson } from "../../../../../../core/json.js";
  5: import * as serializers from "../../../../../../serialization/index.js";
  6: import { PublishTts } from "../../../../../../serialization/resources/tts/types/PublishTts.js";
  7: import type * as Hume from "../../../../../index.js";
  8: 
  9: export declare namespace StreamInputSocket {
 10:     export interface Args {
 11:         socket: core.ReconnectingWebSocket;
 12:     }
 13: 
 14:     export type Response = Hume.tts.TtsOutput;
 15:     type EventHandlers = {
 16:         open?: () => void;
 17:         message?: (message: Response) => void;
 18:         close?: (event: core.CloseEvent) => void;
 19:         error?: (error: Error) => void;
 20:     };
 21: }
 22: 
 23: export class StreamInputSocket {
 24:     public readonly socket: core.ReconnectingWebSocket;
 25:     protected readonly eventHandlers: StreamInputSocket.EventHandlers = {};
 26:     private handleOpen: () => void = () => {
 27:         this.eventHandlers.open?.();
 28:     };
 29:     private handleMessage: (event: { data: string }) => void = (event) => {
 30:         const data = fromJson(event.data);
 31: 
 32:         const parsedResponse = serializers.tts.StreamInputSocketResponse.parse(data, {
 33:             unrecognizedObjectKeys: "passthrough",
 34:             allowUnrecognizedUnionMembers: true,
 35:             allowUnrecognizedEnumValues: true,
 36:             skipValidation: true,
 37:             omitUndefined: true,
 38:         });
 39:         if (parsedResponse.ok) {
 40:             this.eventHandlers.message?.(parsedResponse.value);
 41:         } else {
 42:             this.eventHandlers.error?.(new Error("Received unknown message type"));
 43:         }
 44:     };
 45:     private handleClose: (event: core.CloseEvent) => void = (event) => {
 46:         this.eventHandlers.close?.(event);
 47:     };
 48:     private handleError: (event: core.ErrorEvent) => void = (event) => {
 49:         const message = event.message;
 50:         this.eventHandlers.error?.(new Error(message));
 51:     };
 52: 
 53:     constructor(args: StreamInputSocket.Args) {
 54:         this.socket = args.socket;
 55:         this.socket.addEventListener("open", this.handleOpen);
 56:         this.socket.addEventListener("message", this.handleMessage);
 57:         this.socket.addEventListener("close", this.handleClose);
 58:         this.socket.addEventListener("error", this.handleError);
 59:     }
 60: 
 61:     /** The current state of the connection; this is one of the readyState constants. */
 62:     get readyState(): number {
 63:         return this.socket.readyState;
 64:     }
 65: 
 66:     /**
 67:      * @param event - The event to attach to.
 68:      * @param callback - The callback to run when the event is triggered.
 69:      * Usage:
 70:      * ```typescript
 71:      * this.on('open', () => {
 72:      *     console.log('The websocket is open');
 73:      * });
 74:      * ```
 75:      */
 76:     public on<T extends keyof StreamInputSocket.EventHandlers>(
 77:         event: T,
 78:         callback: StreamInputSocket.EventHandlers[T],
 79:     ): void {
 80:         this.eventHandlers[event] = callback;
 81:     }
 82: 
 83:     public sendPublish(message: Hume.tts.PublishTts): void {
 84:         this.assertSocketIsOpen();
 85:         const jsonPayload = PublishTts.jsonOrThrow(message, {
 86:             unrecognizedObjectKeys: "passthrough",
 87:             allowUnrecognizedUnionMembers: true,
 88:             allowUnrecognizedEnumValues: true,
 89:             skipValidation: true,
 90:             omitUndefined: true,
 91:         });
 92:         this.socket.send(JSON.stringify(jsonPayload));
 93:     }
 94: 
 95:     /** Connect to the websocket and register event handlers. */
 96:     public connect(): StreamInputSocket {
 97:         this.socket.reconnect();
 98: 
 99:         this.socket.addEventListener("open", this.handleOpen);
100:         this.socket.addEventListener("message", this.handleMessage);
101:         this.socket.addEventListener("close", this.handleClose);
102:         this.socket.addEventListener("error", this.handleError);
103: 
104:         return this;
105:     }
106: 
107:     /** Close the websocket and unregister event handlers. */
108:     public close(): void {
109:         this.socket.close();
110: 
111:         this.handleClose({ code: 1000 } as CloseEvent);
112: 
113:         this.socket.removeEventListener("open", this.handleOpen);
114:         this.socket.removeEventListener("message", this.handleMessage);
115:         this.socket.removeEventListener("close", this.handleClose);
116:         this.socket.removeEventListener("error", this.handleError);
117:     }
118: 
119:     /** Returns a promise that resolves when the websocket is open. */
120:     public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
121:         if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
122:             return this.socket;
123:         }
124: 
125:         return new Promise((resolve, reject) => {
126:             this.socket.addEventListener("open", () => {
127:                 resolve(this.socket);
128:             });
129: 
130:             this.socket.addEventListener("error", (event: unknown) => {
131:                 reject(event);
132:             });
133:         });
134:     }
135: 
136:     /** Asserts that the websocket is open. */
137:     private assertSocketIsOpen(): void {
138:         if (!this.socket) {
139:             throw new Error("Socket is not connected.");
140:         }
141: 
142:         if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
143:             throw new Error("Socket is not open.");
144:         }
145:     }
146: 
147:     /** Send a binary payload to the websocket. */
148:     protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
149:         this.socket.send(payload);
150:     }
151: }
````

## File: src/api/resources/tts/resources/streamInput/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/api/resources/tts/resources/voices/client/requests/index.ts
````typescript
1: export type { PostedVoice } from "./PostedVoice.js";
2: export type { VoicesDeleteRequest } from "./VoicesDeleteRequest.js";
3: export type { VoicesListRequest } from "./VoicesListRequest.js";
````

## File: src/api/resources/tts/resources/voices/client/requests/PostedVoice.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
 7:  *         name: "David Hume"
 8:  *     }
 9:  */
10: export interface PostedVoice {
11:     /** A unique ID associated with this TTS generation that can be used as context for generating consistent speech style and prosody across multiple requests. */
12:     generationId: string;
13:     /** The name of a **Voice**. */
14:     name: string;
15: }
````

## File: src/api/resources/tts/resources/voices/client/requests/VoicesDeleteRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * @example
 5:  *     {
 6:  *         name: "David Hume"
 7:  *     }
 8:  */
 9: export interface VoicesDeleteRequest {
10:     /** Name of the voice to delete */
11:     name: string;
12: }
````

## File: src/api/resources/tts/resources/voices/client/requests/VoicesListRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../index.js";
 4: 
 5: /**
 6:  * @example
 7:  *     {
 8:  *         provider: "CUSTOM_VOICE"
 9:  *     }
10:  */
11: export interface VoicesListRequest {
12:     /**
13:      * Specify the voice provider to filter voices returned by the endpoint:
14:      *
15:      * - **`HUME_AI`**: Lists preset, shared voices from Hume's [Voice Library](https://app.hume.ai/voices).
16:      * - **`CUSTOM_VOICE`**: Lists custom voices created and saved to your account.
17:      */
18:     provider: Hume.tts.VoiceProvider;
19:     /**
20:      * Specifies the page number to retrieve, enabling pagination.
21:      *
22:      * This parameter uses zero-based indexing. For example, setting `page_number` to 0 retrieves the first page of results (items 0-9 if `page_size` is 10), setting `page_number` to 1 retrieves the second page (items 10-19), and so on. Defaults to 0, which retrieves the first page.
23:      */
24:     pageNumber?: number;
25:     /**
26:      * Specifies the maximum number of results to include per page, enabling pagination. The value must be between 1 and 100, inclusive.
27:      *
28:      * For example, if `page_size` is set to 10, each page will include up to 10 items. Defaults to 10.
29:      */
30:     pageSize?: number;
31:     ascendingOrder?: boolean;
32:     filterTag?: string | string[];
33: }
````

## File: src/api/resources/tts/resources/voices/client/Client.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
  4: import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
  5: import { mergeHeaders } from "../../../../../../core/headers.js";
  6: import * as core from "../../../../../../core/index.js";
  7: import * as environments from "../../../../../../environments.js";
  8: import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
  9: import * as errors from "../../../../../../errors/index.js";
 10: import * as serializers from "../../../../../../serialization/index.js";
 11: import * as Hume from "../../../../../index.js";
 12: 
 13: export declare namespace VoicesClient {
 14:     export type Options = BaseClientOptions;
 15: 
 16:     export interface RequestOptions extends BaseRequestOptions {}
 17: }
 18: 
 19: export class VoicesClient {
 20:     protected readonly _options: NormalizedClientOptionsWithAuth<VoicesClient.Options>;
 21: 
 22:     constructor(options: VoicesClient.Options = {}) {
 23:         this._options = normalizeClientOptionsWithAuth(options);
 24:     }
 25: 
 26:     /**
 27:      * Lists voices you have saved in your account, or voices from the [Voice Library](https://app.hume.ai/voices).
 28:      *
 29:      * @param {Hume.tts.VoicesListRequest} request
 30:      * @param {VoicesClient.RequestOptions} requestOptions - Request-specific configuration.
 31:      *
 32:      * @throws {@link Hume.tts.BadRequestError}
 33:      *
 34:      * @example
 35:      *     await client.tts.voices.list({
 36:      *         provider: "CUSTOM_VOICE"
 37:      *     })
 38:      */
 39:     public async list(
 40:         request: Hume.tts.VoicesListRequest,
 41:         requestOptions?: VoicesClient.RequestOptions,
 42:     ): Promise<core.Page<Hume.tts.ReturnVoice, Hume.tts.ReturnPagedVoices>> {
 43:         const list = core.HttpResponsePromise.interceptFunction(
 44:             async (request: Hume.tts.VoicesListRequest): Promise<core.WithRawResponse<Hume.tts.ReturnPagedVoices>> => {
 45:                 const { provider, pageNumber, pageSize, ascendingOrder, filterTag } = request;
 46:                 const _queryParams: Record<string, unknown> = {
 47:                     provider: serializers.tts.VoiceProvider.jsonOrThrow(provider, {
 48:                         unrecognizedObjectKeys: "strip",
 49:                         omitUndefined: true,
 50:                     }),
 51:                     page_number: pageNumber,
 52:                     page_size: pageSize,
 53:                     ascending_order: ascendingOrder,
 54:                     filter_tag: filterTag,
 55:                 };
 56:                 const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
 57:                 const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
 58:                     _authRequest.headers,
 59:                     this._options?.headers,
 60:                     requestOptions?.headers,
 61:                 );
 62:                 const _response = await (this._options.fetcher ?? core.fetcher)({
 63:                     url: core.url.join(
 64:                         (await core.Supplier.get(this._options.baseUrl)) ??
 65:                             ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
 66:                                 .base,
 67:                         "v0/tts/voices",
 68:                     ),
 69:                     method: "GET",
 70:                     headers: _headers,
 71:                     queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
 72:                     timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
 73:                     maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
 74:                     abortSignal: requestOptions?.abortSignal,
 75:                     fetchFn: this._options?.fetch,
 76:                     logging: this._options.logging,
 77:                 });
 78:                 if (_response.ok) {
 79:                     return {
 80:                         data: serializers.tts.ReturnPagedVoices.parseOrThrow(_response.body, {
 81:                             unrecognizedObjectKeys: "passthrough",
 82:                             allowUnrecognizedUnionMembers: true,
 83:                             allowUnrecognizedEnumValues: true,
 84:                             skipValidation: true,
 85:                             breadcrumbsPrefix: ["response"],
 86:                         }),
 87:                         rawResponse: _response.rawResponse,
 88:                     };
 89:                 }
 90:                 if (_response.error.reason === "status-code") {
 91:                     switch (_response.error.statusCode) {
 92:                         case 400:
 93:                             throw new Hume.tts.BadRequestError(
 94:                                 serializers.tts.ErrorResponse.parseOrThrow(_response.error.body, {
 95:                                     unrecognizedObjectKeys: "passthrough",
 96:                                     allowUnrecognizedUnionMembers: true,
 97:                                     allowUnrecognizedEnumValues: true,
 98:                                     skipValidation: true,
 99:                                     breadcrumbsPrefix: ["response"],
100:                                 }),
101:                                 _response.rawResponse,
102:                             );
103:                         default:
104:                             throw new errors.HumeError({
105:                                 statusCode: _response.error.statusCode,
106:                                 body: _response.error.body,
107:                                 rawResponse: _response.rawResponse,
108:                             });
109:                     }
110:                 }
111:                 return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v0/tts/voices");
112:             },
113:         );
114:         let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
115:         const dataWithRawResponse = await list(request).withRawResponse();
116:         return new core.Page<Hume.tts.ReturnVoice, Hume.tts.ReturnPagedVoices>({
117:             response: dataWithRawResponse.data,
118:             rawResponse: dataWithRawResponse.rawResponse,
119:             hasNextPage: (response) => (response?.voicesPage ?? []).length > 0,
120:             getItems: (response) => response?.voicesPage ?? [],
121:             loadPage: (_response) => {
122:                 _offset += 1;
123:                 return list(core.setObjectProperty(request, "pageNumber", _offset));
124:             },
125:         });
126:     }
127: 
128:     /**
129:      * Saves a new custom voice to your account using the specified TTS generation ID.
130:      *
131:      * Once saved, this voice can be reused in subsequent TTS requests, ensuring consistent speech style and prosody. For more details on voice creation, see the [Voices Guide](/docs/text-to-speech-tts/voices).
132:      *
133:      * @param {Hume.tts.PostedVoice} request
134:      * @param {VoicesClient.RequestOptions} requestOptions - Request-specific configuration.
135:      *
136:      * @throws {@link Hume.tts.UnprocessableEntityError}
137:      *
138:      * @example
139:      *     await client.tts.voices.create({
140:      *         generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
141:      *         name: "David Hume"
142:      *     })
143:      */
144:     public create(
145:         request: Hume.tts.PostedVoice,
146:         requestOptions?: VoicesClient.RequestOptions,
147:     ): core.HttpResponsePromise<Hume.tts.ReturnVoice> {
148:         return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
149:     }
150: 
151:     private async __create(
152:         request: Hume.tts.PostedVoice,
153:         requestOptions?: VoicesClient.RequestOptions,
154:     ): Promise<core.WithRawResponse<Hume.tts.ReturnVoice>> {
155:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
156:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
157:             _authRequest.headers,
158:             this._options?.headers,
159:             requestOptions?.headers,
160:         );
161:         const _response = await (this._options.fetcher ?? core.fetcher)({
162:             url: core.url.join(
163:                 (await core.Supplier.get(this._options.baseUrl)) ??
164:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
165:                 "v0/tts/voices",
166:             ),
167:             method: "POST",
168:             headers: _headers,
169:             contentType: "application/json",
170:             queryParameters: requestOptions?.queryParams,
171:             requestType: "json",
172:             body: serializers.tts.PostedVoice.jsonOrThrow(request, {
173:                 unrecognizedObjectKeys: "strip",
174:                 omitUndefined: true,
175:             }),
176:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
177:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
178:             abortSignal: requestOptions?.abortSignal,
179:             fetchFn: this._options?.fetch,
180:             logging: this._options.logging,
181:         });
182:         if (_response.ok) {
183:             return {
184:                 data: serializers.tts.ReturnVoice.parseOrThrow(_response.body, {
185:                     unrecognizedObjectKeys: "passthrough",
186:                     allowUnrecognizedUnionMembers: true,
187:                     allowUnrecognizedEnumValues: true,
188:                     skipValidation: true,
189:                     breadcrumbsPrefix: ["response"],
190:                 }),
191:                 rawResponse: _response.rawResponse,
192:             };
193:         }
194: 
195:         if (_response.error.reason === "status-code") {
196:             switch (_response.error.statusCode) {
197:                 case 422:
198:                     throw new Hume.tts.UnprocessableEntityError(
199:                         serializers.tts.HttpValidationError.parseOrThrow(_response.error.body, {
200:                             unrecognizedObjectKeys: "passthrough",
201:                             allowUnrecognizedUnionMembers: true,
202:                             allowUnrecognizedEnumValues: true,
203:                             skipValidation: true,
204:                             breadcrumbsPrefix: ["response"],
205:                         }),
206:                         _response.rawResponse,
207:                     );
208:                 default:
209:                     throw new errors.HumeError({
210:                         statusCode: _response.error.statusCode,
211:                         body: _response.error.body,
212:                         rawResponse: _response.rawResponse,
213:                     });
214:             }
215:         }
216: 
217:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v0/tts/voices");
218:     }
219: 
220:     /**
221:      * Deletes a previously generated custom voice.
222:      *
223:      * @param {Hume.tts.VoicesDeleteRequest} request
224:      * @param {VoicesClient.RequestOptions} requestOptions - Request-specific configuration.
225:      *
226:      * @throws {@link Hume.tts.BadRequestError}
227:      *
228:      * @example
229:      *     await client.tts.voices.delete({
230:      *         name: "David Hume"
231:      *     })
232:      */
233:     public delete(
234:         request: Hume.tts.VoicesDeleteRequest,
235:         requestOptions?: VoicesClient.RequestOptions,
236:     ): core.HttpResponsePromise<void> {
237:         return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
238:     }
239: 
240:     private async __delete(
241:         request: Hume.tts.VoicesDeleteRequest,
242:         requestOptions?: VoicesClient.RequestOptions,
243:     ): Promise<core.WithRawResponse<void>> {
244:         const { name } = request;
245:         const _queryParams: Record<string, unknown> = {
246:             name,
247:         };
248:         const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
249:         const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
250:             _authRequest.headers,
251:             this._options?.headers,
252:             requestOptions?.headers,
253:         );
254:         const _response = await (this._options.fetcher ?? core.fetcher)({
255:             url: core.url.join(
256:                 (await core.Supplier.get(this._options.baseUrl)) ??
257:                     ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
258:                 "v0/tts/voices",
259:             ),
260:             method: "DELETE",
261:             headers: _headers,
262:             queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
263:             timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
264:             maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
265:             abortSignal: requestOptions?.abortSignal,
266:             fetchFn: this._options?.fetch,
267:             logging: this._options.logging,
268:         });
269:         if (_response.ok) {
270:             return { data: undefined, rawResponse: _response.rawResponse };
271:         }
272: 
273:         if (_response.error.reason === "status-code") {
274:             switch (_response.error.statusCode) {
275:                 case 400:
276:                     throw new Hume.tts.BadRequestError(
277:                         serializers.tts.ErrorResponse.parseOrThrow(_response.error.body, {
278:                             unrecognizedObjectKeys: "passthrough",
279:                             allowUnrecognizedUnionMembers: true,
280:                             allowUnrecognizedEnumValues: true,
281:                             skipValidation: true,
282:                             breadcrumbsPrefix: ["response"],
283:                         }),
284:                         _response.rawResponse,
285:                     );
286:                 default:
287:                     throw new errors.HumeError({
288:                         statusCode: _response.error.statusCode,
289:                         body: _response.error.body,
290:                         rawResponse: _response.rawResponse,
291:                     });
292:             }
293:         }
294: 
295:         return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v0/tts/voices");
296:     }
297: }
````

## File: src/api/resources/tts/resources/voices/client/index.ts
````typescript
1: export * from "./requests/index.js";
````

## File: src/api/resources/tts/resources/voices/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/api/resources/tts/resources/index.ts
````typescript
1: export * as streamInput from "./streamInput/index.js";
2: export * from "./voices/client/requests/index.js";
3: export * as voices from "./voices/index.js";
````

## File: src/api/resources/tts/types/AudioEncoding.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * Encoding information about the generated audio, including the `format` and `sample_rate`.
 7:  */
 8: export interface AudioEncoding {
 9:     /** Format for the output audio. */
10:     format: Hume.tts.AudioFormatType;
11:     /** The sample rate (`Hz`) of the generated audio. The default sample rate is `48000 Hz`. */
12:     sampleRate: number;
13: }
````

## File: src/api/resources/tts/types/AudioFormatType.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const AudioFormatType = {
4:     Mp3: "mp3",
5:     Pcm: "pcm",
6:     Wav: "wav",
7: } as const;
8: export type AudioFormatType = (typeof AudioFormatType)[keyof typeof AudioFormatType];
````

## File: src/api/resources/tts/types/ErrorResponse.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface ErrorResponse {
4:     code?: string;
5:     error?: string;
6:     message?: string;
7: }
````

## File: src/api/resources/tts/types/Format.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: /**
6:  * Specifies the output audio file format.
7:  */
8: export type Format = Hume.tts.FormatMp3 | Hume.tts.FormatPcm | Hume.tts.FormatWav;
````

## File: src/api/resources/tts/types/FormatMp3.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface FormatMp3 {
4:     type: "mp3";
5: }
````

## File: src/api/resources/tts/types/FormatPcm.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface FormatPcm {
4:     type: "pcm";
5: }
````

## File: src/api/resources/tts/types/FormatWav.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface FormatWav {
4:     type: "wav";
5: }
````

## File: src/api/resources/tts/types/HttpValidationError.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: export interface HttpValidationError {
6:     detail?: Hume.tts.ValidationError[];
7: }
````

## File: src/api/resources/tts/types/index.ts
````typescript
 1: export * from "./AudioEncoding.js";
 2: export * from "./AudioFormatType.js";
 3: export * from "./ErrorResponse.js";
 4: export * from "./Format.js";
 5: export * from "./FormatMp3.js";
 6: export * from "./FormatPcm.js";
 7: export * from "./FormatWav.js";
 8: export * from "./HttpValidationError.js";
 9: export * from "./MillisecondInterval.js";
10: export * from "./OctaveVersion.js";
11: export * from "./PostedContext.js";
12: export * from "./PostedContextWithGenerationId.js";
13: export * from "./PostedContextWithUtterances.js";
14: export * from "./PostedTts.js";
15: export * from "./PostedUtterance.js";
16: export * from "./PostedUtteranceVoice.js";
17: export * from "./PostedUtteranceVoiceWithId.js";
18: export * from "./PostedUtteranceVoiceWithName.js";
19: export * from "./PublishTts.js";
20: export * from "./ReturnGeneration.js";
21: export * from "./ReturnPagedVoices.js";
22: export * from "./ReturnTts.js";
23: export * from "./ReturnVoice.js";
24: export * from "./Snippet.js";
25: export * from "./SnippetAudioChunk.js";
26: export * from "./Timestamp.js";
27: export * from "./TimestampMessage.js";
28: export * from "./TimestampType.js";
29: export * from "./TtsOutput.js";
30: export * from "./ValidationError.js";
31: export * from "./ValidationErrorLocItem.js";
32: export * from "./VoiceProvider.js";
````

## File: src/api/resources/tts/types/MillisecondInterval.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface MillisecondInterval {
4:     /** Start time of the interval in milliseconds. */
5:     begin: number;
6:     /** End time of the interval in milliseconds. */
7:     end: number;
8: }
````

## File: src/api/resources/tts/types/OctaveVersion.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: /**
 4:  * Selects the Octave model version used to synthesize speech for this request. If you omit this field, Hume
 5:  * automatically routes the request to the most appropriate model. Setting a specific version ensures stable and
 6:  * repeatable behavior across requests.
 7:  *
 8:  * Use `2` to opt into the latest Octave capabilities. When you specify version `2`, you must also provide a
 9:  * `voice`. Requests that set `version: 2` without a voice will be rejected.
10:  *
11:  * For a comparison of Octave versions, see the
12:  * [Octave versions](/docs/text-to-speech-tts/overview#octave-versions) section in the TTS overview.
13:  */
14: export const OctaveVersion = {
15:     One: "1",
16:     Two: "2",
17: } as const;
18: export type OctaveVersion = (typeof OctaveVersion)[keyof typeof OctaveVersion];
````

## File: src/api/resources/tts/types/PostedContext.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: /**
6:  * Utterances to use as context for generating consistent speech style and prosody across multiple requests. These will not be converted to speech output.
7:  */
8: export type PostedContext = Hume.tts.PostedContextWithGenerationId | Hume.tts.PostedContextWithUtterances;
````

## File: src/api/resources/tts/types/PostedContextWithGenerationId.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export interface PostedContextWithGenerationId {
4:     /** The ID of a prior TTS generation to use as context for generating consistent speech style and prosody across multiple requests. Including context may increase audio generation times. */
5:     generationId: string;
6: }
````

## File: src/api/resources/tts/types/PostedContextWithUtterances.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: export interface PostedContextWithUtterances {
6:     utterances: Hume.tts.PostedUtterance[];
7: }
````

## File: src/api/resources/tts/types/PostedTts.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface PostedTts {
 6:     /** Utterances to use as context for generating consistent speech style and prosody across multiple requests. These will not be converted to speech output. */
 7:     context?: Hume.tts.PostedContext;
 8:     /** Specifies the output audio file format. */
 9:     format?: Hume.tts.Format;
10:     /** The set of timestamp types to include in the response. Only supported for Octave 2 requests. */
11:     includeTimestampTypes?: Hume.tts.TimestampType[];
12:     /**
13:      * Number of audio generations to produce from the input utterances.
14:      *
15:      * Using `num_generations` enables faster processing than issuing multiple sequential requests. Additionally, specifying `num_generations` allows prosody continuation across all generations without repeating context, ensuring each generation sounds slightly different while maintaining contextual consistency.
16:      */
17:     numGenerations?: number;
18:     /**
19:      * Controls how audio output is segmented in the response.
20:      *
21:      * - When **enabled** (`true`), input utterances are automatically split into natural-sounding speech segments.
22:      *
23:      * - When **disabled** (`false`), the response maintains a strict one-to-one mapping between input utterances and output snippets.
24:      *
25:      * This setting affects how the `snippets` array is structured in the response, which may be important for applications that need to track the relationship between input text and generated audio segments. When setting to `false`, avoid including utterances with long `text`, as this can result in distorted output.
26:      */
27:     splitUtterances?: boolean;
28:     /** If enabled, the audio for all the chunks of a generation, once concatenated together, will constitute a single audio file. Otherwise, if disabled, each chunk's audio will be its own audio file, each with its own headers (if applicable). */
29:     stripHeaders?: boolean;
30:     /**
31:      * A list of **Utterances** to be converted to speech output.
32:      *
33:      * An **Utterance** is a unit of input for [Octave](/docs/text-to-speech-tts/overview), and includes input `text`, an optional `description` to serve as the prompt for how the speech should be delivered, an optional `voice` specification, and additional controls to guide delivery for `speed` and `trailing_silence`.
34:      */
35:     utterances: Hume.tts.PostedUtterance[];
36:     /**
37:      * Selects the Octave model version used to synthesize speech for this request. If you omit this field, Hume automatically routes the request to the most appropriate model. Setting a specific version ensures stable and repeatable behavior across requests.
38:      *
39:      * Use `2` to opt into the latest Octave capabilities. When you specify version `2`, you must also provide a `voice`. Requests that set `version: 2` without a voice will be rejected.
40:      *
41:      * For a comparison of Octave versions, see the [Octave versions](/docs/text-to-speech-tts/overview#octave-versions) section in the TTS overview.
42:      */
43:     version?: Hume.tts.OctaveVersion;
44:     instantMode?: boolean;
45: }
````

## File: src/api/resources/tts/types/PostedUtterance.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface PostedUtterance {
 6:     /**
 7:      * Natural language instructions describing how the synthesized speech should sound, including but not limited to tone, intonation, pacing, and accent.
 8:      *
 9:      * **This field behaves differently depending on whether a voice is specified**:
10:      * - **Voice specified**: the description will serve as acting directions for delivery. Keep directions concise—100 characters or fewer—for best results. See our guide on [acting instructions](/docs/text-to-speech-tts/acting-instructions).
11:      * - **Voice not specified**: the description will serve as a voice prompt for generating a voice. See our [prompting guide](/docs/text-to-speech-tts/prompting) for design tips.
12:      */
13:     description?: string;
14:     /** Speed multiplier for the synthesized speech. Extreme values below 0.75 and above 1.5 may sometimes cause instability to the generated output. */
15:     speed?: number;
16:     /** The input text to be synthesized into speech. */
17:     text: string;
18:     /** Duration of trailing silence (in seconds) to add to this utterance */
19:     trailingSilence?: number;
20:     /**
21:      * The `name` or `id` associated with a **Voice** from the **Voice Library** to be used as the speaker for this and all subsequent `utterances`, until the `voice` field is updated again.
22:      *
23:      *  See our [voices guide](/docs/text-to-speech-tts/voices) for more details on generating and specifying **Voices**.
24:      */
25:     voice?: Hume.tts.PostedUtteranceVoice;
26: }
````

## File: src/api/resources/tts/types/PostedUtteranceVoice.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: export type PostedUtteranceVoice = Hume.tts.PostedUtteranceVoiceWithId | Hume.tts.PostedUtteranceVoiceWithName;
````

## File: src/api/resources/tts/types/PostedUtteranceVoiceWithId.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface PostedUtteranceVoiceWithId {
 6:     /** The unique ID associated with the **Voice**. */
 7:     id: string;
 8:     /**
 9:      * Specifies the source provider associated with the chosen voice.
10:      *
11:      * - **`HUME_AI`**: Select voices from Hume's [Voice Library](https://app.hume.ai/voices), containing a variety of preset, shared voices.
12:      * - **`CUSTOM_VOICE`**: Select from voices you've personally generated and saved in your account.
13:      *
14:      * If no provider is explicitly set, the default provider is `CUSTOM_VOICE`. When using voices from Hume's **Voice Library**, you must explicitly set the provider to `HUME_AI`.
15:      *
16:      * Preset voices from Hume's **Voice Library** are accessible by all users. In contrast, your custom voices are private and accessible only via requests authenticated with your API key.
17:      */
18:     provider?: Hume.tts.VoiceProvider;
19: }
````

## File: src/api/resources/tts/types/PostedUtteranceVoiceWithName.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface PostedUtteranceVoiceWithName {
 6:     /** The name of a **Voice**. */
 7:     name: string;
 8:     /**
 9:      * Specifies the source provider associated with the chosen voice.
10:      *
11:      * - **`HUME_AI`**: Select voices from Hume's [Voice Library](https://app.hume.ai/voices), containing a variety of preset, shared voices.
12:      * - **`CUSTOM_VOICE`**: Select from voices you've personally generated and saved in your account.
13:      *
14:      * If no provider is explicitly set, the default provider is `CUSTOM_VOICE`. When using voices from Hume's **Voice Library**, you must explicitly set the provider to `HUME_AI`.
15:      *
16:      * Preset voices from Hume's **Voice Library** are accessible by all users. In contrast, your custom voices are private and accessible only via requests authenticated with your API key.
17:      */
18:     provider?: Hume.tts.VoiceProvider;
19: }
````

## File: src/api/resources/tts/types/PublishTts.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * Input message type for the TTS stream.
 7:  */
 8: export interface PublishTts {
 9:     /** Force the generation of audio and close the stream. */
10:     close?: boolean;
11:     /**
12:      * Natural language instructions describing how the synthesized speech should sound, including but not limited to tone, intonation, pacing, and accent.
13:      *
14:      * **This field behaves differently depending on whether a voice is specified**:
15:      * - **Voice specified**: the description will serve as acting directions for delivery. Keep directions concise—100 characters or fewer—for best results. See our guide on [acting instructions](/docs/text-to-speech-tts/acting-instructions).
16:      * - **Voice not specified**: the description will serve as a voice prompt for generating a voice. See our [prompting guide](/docs/text-to-speech-tts/prompting) for design tips.
17:      */
18:     description?: string;
19:     /** Force the generation of audio regardless of how much text has been supplied. */
20:     flush?: boolean;
21:     /** Speed multiplier for the synthesized speech. Extreme values below 0.75 and above 1.5 may sometimes cause instability to the generated output. */
22:     speed?: number;
23:     /** The input text to be synthesized into speech. */
24:     text?: string;
25:     /** Duration of trailing silence (in seconds) to add to this utterance */
26:     trailingSilence?: number;
27:     /**
28:      * The `name` or `id` associated with a **Voice** from the **Voice Library** to be used as the speaker for this and all subsequent `utterances`, until the `voice` field is updated again.
29:      *
30:      *  See our [voices guide](/docs/text-to-speech-tts/voices) for more details on generating and specifying **Voices**.
31:      */
32:     voice?: Hume.tts.PostedUtteranceVoice;
33: }
````

## File: src/api/resources/tts/types/ReturnGeneration.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface ReturnGeneration {
 6:     /** The generated audio output in the requested format, encoded as a base64 string. */
 7:     audio: string;
 8:     /** Duration of the generated audio in seconds. */
 9:     duration: number;
10:     encoding: Hume.tts.AudioEncoding;
11:     /** Size of the generated audio in bytes. */
12:     fileSize: number;
13:     /** A unique ID associated with this TTS generation that can be used as context for generating consistent speech style and prosody across multiple requests. */
14:     generationId: string;
15:     /** A list of snippet groups where each group corresponds to an utterance in the request. Each group contains segmented snippets that represent the original utterance divided into more natural-sounding units optimized for speech delivery. */
16:     snippets: Hume.tts.Snippet[][];
17: }
````

## File: src/api/resources/tts/types/ReturnPagedVoices.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A paginated list Octave voices available for text-to-speech
 7:  */
 8: export interface ReturnPagedVoices {
 9:     /** The page number of the returned results. */
10:     pageNumber: number;
11:     /**
12:      * The maximum number of items returned per page.
13:      *
14:      * This value corresponds to the `page_size` parameter specified in the request.
15:      */
16:     pageSize: number;
17:     /** The total number of pages in the collection. */
18:     totalPages: number;
19:     /** List of voices returned for the specified `page_number` and `page_size`. */
20:     voicesPage: Hume.tts.ReturnVoice[];
21: }
````

## File: src/api/resources/tts/types/ReturnTts.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: export interface ReturnTts {
6:     generations: Hume.tts.ReturnGeneration[];
7:     /** A unique ID associated with this request for tracking and troubleshooting. Use this ID when contacting [support](/support) for troubleshooting assistance. */
8:     requestId?: string;
9: }
````

## File: src/api/resources/tts/types/ReturnVoice.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * An Octave voice available for text-to-speech
 7:  */
 8: export interface ReturnVoice {
 9:     compatibleOctaveModels?: string[];
10:     /** ID of the voice in the `Voice Library`. */
11:     id: string;
12:     /** Name of the voice in the `Voice Library`. */
13:     name: string;
14:     /**
15:      * The provider associated with the created voice.
16:      *
17:      * Voices created through this endpoint will always have the provider set to `CUSTOM_VOICE`, indicating a custom voice stored in your account.
18:      */
19:     provider: Hume.tts.VoiceProvider;
20: }
````

## File: src/api/resources/tts/types/Snippet.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface Snippet {
 6:     /** The segmented audio output in the requested format, encoded as a base64 string. */
 7:     audio: string;
 8:     /** The generation ID this snippet corresponds to. */
 9:     generationId: string;
10:     /** A unique ID associated with this **Snippet**. */
11:     id: string;
12:     /** The text for this **Snippet**. */
13:     text: string;
14:     /** A list of word or phoneme level timestamps for the generated audio. Timestamps are only returned for Octave 2 requests. */
15:     timestamps: Hume.tts.Timestamp[];
16:     /** The transcribed text of the generated audio. It is only present if `instant_mode` is set to `false`. */
17:     transcribedText?: string;
18:     /** The index of the utterance in the request this snippet corresponds to. */
19:     utteranceIndex?: number;
20: }
````

## File: src/api/resources/tts/types/SnippetAudioChunk.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * Metadata for a chunk of generated audio.
 7:  */
 8: export interface SnippetAudioChunk {
 9:     /** The generated audio output chunk in the requested format. */
10:     audio: string;
11:     /** The generated audio output format. */
12:     audioFormat: Hume.tts.AudioFormatType;
13:     /** The index of the audio chunk in the snippet. */
14:     chunkIndex: number;
15:     /** The generation ID of the parent snippet that this chunk corresponds to. */
16:     generationId: string;
17:     /** Whether or not this is the last chunk streamed back from the decoder for one input snippet. */
18:     isLastChunk: boolean;
19:     /** ID of the initiating request. */
20:     requestId: string;
21:     snippet?: Hume.tts.Snippet;
22:     /** The ID of the parent snippet that this chunk corresponds to. */
23:     snippetId: string;
24:     /** The text of the parent snippet that this chunk corresponds to. */
25:     text: string;
26:     /** The transcribed text of the generated audio of the parent snippet that this chunk corresponds to. It is only present if `instant_mode` is set to `false`. */
27:     transcribedText?: string;
28:     type: "audio";
29:     /** The index of the utterance in the request that the parent snippet of this chunk corresponds to. */
30:     utteranceIndex?: number;
31: }
````

## File: src/api/resources/tts/types/Timestamp.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: export interface Timestamp {
 6:     /** The word or phoneme text that the timestamp corresponds to. */
 7:     text: string;
 8:     /** The start and end timestamps for the word or phoneme in milliseconds. */
 9:     time: Hume.tts.MillisecondInterval;
10:     type: Hume.tts.TimestampType;
11: }
````

## File: src/api/resources/tts/types/TimestampMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../index.js";
 4: 
 5: /**
 6:  * A word or phoneme level timestamp for the generated audio.
 7:  */
 8: export interface TimestampMessage {
 9:     /** The generation ID of the parent snippet that this chunk corresponds to. */
10:     generationId: string;
11:     /** ID of the initiating request. */
12:     requestId: string;
13:     /** The ID of the parent snippet that this chunk corresponds to. */
14:     snippetId: string;
15:     /** A word or phoneme level timestamp for the generated audio. */
16:     timestamp: Hume.tts.Timestamp;
17:     type: "timestamp";
18: }
````

## File: src/api/resources/tts/types/TimestampType.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const TimestampType = {
4:     Word: "word",
5:     Phoneme: "phoneme",
6: } as const;
7: export type TimestampType = (typeof TimestampType)[keyof typeof TimestampType];
````

## File: src/api/resources/tts/types/TtsOutput.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: export type TtsOutput = Hume.tts.SnippetAudioChunk | Hume.tts.TimestampMessage;
````

## File: src/api/resources/tts/types/ValidationError.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: import type * as Hume from "../../../index.js";
4: 
5: export interface ValidationError {
6:     loc: Hume.tts.ValidationErrorLocItem[];
7:     msg: string;
8:     type: string;
9: }
````

## File: src/api/resources/tts/types/ValidationErrorLocItem.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export type ValidationErrorLocItem = string | number;
````

## File: src/api/resources/tts/types/VoiceProvider.ts
````typescript
1: // This file was auto-generated by Fern from our API Definition.
2: 
3: export const VoiceProvider = {
4:     HumeAi: "HUME_AI",
5:     CustomVoice: "CUSTOM_VOICE",
6: } as const;
7: export type VoiceProvider = (typeof VoiceProvider)[keyof typeof VoiceProvider];
````

## File: src/api/resources/tts/index.ts
````typescript
1: export * from "./client/index.js";
2: export * from "./errors/index.js";
3: export * from "./resources/index.js";
4: export * from "./types/index.js";
````

## File: src/api/resources/index.ts
````typescript
1: export * as empathicVoice from "./empathicVoice/index.js";
2: export * as expressionMeasurement from "./expressionMeasurement/index.js";
3: export * as tts from "./tts/index.js";
````

## File: src/api/index.ts
````typescript
1: export * from "./resources/index.js";
````

## File: src/auth/HeaderAuthProvider.ts
````typescript
 1: /**
 2:  * THIS FILE IS MANUALLY MAINTAINED: see .fernignore
 3:  *
 4:  * Custom HeaderAuthProvider that supports both apiKey and accessToken authentication.
 5:  * When accessToken is provided to HumeClient, the wrapper converts it to an
 6:  * Authorization: Bearer header. This provider checks for both apiKey and the
 7:  * Authorization header to support both auth methods.
 8:  */
 9: 
10: import * as core from "../core/index.js";
11: import * as errors from "../errors/index.js";
12: 
13: export namespace HeaderAuthProvider {
14:     export type AuthOptions = {
15:         apiKey?: core.Supplier<string | undefined>;
16:     };
17: 
18:     export type Options = {
19:         headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
20:     } & AuthOptions;
21: }
22: 
23: export class HeaderAuthProvider implements core.AuthProvider {
24:     private readonly options: HeaderAuthProvider.Options;
25: 
26:     constructor(options: HeaderAuthProvider.Options) {
27:         this.options = options;
28:     }
29: 
30:     public static canCreate(options: HeaderAuthProvider.Options): boolean {
31:         return options.apiKey != null || HeaderAuthProvider.hasAuthorizationHeader(options.headers);
32:     }
33: 
34:     private static hasAuthorizationHeader(
35:         headers: Record<string, string | core.Supplier<string | null | undefined> | null | undefined> | undefined,
36:     ): boolean {
37:         if (!headers) return false;
38:         return Object.keys(headers).some((key) => key.toLowerCase() === "authorization");
39:     }
40: 
41:     public async getAuthRequest(_arg?: { endpointMetadata?: core.EndpointMetadata }): Promise<core.AuthRequest> {
42:         // Check apiKey first (preferred method)
43:         const apiKey = await core.Supplier.get(this.options.apiKey);
44:         if (apiKey != null) {
45:             return { headers: { "X-Hume-Api-Key": apiKey } };
46:         }
47: 
48:         // Check for Authorization header (from accessToken)
49:         if (this.options.headers) {
50:             const authKey = Object.keys(this.options.headers).find((key) => key.toLowerCase() === "authorization");
51:             if (authKey) {
52:                 const authValue = await core.Supplier.get(this.options.headers[authKey]);
53:                 if (authValue != null) {
54:                     return { headers: { Authorization: authValue } };
55:                 }
56:             }
57:         }
58: 
59:         throw new errors.HumeError({
60:             message: "Please provide either 'apiKey' or 'accessToken' when initializing the client",
61:         });
62:     }
63: }
````

## File: src/auth/HeaderAuthProvider.ts.diff
````diff
 1: diff --git a/src/auth/HeaderAuthProvider.ts b/src/auth/HeaderAuthProvider.ts
 2: index 8089bcc..83c2e42 100644
 3: --- a/src/auth/HeaderAuthProvider.ts
 4: +++ b/src/auth/HeaderAuthProvider.ts
 5: @@ -1,24 +1,10 @@
 6: -/**
 7: - * THIS FILE IS MANUALLY MAINTAINED: see .fernignore
 8: - *
 9: - * Custom HeaderAuthProvider that supports both apiKey and accessToken authentication.
10: - * When accessToken is provided to HumeClient, the wrapper converts it to an
11: - * Authorization: Bearer header. This provider checks for both apiKey and the
12: - * Authorization header to support both auth methods.
13: - */
14: +// This file was auto-generated by Fern from our API Definition.
15:  
16:  import * as core from "../core/index.js";
17:  import * as errors from "../errors/index.js";
18:  
19: -export namespace HeaderAuthProvider {
20: -    export type AuthOptions = {
21: -        apiKey?: core.Supplier<string | undefined>;
22: -    };
23: -
24: -    export type Options = {
25: -        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
26: -    } & AuthOptions;
27: -}
28: +const PARAM_KEY = "apiKey" as const;
29: +const HEADER_NAME = "X-Hume-Api-Key" as const;
30:  
31:  export class HeaderAuthProvider implements core.AuthProvider {
32:      private readonly options: HeaderAuthProvider.Options;
33: @@ -27,37 +13,36 @@ export class HeaderAuthProvider implements core.AuthProvider {
34:          this.options = options;
35:      }
36:  
37: -    public static canCreate(options: HeaderAuthProvider.Options): boolean {
38: -        return options.apiKey != null || HeaderAuthProvider.hasAuthorizationHeader(options.headers);
39: -    }
40: -
41: -    private static hasAuthorizationHeader(
42: -        headers: Record<string, string | core.Supplier<string | null | undefined> | null | undefined> | undefined,
43: -    ): boolean {
44: -        if (!headers) return false;
45: -        return Object.keys(headers).some((key) => key.toLowerCase() === "authorization");
46: +    public static canCreate(options: Partial<HeaderAuthProvider.Options>): boolean {
47: +        return options?.[PARAM_KEY] != null;
48:      }
49:  
50: -    public async getAuthRequest(_arg?: { endpointMetadata?: core.EndpointMetadata }): Promise<core.AuthRequest> {
51: -        // Check apiKey first (preferred method)
52: -        const apiKey = await core.Supplier.get(this.options.apiKey);
53: -        if (apiKey != null) {
54: -            return { headers: { "X-Hume-Api-Key": apiKey } };
55: +    public async getAuthRequest({
56: +        endpointMetadata,
57: +    }: {
58: +        endpointMetadata?: core.EndpointMetadata;
59: +    } = {}): Promise<core.AuthRequest> {
60: +        const headerValue = await core.Supplier.get(this.options[PARAM_KEY]);
61: +        if (headerValue == null) {
62: +            throw new errors.HumeError({
63: +                message: HeaderAuthProvider.AUTH_CONFIG_ERROR_MESSAGE,
64: +            });
65:          }
66:  
67: -        // Check for Authorization header (from accessToken)
68: -        if (this.options.headers) {
69: -            const authKey = Object.keys(this.options.headers).find((key) => key.toLowerCase() === "authorization");
70: -            if (authKey) {
71: -                const authValue = await core.Supplier.get(this.options.headers[authKey]);
72: -                if (authValue != null) {
73: -                    return { headers: { Authorization: authValue } };
74: -                }
75: -            }
76: -        }
77: +        return {
78: +            headers: { [HEADER_NAME]: headerValue },
79: +        };
80: +    }
81: +}
82:  
83: -        throw new errors.HumeError({
84: -            message: "Please provide either 'apiKey' or 'accessToken' when initializing the client",
85: -        });
86: +export namespace HeaderAuthProvider {
87: +    export const AUTH_SCHEME = "HeaderAuthScheme" as const;
88: +    export const AUTH_CONFIG_ERROR_MESSAGE: string =
89: +        `Please provide '${PARAM_KEY}' when initializing the client` as const;
90: +    export type Options = AuthOptions;
91: +    export type AuthOptions = { [PARAM_KEY]: core.Supplier<string> };
92: +
93: +    export function createInstance(options: Options): core.AuthProvider {
94: +        return new HeaderAuthProvider(options);
95:      }
96:  }
````

## File: src/auth/index.ts
````typescript
1: export { HeaderAuthProvider } from "./HeaderAuthProvider.js";
````

## File: src/core/auth/AuthProvider.ts
````typescript
1: import type { EndpointMetadata } from "../fetcher/EndpointMetadata.js";
2: import type { AuthRequest } from "./AuthRequest.js";
3: 
4: export interface AuthProvider {
5:     getAuthRequest(arg?: { endpointMetadata?: EndpointMetadata }): Promise<AuthRequest>;
6: }
````

## File: src/core/auth/AuthRequest.ts
````typescript
1: /**
2:  * Request parameters for authentication requests.
3:  */
4: export interface AuthRequest {
5:     /**
6:      * The headers to be included in the request.
7:      */
8:     headers: Record<string, string>;
9: }
````

## File: src/core/auth/BasicAuth.ts
````typescript
 1: import { base64Decode, base64Encode } from "../base64.js";
 2: 
 3: export interface BasicAuth {
 4:     username: string;
 5:     password: string;
 6: }
 7: 
 8: const BASIC_AUTH_HEADER_PREFIX = /^Basic /i;
 9: 
10: export const BasicAuth = {
11:     toAuthorizationHeader: (basicAuth: BasicAuth | undefined): string | undefined => {
12:         if (basicAuth == null) {
13:             return undefined;
14:         }
15:         const token = base64Encode(`${basicAuth.username}:${basicAuth.password}`);
16:         return `Basic ${token}`;
17:     },
18:     fromAuthorizationHeader: (header: string): BasicAuth => {
19:         const credentials = header.replace(BASIC_AUTH_HEADER_PREFIX, "");
20:         const decoded = base64Decode(credentials);
21:         const [username, ...passwordParts] = decoded.split(":");
22:         const password = passwordParts.length > 0 ? passwordParts.join(":") : undefined;
23: 
24:         if (username == null || password == null) {
25:             throw new Error("Invalid basic auth");
26:         }
27:         return {
28:             username,
29:             password,
30:         };
31:     },
32: };
````

## File: src/core/auth/BearerToken.ts
````typescript
 1: export type BearerToken = string;
 2: 
 3: const BEARER_AUTH_HEADER_PREFIX = /^Bearer /i;
 4: 
 5: function toAuthorizationHeader(token: string | undefined): string | undefined {
 6:     if (token == null) {
 7:         return undefined;
 8:     }
 9:     return `Bearer ${token}`;
10: }
11: 
12: export const BearerToken: {
13:     toAuthorizationHeader: typeof toAuthorizationHeader;
14:     fromAuthorizationHeader: (header: string) => BearerToken;
15: } = {
16:     toAuthorizationHeader: toAuthorizationHeader,
17:     fromAuthorizationHeader: (header: string): BearerToken => {
18:         return header.replace(BEARER_AUTH_HEADER_PREFIX, "").trim() as BearerToken;
19:     },
20: };
````

## File: src/core/auth/index.ts
````typescript
1: export type { AuthProvider } from "./AuthProvider.js";
2: export type { AuthRequest } from "./AuthRequest.js";
3: export { BasicAuth } from "./BasicAuth.js";
4: export { BearerToken } from "./BearerToken.js";
5: export { NoOpAuthProvider } from "./NoOpAuthProvider.js";
````

## File: src/core/auth/NoOpAuthProvider.ts
````typescript
1: import type { AuthProvider } from "./AuthProvider.js";
2: import type { AuthRequest } from "./AuthRequest.js";
3: 
4: export class NoOpAuthProvider implements AuthProvider {
5:     public getAuthRequest(): Promise<AuthRequest> {
6:         return Promise.resolve({ headers: {} });
7:     }
8: }
````

## File: src/core/fetcher/APIResponse.ts
````typescript
 1: import type { RawResponse } from "./RawResponse.js";
 2: 
 3: /**
 4:  * The response of an API call.
 5:  * It is a successful response or a failed response.
 6:  */
 7: export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;
 8: 
 9: export interface SuccessfulResponse<T> {
10:     ok: true;
11:     body: T;
12:     /**
13:      * @deprecated Use `rawResponse` instead
14:      */
15:     headers?: Record<string, any>;
16:     rawResponse: RawResponse;
17: }
18: 
19: export interface FailedResponse<T> {
20:     ok: false;
21:     error: T;
22:     rawResponse: RawResponse;
23: }
````

## File: src/core/fetcher/BinaryResponse.ts
````typescript
 1: export type BinaryResponse = {
 2:     /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/bodyUsed) */
 3:     bodyUsed: Response["bodyUsed"];
 4:     /**
 5:      * Returns a ReadableStream of the response body.
 6:      * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/body)
 7:      */
 8:     stream: () => Response["body"];
 9:     /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/arrayBuffer) */
10:     arrayBuffer: () => ReturnType<Response["arrayBuffer"]>;
11:     /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/blob) */
12:     blob: () => ReturnType<Response["blob"]>;
13:     /**
14:      * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/bytes)
15:      * Some versions of the Fetch API may not support this method.
16:      */
17:     bytes?(): ReturnType<Response["bytes"]>;
18: };
19: 
20: export function getBinaryResponse(response: Response): BinaryResponse {
21:     const binaryResponse: BinaryResponse = {
22:         get bodyUsed() {
23:             return response.bodyUsed;
24:         },
25:         stream: () => response.body,
26:         arrayBuffer: response.arrayBuffer.bind(response),
27:         blob: response.blob.bind(response),
28:     };
29:     if ("bytes" in response && typeof response.bytes === "function") {
30:         binaryResponse.bytes = response.bytes.bind(response);
31:     }
32: 
33:     return binaryResponse;
34: }
````

## File: src/core/fetcher/createRequestUrl.ts
````typescript
1: import { toQueryString } from "../url/qs.js";
2: 
3: export function createRequestUrl(baseUrl: string, queryParameters?: Record<string, unknown>): string {
4:     const queryString = toQueryString(queryParameters, { arrayFormat: "repeat" });
5:     return queryString ? `${baseUrl}?${queryString}` : baseUrl;
6: }
````

## File: src/core/fetcher/EndpointMetadata.ts
````typescript
 1: export type SecuritySchemeKey = string;
 2: /**
 3:  * A collection of security schemes, where the key is the name of the security scheme and the value is the list of scopes required for that scheme.
 4:  * All schemes in the collection must be satisfied for authentication to be successful.
 5:  */
 6: export type SecuritySchemeCollection = Record<SecuritySchemeKey, AuthScope[]>;
 7: export type AuthScope = string;
 8: export type EndpointMetadata = {
 9:     /**
10:      * An array of security scheme collections. Each collection represents an alternative way to authenticate.
11:      */
12:     security?: SecuritySchemeCollection[];
13: };
````

## File: src/core/fetcher/EndpointSupplier.ts
````typescript
 1: import type { EndpointMetadata } from "./EndpointMetadata.js";
 2: import type { Supplier } from "./Supplier.js";
 3: 
 4: type EndpointSupplierFn<T> = (arg: { endpointMetadata?: EndpointMetadata }) => T | Promise<T>;
 5: export type EndpointSupplier<T> = Supplier<T> | EndpointSupplierFn<T>;
 6: export const EndpointSupplier = {
 7:     get: async <T>(supplier: EndpointSupplier<T>, arg: { endpointMetadata?: EndpointMetadata }): Promise<T> => {
 8:         if (typeof supplier === "function") {
 9:             return (supplier as EndpointSupplierFn<T>)(arg);
10:         } else {
11:             return supplier;
12:         }
13:     },
14: };
````

## File: src/core/fetcher/Fetcher.ts
````typescript
  1: import { toJson } from "../json.js";
  2: import { createLogger, type LogConfig, type Logger } from "../logging/logger.js";
  3: import type { APIResponse } from "./APIResponse.js";
  4: import { createRequestUrl } from "./createRequestUrl.js";
  5: import type { EndpointMetadata } from "./EndpointMetadata.js";
  6: import { EndpointSupplier } from "./EndpointSupplier.js";
  7: import { getErrorResponseBody } from "./getErrorResponseBody.js";
  8: import { getFetchFn } from "./getFetchFn.js";
  9: import { getRequestBody } from "./getRequestBody.js";
 10: import { getResponseBody } from "./getResponseBody.js";
 11: import { Headers } from "./Headers.js";
 12: import { makeRequest } from "./makeRequest.js";
 13: import { abortRawResponse, toRawResponse, unknownRawResponse } from "./RawResponse.js";
 14: import { requestWithRetries } from "./requestWithRetries.js";
 15: 
 16: export type FetchFunction = <R = unknown>(args: Fetcher.Args) => Promise<APIResponse<R, Fetcher.Error>>;
 17: 
 18: export declare namespace Fetcher {
 19:     export interface Args {
 20:         url: string;
 21:         method: string;
 22:         contentType?: string;
 23:         headers?: Record<string, unknown>;
 24:         queryParameters?: Record<string, unknown>;
 25:         body?: unknown;
 26:         timeoutMs?: number;
 27:         maxRetries?: number;
 28:         withCredentials?: boolean;
 29:         abortSignal?: AbortSignal;
 30:         requestType?: "json" | "file" | "bytes" | "form" | "other";
 31:         responseType?: "json" | "blob" | "sse" | "streaming" | "text" | "arrayBuffer" | "binary-response";
 32:         duplex?: "half";
 33:         endpointMetadata?: EndpointMetadata;
 34:         fetchFn?: typeof fetch;
 35:         logging?: LogConfig | Logger;
 36:     }
 37: 
 38:     export type Error = FailedStatusCodeError | NonJsonError | BodyIsNullError | TimeoutError | UnknownError;
 39: 
 40:     export interface FailedStatusCodeError {
 41:         reason: "status-code";
 42:         statusCode: number;
 43:         body: unknown;
 44:     }
 45: 
 46:     export interface NonJsonError {
 47:         reason: "non-json";
 48:         statusCode: number;
 49:         rawBody: string;
 50:     }
 51: 
 52:     export interface BodyIsNullError {
 53:         reason: "body-is-null";
 54:         statusCode: number;
 55:     }
 56: 
 57:     export interface TimeoutError {
 58:         reason: "timeout";
 59:     }
 60: 
 61:     export interface UnknownError {
 62:         reason: "unknown";
 63:         errorMessage: string;
 64:     }
 65: }
 66: 
 67: const SENSITIVE_HEADERS = new Set([
 68:     "authorization",
 69:     "www-authenticate",
 70:     "x-api-key",
 71:     "api-key",
 72:     "apikey",
 73:     "x-api-token",
 74:     "x-auth-token",
 75:     "auth-token",
 76:     "cookie",
 77:     "set-cookie",
 78:     "proxy-authorization",
 79:     "proxy-authenticate",
 80:     "x-csrf-token",
 81:     "x-xsrf-token",
 82:     "x-session-token",
 83:     "x-access-token",
 84: ]);
 85: 
 86: function redactHeaders(headers: Headers | Record<string, string>): Record<string, string> {
 87:     const filtered: Record<string, string> = {};
 88:     for (const [key, value] of headers instanceof Headers ? headers.entries() : Object.entries(headers)) {
 89:         if (SENSITIVE_HEADERS.has(key.toLowerCase())) {
 90:             filtered[key] = "[REDACTED]";
 91:         } else {
 92:             filtered[key] = value;
 93:         }
 94:     }
 95:     return filtered;
 96: }
 97: 
 98: const SENSITIVE_QUERY_PARAMS = new Set([
 99:     "api_key",
100:     "api-key",
101:     "apikey",
102:     "token",
103:     "access_token",
104:     "access-token",
105:     "auth_token",
106:     "auth-token",
107:     "password",
108:     "passwd",
109:     "secret",
110:     "api_secret",
111:     "api-secret",
112:     "apisecret",
113:     "key",
114:     "session",
115:     "session_id",
116:     "session-id",
117: ]);
118: 
119: function redactQueryParameters(queryParameters?: Record<string, unknown>): Record<string, unknown> | undefined {
120:     if (queryParameters == null) {
121:         return queryParameters;
122:     }
123:     const redacted: Record<string, unknown> = {};
124:     for (const [key, value] of Object.entries(queryParameters)) {
125:         if (SENSITIVE_QUERY_PARAMS.has(key.toLowerCase())) {
126:             redacted[key] = "[REDACTED]";
127:         } else {
128:             redacted[key] = value;
129:         }
130:     }
131:     return redacted;
132: }
133: 
134: function redactUrl(url: string): string {
135:     const protocolIndex = url.indexOf("://");
136:     if (protocolIndex === -1) return url;
137: 
138:     const afterProtocol = protocolIndex + 3;
139: 
140:     // Find the first delimiter that marks the end of the authority section
141:     const pathStart = url.indexOf("/", afterProtocol);
142:     let queryStart = url.indexOf("?", afterProtocol);
143:     let fragmentStart = url.indexOf("#", afterProtocol);
144: 
145:     const firstDelimiter = Math.min(
146:         pathStart === -1 ? url.length : pathStart,
147:         queryStart === -1 ? url.length : queryStart,
148:         fragmentStart === -1 ? url.length : fragmentStart,
149:     );
150: 
151:     // Find the LAST @ before the delimiter (handles multiple @ in credentials)
152:     let atIndex = -1;
153:     for (let i = afterProtocol; i < firstDelimiter; i++) {
154:         if (url[i] === "@") {
155:             atIndex = i;
156:         }
157:     }
158: 
159:     if (atIndex !== -1) {
160:         url = `${url.slice(0, afterProtocol)}[REDACTED]@${url.slice(atIndex + 1)}`;
161:     }
162: 
163:     // Recalculate queryStart since url might have changed
164:     queryStart = url.indexOf("?");
165:     if (queryStart === -1) return url;
166: 
167:     fragmentStart = url.indexOf("#", queryStart);
168:     const queryEnd = fragmentStart !== -1 ? fragmentStart : url.length;
169:     const queryString = url.slice(queryStart + 1, queryEnd);
170: 
171:     if (queryString.length === 0) return url;
172: 
173:     // FAST PATH: Quick check if any sensitive keywords present
174:     // Using indexOf is faster than regex for simple substring matching
175:     const lower = queryString.toLowerCase();
176:     const hasSensitive =
177:         lower.includes("token") ||
178:         lower.includes("key") ||
179:         lower.includes("password") ||
180:         lower.includes("passwd") ||
181:         lower.includes("secret") ||
182:         lower.includes("session") ||
183:         lower.includes("auth");
184: 
185:     if (!hasSensitive) {
186:         return url;
187:     }
188: 
189:     // SLOW PATH: Parse and redact
190:     const redactedParams: string[] = [];
191:     const params = queryString.split("&");
192: 
193:     for (const param of params) {
194:         const equalIndex = param.indexOf("=");
195:         if (equalIndex === -1) {
196:             redactedParams.push(param);
197:             continue;
198:         }
199: 
200:         const key = param.slice(0, equalIndex);
201:         let shouldRedact = SENSITIVE_QUERY_PARAMS.has(key.toLowerCase());
202: 
203:         if (!shouldRedact && key.includes("%")) {
204:             try {
205:                 const decodedKey = decodeURIComponent(key);
206:                 shouldRedact = SENSITIVE_QUERY_PARAMS.has(decodedKey.toLowerCase());
207:             } catch {}
208:         }
209: 
210:         redactedParams.push(shouldRedact ? `${key}=[REDACTED]` : param);
211:     }
212: 
213:     return url.slice(0, queryStart + 1) + redactedParams.join("&") + url.slice(queryEnd);
214: }
215: 
216: async function getHeaders(args: Fetcher.Args): Promise<Headers> {
217:     const newHeaders: Headers = new Headers();
218: 
219:     newHeaders.set(
220:         "Accept",
221:         args.responseType === "json" ? "application/json" : args.responseType === "text" ? "text/plain" : "*/*",
222:     );
223:     if (args.body !== undefined && args.contentType != null) {
224:         newHeaders.set("Content-Type", args.contentType);
225:     }
226: 
227:     if (args.headers == null) {
228:         return newHeaders;
229:     }
230: 
231:     for (const [key, value] of Object.entries(args.headers)) {
232:         const result = await EndpointSupplier.get(value, { endpointMetadata: args.endpointMetadata ?? {} });
233:         if (typeof result === "string") {
234:             newHeaders.set(key, result);
235:             continue;
236:         }
237:         if (result == null) {
238:             continue;
239:         }
240:         newHeaders.set(key, `${result}`);
241:     }
242:     return newHeaders;
243: }
244: 
245: export async function fetcherImpl<R = unknown>(args: Fetcher.Args): Promise<APIResponse<R, Fetcher.Error>> {
246:     const url = createRequestUrl(args.url, args.queryParameters);
247:     const requestBody: BodyInit | undefined = await getRequestBody({
248:         body: args.body,
249:         type: args.requestType ?? "other",
250:     });
251:     const fetchFn = args.fetchFn ?? (await getFetchFn());
252:     const headers = await getHeaders(args);
253:     const logger = createLogger(args.logging);
254: 
255:     if (logger.isDebug()) {
256:         const metadata = {
257:             method: args.method,
258:             url: redactUrl(url),
259:             headers: redactHeaders(headers),
260:             queryParameters: redactQueryParameters(args.queryParameters),
261:             hasBody: requestBody != null,
262:         };
263:         logger.debug("Making HTTP request", metadata);
264:     }
265: 
266:     try {
267:         const response = await requestWithRetries(
268:             async () =>
269:                 makeRequest(
270:                     fetchFn,
271:                     url,
272:                     args.method,
273:                     headers,
274:                     requestBody,
275:                     args.timeoutMs,
276:                     args.abortSignal,
277:                     args.withCredentials,
278:                     args.duplex,
279:                 ),
280:             args.maxRetries,
281:         );
282: 
283:         if (response.status >= 200 && response.status < 400) {
284:             if (logger.isDebug()) {
285:                 const metadata = {
286:                     method: args.method,
287:                     url: redactUrl(url),
288:                     statusCode: response.status,
289:                     responseHeaders: redactHeaders(response.headers),
290:                 };
291:                 logger.debug("HTTP request succeeded", metadata);
292:             }
293:             const body = await getResponseBody(response, args.responseType);
294:             return {
295:                 ok: true,
296:                 body: body as R,
297:                 headers: response.headers,
298:                 rawResponse: toRawResponse(response),
299:             };
300:         } else {
301:             if (logger.isError()) {
302:                 const metadata = {
303:                     method: args.method,
304:                     url: redactUrl(url),
305:                     statusCode: response.status,
306:                     responseHeaders: redactHeaders(Object.fromEntries(response.headers.entries())),
307:                 };
308:                 logger.error("HTTP request failed with error status", metadata);
309:             }
310:             return {
311:                 ok: false,
312:                 error: {
313:                     reason: "status-code",
314:                     statusCode: response.status,
315:                     body: await getErrorResponseBody(response),
316:                 },
317:                 rawResponse: toRawResponse(response),
318:             };
319:         }
320:     } catch (error) {
321:         if (args.abortSignal?.aborted) {
322:             if (logger.isError()) {
323:                 const metadata = {
324:                     method: args.method,
325:                     url: redactUrl(url),
326:                 };
327:                 logger.error("HTTP request was aborted", metadata);
328:             }
329:             return {
330:                 ok: false,
331:                 error: {
332:                     reason: "unknown",
333:                     errorMessage: "The user aborted a request",
334:                 },
335:                 rawResponse: abortRawResponse,
336:             };
337:         } else if (error instanceof Error && error.name === "AbortError") {
338:             if (logger.isError()) {
339:                 const metadata = {
340:                     method: args.method,
341:                     url: redactUrl(url),
342:                     timeoutMs: args.timeoutMs,
343:                 };
344:                 logger.error("HTTP request timed out", metadata);
345:             }
346:             return {
347:                 ok: false,
348:                 error: {
349:                     reason: "timeout",
350:                 },
351:                 rawResponse: abortRawResponse,
352:             };
353:         } else if (error instanceof Error) {
354:             if (logger.isError()) {
355:                 const metadata = {
356:                     method: args.method,
357:                     url: redactUrl(url),
358:                     errorMessage: error.message,
359:                 };
360:                 logger.error("HTTP request failed with error", metadata);
361:             }
362:             return {
363:                 ok: false,
364:                 error: {
365:                     reason: "unknown",
366:                     errorMessage: error.message,
367:                 },
368:                 rawResponse: unknownRawResponse,
369:             };
370:         }
371: 
372:         if (logger.isError()) {
373:             const metadata = {
374:                 method: args.method,
375:                 url: redactUrl(url),
376:                 error: toJson(error),
377:             };
378:             logger.error("HTTP request failed with unknown error", metadata);
379:         }
380:         return {
381:             ok: false,
382:             error: {
383:                 reason: "unknown",
384:                 errorMessage: toJson(error),
385:             },
386:             rawResponse: unknownRawResponse,
387:         };
388:     }
389: }
390: 
391: export const fetcher: FetchFunction = fetcherImpl;
````

## File: src/core/fetcher/getErrorResponseBody.ts
````typescript
 1: import { fromJson } from "../json.js";
 2: import { getResponseBody } from "./getResponseBody.js";
 3: 
 4: export async function getErrorResponseBody(response: Response): Promise<unknown> {
 5:     let contentType = response.headers.get("Content-Type")?.toLowerCase();
 6:     if (contentType == null || contentType.length === 0) {
 7:         return getResponseBody(response);
 8:     }
 9: 
10:     if (contentType.indexOf(";") !== -1) {
11:         contentType = contentType.split(";")[0]?.trim() ?? "";
12:     }
13:     switch (contentType) {
14:         case "application/hal+json":
15:         case "application/json":
16:         case "application/ld+json":
17:         case "application/problem+json":
18:         case "application/vnd.api+json":
19:         case "text/json": {
20:             const text = await response.text();
21:             return text.length > 0 ? fromJson(text) : undefined;
22:         }
23:         default:
24:             if (contentType.startsWith("application/vnd.") && contentType.endsWith("+json")) {
25:                 const text = await response.text();
26:                 return text.length > 0 ? fromJson(text) : undefined;
27:             }
28: 
29:             // Fallback to plain text if content type is not recognized
30:             // Even if no body is present, the response will be an empty string
31:             return await response.text();
32:     }
33: }
````

## File: src/core/fetcher/getFetchFn.ts
````typescript
1: export async function getFetchFn(): Promise<typeof fetch> {
2:     return fetch;
3: }
````

## File: src/core/fetcher/getHeader.ts
````typescript
1: export function getHeader(headers: Record<string, any>, header: string): string | undefined {
2:     for (const [headerKey, headerValue] of Object.entries(headers)) {
3:         if (headerKey.toLowerCase() === header.toLowerCase()) {
4:             return headerValue;
5:         }
6:     }
7:     return undefined;
8: }
````

## File: src/core/fetcher/getRequestBody.ts
````typescript
 1: import { toJson } from "../json.js";
 2: import { toQueryString } from "../url/qs.js";
 3: 
 4: export declare namespace GetRequestBody {
 5:     interface Args {
 6:         body: unknown;
 7:         type: "json" | "file" | "bytes" | "form" | "other";
 8:     }
 9: }
10: 
11: export async function getRequestBody({ body, type }: GetRequestBody.Args): Promise<BodyInit | undefined> {
12:     if (type === "form") {
13:         return toQueryString(body, { arrayFormat: "repeat", encode: true });
14:     }
15:     if (type.includes("json")) {
16:         return toJson(body);
17:     } else {
18:         return body as BodyInit;
19:     }
20: }
````

## File: src/core/fetcher/getResponseBody.ts
````typescript
 1: import { fromJson } from "../json.js";
 2: import { getBinaryResponse } from "./BinaryResponse.js";
 3: 
 4: export async function getResponseBody(response: Response, responseType?: string): Promise<unknown> {
 5:     switch (responseType) {
 6:         case "binary-response":
 7:             return getBinaryResponse(response);
 8:         case "blob":
 9:             return await response.blob();
10:         case "arrayBuffer":
11:             return await response.arrayBuffer();
12:         case "sse":
13:             if (response.body == null) {
14:                 return {
15:                     ok: false,
16:                     error: {
17:                         reason: "body-is-null",
18:                         statusCode: response.status,
19:                     },
20:                 };
21:             }
22:             return response.body;
23:         case "streaming":
24:             if (response.body == null) {
25:                 return {
26:                     ok: false,
27:                     error: {
28:                         reason: "body-is-null",
29:                         statusCode: response.status,
30:                     },
31:                 };
32:             }
33: 
34:             return response.body;
35: 
36:         case "text":
37:             return await response.text();
38:     }
39: 
40:     // if responseType is "json" or not specified, try to parse as JSON
41:     const text = await response.text();
42:     if (text.length > 0) {
43:         try {
44:             const responseBody = fromJson(text);
45:             return responseBody;
46:         } catch (_err) {
47:             return {
48:                 ok: false,
49:                 error: {
50:                     reason: "non-json",
51:                     statusCode: response.status,
52:                     rawBody: text,
53:                 },
54:             };
55:         }
56:     }
57:     return undefined;
58: }
````

## File: src/core/fetcher/Headers.ts
````typescript
 1: let Headers: typeof globalThis.Headers;
 2: 
 3: if (typeof globalThis.Headers !== "undefined") {
 4:     Headers = globalThis.Headers;
 5: } else {
 6:     Headers = class Headers implements Headers {
 7:         private headers: Map<string, string[]>;
 8: 
 9:         constructor(init?: HeadersInit) {
10:             this.headers = new Map();
11: 
12:             if (init) {
13:                 if (init instanceof Headers) {
14:                     init.forEach((value, key) => this.append(key, value));
15:                 } else if (Array.isArray(init)) {
16:                     for (const [key, value] of init) {
17:                         if (typeof key === "string" && typeof value === "string") {
18:                             this.append(key, value);
19:                         } else {
20:                             throw new TypeError("Each header entry must be a [string, string] tuple");
21:                         }
22:                     }
23:                 } else {
24:                     for (const [key, value] of Object.entries(init)) {
25:                         if (typeof value === "string") {
26:                             this.append(key, value);
27:                         } else {
28:                             throw new TypeError("Header values must be strings");
29:                         }
30:                     }
31:                 }
32:             }
33:         }
34: 
35:         append(name: string, value: string): void {
36:             const key = name.toLowerCase();
37:             const existing = this.headers.get(key) || [];
38:             this.headers.set(key, [...existing, value]);
39:         }
40: 
41:         delete(name: string): void {
42:             const key = name.toLowerCase();
43:             this.headers.delete(key);
44:         }
45: 
46:         get(name: string): string | null {
47:             const key = name.toLowerCase();
48:             const values = this.headers.get(key);
49:             return values ? values.join(", ") : null;
50:         }
51: 
52:         has(name: string): boolean {
53:             const key = name.toLowerCase();
54:             return this.headers.has(key);
55:         }
56: 
57:         set(name: string, value: string): void {
58:             const key = name.toLowerCase();
59:             this.headers.set(key, [value]);
60:         }
61: 
62:         forEach(callbackfn: (value: string, key: string, parent: Headers) => void, thisArg?: unknown): void {
63:             const boundCallback = thisArg ? callbackfn.bind(thisArg) : callbackfn;
64:             this.headers.forEach((values, key) => boundCallback(values.join(", "), key, this));
65:         }
66: 
67:         getSetCookie(): string[] {
68:             return this.headers.get("set-cookie") || [];
69:         }
70: 
71:         *entries(): HeadersIterator<[string, string]> {
72:             for (const [key, values] of this.headers.entries()) {
73:                 yield [key, values.join(", ")];
74:             }
75:         }
76: 
77:         *keys(): HeadersIterator<string> {
78:             yield* this.headers.keys();
79:         }
80: 
81:         *values(): HeadersIterator<string> {
82:             for (const values of this.headers.values()) {
83:                 yield values.join(", ");
84:             }
85:         }
86: 
87:         [Symbol.iterator](): HeadersIterator<[string, string]> {
88:             return this.entries();
89:         }
90:     };
91: }
92: 
93: export { Headers };
````

## File: src/core/fetcher/HttpResponsePromise.ts
````typescript
  1: import type { WithRawResponse } from "./RawResponse.js";
  2: 
  3: /**
  4:  * A promise that returns the parsed response and lets you retrieve the raw response too.
  5:  */
  6: export class HttpResponsePromise<T> extends Promise<T> {
  7:     private innerPromise: Promise<WithRawResponse<T>>;
  8:     private unwrappedPromise: Promise<T> | undefined;
  9: 
 10:     private constructor(promise: Promise<WithRawResponse<T>>) {
 11:         // Initialize with a no-op to avoid premature parsing
 12:         super((resolve) => {
 13:             resolve(undefined as unknown as T);
 14:         });
 15:         this.innerPromise = promise;
 16:     }
 17: 
 18:     /**
 19:      * Creates an `HttpResponsePromise` from a function that returns a promise.
 20:      *
 21:      * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
 22:      * @param args - Arguments to pass to the function.
 23:      * @returns An `HttpResponsePromise` instance.
 24:      */
 25:     public static fromFunction<F extends (...args: never[]) => Promise<WithRawResponse<T>>, T>(
 26:         fn: F,
 27:         ...args: Parameters<F>
 28:     ): HttpResponsePromise<T> {
 29:         return new HttpResponsePromise<T>(fn(...args));
 30:     }
 31: 
 32:     /**
 33:      * Creates a function that returns an `HttpResponsePromise` from a function that returns a promise.
 34:      *
 35:      * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
 36:      * @returns A function that returns an `HttpResponsePromise` instance.
 37:      */
 38:     public static interceptFunction<
 39:         F extends (...args: never[]) => Promise<WithRawResponse<T>>,
 40:         T = Awaited<ReturnType<F>>["data"],
 41:     >(fn: F): (...args: Parameters<F>) => HttpResponsePromise<T> {
 42:         return (...args: Parameters<F>): HttpResponsePromise<T> => {
 43:             return HttpResponsePromise.fromPromise<T>(fn(...args));
 44:         };
 45:     }
 46: 
 47:     /**
 48:      * Creates an `HttpResponsePromise` from an existing promise.
 49:      *
 50:      * @param promise - A promise resolving to a `WithRawResponse` object.
 51:      * @returns An `HttpResponsePromise` instance.
 52:      */
 53:     public static fromPromise<T>(promise: Promise<WithRawResponse<T>>): HttpResponsePromise<T> {
 54:         return new HttpResponsePromise<T>(promise);
 55:     }
 56: 
 57:     /**
 58:      * Creates an `HttpResponsePromise` from an executor function.
 59:      *
 60:      * @param executor - A function that takes resolve and reject callbacks to create a promise.
 61:      * @returns An `HttpResponsePromise` instance.
 62:      */
 63:     public static fromExecutor<T>(
 64:         executor: (resolve: (value: WithRawResponse<T>) => void, reject: (reason?: unknown) => void) => void,
 65:     ): HttpResponsePromise<T> {
 66:         const promise = new Promise<WithRawResponse<T>>(executor);
 67:         return new HttpResponsePromise<T>(promise);
 68:     }
 69: 
 70:     /**
 71:      * Creates an `HttpResponsePromise` from a resolved result.
 72:      *
 73:      * @param result - A `WithRawResponse` object to resolve immediately.
 74:      * @returns An `HttpResponsePromise` instance.
 75:      */
 76:     public static fromResult<T>(result: WithRawResponse<T>): HttpResponsePromise<T> {
 77:         const promise = Promise.resolve(result);
 78:         return new HttpResponsePromise<T>(promise);
 79:     }
 80: 
 81:     private unwrap(): Promise<T> {
 82:         if (!this.unwrappedPromise) {
 83:             this.unwrappedPromise = this.innerPromise.then(({ data }) => data);
 84:         }
 85:         return this.unwrappedPromise;
 86:     }
 87: 
 88:     /** @inheritdoc */
 89:     public override then<TResult1 = T, TResult2 = never>(
 90:         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
 91:         onrejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null,
 92:     ): Promise<TResult1 | TResult2> {
 93:         return this.unwrap().then(onfulfilled, onrejected);
 94:     }
 95: 
 96:     /** @inheritdoc */
 97:     public override catch<TResult = never>(
 98:         onrejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | null,
 99:     ): Promise<T | TResult> {
100:         return this.unwrap().catch(onrejected);
101:     }
102: 
103:     /** @inheritdoc */
104:     public override finally(onfinally?: (() => void) | null): Promise<T> {
105:         return this.unwrap().finally(onfinally);
106:     }
107: 
108:     /**
109:      * Retrieves the data and raw response.
110:      *
111:      * @returns A promise resolving to a `WithRawResponse` object.
112:      */
113:     public async withRawResponse(): Promise<WithRawResponse<T>> {
114:         return await this.innerPromise;
115:     }
116: }
````

## File: src/core/fetcher/index.ts
````typescript
 1: export type { APIResponse } from "./APIResponse.js";
 2: export type { BinaryResponse } from "./BinaryResponse.js";
 3: export type { EndpointMetadata } from "./EndpointMetadata.js";
 4: export { EndpointSupplier } from "./EndpointSupplier.js";
 5: export type { Fetcher, FetchFunction } from "./Fetcher.js";
 6: export { fetcher } from "./Fetcher.js";
 7: export { getHeader } from "./getHeader.js";
 8: export { HttpResponsePromise } from "./HttpResponsePromise.js";
 9: export type { RawResponse, WithRawResponse } from "./RawResponse.js";
10: export { abortRawResponse, toRawResponse, unknownRawResponse } from "./RawResponse.js";
11: export { Supplier } from "./Supplier.js";
````

## File: src/core/fetcher/makeRequest.ts
````typescript
 1: import { anySignal, getTimeoutSignal } from "./signals.js";
 2: 
 3: export const makeRequest = async (
 4:     fetchFn: (url: string, init: RequestInit) => Promise<Response>,
 5:     url: string,
 6:     method: string,
 7:     headers: Headers | Record<string, string>,
 8:     requestBody: BodyInit | undefined,
 9:     timeoutMs?: number,
10:     abortSignal?: AbortSignal,
11:     withCredentials?: boolean,
12:     duplex?: "half",
13: ): Promise<Response> => {
14:     const signals: AbortSignal[] = [];
15: 
16:     let timeoutAbortId: ReturnType<typeof setTimeout> | undefined;
17:     if (timeoutMs != null) {
18:         const { signal, abortId } = getTimeoutSignal(timeoutMs);
19:         timeoutAbortId = abortId;
20:         signals.push(signal);
21:     }
22: 
23:     if (abortSignal != null) {
24:         signals.push(abortSignal);
25:     }
26:     const newSignals = anySignal(signals);
27:     const response = await fetchFn(url, {
28:         method: method,
29:         headers,
30:         body: requestBody,
31:         signal: newSignals,
32:         credentials: withCredentials ? "include" : undefined,
33:         // @ts-ignore
34:         duplex,
35:     });
36: 
37:     if (timeoutAbortId != null) {
38:         clearTimeout(timeoutAbortId);
39:     }
40: 
41:     return response;
42: };
````

## File: src/core/fetcher/RawResponse.ts
````typescript
 1: import { Headers } from "./Headers.js";
 2: 
 3: /**
 4:  * The raw response from the fetch call excluding the body.
 5:  */
 6: export type RawResponse = Omit<
 7:     {
 8:         [K in keyof Response as Response[K] extends Function ? never : K]: Response[K]; // strips out functions
 9:     },
10:     "ok" | "body" | "bodyUsed"
11: >; // strips out body and bodyUsed
12: 
13: /**
14:  * A raw response indicating that the request was aborted.
15:  */
16: export const abortRawResponse: RawResponse = {
17:     headers: new Headers(),
18:     redirected: false,
19:     status: 499,
20:     statusText: "Client Closed Request",
21:     type: "error",
22:     url: "",
23: } as const;
24: 
25: /**
26:  * A raw response indicating an unknown error.
27:  */
28: export const unknownRawResponse: RawResponse = {
29:     headers: new Headers(),
30:     redirected: false,
31:     status: 0,
32:     statusText: "Unknown Error",
33:     type: "error",
34:     url: "",
35: } as const;
36: 
37: /**
38:  * Converts a `RawResponse` object into a `RawResponse` by extracting its properties,
39:  * excluding the `body` and `bodyUsed` fields.
40:  *
41:  * @param response - The `RawResponse` object to convert.
42:  * @returns A `RawResponse` object containing the extracted properties of the input response.
43:  */
44: export function toRawResponse(response: Response): RawResponse {
45:     return {
46:         headers: response.headers,
47:         redirected: response.redirected,
48:         status: response.status,
49:         statusText: response.statusText,
50:         type: response.type,
51:         url: response.url,
52:     };
53: }
54: 
55: /**
56:  * Creates a `RawResponse` from a standard `Response` object.
57:  */
58: export interface WithRawResponse<T> {
59:     readonly data: T;
60:     readonly rawResponse: RawResponse;
61: }
````

## File: src/core/fetcher/requestWithRetries.ts
````typescript
 1: const INITIAL_RETRY_DELAY = 1000; // in milliseconds
 2: const MAX_RETRY_DELAY = 60000; // in milliseconds
 3: const DEFAULT_MAX_RETRIES = 2;
 4: const JITTER_FACTOR = 0.2; // 20% random jitter
 5: 
 6: function addPositiveJitter(delay: number): number {
 7:     const jitterMultiplier = 1 + Math.random() * JITTER_FACTOR;
 8:     return delay * jitterMultiplier;
 9: }
10: 
11: function addSymmetricJitter(delay: number): number {
12:     const jitterMultiplier = 1 + (Math.random() - 0.5) * JITTER_FACTOR;
13:     return delay * jitterMultiplier;
14: }
15: 
16: function getRetryDelayFromHeaders(response: Response, retryAttempt: number): number {
17:     const retryAfter = response.headers.get("Retry-After");
18:     if (retryAfter) {
19:         const retryAfterSeconds = parseInt(retryAfter, 10);
20:         if (!Number.isNaN(retryAfterSeconds) && retryAfterSeconds > 0) {
21:             return Math.min(retryAfterSeconds * 1000, MAX_RETRY_DELAY);
22:         }
23: 
24:         const retryAfterDate = new Date(retryAfter);
25:         if (!Number.isNaN(retryAfterDate.getTime())) {
26:             const delay = retryAfterDate.getTime() - Date.now();
27:             if (delay > 0) {
28:                 return Math.min(Math.max(delay, 0), MAX_RETRY_DELAY);
29:             }
30:         }
31:     }
32: 
33:     const rateLimitReset = response.headers.get("X-RateLimit-Reset");
34:     if (rateLimitReset) {
35:         const resetTime = parseInt(rateLimitReset, 10);
36:         if (!Number.isNaN(resetTime)) {
37:             const delay = resetTime * 1000 - Date.now();
38:             if (delay > 0) {
39:                 return addPositiveJitter(Math.min(delay, MAX_RETRY_DELAY));
40:             }
41:         }
42:     }
43: 
44:     return addSymmetricJitter(Math.min(INITIAL_RETRY_DELAY * 2 ** retryAttempt, MAX_RETRY_DELAY));
45: }
46: 
47: export async function requestWithRetries(
48:     requestFn: () => Promise<Response>,
49:     maxRetries: number = DEFAULT_MAX_RETRIES,
50: ): Promise<Response> {
51:     let response: Response = await requestFn();
52: 
53:     for (let i = 0; i < maxRetries; ++i) {
54:         if ([408, 429].includes(response.status) || response.status >= 500) {
55:             const delay = getRetryDelayFromHeaders(response, i);
56: 
57:             await new Promise((resolve) => setTimeout(resolve, delay));
58:             response = await requestFn();
59:         } else {
60:             break;
61:         }
62:     }
63:     return response!;
64: }
````

## File: src/core/fetcher/signals.ts
````typescript
 1: const TIMEOUT = "timeout";
 2: 
 3: export function getTimeoutSignal(timeoutMs: number): { signal: AbortSignal; abortId: ReturnType<typeof setTimeout> } {
 4:     const controller = new AbortController();
 5:     const abortId = setTimeout(() => controller.abort(TIMEOUT), timeoutMs);
 6:     return { signal: controller.signal, abortId };
 7: }
 8: 
 9: export function anySignal(...args: AbortSignal[] | [AbortSignal[]]): AbortSignal {
10:     const signals = (args.length === 1 && Array.isArray(args[0]) ? args[0] : args) as AbortSignal[];
11: 
12:     const controller = new AbortController();
13: 
14:     for (const signal of signals) {
15:         if (signal.aborted) {
16:             controller.abort((signal as any)?.reason);
17:             break;
18:         }
19: 
20:         signal.addEventListener("abort", () => controller.abort((signal as any)?.reason), {
21:             signal: controller.signal,
22:         });
23:     }
24: 
25:     return controller.signal;
26: }
````

## File: src/core/fetcher/Supplier.ts
````typescript
 1: /** THIS FILE IS MANUALLY MAINAINED: see .fernignore */
 2: export type Supplier<T> = T | (() => T);
 3: 
 4: export const Supplier = {
 5:     get: <T>(supplier: Supplier<T>): T => {
 6:         if (typeof supplier === "function") {
 7:             return (supplier as () => T)();
 8:         } else {
 9:             return supplier;
10:         }
11:     },
12:     map: <T, U, R = U>(supplier: Supplier<T>, f: (value: T) => R): Supplier<R> => {
13:         if (typeof supplier === "function") {
14:             return () => f(Supplier.get(supplier));
15:         } else {
16:             return f(supplier);
17:         }
18:     },
19: };
````

## File: src/core/fetcher/Supplier.ts.diff
````diff
 1: diff --git a/src/core/fetcher/Supplier.ts b/src/core/fetcher/Supplier.ts
 2: index aa95dd8..867c931 100644
 3: --- a/src/core/fetcher/Supplier.ts
 4: +++ b/src/core/fetcher/Supplier.ts
 5: @@ -1,19 +1,11 @@
 6: -/** THIS FILE IS MANUALLY MAINAINED: see .fernignore */
 7: -export type Supplier<T> = T | (() => T);
 8: +export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);
 9:  
10:  export const Supplier = {
11: -    get: <T>(supplier: Supplier<T>): T => {
12: +    get: async <T>(supplier: Supplier<T>): Promise<T> => {
13:          if (typeof supplier === "function") {
14:              return (supplier as () => T)();
15:          } else {
16:              return supplier;
17:          }
18:      },
19: -    map: <T, U, R = U>(supplier: Supplier<T>, f: (value: T) => R): Supplier<R> => {
20: -        if (typeof supplier === "function") {
21: -            return () => f(Supplier.get(supplier));
22: -        } else {
23: -            return f(supplier);
24: -        }
25: -    },
26:  };
````

## File: src/core/file/exports.ts
````typescript
1: export type { Uploadable } from "./types.js";
````

## File: src/core/file/file.ts
````typescript
  1: import type { Uploadable } from "./types.js";
  2: 
  3: export async function toBinaryUploadRequest(
  4:     file: Uploadable,
  5: ): Promise<{ body: Uploadable.FileLike; headers?: Record<string, string> }> {
  6:     const { data, filename, contentLength, contentType } = await getFileWithMetadata(file);
  7:     const request = {
  8:         body: data,
  9:         headers: {} as Record<string, string>,
 10:     };
 11:     if (filename) {
 12:         request.headers["Content-Disposition"] = `attachment; filename="${filename}"`;
 13:     }
 14:     if (contentType) {
 15:         request.headers["Content-Type"] = contentType;
 16:     }
 17:     if (contentLength != null) {
 18:         request.headers["Content-Length"] = contentLength.toString();
 19:     }
 20:     return request;
 21: }
 22: 
 23: export async function toMultipartDataPart(
 24:     file: Uploadable,
 25: ): Promise<{ data: Uploadable.FileLike; filename?: string; contentType?: string }> {
 26:     const { data, filename, contentType } = await getFileWithMetadata(file, {
 27:         noSniffFileSize: true,
 28:     });
 29:     return {
 30:         data,
 31:         filename,
 32:         contentType,
 33:     };
 34: }
 35: 
 36: async function getFileWithMetadata(
 37:     file: Uploadable,
 38:     { noSniffFileSize }: { noSniffFileSize?: boolean } = {},
 39: ): Promise<Uploadable.WithMetadata> {
 40:     if (isFileLike(file)) {
 41:         return getFileWithMetadata(
 42:             {
 43:                 data: file,
 44:             },
 45:             { noSniffFileSize },
 46:         );
 47:     }
 48: 
 49:     if ("path" in file) {
 50:         const fs = await import("fs");
 51:         if (!fs || !fs.createReadStream) {
 52:             throw new Error("File path uploads are not supported in this environment.");
 53:         }
 54:         const data = fs.createReadStream(file.path);
 55:         const contentLength =
 56:             file.contentLength ?? (noSniffFileSize === true ? undefined : await tryGetFileSizeFromPath(file.path));
 57:         const filename = file.filename ?? getNameFromPath(file.path);
 58:         return {
 59:             data,
 60:             filename,
 61:             contentType: file.contentType,
 62:             contentLength,
 63:         };
 64:     }
 65:     if ("data" in file) {
 66:         const data = file.data;
 67:         const contentLength =
 68:             file.contentLength ??
 69:             (await tryGetContentLengthFromFileLike(data, {
 70:                 noSniffFileSize,
 71:             }));
 72:         const filename = file.filename ?? tryGetNameFromFileLike(data);
 73:         return {
 74:             data,
 75:             filename,
 76:             contentType: file.contentType ?? tryGetContentTypeFromFileLike(data),
 77:             contentLength,
 78:         };
 79:     }
 80: 
 81:     throw new Error(`Invalid FileUpload of type ${typeof file}: ${JSON.stringify(file)}`);
 82: }
 83: 
 84: function isFileLike(value: unknown): value is Uploadable.FileLike {
 85:     return (
 86:         isBuffer(value) ||
 87:         isArrayBufferView(value) ||
 88:         isArrayBuffer(value) ||
 89:         isUint8Array(value) ||
 90:         isBlob(value) ||
 91:         isFile(value) ||
 92:         isStreamLike(value) ||
 93:         isReadableStream(value)
 94:     );
 95: }
 96: 
 97: async function tryGetFileSizeFromPath(path: string): Promise<number | undefined> {
 98:     try {
 99:         const fs = await import("fs");
100:         if (!fs || !fs.promises || !fs.promises.stat) {
101:             return undefined;
102:         }
103:         const fileStat = await fs.promises.stat(path);
104:         return fileStat.size;
105:     } catch (_fallbackError) {
106:         return undefined;
107:     }
108: }
109: 
110: function tryGetNameFromFileLike(data: Uploadable.FileLike): string | undefined {
111:     if (isNamedValue(data)) {
112:         return data.name;
113:     }
114:     if (isPathedValue(data)) {
115:         return getNameFromPath(data.path.toString());
116:     }
117:     return undefined;
118: }
119: 
120: async function tryGetContentLengthFromFileLike(
121:     data: Uploadable.FileLike,
122:     { noSniffFileSize }: { noSniffFileSize?: boolean } = {},
123: ): Promise<number | undefined> {
124:     if (isBuffer(data)) {
125:         return data.length;
126:     }
127:     if (isArrayBufferView(data)) {
128:         return data.byteLength;
129:     }
130:     if (isArrayBuffer(data)) {
131:         return data.byteLength;
132:     }
133:     if (isBlob(data)) {
134:         return data.size;
135:     }
136:     if (isFile(data)) {
137:         return data.size;
138:     }
139:     if (noSniffFileSize === true) {
140:         return undefined;
141:     }
142:     if (isPathedValue(data)) {
143:         return await tryGetFileSizeFromPath(data.path.toString());
144:     }
145:     return undefined;
146: }
147: 
148: function tryGetContentTypeFromFileLike(data: Uploadable.FileLike): string | undefined {
149:     if (isBlob(data)) {
150:         return data.type;
151:     }
152:     if (isFile(data)) {
153:         return data.type;
154:     }
155: 
156:     return undefined;
157: }
158: 
159: function getNameFromPath(path: string): string | undefined {
160:     const lastForwardSlash = path.lastIndexOf("/");
161:     const lastBackSlash = path.lastIndexOf("\\");
162:     const lastSlashIndex = Math.max(lastForwardSlash, lastBackSlash);
163:     return lastSlashIndex >= 0 ? path.substring(lastSlashIndex + 1) : path;
164: }
165: 
166: type NamedValue = {
167:     name: string;
168: } & unknown;
169: 
170: type PathedValue = {
171:     path: string | { toString(): string };
172: } & unknown;
173: 
174: type StreamLike = {
175:     read?: () => unknown;
176:     pipe?: (dest: unknown) => unknown;
177: } & unknown;
178: 
179: function isNamedValue(value: unknown): value is NamedValue {
180:     return typeof value === "object" && value != null && "name" in value;
181: }
182: 
183: function isPathedValue(value: unknown): value is PathedValue {
184:     return typeof value === "object" && value != null && "path" in value;
185: }
186: 
187: function isStreamLike(value: unknown): value is StreamLike {
188:     return typeof value === "object" && value != null && ("read" in value || "pipe" in value);
189: }
190: 
191: function isReadableStream(value: unknown): value is ReadableStream {
192:     return typeof value === "object" && value != null && "getReader" in value;
193: }
194: 
195: function isBuffer(value: unknown): value is Buffer {
196:     return typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(value);
197: }
198: 
199: function isArrayBufferView(value: unknown): value is ArrayBufferView {
200:     return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
201: }
202: 
203: function isArrayBuffer(value: unknown): value is ArrayBuffer {
204:     return typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer;
205: }
206: 
207: function isUint8Array(value: unknown): value is Uint8Array {
208:     return typeof Uint8Array !== "undefined" && value instanceof Uint8Array;
209: }
210: 
211: function isBlob(value: unknown): value is Blob {
212:     return typeof Blob !== "undefined" && value instanceof Blob;
213: }
214: 
215: function isFile(value: unknown): value is File {
216:     return typeof File !== "undefined" && value instanceof File;
217: }
````

## File: src/core/file/index.ts
````typescript
1: export * from "./file.js";
2: export * from "./types.js";
````

## File: src/core/file/types.ts
````typescript
 1: /**
 2:  * A file that can be uploaded. Can be a file-like object (stream, buffer, blob, etc.),
 3:  * a path to a file, or an object with a file-like object and metadata.
 4:  */
 5: export type Uploadable = Uploadable.FileLike | Uploadable.FromPath | Uploadable.WithMetadata;
 6: 
 7: export namespace Uploadable {
 8:     /**
 9:      * Various file-like objects that can be used to upload a file.
10:      */
11:     export type FileLike =
12:         | ArrayBuffer
13:         | ArrayBufferLike
14:         | ArrayBufferView
15:         | Uint8Array
16:         | import("buffer").Buffer
17:         | import("buffer").Blob
18:         | import("buffer").File
19:         | import("stream").Readable
20:         | import("stream/web").ReadableStream
21:         | globalThis.Blob
22:         | globalThis.File
23:         | ReadableStream;
24: 
25:     /**
26:      * A file path with optional metadata, used for uploading a file from the file system.
27:      */
28:     export type FromPath = {
29:         /** The path to the file to upload */
30:         path: string;
31:         /**
32:          * Optional override for the file name (defaults to basename of path).
33:          * This is used to set the `Content-Disposition` header in upload requests.
34:          */
35:         filename?: string;
36:         /**
37:          * Optional MIME type of the file (e.g., 'image/jpeg', 'text/plain').
38:          * This is used to set the `Content-Type` header in upload requests.
39:          */
40:         contentType?: string;
41:         /**
42:          * Optional file size in bytes.
43:          * If not provided, the file size will be determined from the file system.
44:          * The content length is used to set the `Content-Length` header in upload requests.
45:          */
46:         contentLength?: number;
47:     };
48: 
49:     /**
50:      * A file-like object with metadata, used for uploading files.
51:      */
52:     export type WithMetadata = {
53:         /** The file data */
54:         data: FileLike;
55:         /**
56:          * Optional override for the file name (defaults to basename of path).
57:          * This is used to set the `Content-Disposition` header in upload requests.
58:          */
59:         filename?: string;
60:         /**
61:          * Optional MIME type of the file (e.g., 'image/jpeg', 'text/plain').
62:          * This is used to set the `Content-Type` header in upload requests.
63:          *
64:          * If not provided, the content type may be determined from the data itself.
65:          * * If the data is a `File`, `Blob`, or similar, the content type will be determined from the file itself, if the type is set.
66:          * * Any other data type will not have a content type set, and the upload request will use `Content-Type: application/octet-stream` instead.
67:          */
68:         contentType?: string;
69:         /**
70:          * Optional file size in bytes.
71:          * The content length is used to set the `Content-Length` header in upload requests.
72:          * If the content length is not provided and cannot be determined, the upload request will not include the `Content-Length` header, but will use `Transfer-Encoding: chunked` instead.
73:          *
74:          * If not provided, the file size will be determined depending on the data type.
75:          * * If the data is of type `fs.ReadStream` (`createReadStream`), the size will be determined from the file system.
76:          * * If the data is a `Buffer`, `ArrayBuffer`, `Uint8Array`, `Blob`, `File`, or similar, the size will be determined from the data itself.
77:          * * If the data is a `Readable` or `ReadableStream`, the size will not be determined.
78:          */
79:         contentLength?: number;
80:     };
81: }
````

## File: src/core/form-data-utils/encodeAsFormParameter.ts
````typescript
 1: import { toQueryString } from "../url/qs.js";
 2: 
 3: export function encodeAsFormParameter(value: unknown): Record<string, string> {
 4:     const stringified = toQueryString(value, { encode: false });
 5: 
 6:     const keyValuePairs = stringified.split("&").map((pair) => {
 7:         const [key, value] = pair.split("=");
 8:         return [key, value] as const;
 9:     });
10: 
11:     return Object.fromEntries(keyValuePairs);
12: }
````

## File: src/core/form-data-utils/FormDataWrapper.ts
````typescript
  1: import { toMultipartDataPart, type Uploadable } from "../../core/file/index.js";
  2: import { toJson } from "../../core/json.js";
  3: import { RUNTIME } from "../runtime/index.js";
  4: 
  5: interface FormDataRequest<Body> {
  6:     body: Body;
  7:     headers: Record<string, string>;
  8:     duplex?: "half";
  9: }
 10: 
 11: export async function newFormData(): Promise<FormDataWrapper> {
 12:     return new FormDataWrapper();
 13: }
 14: 
 15: export class FormDataWrapper {
 16:     private fd: FormData = new FormData();
 17: 
 18:     public async setup(): Promise<void> {
 19:         // noop
 20:     }
 21: 
 22:     public append(key: string, value: unknown): void {
 23:         this.fd.append(key, String(value));
 24:     }
 25: 
 26:     public async appendFile(key: string, value: Uploadable): Promise<void> {
 27:         const { data, filename, contentType } = await toMultipartDataPart(value);
 28:         const blob = await convertToBlob(data, contentType);
 29:         if (filename) {
 30:             this.fd.append(key, blob, filename);
 31:         } else {
 32:             this.fd.append(key, blob);
 33:         }
 34:     }
 35: 
 36:     public getRequest(): FormDataRequest<FormData> {
 37:         return {
 38:             body: this.fd,
 39:             headers: {},
 40:             duplex: "half" as const,
 41:         };
 42:     }
 43: }
 44: 
 45: type StreamLike = {
 46:     read?: () => unknown;
 47:     pipe?: (dest: unknown) => unknown;
 48: } & unknown;
 49: 
 50: function isStreamLike(value: unknown): value is StreamLike {
 51:     return typeof value === "object" && value != null && ("read" in value || "pipe" in value);
 52: }
 53: 
 54: function isReadableStream(value: unknown): value is ReadableStream {
 55:     return typeof value === "object" && value != null && "getReader" in value;
 56: }
 57: 
 58: function isBuffer(value: unknown): value is Buffer {
 59:     return typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(value);
 60: }
 61: 
 62: function isArrayBufferView(value: unknown): value is ArrayBufferView {
 63:     return ArrayBuffer.isView(value);
 64: }
 65: 
 66: async function streamToBuffer(stream: unknown): Promise<Buffer> {
 67:     if (RUNTIME.type === "node") {
 68:         const { Readable } = await import("stream");
 69: 
 70:         if (stream instanceof Readable) {
 71:             const chunks: Buffer[] = [];
 72:             for await (const chunk of stream) {
 73:                 chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
 74:             }
 75:             return Buffer.concat(chunks);
 76:         }
 77:     }
 78: 
 79:     if (isReadableStream(stream)) {
 80:         const reader = stream.getReader();
 81:         const chunks: Uint8Array[] = [];
 82: 
 83:         try {
 84:             while (true) {
 85:                 const { done, value } = await reader.read();
 86:                 if (done) break;
 87:                 chunks.push(value);
 88:             }
 89:         } finally {
 90:             reader.releaseLock();
 91:         }
 92: 
 93:         const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
 94:         const result = new Uint8Array(totalLength);
 95:         let offset = 0;
 96:         for (const chunk of chunks) {
 97:             result.set(chunk, offset);
 98:             offset += chunk.length;
 99:         }
100: 
101:         return Buffer.from(result);
102:     }
103: 
104:     throw new Error(
105:         `Unsupported stream type: ${typeof stream}. Expected Node.js Readable stream or Web ReadableStream.`,
106:     );
107: }
108: 
109: async function convertToBlob(value: unknown, contentType?: string): Promise<Blob> {
110:     if (isStreamLike(value) || isReadableStream(value)) {
111:         const buffer = await streamToBuffer(value);
112:         return new Blob([buffer], { type: contentType });
113:     }
114: 
115:     if (value instanceof Blob) {
116:         return value;
117:     }
118: 
119:     if (isBuffer(value)) {
120:         return new Blob([value], { type: contentType });
121:     }
122: 
123:     if (value instanceof ArrayBuffer) {
124:         return new Blob([value], { type: contentType });
125:     }
126: 
127:     if (isArrayBufferView(value)) {
128:         return new Blob([value], { type: contentType });
129:     }
130: 
131:     if (typeof value === "string") {
132:         return new Blob([value], { type: contentType });
133:     }
134: 
135:     if (typeof value === "object" && value !== null) {
136:         return new Blob([toJson(value)], { type: contentType ?? "application/json" });
137:     }
138: 
139:     return new Blob([String(value)], { type: contentType });
140: }
````

## File: src/core/form-data-utils/index.ts
````typescript
1: export { encodeAsFormParameter } from "./encodeAsFormParameter.js";
2: export * from "./FormDataWrapper.js";
````

## File: src/core/logging/exports.ts
````typescript
 1: import * as logger from "./logger.js";
 2: 
 3: export namespace logging {
 4:     /**
 5:      * Configuration for logger instances.
 6:      */
 7:     export type LogConfig = logger.LogConfig;
 8:     export type LogLevel = logger.LogLevel;
 9:     export const LogLevel: typeof logger.LogLevel = logger.LogLevel;
10:     export type ILogger = logger.ILogger;
11:     /**
12:      * Console logger implementation that outputs to the console.
13:      */
14:     export type ConsoleLogger = logger.ConsoleLogger;
15:     /**
16:      * Console logger implementation that outputs to the console.
17:      */
18:     export const ConsoleLogger: typeof logger.ConsoleLogger = logger.ConsoleLogger;
19: }
````

## File: src/core/logging/index.ts
````typescript
1: export * from "./logger.js";
````

## File: src/core/logging/logger.ts
````typescript
  1: export const LogLevel = {
  2:     Debug: "debug",
  3:     Info: "info",
  4:     Warn: "warn",
  5:     Error: "error",
  6: } as const;
  7: export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];
  8: const logLevelMap: Record<LogLevel, number> = {
  9:     [LogLevel.Debug]: 1,
 10:     [LogLevel.Info]: 2,
 11:     [LogLevel.Warn]: 3,
 12:     [LogLevel.Error]: 4,
 13: };
 14: 
 15: export interface ILogger {
 16:     /**
 17:      * Logs a debug message.
 18:      * @param message - The message to log
 19:      * @param args - Additional arguments to log
 20:      */
 21:     debug(message: string, ...args: unknown[]): void;
 22:     /**
 23:      * Logs an info message.
 24:      * @param message - The message to log
 25:      * @param args - Additional arguments to log
 26:      */
 27:     info(message: string, ...args: unknown[]): void;
 28:     /**
 29:      * Logs a warning message.
 30:      * @param message - The message to log
 31:      * @param args - Additional arguments to log
 32:      */
 33:     warn(message: string, ...args: unknown[]): void;
 34:     /**
 35:      * Logs an error message.
 36:      * @param message - The message to log
 37:      * @param args - Additional arguments to log
 38:      */
 39:     error(message: string, ...args: unknown[]): void;
 40: }
 41: 
 42: /**
 43:  * Configuration for logger initialization.
 44:  */
 45: export interface LogConfig {
 46:     /**
 47:      * Minimum log level to output.
 48:      * @default LogLevel.Info
 49:      */
 50:     level?: LogLevel;
 51:     /**
 52:      * Logger implementation to use.
 53:      * @default new ConsoleLogger()
 54:      */
 55:     logger?: ILogger;
 56:     /**
 57:      * Whether logging should be silenced.
 58:      * @default true
 59:      */
 60:     silent?: boolean;
 61: }
 62: 
 63: /**
 64:  * Default console-based logger implementation.
 65:  */
 66: export class ConsoleLogger implements ILogger {
 67:     debug(message: string, ...args: unknown[]): void {
 68:         console.debug(message, ...args);
 69:     }
 70:     info(message: string, ...args: unknown[]): void {
 71:         console.info(message, ...args);
 72:     }
 73:     warn(message: string, ...args: unknown[]): void {
 74:         console.warn(message, ...args);
 75:     }
 76:     error(message: string, ...args: unknown[]): void {
 77:         console.error(message, ...args);
 78:     }
 79: }
 80: 
 81: /**
 82:  * Logger class that provides level-based logging functionality.
 83:  */
 84: export class Logger {
 85:     private readonly level: number;
 86:     private readonly logger: ILogger;
 87:     private readonly silent: boolean;
 88: 
 89:     /**
 90:      * Creates a new logger instance.
 91:      * @param config - Logger configuration
 92:      */
 93:     constructor(config: Required<LogConfig>) {
 94:         this.level = logLevelMap[config.level];
 95:         this.logger = config.logger;
 96:         this.silent = config.silent;
 97:     }
 98: 
 99:     /**
100:      * Checks if a log level should be output based on configuration.
101:      * @param level - The log level to check
102:      * @returns True if the level should be logged
103:      */
104:     public shouldLog(level: LogLevel): boolean {
105:         return !this.silent && this.level <= logLevelMap[level];
106:     }
107: 
108:     /**
109:      * Checks if debug logging is enabled.
110:      * @returns True if debug logs should be output
111:      */
112:     public isDebug(): boolean {
113:         return this.shouldLog(LogLevel.Debug);
114:     }
115: 
116:     /**
117:      * Logs a debug message if debug logging is enabled.
118:      * @param message - The message to log
119:      * @param args - Additional arguments to log
120:      */
121:     public debug(message: string, ...args: unknown[]): void {
122:         if (this.isDebug()) {
123:             this.logger.debug(message, ...args);
124:         }
125:     }
126: 
127:     /**
128:      * Checks if info logging is enabled.
129:      * @returns True if info logs should be output
130:      */
131:     public isInfo(): boolean {
132:         return this.shouldLog(LogLevel.Info);
133:     }
134: 
135:     /**
136:      * Logs an info message if info logging is enabled.
137:      * @param message - The message to log
138:      * @param args - Additional arguments to log
139:      */
140:     public info(message: string, ...args: unknown[]): void {
141:         if (this.isInfo()) {
142:             this.logger.info(message, ...args);
143:         }
144:     }
145: 
146:     /**
147:      * Checks if warning logging is enabled.
148:      * @returns True if warning logs should be output
149:      */
150:     public isWarn(): boolean {
151:         return this.shouldLog(LogLevel.Warn);
152:     }
153: 
154:     /**
155:      * Logs a warning message if warning logging is enabled.
156:      * @param message - The message to log
157:      * @param args - Additional arguments to log
158:      */
159:     public warn(message: string, ...args: unknown[]): void {
160:         if (this.isWarn()) {
161:             this.logger.warn(message, ...args);
162:         }
163:     }
164: 
165:     /**
166:      * Checks if error logging is enabled.
167:      * @returns True if error logs should be output
168:      */
169:     public isError(): boolean {
170:         return this.shouldLog(LogLevel.Error);
171:     }
172: 
173:     /**
174:      * Logs an error message if error logging is enabled.
175:      * @param message - The message to log
176:      * @param args - Additional arguments to log
177:      */
178:     public error(message: string, ...args: unknown[]): void {
179:         if (this.isError()) {
180:             this.logger.error(message, ...args);
181:         }
182:     }
183: }
184: 
185: export function createLogger(config?: LogConfig | Logger): Logger {
186:     if (config == null) {
187:         return defaultLogger;
188:     }
189:     if (config instanceof Logger) {
190:         return config;
191:     }
192:     config = config ?? {};
193:     config.level ??= LogLevel.Info;
194:     config.logger ??= new ConsoleLogger();
195:     config.silent ??= true;
196:     return new Logger(config as Required<LogConfig>);
197: }
198: 
199: const defaultLogger: Logger = new Logger({
200:     level: LogLevel.Info,
201:     logger: new ConsoleLogger(),
202:     silent: true,
203: });
````

## File: src/core/pagination/CustomPager.ts
````typescript
  1: import type { BaseRequestOptions, NormalizedClientOptions } from "../../BaseClient.js";
  2: import type { APIResponse } from "../fetcher/APIResponse.js";
  3: import type { Fetcher } from "../fetcher/Fetcher.js";
  4: import type { RawResponse } from "../fetcher/index.js";
  5: 
  6: /**
  7:  *
  8:  * @template TItem The type of the items in the page.
  9:  * @template TResponse The type of the API response.
 10:  */
 11: export class CustomPager<TItem, TResponse> implements AsyncIterable<TItem> {
 12:     /** The items from the current page */
 13:     public data: TItem[];
 14:     /** The raw HTTP response */
 15:     public rawResponse: RawResponse;
 16:     /** The parsed response object */
 17:     public response: TResponse;
 18: 
 19:     private sendRequest: (request: Fetcher.Args) => Promise<APIResponse<TResponse, Fetcher.Error>>;
 20:     private nextRequest?: Fetcher.Args;
 21:     private previousRequest?: Fetcher.Args;
 22:     private _hasNextPage: boolean;
 23:     private _hasPreviousPage: boolean;
 24: 
 25:     constructor(args: {
 26:         response: TResponse;
 27:         rawResponse: RawResponse;
 28:         items: TItem[];
 29:         hasNextPage: boolean;
 30:         hasPreviousPage: boolean;
 31:         nextRequest?: Fetcher.Args;
 32:         previousRequest?: Fetcher.Args;
 33:         sendRequest: (request: Fetcher.Args) => Promise<APIResponse<TResponse, Fetcher.Error>>;
 34:     }) {
 35:         this.response = args.response;
 36:         this.rawResponse = args.rawResponse;
 37:         this.data = args.items;
 38:         this._hasNextPage = args.hasNextPage;
 39:         this._hasPreviousPage = args.hasPreviousPage;
 40:         this.nextRequest = args.nextRequest;
 41:         this.previousRequest = args.previousRequest;
 42:         this.sendRequest = args.sendRequest;
 43:     }
 44: 
 45:     /**
 46:      * @returns whether there is a next page to load
 47:      */
 48:     public hasNextPage(): boolean {
 49:         return this._hasNextPage;
 50:     }
 51: 
 52:     /**
 53:      * @returns whether there is a previous page to load
 54:      */
 55:     public hasPreviousPage(): boolean {
 56:         return this._hasPreviousPage;
 57:     }
 58: 
 59:     /**
 60:      * Returns the current page data.
 61:      * This is an alias for the `data` property for consistency with other pagination APIs.
 62:      *
 63:      * @returns the items from the current page
 64:      */
 65:     public getCurrentPage(): TItem[] {
 66:         return this.data;
 67:     }
 68: 
 69:     /**
 70:      * Retrieves the next page of results.
 71:      * @returns this pager with updated data
 72:      * @throws Error if there is no next page
 73:      */
 74:     public async getNextPage(): Promise<this> {
 75:         if (!this._hasNextPage || !this.nextRequest) {
 76:             throw new Error("No next page available");
 77:         }
 78:         const response = await this.sendRequest(this.nextRequest);
 79:         if (!response.ok) {
 80:             const reason =
 81:                 response.error.reason === "status-code" ? `HTTP ${response.error.statusCode}` : response.error.reason;
 82:             throw new Error(`Failed to fetch next page: ${reason}`);
 83:         }
 84:         const data = response.body;
 85:         const rawResponse = response.rawResponse;
 86:         const parsed = await parse<TItem, TResponse>({ request: this.nextRequest, data, rawResponse });
 87:         this.response = data;
 88:         this.rawResponse = rawResponse;
 89:         this.data = parsed.items;
 90:         this._hasNextPage = parsed.hasNextPage;
 91:         this._hasPreviousPage = parsed.hasPreviousPage;
 92:         this.nextRequest = parsed.nextRequest;
 93:         this.previousRequest = parsed.previousRequest;
 94:         return this;
 95:     }
 96: 
 97:     /**
 98:      * Retrieves the previous page of results.
 99:      * @returns this pager with updated data
100:      * @throws Error if there is no previous page
101:      */
102:     public async getPreviousPage(): Promise<this> {
103:         if (!this._hasPreviousPage || !this.previousRequest) {
104:             throw new Error("No previous page available");
105:         }
106:         const response = await this.sendRequest(this.previousRequest);
107:         if (!response.ok) {
108:             const reason =
109:                 response.error.reason === "status-code" ? `HTTP ${response.error.statusCode}` : response.error.reason;
110:             throw new Error(`Failed to fetch previous page: ${reason}`);
111:         }
112:         const data = response.body;
113:         const rawResponse = response.rawResponse;
114:         const parsed = await parse<TItem, TResponse>({ request: this.previousRequest, data, rawResponse });
115:         this.response = data;
116:         this.rawResponse = rawResponse;
117:         this.data = parsed.items;
118:         this._hasNextPage = parsed.hasNextPage;
119:         this._hasPreviousPage = parsed.hasPreviousPage;
120:         this.nextRequest = parsed.nextRequest;
121:         this.previousRequest = parsed.previousRequest;
122:         return this;
123:     }
124: 
125:     private async *iterMessages(): AsyncGenerator<TItem, void> {
126:         for (const item of this.data) {
127:             yield item;
128:         }
129: 
130:         while (this.hasNextPage()) {
131:             await this.getNextPage();
132:             for (const item of this.data) {
133:                 yield item;
134:             }
135:         }
136:     }
137: 
138:     async *[Symbol.asyncIterator](): AsyncIterator<TItem, void, unknown> {
139:         for await (const message of this.iterMessages()) {
140:             yield message;
141:         }
142:     }
143: }
144: 
145: export async function createCustomPager<TItem, TResponse>({
146:     sendRequest,
147:     initialHttpRequest,
148:     clientOptions,
149: }: {
150:     sendRequest: (request: Fetcher.Args) => Promise<APIResponse<TResponse, Fetcher.Error>>;
151:     initialHttpRequest: Fetcher.Args;
152:     clientOptions: NormalizedClientOptions;
153:     requestOptions?: BaseRequestOptions;
154: }): Promise<CustomPager<TItem, TResponse>> {
155:     const response = await sendRequest(initialHttpRequest);
156:     if (!response.ok) {
157:         const reason =
158:             response.error.reason === "status-code" ? `HTTP ${response.error.statusCode}` : response.error.reason;
159:         throw new Error(`Failed to fetch initial page: ${reason}`);
160:     }
161:     const data = response.body;
162:     const rawResponse = response.rawResponse;
163:     const parsed = await parse<TItem, TResponse>({ request: initialHttpRequest, data, rawResponse });
164:     return new CustomPager({
165:         response: data,
166:         rawResponse,
167:         items: parsed.items,
168:         hasNextPage: parsed.hasNextPage,
169:         hasPreviousPage: parsed.hasPreviousPage,
170:         nextRequest: parsed.nextRequest,
171:         previousRequest: parsed.previousRequest,
172:         sendRequest: sendRequest,
173:     });
174: }
175: 
176: async function parse<TItem, TResponse>(_args: {
177:     request: Fetcher.Args;
178:     data: TResponse;
179:     rawResponse: RawResponse;
180: }): Promise<{
181:     nextRequest?: Fetcher.Args;
182:     hasNextPage: boolean;
183:     previousRequest?: Fetcher.Args;
184:     hasPreviousPage: boolean;
185:     items: TItem[];
186: }> {
187:     // Placeholder implementation.
188:     // TODO: Replace this with actual parsing logic.
189:     return {
190:         items: [],
191:         hasNextPage: false,
192:         hasPreviousPage: false,
193:     };
194: }
````

## File: src/core/pagination/exports.ts
````typescript
1: export type { Page } from "./Page.js";
````

## File: src/core/pagination/index.ts
````typescript
1: export { CustomPager, createCustomPager } from "./CustomPager.js";
2: export { Page } from "./Page.js";
````

## File: src/core/pagination/Page.ts
````typescript
 1: import type { HttpResponsePromise, RawResponse } from "../fetcher/index.js";
 2: 
 3: /**
 4:  * A page of results from a paginated API.
 5:  *
 6:  * @template T The type of the items in the page.
 7:  * @template R The type of the API response.
 8:  */
 9: export class Page<T, R = unknown> implements AsyncIterable<T> {
10:     public data: T[];
11:     public rawResponse: RawResponse;
12:     public response: R;
13: 
14:     private _hasNextPage: (response: R) => boolean;
15:     private getItems: (response: R) => T[];
16:     private loadNextPage: (response: R) => HttpResponsePromise<R>;
17: 
18:     constructor({
19:         response,
20:         rawResponse,
21:         hasNextPage,
22:         getItems,
23:         loadPage,
24:     }: {
25:         response: R;
26:         rawResponse: RawResponse;
27:         hasNextPage: (response: R) => boolean;
28:         getItems: (response: R) => T[];
29:         loadPage: (response: R) => HttpResponsePromise<R>;
30:     }) {
31:         this.response = response;
32:         this.rawResponse = rawResponse;
33:         this.data = getItems(response);
34:         this._hasNextPage = hasNextPage;
35:         this.getItems = getItems;
36:         this.loadNextPage = loadPage;
37:     }
38: 
39:     /**
40:      * Retrieves the next page
41:      * @returns this
42:      */
43:     public async getNextPage(): Promise<this> {
44:         const { data, rawResponse } = await this.loadNextPage(this.response).withRawResponse();
45:         this.response = data;
46:         this.rawResponse = rawResponse;
47:         this.data = this.getItems(this.response);
48:         return this;
49:     }
50: 
51:     /**
52:      * @returns whether there is a next page to load
53:      */
54:     public hasNextPage(): boolean {
55:         return this._hasNextPage(this.response);
56:     }
57: 
58:     private async *iterMessages(): AsyncGenerator<T, void> {
59:         for (const item of this.data) {
60:             yield item;
61:         }
62: 
63:         while (this.hasNextPage()) {
64:             await this.getNextPage();
65:             for (const item of this.data) {
66:                 yield item;
67:             }
68:         }
69:     }
70: 
71:     async *[Symbol.asyncIterator](): AsyncIterator<T, void, any> {
72:         for await (const message of this.iterMessages()) {
73:             yield message;
74:         }
75:     }
76: }
````

## File: src/core/runtime/index.ts
````typescript
1: export { RUNTIME } from "./runtime.js";
````

## File: src/core/runtime/runtime.ts
````typescript
  1: interface DenoGlobal {
  2:     version: {
  3:         deno: string;
  4:     };
  5: }
  6: 
  7: interface BunGlobal {
  8:     version: string;
  9: }
 10: 
 11: declare const Deno: DenoGlobal | undefined;
 12: declare const Bun: BunGlobal | undefined;
 13: declare const EdgeRuntime: string | undefined;
 14: declare const self: typeof globalThis.self & {
 15:     importScripts?: unknown;
 16: };
 17: 
 18: /**
 19:  * A constant that indicates which environment and version the SDK is running in.
 20:  */
 21: export const RUNTIME: Runtime = evaluateRuntime();
 22: 
 23: export interface Runtime {
 24:     type: "browser" | "web-worker" | "deno" | "bun" | "node" | "react-native" | "unknown" | "workerd" | "edge-runtime";
 25:     version?: string;
 26:     parsedVersion?: number;
 27: }
 28: 
 29: function evaluateRuntime(): Runtime {
 30:     /**
 31:      * A constant that indicates whether the environment the code is running is a Web Browser.
 32:      */
 33:     const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
 34:     if (isBrowser) {
 35:         return {
 36:             type: "browser",
 37:             version: window.navigator.userAgent,
 38:         };
 39:     }
 40: 
 41:     /**
 42:      * A constant that indicates whether the environment the code is running is Cloudflare.
 43:      * https://developers.cloudflare.com/workers/runtime-apis/web-standards/#navigatoruseragent
 44:      */
 45:     const isCloudflare = typeof globalThis !== "undefined" && globalThis?.navigator?.userAgent === "Cloudflare-Workers";
 46:     if (isCloudflare) {
 47:         return {
 48:             type: "workerd",
 49:         };
 50:     }
 51: 
 52:     /**
 53:      * A constant that indicates whether the environment the code is running is Edge Runtime.
 54:      * https://vercel.com/docs/functions/runtimes/edge-runtime#check-if-you're-running-on-the-edge-runtime
 55:      */
 56:     const isEdgeRuntime = typeof EdgeRuntime === "string";
 57:     if (isEdgeRuntime) {
 58:         return {
 59:             type: "edge-runtime",
 60:         };
 61:     }
 62: 
 63:     /**
 64:      * A constant that indicates whether the environment the code is running is a Web Worker.
 65:      */
 66:     const isWebWorker =
 67:         typeof self === "object" &&
 68:         typeof self?.importScripts === "function" &&
 69:         (self.constructor?.name === "DedicatedWorkerGlobalScope" ||
 70:             self.constructor?.name === "ServiceWorkerGlobalScope" ||
 71:             self.constructor?.name === "SharedWorkerGlobalScope");
 72:     if (isWebWorker) {
 73:         return {
 74:             type: "web-worker",
 75:         };
 76:     }
 77: 
 78:     /**
 79:      * A constant that indicates whether the environment the code is running is Deno.
 80:      * FYI Deno spoofs process.versions.node, see https://deno.land/std@0.177.0/node/process.ts?s=versions
 81:      */
 82:     const isDeno =
 83:         typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
 84:     if (isDeno) {
 85:         return {
 86:             type: "deno",
 87:             version: Deno.version.deno,
 88:         };
 89:     }
 90: 
 91:     /**
 92:      * A constant that indicates whether the environment the code is running is Bun.sh.
 93:      */
 94:     const isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
 95:     if (isBun) {
 96:         return {
 97:             type: "bun",
 98:             version: Bun.version,
 99:         };
100:     }
101: 
102:     /**
103:      * A constant that indicates whether the environment the code is running is in React-Native.
104:      * This check should come before Node.js detection since React Native may have a process polyfill.
105:      * https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js
106:      */
107:     const isReactNative = typeof navigator !== "undefined" && navigator?.product === "ReactNative";
108:     if (isReactNative) {
109:         return {
110:             type: "react-native",
111:         };
112:     }
113: 
114:     /**
115:      * A constant that indicates whether the environment the code is running is Node.JS.
116:      */
117:     const isNode =
118:         typeof process !== "undefined" &&
119:         "version" in process &&
120:         !!process.version &&
121:         "versions" in process &&
122:         !!process.versions?.node;
123:     if (isNode) {
124:         return {
125:             type: "node",
126:             version: process.versions.node,
127:             parsedVersion: Number(process.versions.node.split(".")[0]),
128:         };
129:     }
130: 
131:     return {
132:         type: "unknown",
133:     };
134: }
````

## File: src/core/schemas/builders/bigint/bigint.ts
````typescript
 1: import { type BaseSchema, type Schema, SchemaType } from "../../Schema.js";
 2: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
 3: import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
 4: import { getSchemaUtils } from "../schema-utils/index.js";
 5: 
 6: export function bigint(): Schema<bigint | number, bigint> {
 7:     const baseSchema: BaseSchema<bigint | number, bigint> = {
 8:         parse: (raw, { breadcrumbsPrefix = [] } = {}) => {
 9:             if (typeof raw === "bigint") {
10:                 return {
11:                     ok: true,
12:                     value: raw,
13:                 };
14:             }
15:             if (typeof raw === "number") {
16:                 return {
17:                     ok: true,
18:                     value: BigInt(raw),
19:                 };
20:             }
21:             return {
22:                 ok: false,
23:                 errors: [
24:                     {
25:                         path: breadcrumbsPrefix,
26:                         message: getErrorMessageForIncorrectType(raw, "bigint | number"),
27:                     },
28:                 ],
29:             };
30:         },
31:         json: (bigint, { breadcrumbsPrefix = [] } = {}) => {
32:             if (typeof bigint !== "bigint") {
33:                 return {
34:                     ok: false,
35:                     errors: [
36:                         {
37:                             path: breadcrumbsPrefix,
38:                             message: getErrorMessageForIncorrectType(bigint, "bigint"),
39:                         },
40:                     ],
41:                 };
42:             }
43:             return {
44:                 ok: true,
45:                 value: bigint,
46:             };
47:         },
48:         getType: () => SchemaType.BIGINT,
49:     };
50: 
51:     return {
52:         ...maybeSkipValidation(baseSchema),
53:         ...getSchemaUtils(baseSchema),
54:     };
55: }
````

## File: src/core/schemas/builders/bigint/index.ts
````typescript
1: export { bigint } from "./bigint.js";
````

## File: src/core/schemas/builders/date/date.ts
````typescript
 1: import { type BaseSchema, type Schema, SchemaType } from "../../Schema.js";
 2: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
 3: import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
 4: import { getSchemaUtils } from "../schema-utils/index.js";
 5: 
 6: // https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime
 7: const ISO_8601_REGEX =
 8:     /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
 9: 
10: export function date(): Schema<string, Date> {
11:     const baseSchema: BaseSchema<string, Date> = {
12:         parse: (raw, { breadcrumbsPrefix = [] } = {}) => {
13:             if (typeof raw !== "string") {
14:                 return {
15:                     ok: false,
16:                     errors: [
17:                         {
18:                             path: breadcrumbsPrefix,
19:                             message: getErrorMessageForIncorrectType(raw, "string"),
20:                         },
21:                     ],
22:                 };
23:             }
24:             if (!ISO_8601_REGEX.test(raw)) {
25:                 return {
26:                     ok: false,
27:                     errors: [
28:                         {
29:                             path: breadcrumbsPrefix,
30:                             message: getErrorMessageForIncorrectType(raw, "ISO 8601 date string"),
31:                         },
32:                     ],
33:                 };
34:             }
35:             return {
36:                 ok: true,
37:                 value: new Date(raw),
38:             };
39:         },
40:         json: (date, { breadcrumbsPrefix = [] } = {}) => {
41:             if (date instanceof Date) {
42:                 return {
43:                     ok: true,
44:                     value: date.toISOString(),
45:                 };
46:             } else {
47:                 return {
48:                     ok: false,
49:                     errors: [
50:                         {
51:                             path: breadcrumbsPrefix,
52:                             message: getErrorMessageForIncorrectType(date, "Date object"),
53:                         },
54:                     ],
55:                 };
56:             }
57:         },
58:         getType: () => SchemaType.DATE,
59:     };
60: 
61:     return {
62:         ...maybeSkipValidation(baseSchema),
63:         ...getSchemaUtils(baseSchema),
64:     };
65: }
````

## File: src/core/schemas/builders/date/index.ts
````typescript
1: export { date } from "./date.js";
````

## File: src/core/schemas/builders/enum/enum.ts
````typescript
 1: import { type Schema, SchemaType } from "../../Schema.js";
 2: import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
 3: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
 4: 
 5: export function enum_<U extends string, E extends U[]>(values: E): Schema<E[number], E[number]> {
 6:     const validValues = new Set<string>(values);
 7: 
 8:     const schemaCreator = createIdentitySchemaCreator(
 9:         SchemaType.ENUM,
10:         (value, { allowUnrecognizedEnumValues, breadcrumbsPrefix = [] } = {}) => {
11:             if (typeof value !== "string") {
12:                 return {
13:                     ok: false,
14:                     errors: [
15:                         {
16:                             path: breadcrumbsPrefix,
17:                             message: getErrorMessageForIncorrectType(value, "string"),
18:                         },
19:                     ],
20:                 };
21:             }
22: 
23:             if (!validValues.has(value) && !allowUnrecognizedEnumValues) {
24:                 return {
25:                     ok: false,
26:                     errors: [
27:                         {
28:                             path: breadcrumbsPrefix,
29:                             message: getErrorMessageForIncorrectType(value, "enum"),
30:                         },
31:                     ],
32:                 };
33:             }
34: 
35:             return {
36:                 ok: true,
37:                 value: value as U,
38:             };
39:         },
40:     );
41: 
42:     return schemaCreator();
43: }
````

## File: src/core/schemas/builders/enum/index.ts
````typescript
1: export { enum_ } from "./enum.js";
````

## File: src/core/schemas/builders/lazy/index.ts
````typescript
1: export type { SchemaGetter } from "./lazy.js";
2: export { lazy } from "./lazy.js";
3: export { lazyObject } from "./lazyObject.js";
````

## File: src/core/schemas/builders/lazy/lazy.ts
````typescript
 1: import type { BaseSchema, Schema } from "../../Schema.js";
 2: import { getSchemaUtils } from "../schema-utils/index.js";
 3: 
 4: export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType;
 5: 
 6: export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
 7:     const baseSchema = constructLazyBaseSchema(getter);
 8:     return {
 9:         ...baseSchema,
10:         ...getSchemaUtils(baseSchema),
11:     };
12: }
13: 
14: export function constructLazyBaseSchema<Raw, Parsed>(
15:     getter: SchemaGetter<Schema<Raw, Parsed>>,
16: ): BaseSchema<Raw, Parsed> {
17:     return {
18:         parse: (raw, opts) => getMemoizedSchema(getter).parse(raw, opts),
19:         json: (parsed, opts) => getMemoizedSchema(getter).json(parsed, opts),
20:         getType: () => getMemoizedSchema(getter).getType(),
21:     };
22: }
23: 
24: type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };
25: 
26: export function getMemoizedSchema<SchemaType extends Schema<any, any>>(getter: SchemaGetter<SchemaType>): SchemaType {
27:     const castedGetter = getter as MemoizedGetter<SchemaType>;
28:     if (castedGetter.__zurg_memoized == null) {
29:         castedGetter.__zurg_memoized = getter();
30:     }
31:     return castedGetter.__zurg_memoized;
32: }
````

## File: src/core/schemas/builders/lazy/lazyObject.ts
````typescript
 1: import { getObjectUtils } from "../object/index.js";
 2: import type { BaseObjectSchema, ObjectSchema } from "../object/types.js";
 3: import { getObjectLikeUtils } from "../object-like/index.js";
 4: import { getSchemaUtils } from "../schema-utils/index.js";
 5: import { constructLazyBaseSchema, getMemoizedSchema, type SchemaGetter } from "./lazy.js";
 6: 
 7: export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
 8:     const baseSchema: BaseObjectSchema<Raw, Parsed> = {
 9:         ...constructLazyBaseSchema(getter),
10:         _getRawProperties: () => getMemoizedSchema(getter)._getRawProperties(),
11:         _getParsedProperties: () => getMemoizedSchema(getter)._getParsedProperties(),
12:     };
13: 
14:     return {
15:         ...baseSchema,
16:         ...getSchemaUtils(baseSchema),
17:         ...getObjectLikeUtils(baseSchema),
18:         ...getObjectUtils(baseSchema),
19:     };
20: }
````

## File: src/core/schemas/builders/list/index.ts
````typescript
1: export { list } from "./list.js";
````

## File: src/core/schemas/builders/list/list.ts
````typescript
 1: import { type BaseSchema, type MaybeValid, type Schema, SchemaType, type ValidationError } from "../../Schema.js";
 2: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
 3: import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
 4: import { getSchemaUtils } from "../schema-utils/index.js";
 5: 
 6: export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
 7:     const baseSchema: BaseSchema<Raw[], Parsed[]> = {
 8:         parse: (raw, opts) =>
 9:             validateAndTransformArray(raw, (item, index) =>
10:                 schema.parse(item, {
11:                     ...opts,
12:                     breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `[${index}]`],
13:                 }),
14:             ),
15:         json: (parsed, opts) =>
16:             validateAndTransformArray(parsed, (item, index) =>
17:                 schema.json(item, {
18:                     ...opts,
19:                     breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `[${index}]`],
20:                 }),
21:             ),
22:         getType: () => SchemaType.LIST,
23:     };
24: 
25:     return {
26:         ...maybeSkipValidation(baseSchema),
27:         ...getSchemaUtils(baseSchema),
28:     };
29: }
30: 
31: function validateAndTransformArray<Raw, Parsed>(
32:     value: unknown,
33:     transformItem: (item: Raw, index: number) => MaybeValid<Parsed>,
34: ): MaybeValid<Parsed[]> {
35:     if (!Array.isArray(value)) {
36:         return {
37:             ok: false,
38:             errors: [
39:                 {
40:                     message: getErrorMessageForIncorrectType(value, "list"),
41:                     path: [],
42:                 },
43:             ],
44:         };
45:     }
46: 
47:     const maybeValidItems = value.map((item, index) => transformItem(item, index));
48: 
49:     return maybeValidItems.reduce<MaybeValid<Parsed[]>>(
50:         (acc, item) => {
51:             if (acc.ok && item.ok) {
52:                 return {
53:                     ok: true,
54:                     value: [...acc.value, item.value],
55:                 };
56:             }
57: 
58:             const errors: ValidationError[] = [];
59:             if (!acc.ok) {
60:                 errors.push(...acc.errors);
61:             }
62:             if (!item.ok) {
63:                 errors.push(...item.errors);
64:             }
65: 
66:             return {
67:                 ok: false,
68:                 errors,
69:             };
70:         },
71:         { ok: true, value: [] },
72:     );
73: }
````

## File: src/core/schemas/builders/literals/booleanLiteral.ts
````typescript
 1: import { type Schema, SchemaType } from "../../Schema.js";
 2: import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
 3: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
 4: 
 5: export function booleanLiteral<V extends boolean>(literal: V): Schema<V, V> {
 6:     const schemaCreator = createIdentitySchemaCreator(
 7:         SchemaType.BOOLEAN_LITERAL,
 8:         (value, { breadcrumbsPrefix = [] } = {}) => {
 9:             if (value === literal) {
10:                 return {
11:                     ok: true,
12:                     value: literal,
13:                 };
14:             } else {
15:                 return {
16:                     ok: false,
17:                     errors: [
18:                         {
19:                             path: breadcrumbsPrefix,
20:                             message: getErrorMessageForIncorrectType(value, `${literal.toString()}`),
21:                         },
22:                     ],
23:                 };
24:             }
25:         },
26:     );
27: 
28:     return schemaCreator();
29: }
````

## File: src/core/schemas/builders/literals/index.ts
````typescript
1: export { booleanLiteral } from "./booleanLiteral.js";
2: export { stringLiteral } from "./stringLiteral.js";
````

## File: src/core/schemas/builders/literals/stringLiteral.ts
````typescript
 1: import { type Schema, SchemaType } from "../../Schema.js";
 2: import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
 3: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
 4: 
 5: export function stringLiteral<V extends string>(literal: V): Schema<V, V> {
 6:     const schemaCreator = createIdentitySchemaCreator(
 7:         SchemaType.STRING_LITERAL,
 8:         (value, { breadcrumbsPrefix = [] } = {}) => {
 9:             if (value === literal) {
10:                 return {
11:                     ok: true,
12:                     value: literal,
13:                 };
14:             } else {
15:                 return {
16:                     ok: false,
17:                     errors: [
18:                         {
19:                             path: breadcrumbsPrefix,
20:                             message: getErrorMessageForIncorrectType(value, `"${literal}"`),
21:                         },
22:                     ],
23:                 };
24:             }
25:         },
26:     );
27: 
28:     return schemaCreator();
29: }
````

## File: src/core/schemas/builders/object/index.ts
````typescript
 1: export { getObjectUtils, object } from "./object.js";
 2: export type {
 3:     inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas,
 4:     inferParsedObjectWithoutOptionalPropertiesFromPropertySchemas,
 5: } from "./objectWithoutOptionalProperties.js";
 6: export { objectWithoutOptionalProperties } from "./objectWithoutOptionalProperties.js";
 7: export type { Property } from "./property.js";
 8: export { isProperty, property } from "./property.js";
 9: export type {
10:     BaseObjectSchema,
11:     inferObjectSchemaFromPropertySchemas,
12:     inferParsedObject,
13:     inferParsedObjectFromPropertySchemas,
14:     inferParsedPropertySchema,
15:     inferRawKey,
16:     inferRawObject,
17:     inferRawObjectFromPropertySchemas,
18:     inferRawPropertySchema,
19:     ObjectSchema,
20:     ObjectUtils,
21:     PropertySchemas,
22: } from "./types.js";
````

## File: src/core/schemas/builders/object/object.ts
````typescript
  1: import { type MaybeValid, type Schema, SchemaType, type ValidationError } from "../../Schema.js";
  2: import { entries } from "../../utils/entries.js";
  3: import { filterObject } from "../../utils/filterObject.js";
  4: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
  5: import { isPlainObject } from "../../utils/isPlainObject.js";
  6: import { keys } from "../../utils/keys.js";
  7: import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
  8: import { partition } from "../../utils/partition.js";
  9: import { getObjectLikeUtils } from "../object-like/index.js";
 10: import { getSchemaUtils } from "../schema-utils/index.js";
 11: import { isProperty } from "./property.js";
 12: import type {
 13:     BaseObjectSchema,
 14:     inferObjectSchemaFromPropertySchemas,
 15:     inferParsedObjectFromPropertySchemas,
 16:     inferRawObjectFromPropertySchemas,
 17:     ObjectSchema,
 18:     ObjectUtils,
 19:     PropertySchemas,
 20: } from "./types.js";
 21: 
 22: interface ObjectPropertyWithRawKey {
 23:     rawKey: string;
 24:     parsedKey: string;
 25:     valueSchema: Schema<any, any>;
 26: }
 27: 
 28: export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
 29:     schemas: T,
 30: ): inferObjectSchemaFromPropertySchemas<T> {
 31:     const baseSchema: BaseObjectSchema<
 32:         inferRawObjectFromPropertySchemas<T>,
 33:         inferParsedObjectFromPropertySchemas<T>
 34:     > = {
 35:         _getRawProperties: () =>
 36:             Object.entries(schemas).map(([parsedKey, propertySchema]) =>
 37:                 isProperty(propertySchema) ? propertySchema.rawKey : parsedKey,
 38:             ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[],
 39:         _getParsedProperties: () => keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[],
 40: 
 41:         parse: (raw, opts) => {
 42:             const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};
 43:             const requiredKeys: string[] = [];
 44: 
 45:             for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
 46:                 const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
 47:                 const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)
 48:                     ? schemaOrObjectProperty.valueSchema
 49:                     : schemaOrObjectProperty;
 50: 
 51:                 const property: ObjectPropertyWithRawKey = {
 52:                     rawKey,
 53:                     parsedKey: parsedKey as string,
 54:                     valueSchema,
 55:                 };
 56: 
 57:                 rawKeyToProperty[rawKey] = property;
 58: 
 59:                 if (isSchemaRequired(valueSchema)) {
 60:                     requiredKeys.push(rawKey);
 61:                 }
 62:             }
 63: 
 64:             return validateAndTransformObject({
 65:                 value: raw,
 66:                 requiredKeys,
 67:                 getProperty: (rawKey) => {
 68:                     const property = rawKeyToProperty[rawKey];
 69:                     if (property == null) {
 70:                         return undefined;
 71:                     }
 72:                     return {
 73:                         transformedKey: property.parsedKey,
 74:                         transform: (propertyValue) =>
 75:                             property.valueSchema.parse(propertyValue, {
 76:                                 ...opts,
 77:                                 breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), rawKey],
 78:                             }),
 79:                     };
 80:                 },
 81:                 unrecognizedObjectKeys: opts?.unrecognizedObjectKeys,
 82:                 skipValidation: opts?.skipValidation,
 83:                 breadcrumbsPrefix: opts?.breadcrumbsPrefix,
 84:                 omitUndefined: opts?.omitUndefined,
 85:             });
 86:         },
 87: 
 88:         json: (parsed, opts) => {
 89:             const requiredKeys: string[] = [];
 90: 
 91:             for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
 92:                 const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)
 93:                     ? schemaOrObjectProperty.valueSchema
 94:                     : schemaOrObjectProperty;
 95: 
 96:                 if (isSchemaRequired(valueSchema)) {
 97:                     requiredKeys.push(parsedKey as string);
 98:                 }
 99:             }
100: 
101:             return validateAndTransformObject({
102:                 value: parsed,
103:                 requiredKeys,
104:                 getProperty: (
105:                     parsedKey,
106:                 ): { transformedKey: string; transform: (propertyValue: object) => MaybeValid<any> } | undefined => {
107:                     const property = schemas[parsedKey as keyof T];
108: 
109:                     // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
110:                     if (property == null) {
111:                         return undefined;
112:                     }
113: 
114:                     if (isProperty(property)) {
115:                         return {
116:                             transformedKey: property.rawKey,
117:                             transform: (propertyValue) =>
118:                                 property.valueSchema.json(propertyValue, {
119:                                     ...opts,
120:                                     breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), parsedKey],
121:                                 }),
122:                         };
123:                     } else {
124:                         return {
125:                             transformedKey: parsedKey,
126:                             transform: (propertyValue) =>
127:                                 property.json(propertyValue, {
128:                                     ...opts,
129:                                     breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), parsedKey],
130:                                 }),
131:                         };
132:                     }
133:                 },
134:                 unrecognizedObjectKeys: opts?.unrecognizedObjectKeys,
135:                 skipValidation: opts?.skipValidation,
136:                 breadcrumbsPrefix: opts?.breadcrumbsPrefix,
137:                 omitUndefined: opts?.omitUndefined,
138:             });
139:         },
140: 
141:         getType: () => SchemaType.OBJECT,
142:     };
143: 
144:     return {
145:         ...maybeSkipValidation(baseSchema),
146:         ...getSchemaUtils(baseSchema),
147:         ...getObjectLikeUtils(baseSchema),
148:         ...getObjectUtils(baseSchema),
149:     };
150: }
151: 
152: function validateAndTransformObject<Transformed>({
153:     value,
154:     requiredKeys,
155:     getProperty,
156:     unrecognizedObjectKeys = "fail",
157:     skipValidation = false,
158:     breadcrumbsPrefix = [],
159: }: {
160:     value: unknown;
161:     requiredKeys: string[];
162:     getProperty: (
163:         preTransformedKey: string,
164:     ) => { transformedKey: string; transform: (propertyValue: object) => MaybeValid<any> } | undefined;
165:     unrecognizedObjectKeys: "fail" | "passthrough" | "strip" | undefined;
166:     skipValidation: boolean | undefined;
167:     breadcrumbsPrefix: string[] | undefined;
168:     omitUndefined: boolean | undefined;
169: }): MaybeValid<Transformed> {
170:     if (!isPlainObject(value)) {
171:         return {
172:             ok: false,
173:             errors: [
174:                 {
175:                     path: breadcrumbsPrefix,
176:                     message: getErrorMessageForIncorrectType(value, "object"),
177:                 },
178:             ],
179:         };
180:     }
181: 
182:     const missingRequiredKeys = new Set(requiredKeys);
183:     const errors: ValidationError[] = [];
184:     const transformed: Record<string | number | symbol, any> = {};
185: 
186:     for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {
187:         const property = getProperty(preTransformedKey);
188: 
189:         if (property != null) {
190:             missingRequiredKeys.delete(preTransformedKey);
191: 
192:             const value = property.transform(preTransformedItemValue as object);
193:             if (value.ok) {
194:                 transformed[property.transformedKey] = value.value;
195:             } else {
196:                 transformed[preTransformedKey] = preTransformedItemValue;
197:                 errors.push(...value.errors);
198:             }
199:         } else {
200:             switch (unrecognizedObjectKeys) {
201:                 case "fail":
202:                     errors.push({
203:                         path: [...breadcrumbsPrefix, preTransformedKey],
204:                         message: `Unexpected key "${preTransformedKey}"`,
205:                     });
206:                     break;
207:                 case "strip":
208:                     break;
209:                 case "passthrough":
210:                     transformed[preTransformedKey] = preTransformedItemValue;
211:                     break;
212:             }
213:         }
214:     }
215: 
216:     errors.push(
217:         ...requiredKeys
218:             .filter((key) => missingRequiredKeys.has(key))
219:             .map((key) => ({
220:                 path: breadcrumbsPrefix,
221:                 message: `Missing required key "${key}"`,
222:             })),
223:     );
224: 
225:     if (errors.length === 0 || skipValidation) {
226:         return {
227:             ok: true,
228:             value: transformed as Transformed,
229:         };
230:     } else {
231:         return {
232:             ok: false,
233:             errors,
234:         };
235:     }
236: }
237: 
238: export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
239:     return {
240:         extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
241:             const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
242:                 _getParsedProperties: () => [...schema._getParsedProperties(), ...extension._getParsedProperties()],
243:                 _getRawProperties: () => [...schema._getRawProperties(), ...extension._getRawProperties()],
244:                 parse: (raw, opts) => {
245:                     return validateAndTransformExtendedObject({
246:                         extensionKeys: extension._getRawProperties(),
247:                         value: raw,
248:                         transformBase: (rawBase) => schema.parse(rawBase, opts),
249:                         transformExtension: (rawExtension) => extension.parse(rawExtension, opts),
250:                         breadcrumbsPrefix: opts?.breadcrumbsPrefix,
251:                     });
252:                 },
253:                 json: (parsed, opts) => {
254:                     return validateAndTransformExtendedObject({
255:                         extensionKeys: extension._getParsedProperties(),
256:                         value: parsed,
257:                         transformBase: (parsedBase) => schema.json(parsedBase, opts),
258:                         transformExtension: (parsedExtension) => extension.json(parsedExtension, opts),
259:                         breadcrumbsPrefix: opts?.breadcrumbsPrefix,
260:                     });
261:                 },
262:                 getType: () => SchemaType.OBJECT,
263:             };
264: 
265:             return {
266:                 ...baseSchema,
267:                 ...getSchemaUtils(baseSchema),
268:                 ...getObjectLikeUtils(baseSchema),
269:                 ...getObjectUtils(baseSchema),
270:             };
271:         },
272:         passthrough: () => {
273:             const baseSchema: BaseObjectSchema<Raw & { [key: string]: unknown }, Parsed & { [key: string]: unknown }> =
274:                 {
275:                     _getParsedProperties: () => schema._getParsedProperties(),
276:                     _getRawProperties: () => schema._getRawProperties(),
277:                     parse: (raw, opts) => {
278:                         const transformed = schema.parse(raw, { ...opts, unrecognizedObjectKeys: "passthrough" });
279:                         if (!transformed.ok) {
280:                             return transformed;
281:                         }
282:                         return {
283:                             ok: true,
284:                             value: {
285:                                 ...(raw as any),
286:                                 ...transformed.value,
287:                             },
288:                         };
289:                     },
290:                     json: (parsed, opts) => {
291:                         const transformed = schema.json(parsed, { ...opts, unrecognizedObjectKeys: "passthrough" });
292:                         if (!transformed.ok) {
293:                             return transformed;
294:                         }
295:                         return {
296:                             ok: true,
297:                             value: {
298:                                 ...(parsed as any),
299:                                 ...transformed.value,
300:                             },
301:                         };
302:                     },
303:                     getType: () => SchemaType.OBJECT,
304:                 };
305: 
306:             return {
307:                 ...baseSchema,
308:                 ...getSchemaUtils(baseSchema),
309:                 ...getObjectLikeUtils(baseSchema),
310:                 ...getObjectUtils(baseSchema),
311:             };
312:         },
313:     };
314: }
315: 
316: function validateAndTransformExtendedObject<PreTransformedExtension, TransformedBase, TransformedExtension>({
317:     extensionKeys,
318:     value,
319:     transformBase,
320:     transformExtension,
321:     breadcrumbsPrefix = [],
322: }: {
323:     extensionKeys: (keyof PreTransformedExtension)[];
324:     value: unknown;
325:     transformBase: (value: object) => MaybeValid<TransformedBase>;
326:     transformExtension: (value: object) => MaybeValid<TransformedExtension>;
327:     breadcrumbsPrefix?: string[];
328: }): MaybeValid<TransformedBase & TransformedExtension> {
329:     if (!isPlainObject(value)) {
330:         return {
331:             ok: false,
332:             errors: [
333:                 {
334:                     path: breadcrumbsPrefix,
335:                     message: getErrorMessageForIncorrectType(value, "object"),
336:                 },
337:             ],
338:         };
339:     }
340: 
341:     const extensionPropertiesSet = new Set(extensionKeys);
342:     const [extensionProperties, baseProperties] = partition(keys(value), (key) =>
343:         extensionPropertiesSet.has(key as keyof PreTransformedExtension),
344:     );
345: 
346:     const transformedBase = transformBase(filterObject(value, baseProperties));
347:     const transformedExtension = transformExtension(filterObject(value, extensionProperties));
348: 
349:     if (transformedBase.ok && transformedExtension.ok) {
350:         return {
351:             ok: true,
352:             value: {
353:                 ...transformedBase.value,
354:                 ...transformedExtension.value,
355:             },
356:         };
357:     } else {
358:         return {
359:             ok: false,
360:             errors: [
361:                 ...(transformedBase.ok ? [] : transformedBase.errors),
362:                 ...(transformedExtension.ok ? [] : transformedExtension.errors),
363:             ],
364:         };
365:     }
366: }
367: 
368: function isSchemaRequired(schema: Schema<any, any>): boolean {
369:     return !isSchemaOptional(schema);
370: }
371: 
372: function isSchemaOptional(schema: Schema<any, any>): boolean {
373:     switch (schema.getType()) {
374:         case SchemaType.ANY:
375:         case SchemaType.UNKNOWN:
376:         case SchemaType.OPTIONAL:
377:         case SchemaType.OPTIONAL_NULLABLE:
378:             return true;
379:         default:
380:             return false;
381:     }
382: }
````

## File: src/core/schemas/builders/object/objectWithoutOptionalProperties.ts
````typescript
 1: import { object } from "./object.js";
 2: import type {
 3:     inferParsedPropertySchema,
 4:     inferRawObjectFromPropertySchemas,
 5:     ObjectSchema,
 6:     PropertySchemas,
 7: } from "./types.js";
 8: 
 9: export function objectWithoutOptionalProperties<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
10:     schemas: T,
11: ): inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas<T> {
12:     return object(schemas) as unknown as inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas<T>;
13: }
14: 
15: export type inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> =
16:     ObjectSchema<
17:         inferRawObjectFromPropertySchemas<T>,
18:         inferParsedObjectWithoutOptionalPropertiesFromPropertySchemas<T>
19:     >;
20: 
21: export type inferParsedObjectWithoutOptionalPropertiesFromPropertySchemas<T extends PropertySchemas<keyof T>> = {
22:     [K in keyof T]: inferParsedPropertySchema<T[K]>;
23: };
````

## File: src/core/schemas/builders/object/property.ts
````typescript
 1: import type { Schema } from "../../Schema.js";
 2: 
 3: export function property<RawKey extends string, RawValue, ParsedValue>(
 4:     rawKey: RawKey,
 5:     valueSchema: Schema<RawValue, ParsedValue>,
 6: ): Property<RawKey, RawValue, ParsedValue> {
 7:     return {
 8:         rawKey,
 9:         valueSchema,
10:         isProperty: true,
11:     };
12: }
13: 
14: export interface Property<RawKey extends string, RawValue, ParsedValue> {
15:     rawKey: RawKey;
16:     valueSchema: Schema<RawValue, ParsedValue>;
17:     isProperty: true;
18: }
19: 
20: export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
21:     // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
22:     return (maybeProperty as O).isProperty;
23: }
````

## File: src/core/schemas/builders/object/types.ts
````typescript
 1: import type { BaseSchema, inferParsed, inferRaw, Schema } from "../../Schema.js";
 2: import type { addQuestionMarksToNullableProperties } from "../../utils/addQuestionMarksToNullableProperties.js";
 3: import type { ObjectLikeUtils } from "../object-like/index.js";
 4: import type { SchemaUtils } from "../schema-utils/index.js";
 5: import type { Property } from "./property.js";
 6: 
 7: export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
 8:     ObjectLikeUtils<Raw, Parsed> &
 9:     ObjectUtils<Raw, Parsed> &
10:     SchemaUtils<Raw, Parsed>;
11: 
12: export interface BaseObjectSchema<Raw, Parsed> extends BaseSchema<Raw, Parsed> {
13:     _getRawProperties: () => (keyof Raw)[];
14:     _getParsedProperties: () => (keyof Parsed)[];
15: }
16: 
17: export interface ObjectUtils<Raw, Parsed> {
18:     extend: <RawExtension, ParsedExtension>(
19:         schemas: ObjectSchema<RawExtension, ParsedExtension>,
20:     ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
21:     passthrough: () => ObjectSchema<Raw & { [key: string]: unknown }, Parsed & { [key: string]: unknown }>;
22: }
23: 
24: export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;
25: 
26: export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
27:     ? Parsed
28:     : never;
29: 
30: export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
31:     inferRawObjectFromPropertySchemas<T>,
32:     inferParsedObjectFromPropertySchemas<T>
33: >;
34: 
35: export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
36:     addQuestionMarksToNullableProperties<{
37:         [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
38:     }>;
39: 
40: export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
41:     addQuestionMarksToNullableProperties<{
42:         [K in keyof T]: inferParsedPropertySchema<T[K]>;
43:     }>;
44: 
45: export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
46:     ParsedKeys,
47:     Property<any, any, any> | Schema<any, any>
48: >;
49: 
50: export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
51:     any,
52:     infer Raw,
53:     any
54: >
55:     ? Raw
56:     : P extends Schema<any, any>
57:       ? inferRaw<P>
58:       : never;
59: 
60: export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
61:     any,
62:     any,
63:     infer Parsed
64: >
65:     ? Parsed
66:     : P extends Schema<any, any>
67:       ? inferParsed<P>
68:       : never;
69: 
70: export type inferRawKey<
71:     ParsedKey extends string | number | symbol,
72:     P extends Property<any, any, any> | Schema<any, any>,
73: > = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
````

## File: src/core/schemas/builders/object-like/getObjectLikeUtils.ts
````typescript
 1: import type { BaseSchema } from "../../Schema.js";
 2: import { filterObject } from "../../utils/filterObject.js";
 3: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
 4: import { isPlainObject } from "../../utils/isPlainObject.js";
 5: import { getSchemaUtils } from "../schema-utils/index.js";
 6: import type { ObjectLikeSchema, ObjectLikeUtils } from "./types.js";
 7: 
 8: export function getObjectLikeUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): ObjectLikeUtils<Raw, Parsed> {
 9:     return {
10:         withParsedProperties: (properties) => withParsedProperties(schema, properties),
11:     };
12: }
13: 
14: /**
15:  * object-like utils are defined in one file to resolve issues with circular imports
16:  */
17: 
18: export function withParsedProperties<RawObjectShape, ParsedObjectShape, Properties>(
19:     objectLike: BaseSchema<RawObjectShape, ParsedObjectShape>,
20:     properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) },
21: ): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
22:     const objectSchema: BaseSchema<RawObjectShape, ParsedObjectShape & Properties> = {
23:         parse: (raw, opts) => {
24:             const parsedObject = objectLike.parse(raw, opts);
25:             if (!parsedObject.ok) {
26:                 return parsedObject;
27:             }
28: 
29:             const additionalProperties = Object.entries(properties).reduce<Record<string, any>>(
30:                 (processed, [key, value]) => {
31:                     return {
32:                         ...processed,
33:                         [key]: typeof value === "function" ? value(parsedObject.value) : value,
34:                     };
35:                 },
36:                 {},
37:             );
38: 
39:             return {
40:                 ok: true,
41:                 value: {
42:                     ...parsedObject.value,
43:                     ...(additionalProperties as Properties),
44:                 },
45:             };
46:         },
47: 
48:         json: (parsed, opts) => {
49:             if (!isPlainObject(parsed)) {
50:                 return {
51:                     ok: false,
52:                     errors: [
53:                         {
54:                             path: opts?.breadcrumbsPrefix ?? [],
55:                             message: getErrorMessageForIncorrectType(parsed, "object"),
56:                         },
57:                     ],
58:                 };
59:             }
60: 
61:             // strip out added properties
62:             const addedPropertyKeys = new Set(Object.keys(properties));
63:             const parsedWithoutAddedProperties = filterObject(
64:                 parsed,
65:                 Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key)),
66:             );
67: 
68:             return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
69:         },
70: 
71:         getType: () => objectLike.getType(),
72:     };
73: 
74:     return {
75:         ...objectSchema,
76:         ...getSchemaUtils(objectSchema),
77:         ...getObjectLikeUtils(objectSchema),
78:     };
79: }
````

## File: src/core/schemas/builders/object-like/index.ts
````typescript
1: export { getObjectLikeUtils, withParsedProperties } from "./getObjectLikeUtils.js";
2: export type { ObjectLikeSchema, ObjectLikeUtils } from "./types.js";
````

## File: src/core/schemas/builders/object-like/types.ts
````typescript
 1: import type { BaseSchema, Schema } from "../../Schema.js";
 2: 
 3: export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
 4:     BaseSchema<Raw, Parsed> &
 5:     ObjectLikeUtils<Raw, Parsed>;
 6: 
 7: export interface ObjectLikeUtils<Raw, Parsed> {
 8:     withParsedProperties: <T extends Record<string, any>>(
 9:         properties: {
10:             [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
11:         },
12:     ) => ObjectLikeSchema<Raw, Parsed & T>;
13: }
````

## File: src/core/schemas/builders/primitives/any.ts
````typescript
1: import { type Schema, SchemaType } from "../../Schema.js";
2: import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
3: 
4: export const any: () => Schema<any, any> = createIdentitySchemaCreator<any>(SchemaType.ANY, (value) => ({
5:     ok: true,
6:     value,
7: }));
````

## File: src/core/schemas/builders/primitives/boolean.ts
````typescript
 1: import { type Schema, SchemaType } from "../../Schema.js";
 2: import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
 3: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
 4: 
 5: export const boolean: () => Schema<boolean, boolean> = createIdentitySchemaCreator<boolean>(
 6:     SchemaType.BOOLEAN,
 7:     (value, { breadcrumbsPrefix = [] } = {}) => {
 8:         if (typeof value === "boolean") {
 9:             return {
10:                 ok: true,
11:                 value,
12:             };
13:         } else {
14:             return {
15:                 ok: false,
16:                 errors: [
17:                     {
18:                         path: breadcrumbsPrefix,
19:                         message: getErrorMessageForIncorrectType(value, "boolean"),
20:                     },
21:                 ],
22:             };
23:         }
24:     },
25: );
````

## File: src/core/schemas/builders/primitives/index.ts
````typescript
1: export { any } from "./any.js";
2: export { boolean } from "./boolean.js";
3: export { never } from "./never.js";
4: export { number } from "./number.js";
5: export { string } from "./string.js";
6: export { unknown } from "./unknown.js";
````

## File: src/core/schemas/builders/primitives/never.ts
````typescript
 1: import { type Schema, SchemaType } from "../../Schema.js";
 2: import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
 3: 
 4: export const never: () => Schema<never, never> = createIdentitySchemaCreator<never>(
 5:     SchemaType.NEVER,
 6:     (_value, { breadcrumbsPrefix = [] } = {}) => ({
 7:         ok: false,
 8:         errors: [
 9:             {
10:                 path: breadcrumbsPrefix,
11:                 message: "Expected never",
12:             },
13:         ],
14:     }),
15: );
````

## File: src/core/schemas/builders/primitives/number.ts
````typescript
 1: import { type Schema, SchemaType } from "../../Schema.js";
 2: import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
 3: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
 4: 
 5: export const number: () => Schema<number, number> = createIdentitySchemaCreator<number>(
 6:     SchemaType.NUMBER,
 7:     (value, { breadcrumbsPrefix = [] } = {}) => {
 8:         if (typeof value === "number") {
 9:             return {
10:                 ok: true,
11:                 value,
12:             };
13:         } else {
14:             return {
15:                 ok: false,
16:                 errors: [
17:                     {
18:                         path: breadcrumbsPrefix,
19:                         message: getErrorMessageForIncorrectType(value, "number"),
20:                     },
21:                 ],
22:             };
23:         }
24:     },
25: );
````

## File: src/core/schemas/builders/primitives/string.ts
````typescript
 1: import { type Schema, SchemaType } from "../../Schema.js";
 2: import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
 3: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
 4: 
 5: export const string: () => Schema<string, string> = createIdentitySchemaCreator<string>(
 6:     SchemaType.STRING,
 7:     (value, { breadcrumbsPrefix = [] } = {}) => {
 8:         if (typeof value === "string") {
 9:             return {
10:                 ok: true,
11:                 value,
12:             };
13:         } else {
14:             return {
15:                 ok: false,
16:                 errors: [
17:                     {
18:                         path: breadcrumbsPrefix,
19:                         message: getErrorMessageForIncorrectType(value, "string"),
20:                     },
21:                 ],
22:             };
23:         }
24:     },
25: );
````

## File: src/core/schemas/builders/primitives/unknown.ts
````typescript
1: import { type Schema, SchemaType } from "../../Schema.js";
2: import { createIdentitySchemaCreator } from "../../utils/createIdentitySchemaCreator.js";
3: 
4: export const unknown: () => Schema<unknown, unknown> = createIdentitySchemaCreator<unknown>(
5:     SchemaType.UNKNOWN,
6:     (value) => ({ ok: true, value }),
7: );
````

## File: src/core/schemas/builders/record/index.ts
````typescript
1: export { record } from "./record.js";
2: export type { BaseRecordSchema, RecordSchema } from "./types.js";
````

## File: src/core/schemas/builders/record/record.ts
````typescript
  1: import { type MaybeValid, type Schema, SchemaType, type ValidationError } from "../../Schema.js";
  2: import { entries } from "../../utils/entries.js";
  3: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
  4: import { isPlainObject } from "../../utils/isPlainObject.js";
  5: import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
  6: import { getSchemaUtils } from "../schema-utils/index.js";
  7: import type { BaseRecordSchema, RecordSchema } from "./types.js";
  8: 
  9: export function record<RawKey extends string | number, RawValue, ParsedValue, ParsedKey extends string | number>(
 10:     keySchema: Schema<RawKey, ParsedKey>,
 11:     valueSchema: Schema<RawValue, ParsedValue>,
 12: ): RecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> {
 13:     const baseSchema: BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> = {
 14:         parse: (raw, opts) => {
 15:             return validateAndTransformRecord({
 16:                 value: raw,
 17:                 isKeyNumeric: keySchema.getType() === SchemaType.NUMBER,
 18:                 transformKey: (key) =>
 19:                     keySchema.parse(key, {
 20:                         ...opts,
 21:                         breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key} (key)`],
 22:                     }),
 23:                 transformValue: (value, key) =>
 24:                     valueSchema.parse(value, {
 25:                         ...opts,
 26:                         breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key}`],
 27:                     }),
 28:                 breadcrumbsPrefix: opts?.breadcrumbsPrefix,
 29:             });
 30:         },
 31:         json: (parsed, opts) => {
 32:             return validateAndTransformRecord({
 33:                 value: parsed,
 34:                 isKeyNumeric: keySchema.getType() === SchemaType.NUMBER,
 35:                 transformKey: (key) =>
 36:                     keySchema.json(key, {
 37:                         ...opts,
 38:                         breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key} (key)`],
 39:                     }),
 40:                 transformValue: (value, key) =>
 41:                     valueSchema.json(value, {
 42:                         ...opts,
 43:                         breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key}`],
 44:                     }),
 45:                 breadcrumbsPrefix: opts?.breadcrumbsPrefix,
 46:             });
 47:         },
 48:         getType: () => SchemaType.RECORD,
 49:     };
 50: 
 51:     return {
 52:         ...maybeSkipValidation(baseSchema),
 53:         ...getSchemaUtils(baseSchema),
 54:     };
 55: }
 56: 
 57: function validateAndTransformRecord<TransformedKey extends string | number, TransformedValue>({
 58:     value,
 59:     isKeyNumeric,
 60:     transformKey,
 61:     transformValue,
 62:     breadcrumbsPrefix = [],
 63: }: {
 64:     value: unknown;
 65:     isKeyNumeric: boolean;
 66:     transformKey: (key: string | number) => MaybeValid<TransformedKey>;
 67:     transformValue: (value: unknown, key: string | number) => MaybeValid<TransformedValue>;
 68:     breadcrumbsPrefix: string[] | undefined;
 69: }): MaybeValid<Record<TransformedKey, TransformedValue>> {
 70:     if (!isPlainObject(value)) {
 71:         return {
 72:             ok: false,
 73:             errors: [
 74:                 {
 75:                     path: breadcrumbsPrefix,
 76:                     message: getErrorMessageForIncorrectType(value, "object"),
 77:                 },
 78:             ],
 79:         };
 80:     }
 81: 
 82:     return entries(value).reduce<MaybeValid<Record<TransformedKey, TransformedValue>>>(
 83:         (accPromise, [stringKey, value]) => {
 84:             if (value === undefined) {
 85:                 return accPromise;
 86:             }
 87: 
 88:             const acc = accPromise;
 89: 
 90:             let key: string | number = stringKey;
 91:             if (isKeyNumeric) {
 92:                 const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
 93:                 if (!Number.isNaN(numberKey)) {
 94:                     key = numberKey;
 95:                 }
 96:             }
 97:             const transformedKey = transformKey(key);
 98: 
 99:             const transformedValue = transformValue(value, key);
100: 
101:             if (acc.ok && transformedKey.ok && transformedValue.ok) {
102:                 return {
103:                     ok: true,
104:                     value: {
105:                         ...acc.value,
106:                         [transformedKey.value]: transformedValue.value,
107:                     },
108:                 };
109:             }
110: 
111:             const errors: ValidationError[] = [];
112:             if (!acc.ok) {
113:                 errors.push(...acc.errors);
114:             }
115:             if (!transformedKey.ok) {
116:                 errors.push(...transformedKey.errors);
117:             }
118:             if (!transformedValue.ok) {
119:                 errors.push(...transformedValue.errors);
120:             }
121: 
122:             return {
123:                 ok: false,
124:                 errors,
125:             };
126:         },
127:         { ok: true, value: {} as Record<TransformedKey, TransformedValue> },
128:     );
129: }
````

## File: src/core/schemas/builders/record/types.ts
````typescript
 1: import type { BaseSchema } from "../../Schema.js";
 2: import type { SchemaUtils } from "../schema-utils/index.js";
 3: 
 4: export type RecordSchema<
 5:     RawKey extends string | number,
 6:     RawValue,
 7:     ParsedKey extends string | number,
 8:     ParsedValue,
 9: > = BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> &
10:     SchemaUtils<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>>;
11: 
12: export type BaseRecordSchema<
13:     RawKey extends string | number,
14:     RawValue,
15:     ParsedKey extends string | number,
16:     ParsedValue,
17: > = BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>>;
````

## File: src/core/schemas/builders/schema-utils/getSchemaUtils.ts
````typescript
  1: import { type BaseSchema, type Schema, type SchemaOptions, SchemaType } from "../../Schema.js";
  2: import { JsonError } from "./JsonError.js";
  3: import { ParseError } from "./ParseError.js";
  4: 
  5: export interface SchemaUtils<Raw, Parsed> {
  6:     nullable: () => Schema<Raw | null, Parsed | null>;
  7:     optional: () => Schema<Raw | null | undefined, Parsed | undefined>;
  8:     optionalNullable: () => Schema<Raw | null | undefined, Parsed | null | undefined>;
  9:     transform: <Transformed>(transformer: SchemaTransformer<Parsed, Transformed>) => Schema<Raw, Transformed>;
 10:     parseOrThrow: (raw: unknown, opts?: SchemaOptions) => Parsed;
 11:     jsonOrThrow: (raw: unknown, opts?: SchemaOptions) => Raw;
 12: }
 13: 
 14: export interface SchemaTransformer<Parsed, Transformed> {
 15:     transform: (parsed: Parsed) => Transformed;
 16:     untransform: (transformed: any) => Parsed;
 17: }
 18: 
 19: export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
 20:     return {
 21:         nullable: () => nullable(schema),
 22:         optional: () => optional(schema),
 23:         optionalNullable: () => optionalNullable(schema),
 24:         transform: (transformer) => transform(schema, transformer),
 25:         parseOrThrow: (raw, opts) => {
 26:             const parsed = schema.parse(raw, opts);
 27:             if (parsed.ok) {
 28:                 return parsed.value;
 29:             }
 30:             throw new ParseError(parsed.errors);
 31:         },
 32:         jsonOrThrow: (parsed, opts) => {
 33:             const raw = schema.json(parsed, opts);
 34:             if (raw.ok) {
 35:                 return raw.value;
 36:             }
 37:             throw new JsonError(raw.errors);
 38:         },
 39:     };
 40: }
 41: 
 42: /**
 43:  * schema utils are defined in one file to resolve issues with circular imports
 44:  */
 45: 
 46: export function nullable<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): Schema<Raw | null, Parsed | null> {
 47:     const baseSchema: BaseSchema<Raw | null, Parsed | null> = {
 48:         parse: (raw, opts) => {
 49:             if (raw == null) {
 50:                 return {
 51:                     ok: true,
 52:                     value: null,
 53:                 };
 54:             }
 55:             return schema.parse(raw, opts);
 56:         },
 57:         json: (parsed, opts) => {
 58:             if (parsed == null) {
 59:                 return {
 60:                     ok: true,
 61:                     value: null,
 62:                 };
 63:             }
 64:             return schema.json(parsed, opts);
 65:         },
 66:         getType: () => SchemaType.NULLABLE,
 67:     };
 68: 
 69:     return {
 70:         ...baseSchema,
 71:         ...getSchemaUtils(baseSchema),
 72:     };
 73: }
 74: 
 75: export function optional<Raw, Parsed>(
 76:     schema: BaseSchema<Raw, Parsed>,
 77: ): Schema<Raw | null | undefined, Parsed | undefined> {
 78:     const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
 79:         parse: (raw, opts) => {
 80:             if (raw == null) {
 81:                 return {
 82:                     ok: true,
 83:                     value: undefined,
 84:                 };
 85:             }
 86:             return schema.parse(raw, opts);
 87:         },
 88:         json: (parsed, opts) => {
 89:             if (opts?.omitUndefined && parsed === undefined) {
 90:                 return {
 91:                     ok: true,
 92:                     value: undefined,
 93:                 };
 94:             }
 95:             if (parsed == null) {
 96:                 return {
 97:                     ok: true,
 98:                     value: null,
 99:                 };
100:             }
101:             return schema.json(parsed, opts);
102:         },
103:         getType: () => SchemaType.OPTIONAL,
104:     };
105: 
106:     return {
107:         ...baseSchema,
108:         ...getSchemaUtils(baseSchema),
109:     };
110: }
111: 
112: export function optionalNullable<Raw, Parsed>(
113:     schema: BaseSchema<Raw, Parsed>,
114: ): Schema<Raw | null | undefined, Parsed | null | undefined> {
115:     const baseSchema: BaseSchema<Raw | null | undefined, Parsed | null | undefined> = {
116:         parse: (raw, opts) => {
117:             if (raw === undefined) {
118:                 return {
119:                     ok: true,
120:                     value: undefined,
121:                 };
122:             }
123:             if (raw === null) {
124:                 return {
125:                     ok: true,
126:                     value: null,
127:                 };
128:             }
129:             return schema.parse(raw, opts);
130:         },
131:         json: (parsed, opts) => {
132:             if (parsed === undefined) {
133:                 return {
134:                     ok: true,
135:                     value: undefined,
136:                 };
137:             }
138:             if (parsed === null) {
139:                 return {
140:                     ok: true,
141:                     value: null,
142:                 };
143:             }
144:             return schema.json(parsed, opts);
145:         },
146:         getType: () => SchemaType.OPTIONAL_NULLABLE,
147:     };
148: 
149:     return {
150:         ...baseSchema,
151:         ...getSchemaUtils(baseSchema),
152:     };
153: }
154: 
155: export function transform<Raw, Parsed, Transformed>(
156:     schema: BaseSchema<Raw, Parsed>,
157:     transformer: SchemaTransformer<Parsed, Transformed>,
158: ): Schema<Raw, Transformed> {
159:     const baseSchema: BaseSchema<Raw, Transformed> = {
160:         parse: (raw, opts) => {
161:             const parsed = schema.parse(raw, opts);
162:             if (!parsed.ok) {
163:                 return parsed;
164:             }
165:             return {
166:                 ok: true,
167:                 value: transformer.transform(parsed.value),
168:             };
169:         },
170:         json: (transformed, opts) => {
171:             const parsed = transformer.untransform(transformed);
172:             return schema.json(parsed, opts);
173:         },
174:         getType: () => schema.getType(),
175:     };
176: 
177:     return {
178:         ...baseSchema,
179:         ...getSchemaUtils(baseSchema),
180:     };
181: }
````

## File: src/core/schemas/builders/schema-utils/index.ts
````typescript
1: export type { SchemaUtils } from "./getSchemaUtils.js";
2: export { getSchemaUtils, optional, transform } from "./getSchemaUtils.js";
3: export { JsonError } from "./JsonError.js";
4: export { ParseError } from "./ParseError.js";
````

## File: src/core/schemas/builders/schema-utils/JsonError.ts
````typescript
1: import type { ValidationError } from "../../Schema.js";
2: import { stringifyValidationError } from "./stringifyValidationErrors.js";
3: 
4: export class JsonError extends Error {
5:     constructor(public readonly errors: ValidationError[]) {
6:         super(errors.map(stringifyValidationError).join("; "));
7:         Object.setPrototypeOf(this, JsonError.prototype);
8:     }
9: }
````

## File: src/core/schemas/builders/schema-utils/ParseError.ts
````typescript
1: import type { ValidationError } from "../../Schema.js";
2: import { stringifyValidationError } from "./stringifyValidationErrors.js";
3: 
4: export class ParseError extends Error {
5:     constructor(public readonly errors: ValidationError[]) {
6:         super(errors.map(stringifyValidationError).join("; "));
7:         Object.setPrototypeOf(this, ParseError.prototype);
8:     }
9: }
````

## File: src/core/schemas/builders/schema-utils/stringifyValidationErrors.ts
````typescript
1: import type { ValidationError } from "../../Schema.js";
2: 
3: export function stringifyValidationError(error: ValidationError): string {
4:     if (error.path.length === 0) {
5:         return error.message;
6:     }
7:     return `${error.path.join(" -> ")}: ${error.message}`;
8: }
````

## File: src/core/schemas/builders/set/index.ts
````typescript
1: export { set } from "./set.js";
````

## File: src/core/schemas/builders/set/set.ts
````typescript
 1: import { type BaseSchema, type Schema, SchemaType } from "../../Schema.js";
 2: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
 3: import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
 4: import { list } from "../list/index.js";
 5: import { getSchemaUtils } from "../schema-utils/index.js";
 6: 
 7: export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
 8:     const listSchema = list(schema);
 9:     const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
10:         parse: (raw, opts) => {
11:             const parsedList = listSchema.parse(raw, opts);
12:             if (parsedList.ok) {
13:                 return {
14:                     ok: true,
15:                     value: new Set(parsedList.value),
16:                 };
17:             } else {
18:                 return parsedList;
19:             }
20:         },
21:         json: (parsed, opts) => {
22:             if (!(parsed instanceof Set)) {
23:                 return {
24:                     ok: false,
25:                     errors: [
26:                         {
27:                             path: opts?.breadcrumbsPrefix ?? [],
28:                             message: getErrorMessageForIncorrectType(parsed, "Set"),
29:                         },
30:                     ],
31:                 };
32:             }
33:             const jsonList = listSchema.json([...parsed], opts);
34:             return jsonList;
35:         },
36:         getType: () => SchemaType.SET,
37:     };
38: 
39:     return {
40:         ...maybeSkipValidation(baseSchema),
41:         ...getSchemaUtils(baseSchema),
42:     };
43: }
````

## File: src/core/schemas/builders/undiscriminated-union/index.ts
````typescript
1: export type {
2:     inferParsedUnidiscriminatedUnionSchema,
3:     inferRawUnidiscriminatedUnionSchema,
4:     UndiscriminatedUnionSchema,
5: } from "./types.js";
6: export { undiscriminatedUnion } from "./undiscriminatedUnion.js";
````

## File: src/core/schemas/builders/undiscriminated-union/types.ts
````typescript
 1: import type { inferParsed, inferRaw, Schema } from "../../Schema.js";
 2: 
 3: export type UndiscriminatedUnionSchema<Schemas extends [...Schema[]]> = Schema<
 4:     inferRawUnidiscriminatedUnionSchema<Schemas>,
 5:     inferParsedUnidiscriminatedUnionSchema<Schemas>
 6: >;
 7: 
 8: export type inferRawUnidiscriminatedUnionSchema<Schemas extends [...Schema[]]> = inferRaw<Schemas[number]>;
 9: 
10: export type inferParsedUnidiscriminatedUnionSchema<Schemas extends [...Schema[]]> = inferParsed<Schemas[number]>;
````

## File: src/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.ts
````typescript
 1: import {
 2:     type BaseSchema,
 3:     type MaybeValid,
 4:     type Schema,
 5:     type SchemaOptions,
 6:     SchemaType,
 7:     type ValidationError,
 8: } from "../../Schema.js";
 9: import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
10: import { getSchemaUtils } from "../schema-utils/index.js";
11: import type { inferParsedUnidiscriminatedUnionSchema, inferRawUnidiscriminatedUnionSchema } from "./types.js";
12: 
13: export function undiscriminatedUnion<Schemas extends [Schema<any, any>, ...Schema<any, any>[]]>(
14:     schemas: Schemas,
15: ): Schema<inferRawUnidiscriminatedUnionSchema<Schemas>, inferParsedUnidiscriminatedUnionSchema<Schemas>> {
16:     const baseSchema: BaseSchema<
17:         inferRawUnidiscriminatedUnionSchema<Schemas>,
18:         inferParsedUnidiscriminatedUnionSchema<Schemas>
19:     > = {
20:         parse: (raw, opts) => {
21:             return validateAndTransformUndiscriminatedUnion<inferParsedUnidiscriminatedUnionSchema<Schemas>>(
22:                 (schema, opts) => schema.parse(raw, opts),
23:                 schemas,
24:                 opts,
25:             );
26:         },
27:         json: (parsed, opts) => {
28:             return validateAndTransformUndiscriminatedUnion<inferRawUnidiscriminatedUnionSchema<Schemas>>(
29:                 (schema, opts) => schema.json(parsed, opts),
30:                 schemas,
31:                 opts,
32:             );
33:         },
34:         getType: () => SchemaType.UNDISCRIMINATED_UNION,
35:     };
36: 
37:     return {
38:         ...maybeSkipValidation(baseSchema),
39:         ...getSchemaUtils(baseSchema),
40:     };
41: }
42: 
43: function validateAndTransformUndiscriminatedUnion<Transformed>(
44:     transform: (schema: Schema<any, any>, opts: SchemaOptions) => MaybeValid<Transformed>,
45:     schemas: Schema<any, any>[],
46:     opts: SchemaOptions | undefined,
47: ): MaybeValid<Transformed> {
48:     const errors: ValidationError[] = [];
49:     for (const [index, schema] of schemas.entries()) {
50:         const transformed = transform(schema, { ...opts, skipValidation: false });
51:         if (transformed.ok) {
52:             return transformed;
53:         } else {
54:             for (const error of transformed.errors) {
55:                 errors.push({
56:                     path: error.path,
57:                     message: `[Variant ${index}] ${error.message}`,
58:                 });
59:             }
60:         }
61:     }
62: 
63:     return {
64:         ok: false,
65:         errors,
66:     };
67: }
````

## File: src/core/schemas/builders/union/discriminant.ts
````typescript
 1: export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
 2:     parsedDiscriminant: ParsedDiscriminant,
 3:     rawDiscriminant: RawDiscriminant,
 4: ): Discriminant<RawDiscriminant, ParsedDiscriminant> {
 5:     return {
 6:         parsedDiscriminant,
 7:         rawDiscriminant,
 8:     };
 9: }
10: 
11: export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
12:     parsedDiscriminant: ParsedDiscriminant;
13:     rawDiscriminant: RawDiscriminant;
14: }
````

## File: src/core/schemas/builders/union/index.ts
````typescript
 1: export type { Discriminant } from "./discriminant.js";
 2: export { discriminant } from "./discriminant.js";
 3: export type {
 4:     inferParsedDiscriminant,
 5:     inferParsedUnion,
 6:     inferRawDiscriminant,
 7:     inferRawUnion,
 8:     UnionSubtypes,
 9: } from "./types.js";
10: export { union } from "./union.js";
````

## File: src/core/schemas/builders/union/types.ts
````typescript
 1: import type { inferParsedObject, inferRawObject, ObjectSchema } from "../object/index.js";
 2: import type { Discriminant } from "./discriminant.js";
 3: 
 4: export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
 5:     [K in DiscriminantValues]: ObjectSchema<any, any>;
 6: };
 7: 
 8: export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
 9:     [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
10: }[keyof U];
11: 
12: export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
13:     [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
14: }[keyof U];
15: 
16: export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
17:     ? D
18:     : D extends Discriminant<infer Raw, any>
19:       ? Raw
20:       : never;
21: 
22: export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
23:     ? D
24:     : D extends Discriminant<any, infer Parsed>
25:       ? Parsed
26:       : never;
````

## File: src/core/schemas/builders/union/union.ts
````typescript
  1: import { type BaseSchema, type MaybeValid, SchemaType } from "../../Schema.js";
  2: import { getErrorMessageForIncorrectType } from "../../utils/getErrorMessageForIncorrectType.js";
  3: import { isPlainObject } from "../../utils/isPlainObject.js";
  4: import { keys } from "../../utils/keys.js";
  5: import { maybeSkipValidation } from "../../utils/maybeSkipValidation.js";
  6: import { enum_ } from "../enum/index.js";
  7: import type { ObjectSchema } from "../object/index.js";
  8: import { getObjectLikeUtils, type ObjectLikeSchema } from "../object-like/index.js";
  9: import { getSchemaUtils } from "../schema-utils/index.js";
 10: import type { Discriminant } from "./discriminant.js";
 11: import type {
 12:     inferParsedDiscriminant,
 13:     inferParsedUnion,
 14:     inferRawDiscriminant,
 15:     inferRawUnion,
 16:     UnionSubtypes,
 17: } from "./types.js";
 18: 
 19: export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
 20:     discriminant: D,
 21:     union: U,
 22: ): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
 23:     const rawDiscriminant =
 24:         typeof discriminant === "string" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
 25:     const parsedDiscriminant =
 26:         typeof discriminant === "string"
 27:             ? discriminant
 28:             : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);
 29: 
 30:     const discriminantValueSchema = enum_(keys(union) as string[]);
 31: 
 32:     const baseSchema: BaseSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
 33:         parse: (raw, opts) => {
 34:             return transformAndValidateUnion({
 35:                 value: raw,
 36:                 discriminant: rawDiscriminant,
 37:                 transformedDiscriminant: parsedDiscriminant,
 38:                 transformDiscriminantValue: (discriminantValue) =>
 39:                     discriminantValueSchema.parse(discriminantValue, {
 40:                         allowUnrecognizedEnumValues: opts?.allowUnrecognizedUnionMembers,
 41:                         breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), rawDiscriminant],
 42:                     }),
 43:                 getAdditionalPropertiesSchema: (discriminantValue) => union[discriminantValue],
 44:                 allowUnrecognizedUnionMembers: opts?.allowUnrecognizedUnionMembers,
 45:                 transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema) =>
 46:                     additionalPropertiesSchema.parse(additionalProperties, opts),
 47:                 breadcrumbsPrefix: opts?.breadcrumbsPrefix,
 48:             });
 49:         },
 50:         json: (parsed, opts) => {
 51:             return transformAndValidateUnion({
 52:                 value: parsed,
 53:                 discriminant: parsedDiscriminant,
 54:                 transformedDiscriminant: rawDiscriminant,
 55:                 transformDiscriminantValue: (discriminantValue) =>
 56:                     discriminantValueSchema.json(discriminantValue, {
 57:                         allowUnrecognizedEnumValues: opts?.allowUnrecognizedUnionMembers,
 58:                         breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), parsedDiscriminant],
 59:                     }),
 60:                 getAdditionalPropertiesSchema: (discriminantValue) => union[discriminantValue],
 61:                 allowUnrecognizedUnionMembers: opts?.allowUnrecognizedUnionMembers,
 62:                 transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema) =>
 63:                     additionalPropertiesSchema.json(additionalProperties, opts),
 64:                 breadcrumbsPrefix: opts?.breadcrumbsPrefix,
 65:             });
 66:         },
 67:         getType: () => SchemaType.UNION,
 68:     };
 69: 
 70:     return {
 71:         ...maybeSkipValidation(baseSchema),
 72:         ...getSchemaUtils(baseSchema),
 73:         ...getObjectLikeUtils(baseSchema),
 74:     };
 75: }
 76: 
 77: function transformAndValidateUnion<
 78:     TransformedDiscriminant extends string,
 79:     TransformedDiscriminantValue extends string,
 80:     TransformedAdditionalProperties,
 81: >({
 82:     value,
 83:     discriminant,
 84:     transformedDiscriminant,
 85:     transformDiscriminantValue,
 86:     getAdditionalPropertiesSchema,
 87:     allowUnrecognizedUnionMembers = false,
 88:     transformAdditionalProperties,
 89:     breadcrumbsPrefix = [],
 90: }: {
 91:     value: unknown;
 92:     discriminant: string;
 93:     transformedDiscriminant: TransformedDiscriminant;
 94:     transformDiscriminantValue: (discriminantValue: unknown) => MaybeValid<TransformedDiscriminantValue>;
 95:     getAdditionalPropertiesSchema: (discriminantValue: string) => ObjectSchema<any, any> | undefined;
 96:     allowUnrecognizedUnionMembers: boolean | undefined;
 97:     transformAdditionalProperties: (
 98:         additionalProperties: unknown,
 99:         additionalPropertiesSchema: ObjectSchema<any, any>,
100:     ) => MaybeValid<TransformedAdditionalProperties>;
101:     breadcrumbsPrefix: string[] | undefined;
102: }): MaybeValid<Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties> {
103:     if (!isPlainObject(value)) {
104:         return {
105:             ok: false,
106:             errors: [
107:                 {
108:                     path: breadcrumbsPrefix,
109:                     message: getErrorMessageForIncorrectType(value, "object"),
110:                 },
111:             ],
112:         };
113:     }
114: 
115:     const { [discriminant]: discriminantValue, ...additionalProperties } = value;
116: 
117:     if (discriminantValue == null) {
118:         return {
119:             ok: false,
120:             errors: [
121:                 {
122:                     path: breadcrumbsPrefix,
123:                     message: `Missing discriminant ("${discriminant}")`,
124:                 },
125:             ],
126:         };
127:     }
128: 
129:     const transformedDiscriminantValue = transformDiscriminantValue(discriminantValue);
130:     if (!transformedDiscriminantValue.ok) {
131:         return {
132:             ok: false,
133:             errors: transformedDiscriminantValue.errors,
134:         };
135:     }
136: 
137:     const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);
138: 
139:     if (additionalPropertiesSchema == null) {
140:         if (allowUnrecognizedUnionMembers) {
141:             return {
142:                 ok: true,
143:                 value: {
144:                     [transformedDiscriminant]: transformedDiscriminantValue.value,
145:                     ...additionalProperties,
146:                 } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,
147:             };
148:         } else {
149:             return {
150:                 ok: false,
151:                 errors: [
152:                     {
153:                         path: [...breadcrumbsPrefix, discriminant],
154:                         message: "Unexpected discriminant value",
155:                     },
156:                 ],
157:             };
158:         }
159:     }
160: 
161:     const transformedAdditionalProperties = transformAdditionalProperties(
162:         additionalProperties,
163:         additionalPropertiesSchema,
164:     );
165:     if (!transformedAdditionalProperties.ok) {
166:         return transformedAdditionalProperties;
167:     }
168: 
169:     return {
170:         ok: true,
171:         value: {
172:             [transformedDiscriminant]: discriminantValue,
173:             ...transformedAdditionalProperties.value,
174:         } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,
175:     };
176: }
````

## File: src/core/schemas/builders/index.ts
````typescript
 1: export * from "./bigint/index.js";
 2: export * from "./date/index.js";
 3: export * from "./enum/index.js";
 4: export * from "./lazy/index.js";
 5: export * from "./list/index.js";
 6: export * from "./literals/index.js";
 7: export * from "./object/index.js";
 8: export * from "./object-like/index.js";
 9: export * from "./primitives/index.js";
10: export * from "./record/index.js";
11: export * from "./schema-utils/index.js";
12: export * from "./set/index.js";
13: export * from "./undiscriminated-union/index.js";
14: export * from "./union/index.js";
````

## File: src/core/schemas/utils/addQuestionMarksToNullableProperties.ts
````typescript
1: export type addQuestionMarksToNullableProperties<T> = {
2:     [K in OptionalKeys<T>]?: T[K];
3: } & Pick<T, RequiredKeys<T>>;
4: 
5: export type OptionalKeys<T> = {
6:     [K in keyof T]-?: undefined extends T[K] ? K : never;
7: }[keyof T];
8: 
9: export type RequiredKeys<T> = Exclude<keyof T, OptionalKeys<T>>;
````

## File: src/core/schemas/utils/createIdentitySchemaCreator.ts
````typescript
 1: import { getSchemaUtils } from "../builders/schema-utils/index.js";
 2: import type { BaseSchema, MaybeValid, Schema, SchemaOptions, SchemaType } from "../Schema.js";
 3: import { maybeSkipValidation } from "./maybeSkipValidation.js";
 4: 
 5: export function createIdentitySchemaCreator<T>(
 6:     schemaType: SchemaType,
 7:     validate: (value: unknown, opts?: SchemaOptions) => MaybeValid<T>,
 8: ): () => Schema<T, T> {
 9:     return () => {
10:         const baseSchema: BaseSchema<T, T> = {
11:             parse: validate,
12:             json: validate,
13:             getType: () => schemaType,
14:         };
15: 
16:         return {
17:             ...maybeSkipValidation(baseSchema),
18:             ...getSchemaUtils(baseSchema),
19:         };
20:     };
21: }
````

## File: src/core/schemas/utils/entries.ts
````typescript
1: export function entries<T extends object>(object: T): [keyof T, T[keyof T]][] {
2:     return Object.entries(object) as [keyof T, T[keyof T]][];
3: }
````

## File: src/core/schemas/utils/filterObject.ts
````typescript
 1: export function filterObject<T extends object, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
 2:     const keysToIncludeSet = new Set(keysToInclude);
 3:     return Object.entries(obj).reduce(
 4:         (acc, [key, value]) => {
 5:             if (keysToIncludeSet.has(key as K)) {
 6:                 acc[key as K] = value as T[K];
 7:             }
 8:             return acc;
 9:             // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
10:         },
11:         {} as Pick<T, K>,
12:     );
13: }
````

## File: src/core/schemas/utils/getErrorMessageForIncorrectType.ts
````typescript
 1: export function getErrorMessageForIncorrectType(value: unknown, expectedType: string): string {
 2:     return `Expected ${expectedType}. Received ${getTypeAsString(value)}.`;
 3: }
 4: 
 5: function getTypeAsString(value: unknown): string {
 6:     if (Array.isArray(value)) {
 7:         return "list";
 8:     }
 9:     if (value === null) {
10:         return "null";
11:     }
12:     if (value instanceof BigInt) {
13:         return "BigInt";
14:     }
15:     switch (typeof value) {
16:         case "string":
17:             return `"${value}"`;
18:         case "bigint":
19:         case "number":
20:         case "boolean":
21:         case "undefined":
22:             return `${value}`;
23:     }
24:     return typeof value;
25: }
````

## File: src/core/schemas/utils/isPlainObject.ts
````typescript
 1: // borrowed from https://github.com/lodash/lodash/blob/master/isPlainObject.js
 2: export function isPlainObject(value: unknown): value is Record<string, unknown> {
 3:     if (typeof value !== "object" || value === null) {
 4:         return false;
 5:     }
 6: 
 7:     if (Object.getPrototypeOf(value) === null) {
 8:         return true;
 9:     }
10: 
11:     let proto = value;
12:     while (Object.getPrototypeOf(proto) !== null) {
13:         proto = Object.getPrototypeOf(proto);
14:     }
15: 
16:     return Object.getPrototypeOf(value) === proto;
17: }
````

## File: src/core/schemas/utils/keys.ts
````typescript
1: export function keys<T extends object>(object: T): (keyof T)[] {
2:     return Object.keys(object) as (keyof T)[];
3: }
````

## File: src/core/schemas/utils/MaybePromise.ts
````typescript
1: export type MaybePromise<T> = T | Promise<T>;
````

## File: src/core/schemas/utils/maybeSkipValidation.ts
````typescript
 1: import type { BaseSchema, MaybeValid, SchemaOptions } from "../Schema.js";
 2: 
 3: export function maybeSkipValidation<S extends BaseSchema<Raw, Parsed>, Raw, Parsed>(schema: S): S {
 4:     return {
 5:         ...schema,
 6:         json: transformAndMaybeSkipValidation(schema.json),
 7:         parse: transformAndMaybeSkipValidation(schema.parse),
 8:     };
 9: }
10: 
11: function transformAndMaybeSkipValidation<T>(
12:     transform: (value: unknown, opts?: SchemaOptions) => MaybeValid<T>,
13: ): (value: unknown, opts?: SchemaOptions) => MaybeValid<T> {
14:     return (value, opts): MaybeValid<T> => {
15:         const transformed = transform(value, opts);
16:         const { skipValidation = false } = opts ?? {};
17:         if (!transformed.ok && skipValidation) {
18:             // biome-ignore lint/suspicious/noConsole: allow console
19:             console.warn(
20:                 [
21:                     "Failed to validate.",
22:                     ...transformed.errors.map(
23:                         (error) =>
24:                             "  - " +
25:                             (error.path.length > 0 ? `${error.path.join(".")}: ${error.message}` : error.message),
26:                     ),
27:                 ].join("\n"),
28:             );
29: 
30:             return {
31:                 ok: true,
32:                 value: value as T,
33:             };
34:         } else {
35:             return transformed;
36:         }
37:     };
38: }
````

## File: src/core/schemas/utils/partition.ts
````typescript
 1: export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
 2:     const trueItems: T[] = [],
 3:         falseItems: T[] = [];
 4:     for (const item of items) {
 5:         if (predicate(item)) {
 6:             trueItems.push(item);
 7:         } else {
 8:             falseItems.push(item);
 9:         }
10:     }
11:     return [trueItems, falseItems];
12: }
````

## File: src/core/schemas/index.ts
````typescript
1: export * from "./builders/index.js";
2: export type { inferParsed, inferRaw, Schema, SchemaOptions } from "./Schema.js";
````

## File: src/core/schemas/Schema.ts
````typescript
  1: import type { SchemaUtils } from "./builders/index.js";
  2: 
  3: export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;
  4: 
  5: export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
  6: export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;
  7: 
  8: export interface BaseSchema<Raw, Parsed> {
  9:     parse: (raw: unknown, opts?: SchemaOptions) => MaybeValid<Parsed>;
 10:     json: (parsed: unknown, opts?: SchemaOptions) => MaybeValid<Raw>;
 11:     getType: () => SchemaType | SchemaType;
 12: }
 13: 
 14: export const SchemaType = {
 15:     BIGINT: "bigint",
 16:     DATE: "date",
 17:     ENUM: "enum",
 18:     LIST: "list",
 19:     STRING_LITERAL: "stringLiteral",
 20:     BOOLEAN_LITERAL: "booleanLiteral",
 21:     OBJECT: "object",
 22:     ANY: "any",
 23:     BOOLEAN: "boolean",
 24:     NUMBER: "number",
 25:     STRING: "string",
 26:     UNKNOWN: "unknown",
 27:     NEVER: "never",
 28:     RECORD: "record",
 29:     SET: "set",
 30:     UNION: "union",
 31:     UNDISCRIMINATED_UNION: "undiscriminatedUnion",
 32:     NULLABLE: "nullable",
 33:     OPTIONAL: "optional",
 34:     OPTIONAL_NULLABLE: "optionalNullable",
 35: } as const;
 36: 
 37: export type SchemaType = (typeof SchemaType)[keyof typeof SchemaType];
 38: 
 39: export type MaybeValid<T> = Valid<T> | Invalid;
 40: 
 41: export interface Valid<T> {
 42:     ok: true;
 43:     value: T;
 44: }
 45: 
 46: export interface Invalid {
 47:     ok: false;
 48:     errors: ValidationError[];
 49: }
 50: 
 51: export interface ValidationError {
 52:     path: string[];
 53:     message: string;
 54: }
 55: 
 56: export interface SchemaOptions {
 57:     /**
 58:      * how to handle unrecognized keys in objects
 59:      *
 60:      * @default "fail"
 61:      */
 62:     unrecognizedObjectKeys?: "fail" | "passthrough" | "strip";
 63: 
 64:     /**
 65:      * whether to fail when an unrecognized discriminant value is
 66:      * encountered in a union
 67:      *
 68:      * @default false
 69:      */
 70:     allowUnrecognizedUnionMembers?: boolean;
 71: 
 72:     /**
 73:      * whether to fail when an unrecognized enum value is encountered
 74:      *
 75:      * @default false
 76:      */
 77:     allowUnrecognizedEnumValues?: boolean;
 78: 
 79:     /**
 80:      * whether to allow data that doesn't conform to the schema.
 81:      * invalid data is passed through without transformation.
 82:      *
 83:      * when this is enabled, .parse() and .json() will always
 84:      * return `ok: true`. `.parseOrThrow()` and `.jsonOrThrow()`
 85:      * will never fail.
 86:      *
 87:      * @default false
 88:      */
 89:     skipValidation?: boolean;
 90: 
 91:     /**
 92:      * each validation failure contains a "path" property, which is
 93:      * the breadcrumbs to the offending node in the JSON. you can supply
 94:      * a prefix that is prepended to all the errors' paths. this can be
 95:      * helpful for zurg's internal debug logging.
 96:      */
 97:     breadcrumbsPrefix?: string[];
 98: 
 99:     /**
100:      * whether to send 'null' for optional properties explicitly set to 'undefined'.
101:      */
102:     omitUndefined?: boolean;
103: }
````

## File: src/core/stream/index.ts
````typescript
1: export { Stream } from "./Stream.js";
````

## File: src/core/stream/Stream.ts
````typescript
  1: import { RUNTIME } from "../runtime/index.js";
  2: 
  3: export declare namespace Stream {
  4:     interface Args {
  5:         /**
  6:          * The HTTP response stream to read from.
  7:          */
  8: 
  9:         stream: ReadableStream;
 10: 
 11:         /**
 12:          * The event shape to use for parsing the stream data.
 13:          */
 14:         eventShape: JsonEvent | SseEvent;
 15:         /**
 16:          * An abort signal to stop the stream.
 17:          */
 18:         signal?: AbortSignal;
 19:     }
 20: 
 21:     interface JsonEvent {
 22:         type: "json";
 23:         messageTerminator: string;
 24:     }
 25: 
 26:     interface SseEvent {
 27:         type: "sse";
 28:         streamTerminator?: string;
 29:     }
 30: }
 31: 
 32: const DATA_PREFIX = "data:";
 33: 
 34: export class Stream<T> implements AsyncIterable<T> {
 35:     private stream: ReadableStream;
 36: 
 37:     private parse: (val: unknown) => Promise<T>;
 38:     /**
 39:      * The prefix to use for each message. For example,
 40:      * for SSE, the prefix is "data: ".
 41:      */
 42:     private prefix: string | undefined;
 43:     private messageTerminator: string;
 44:     private streamTerminator: string | undefined;
 45:     private controller: AbortController = new AbortController();
 46:     private decoder: TextDecoder | undefined;
 47: 
 48:     constructor({ stream, parse, eventShape, signal }: Stream.Args & { parse: (val: unknown) => Promise<T> }) {
 49:         this.stream = stream;
 50:         this.parse = parse;
 51:         if (eventShape.type === "sse") {
 52:             this.prefix = DATA_PREFIX;
 53:             this.messageTerminator = "\n";
 54:             this.streamTerminator = eventShape.streamTerminator;
 55:         } else {
 56:             this.messageTerminator = eventShape.messageTerminator;
 57:         }
 58:         signal?.addEventListener("abort", () => this.controller.abort());
 59: 
 60:         // Initialize shared TextDecoder
 61:         if (typeof TextDecoder !== "undefined") {
 62:             this.decoder = new TextDecoder("utf-8");
 63:         }
 64:     }
 65: 
 66:     private async *iterMessages(): AsyncGenerator<T, void> {
 67:         this.controller.signal;
 68:         const stream = readableStreamAsyncIterable<any>(this.stream);
 69:         let buf = "";
 70:         let prefixSeen = false;
 71:         for await (const chunk of stream) {
 72:             buf += this.decodeChunk(chunk);
 73: 
 74:             let terminatorIndex: number;
 75:             while ((terminatorIndex = buf.indexOf(this.messageTerminator)) >= 0) {
 76:                 let line = buf.slice(0, terminatorIndex);
 77:                 buf = buf.slice(terminatorIndex + this.messageTerminator.length);
 78: 
 79:                 if (!line.trim()) {
 80:                     continue;
 81:                 }
 82: 
 83:                 if (!prefixSeen && this.prefix != null) {
 84:                     const prefixIndex = line.indexOf(this.prefix);
 85:                     if (prefixIndex === -1) {
 86:                         continue;
 87:                     }
 88:                     prefixSeen = true;
 89:                     line = line.slice(prefixIndex + this.prefix.length);
 90:                 }
 91: 
 92:                 if (this.streamTerminator != null && line.includes(this.streamTerminator)) {
 93:                     return;
 94:                 }
 95:                 const message = await this.parse(JSON.parse(line));
 96:                 yield message;
 97:                 prefixSeen = false;
 98:             }
 99:         }
100:     }
101: 
102:     async *[Symbol.asyncIterator](): AsyncIterator<T, void, unknown> {
103:         for await (const message of this.iterMessages()) {
104:             yield message;
105:         }
106:     }
107: 
108:     private decodeChunk(chunk: any): string {
109:         let decoded = "";
110:         // If TextDecoder is available, use the streaming decoder instance
111:         if (this.decoder != null) {
112:             decoded += this.decoder.decode(chunk, { stream: true });
113:         }
114:         // Buffer is present in Node.js environment
115:         else if (RUNTIME.type === "node" && typeof chunk !== "undefined") {
116:             decoded += Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
117:         }
118:         return decoded;
119:     }
120: }
121: 
122: /**
123:  * Browser polyfill for ReadableStream
124:  */
125: // biome-ignore lint/suspicious/noExplicitAny: allow explicit any
126: export function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {
127:     if (stream[Symbol.asyncIterator]) {
128:         return stream;
129:     }
130: 
131:     const reader = stream.getReader();
132:     return {
133:         async next() {
134:             try {
135:                 const result = await reader.read();
136:                 if (result?.done) {
137:                     reader.releaseLock();
138:                 } // release lock when stream becomes closed
139:                 return result;
140:             } catch (e) {
141:                 reader.releaseLock(); // release lock when stream becomes errored
142:                 throw e;
143:             }
144:         },
145:         async return() {
146:             const cancelPromise = reader.cancel();
147:             reader.releaseLock();
148:             await cancelPromise;
149:             return { done: true, value: undefined };
150:         },
151:         [Symbol.asyncIterator]() {
152:             return this;
153:         },
154:     };
155: }
````

## File: src/core/url/encodePathParam.ts
````typescript
 1: export function encodePathParam(param: unknown): string {
 2:     if (param === null) {
 3:         return "null";
 4:     }
 5:     const typeofParam = typeof param;
 6:     switch (typeofParam) {
 7:         case "undefined":
 8:             return "undefined";
 9:         case "string":
10:         case "number":
11:         case "boolean":
12:             break;
13:         default:
14:             param = String(param);
15:             break;
16:     }
17:     return encodeURIComponent(param as string | number | boolean);
18: }
````

## File: src/core/url/index.ts
````typescript
1: export { encodePathParam } from "./encodePathParam.js";
2: export { join } from "./join.js";
3: export { toQueryString } from "./qs.js";
````

## File: src/core/url/join.ts
````typescript
 1: export function join(base: string, ...segments: string[]): string {
 2:     if (!base) {
 3:         return "";
 4:     }
 5: 
 6:     if (segments.length === 0) {
 7:         return base;
 8:     }
 9: 
10:     if (base.includes("://")) {
11:         let url: URL;
12:         try {
13:             url = new URL(base);
14:         } catch {
15:             return joinPath(base, ...segments);
16:         }
17: 
18:         const lastSegment = segments[segments.length - 1];
19:         const shouldPreserveTrailingSlash = lastSegment?.endsWith("/");
20: 
21:         for (const segment of segments) {
22:             const cleanSegment = trimSlashes(segment);
23:             if (cleanSegment) {
24:                 url.pathname = joinPathSegments(url.pathname, cleanSegment);
25:             }
26:         }
27: 
28:         if (shouldPreserveTrailingSlash && !url.pathname.endsWith("/")) {
29:             url.pathname += "/";
30:         }
31: 
32:         return url.toString();
33:     }
34: 
35:     return joinPath(base, ...segments);
36: }
37: 
38: function joinPath(base: string, ...segments: string[]): string {
39:     if (segments.length === 0) {
40:         return base;
41:     }
42: 
43:     let result = base;
44: 
45:     const lastSegment = segments[segments.length - 1];
46:     const shouldPreserveTrailingSlash = lastSegment?.endsWith("/");
47: 
48:     for (const segment of segments) {
49:         const cleanSegment = trimSlashes(segment);
50:         if (cleanSegment) {
51:             result = joinPathSegments(result, cleanSegment);
52:         }
53:     }
54: 
55:     if (shouldPreserveTrailingSlash && !result.endsWith("/")) {
56:         result += "/";
57:     }
58: 
59:     return result;
60: }
61: 
62: function joinPathSegments(left: string, right: string): string {
63:     if (left.endsWith("/")) {
64:         return left + right;
65:     }
66:     return `${left}/${right}`;
67: }
68: 
69: function trimSlashes(str: string): string {
70:     if (!str) return str;
71: 
72:     let start = 0;
73:     let end = str.length;
74: 
75:     if (str.startsWith("/")) start = 1;
76:     if (str.endsWith("/")) end = str.length - 1;
77: 
78:     return start === 0 && end === str.length ? str : str.slice(start, end);
79: }
````

## File: src/core/url/qs.ts
````typescript
 1: interface QueryStringOptions {
 2:     arrayFormat?: "indices" | "repeat";
 3:     encode?: boolean;
 4: }
 5: 
 6: const defaultQsOptions: Required<QueryStringOptions> = {
 7:     arrayFormat: "indices",
 8:     encode: true,
 9: } as const;
10: 
11: function encodeValue(value: unknown, shouldEncode: boolean): string {
12:     if (value === undefined) {
13:         return "";
14:     }
15:     if (value === null) {
16:         return "";
17:     }
18:     const stringValue = String(value);
19:     return shouldEncode ? encodeURIComponent(stringValue) : stringValue;
20: }
21: 
22: function stringifyObject(obj: Record<string, unknown>, prefix = "", options: Required<QueryStringOptions>): string[] {
23:     const parts: string[] = [];
24: 
25:     for (const [key, value] of Object.entries(obj)) {
26:         const fullKey = prefix ? `${prefix}[${key}]` : key;
27: 
28:         if (value === undefined) {
29:             continue;
30:         }
31: 
32:         if (Array.isArray(value)) {
33:             if (value.length === 0) {
34:                 continue;
35:             }
36:             for (let i = 0; i < value.length; i++) {
37:                 const item = value[i];
38:                 if (item === undefined) {
39:                     continue;
40:                 }
41:                 if (typeof item === "object" && !Array.isArray(item) && item !== null) {
42:                     const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i}]` : fullKey;
43:                     parts.push(...stringifyObject(item as Record<string, unknown>, arrayKey, options));
44:                 } else {
45:                     const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i}]` : fullKey;
46:                     const encodedKey = options.encode ? encodeURIComponent(arrayKey) : arrayKey;
47:                     parts.push(`${encodedKey}=${encodeValue(item, options.encode)}`);
48:                 }
49:             }
50:         } else if (typeof value === "object" && value !== null) {
51:             if (Object.keys(value as Record<string, unknown>).length === 0) {
52:                 continue;
53:             }
54:             parts.push(...stringifyObject(value as Record<string, unknown>, fullKey, options));
55:         } else {
56:             const encodedKey = options.encode ? encodeURIComponent(fullKey) : fullKey;
57:             parts.push(`${encodedKey}=${encodeValue(value, options.encode)}`);
58:         }
59:     }
60: 
61:     return parts;
62: }
63: 
64: export function toQueryString(obj: unknown, options?: QueryStringOptions): string {
65:     if (obj == null || typeof obj !== "object") {
66:         return "";
67:     }
68: 
69:     const parts = stringifyObject(obj as Record<string, unknown>, "", {
70:         ...defaultQsOptions,
71:         ...options,
72:     });
73:     return parts.join("&");
74: }
````

## File: src/core/utils/index.ts
````typescript
1: export { setObjectProperty } from "./setObjectProperty.js";
````

## File: src/core/utils/setObjectProperty.ts
````typescript
 1: /**
 2:  * Sets the value at path of object. If a portion of path doesn’t exist it’s created. This is
 3:  * inspired by Lodash's set function, but is simplified to accommodate our use case.
 4:  * For more details, see https://lodash.com/docs/4.17.15#set.
 5:  *
 6:  * @param object The object to modify.
 7:  * @param path The path of the property to set.
 8:  * @param value The value to set.
 9:  * @return Returns object.
10:  */
11: export function setObjectProperty<T extends object>(object: T, path: string, value: any): T {
12:     if (object == null) {
13:         return object;
14:     }
15: 
16:     const keys: string[] = path.split(".");
17:     if (keys.length === 0) {
18:         // Invalid path; do nothing.
19:         return object;
20:     }
21: 
22:     let current: Record<string, any> = object;
23:     for (let i = 0; i < keys.length - 1; i++) {
24:         const key = keys[i];
25:         if (key == null) {
26:             // Unreachable.
27:             continue;
28:         }
29:         if (!current[key] || typeof current[key] !== "object") {
30:             current[key] = {};
31:         }
32:         current = current[key] as Record<string, any>;
33:     }
34: 
35:     const lastKey = keys[keys.length - 1];
36:     if (lastKey == null) {
37:         // Unreachable.
38:         return object;
39:     }
40: 
41:     current[lastKey] = value;
42:     return object;
43: }
````

## File: src/core/websocket/events.ts
````typescript
 1: export class Event {
 2:     public target: any;
 3:     public type: string;
 4:     constructor(type: string, target: any) {
 5:         this.target = target;
 6:         this.type = type;
 7:     }
 8: }
 9: 
10: export class ErrorEvent extends Event {
11:     public message: string;
12:     public error: Error;
13:     constructor(error: Error, target: any) {
14:         super("error", target);
15:         this.message = error.message;
16:         this.error = error;
17:     }
18: }
19: 
20: export class CloseEvent extends Event {
21:     public code: number;
22:     public reason: string;
23:     public wasClean = true;
24:     constructor(code = 1000, reason = "", target: any) {
25:         super("close", target);
26:         this.code = code;
27:         this.reason = reason;
28:     }
29: }
30: export interface WebSocketEventMap {
31:     close: CloseEvent;
32:     error: ErrorEvent;
33:     message: MessageEvent;
34:     open: Event;
35: }
36: 
37: export interface WebSocketEventListenerMap {
38:     close: (event: CloseEvent) => void | { handleEvent: (event: CloseEvent) => void };
39:     error: (event: ErrorEvent) => void | { handleEvent: (event: ErrorEvent) => void };
40:     message: (event: MessageEvent) => void | { handleEvent: (event: MessageEvent) => void };
41:     open: (event: Event) => void | { handleEvent: (event: Event) => void };
42: }
````

## File: src/core/websocket/exports.ts
````typescript
1: import type * as events from "./events.js";
2: import type * as ws from "./ws.js";
3: 
4: export type ReconnectingWebSocket = typeof ws.ReconnectingWebSocket;
5: export declare namespace ReconnectingWebSocket {
6:     export type Event = events.Event;
7:     export type CloseEvent = events.CloseEvent;
8:     export type ErrorEvent = events.ErrorEvent;
9: }
````

## File: src/core/websocket/index.ts
````typescript
1: export * from "./ws.js";
````

## File: src/core/websocket/ws.ts
````typescript
  1: import { WebSocket as NodeWebSocket } from "ws";
  2: 
  3: import { RUNTIME } from "../runtime/index.js";
  4: import { toQueryString } from "../url/qs.js";
  5: import * as Events from "./events.js";
  6: import { SDK_VERSION } from "../../version.js";
  7: 
  8: const getGlobalWebSocket = (): WebSocket | undefined => {
  9:     if (typeof WebSocket !== "undefined") {
 10:         // @ts-ignore
 11:         return WebSocket;
 12:     } else if (RUNTIME.type === "node") {
 13:         return NodeWebSocket as unknown as WebSocket;
 14:     }
 15:     return undefined;
 16: };
 17: 
 18: /**
 19:  * Returns true if given argument looks like a WebSocket class
 20:  */
 21: const isWebSocket = (w: any) => typeof w !== "undefined" && !!w && w.CLOSING === 2;
 22: 
 23: export type Event = Events.Event;
 24: export type ErrorEvent = Events.ErrorEvent;
 25: export type CloseEvent = Events.CloseEvent;
 26: 
 27: export declare namespace ReconnectingWebSocket {
 28:     export interface Args {
 29:         url: string;
 30:         protocols?: string | string[];
 31:         options?: ReconnectingWebSocket.Options;
 32:         headers?: Record<string, unknown>;
 33:         queryParameters?: Record<string, string | string[] | object | object[] | null | undefined>;
 34:     }
 35: 
 36:     export type Options = {
 37:         WebSocket?: any;
 38:         maxReconnectionDelay?: number;
 39:         minReconnectionDelay?: number;
 40:         reconnectionDelayGrowFactor?: number;
 41:         minUptime?: number;
 42:         connectionTimeout?: number;
 43:         maxRetries?: number;
 44:         maxEnqueuedMessages?: number;
 45:         startClosed?: boolean;
 46:         debug?: boolean;
 47:     };
 48: 
 49:     export type UrlProvider = string | (() => string) | (() => Promise<string>);
 50: 
 51:     export type Message = string | ArrayBuffer | Blob | ArrayBufferView;
 52: 
 53:     export type ListenersMap = {
 54:         error: Array<Events.WebSocketEventListenerMap["error"]>;
 55:         message: Array<Events.WebSocketEventListenerMap["message"]>;
 56:         open: Array<Events.WebSocketEventListenerMap["open"]>;
 57:         close: Array<Events.WebSocketEventListenerMap["close"]>;
 58:     };
 59: }
 60: 
 61: const DEFAULT_OPTIONS = {
 62:     maxReconnectionDelay: 10000,
 63:     minReconnectionDelay: 1000 + Math.random() * 4000,
 64:     minUptime: 5000,
 65:     reconnectionDelayGrowFactor: 1.3,
 66:     connectionTimeout: 4000,
 67:     maxRetries: Infinity,
 68:     maxEnqueuedMessages: Infinity,
 69:     startClosed: false,
 70:     debug: false,
 71: };
 72: 
 73: function addApiKeyFromHeader({
 74:     headers,
 75:     queryParameters,
 76: }: {
 77:     headers: Record<string, any> | undefined;
 78:     queryParameters: Record<string, any> | undefined;
 79: }) {
 80:     const apiKeyValue = Object.entries(headers ?? {}).find(([k]) => k.toLowerCase() === "x-hume-api-key")?.[1];
 81:     if (apiKeyValue && !queryParameters?.["api_key"]) {
 82:         return { ...queryParameters, api_key: apiKeyValue };
 83:     }
 84:     return queryParameters;
 85: }
 86: 
 87: function addAccessTokenFromHeader({
 88:     headers,
 89:     queryParameters,
 90: }: {
 91:     headers: Record<string, any> | undefined;
 92:     queryParameters: Record<string, any> | undefined;
 93: }) {
 94:     const authHeaderValue = headers?.["Authorization"] || headers?.["authorization"];
 95:     if (!authHeaderValue) {
 96:         return queryParameters;
 97:     }
 98:     if (!authHeaderValue.startsWith("Bearer ")) {
 99:         return queryParameters;
100:     }
101:     if (queryParameters?.["access_token"]) {
102:         return queryParameters;
103:     }
104:     const token = authHeaderValue.substring("Bearer ".length);
105:     return { ...queryParameters, access_token: token };
106: }
107: 
108: function addSdkTracking(queryParameters: Record<string, any> | undefined) {
109:     return {
110:         ...queryParameters,
111:         fernSdkLanguage: "JavaScript",
112:         fernSdkVersion: SDK_VERSION,
113:     };
114: }
115: 
116: export class ReconnectingWebSocket {
117:     private _ws?: WebSocket;
118:     private _listeners: ReconnectingWebSocket.ListenersMap = {
119:         error: [],
120:         message: [],
121:         open: [],
122:         close: [],
123:     };
124:     private _retryCount = -1;
125:     private _uptimeTimeout: any;
126:     private _connectTimeout: any;
127:     private _shouldReconnect = true;
128:     private _connectLock = false;
129:     private _binaryType: BinaryType = "blob";
130:     private _closeCalled = false;
131:     private _messageQueue: ReconnectingWebSocket.Message[] = [];
132: 
133:     private readonly _url: ReconnectingWebSocket.UrlProvider;
134:     private readonly _protocols?: string | string[];
135:     private readonly _options: ReconnectingWebSocket.Options;
136:     private readonly _headers?: Record<string, any>;
137:     private readonly _queryParameters?: Record<string, any>;
138: 
139:     constructor({ url, protocols, options, headers, queryParameters }: ReconnectingWebSocket.Args) {
140:         this._url = url;
141:         this._protocols = protocols;
142:         this._options = options ?? DEFAULT_OPTIONS;
143:         this._headers = headers;
144:         this._queryParameters = addSdkTracking(
145:             addAccessTokenFromHeader({
146:                 headers,
147:                 queryParameters: addApiKeyFromHeader({
148:                     headers,
149:                     queryParameters,
150:                 }),
151:             }),
152:         );
153: 
154:         if (this._options.startClosed) {
155:             this._shouldReconnect = false;
156:         }
157:         this._connect();
158:     }
159: 
160:     static get CONNECTING() {
161:         return 0;
162:     }
163:     static get OPEN() {
164:         return 1;
165:     }
166:     static get CLOSING() {
167:         return 2;
168:     }
169:     static get CLOSED() {
170:         return 3;
171:     }
172: 
173:     get CONNECTING(): number {
174:         return ReconnectingWebSocket.CONNECTING;
175:     }
176:     get OPEN(): number {
177:         return ReconnectingWebSocket.OPEN;
178:     }
179:     get CLOSING(): number {
180:         return ReconnectingWebSocket.CLOSING;
181:     }
182:     get CLOSED(): number {
183:         return ReconnectingWebSocket.CLOSED;
184:     }
185: 
186:     get binaryType() {
187:         return this._ws ? this._ws.binaryType : this._binaryType;
188:     }
189: 
190:     set binaryType(value: BinaryType) {
191:         this._binaryType = value;
192:         if (this._ws) {
193:             this._ws.binaryType = value;
194:         }
195:     }
196: 
197:     /**
198:      * Returns the number or connection retries
199:      */
200:     get retryCount(): number {
201:         return Math.max(this._retryCount, 0);
202:     }
203: 
204:     /**
205:      * The number of bytes of data that have been queued using calls to send() but not yet
206:      * transmitted to the network. This value resets to zero once all queued data has been sent.
207:      * This value does not reset to zero when the connection is closed; if you keep calling send(),
208:      * this will continue to climb. Read only
209:      */
210:     get bufferedAmount(): number {
211:         const bytes = this._messageQueue.reduce((acc, message) => {
212:             if (typeof message === "string") {
213:                 acc += message.length; // not byte size
214:             } else if (message instanceof Blob) {
215:                 acc += message.size;
216:             } else {
217:                 acc += message.byteLength;
218:             }
219:             return acc;
220:         }, 0);
221:         return bytes + (this._ws ? this._ws.bufferedAmount : 0);
222:     }
223: 
224:     /**
225:      * The extensions selected by the server. This is currently only the empty string or a list of
226:      * extensions as negotiated by the connection
227:      */
228:     get extensions(): string {
229:         return this._ws ? this._ws.extensions : "";
230:     }
231: 
232:     /**
233:      * A string indicating the name of the sub-protocol the server selected;
234:      * this will be one of the strings specified in the protocols parameter when creating the
235:      * WebSocket object
236:      */
237:     get protocol(): string {
238:         return this._ws ? this._ws.protocol : "";
239:     }
240: 
241:     /**
242:      * The current state of the connection; this is one of the Ready state constants
243:      */
244:     get readyState(): number {
245:         if (this._ws) {
246:             return this._ws.readyState;
247:         }
248:         return this._options.startClosed ? ReconnectingWebSocket.CLOSED : ReconnectingWebSocket.CONNECTING;
249:     }
250: 
251:     /**
252:      * The URL as resolved by the constructor
253:      */
254:     get url(): string {
255:         return this._ws ? this._ws.url : "";
256:     }
257: 
258:     /**
259:      * An event listener to be called when the WebSocket connection's readyState changes to CLOSED
260:      */
261:     public onclose: ((event: Events.CloseEvent) => void) | null = null;
262: 
263:     /**
264:      * An event listener to be called when an error occurs
265:      */
266:     public onerror: ((event: Events.ErrorEvent) => void) | null = null;
267: 
268:     /**
269:      * An event listener to be called when a message is received from the server
270:      */
271:     public onmessage: ((event: MessageEvent) => void) | null = null;
272: 
273:     /**
274:      * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
275:      * this indicates that the connection is ready to send and receive data
276:      */
277:     public onopen: ((event: Event) => void) | null = null;
278: 
279:     /**
280:      * Closes the WebSocket connection or connection attempt, if any. If the connection is already
281:      * CLOSED, this method does nothing
282:      */
283:     public close(code = 1000, reason?: string): void {
284:         this._closeCalled = true;
285:         this._shouldReconnect = false;
286:         this._clearTimeouts();
287:         if (!this._ws) {
288:             this._debug("close enqueued: no ws instance");
289:             return;
290:         }
291:         if (this._ws.readyState === this.CLOSED) {
292:             this._debug("close: already closed");
293:             return;
294:         }
295:         this._ws.close(code, reason);
296:     }
297: 
298:     /**
299:      * Closes the WebSocket connection or connection attempt and connects again.
300:      * Resets retry counter;
301:      */
302:     public reconnect(code?: number, reason?: string): void {
303:         this._shouldReconnect = true;
304:         this._closeCalled = false;
305:         this._retryCount = -1;
306:         if (!this._ws || this._ws.readyState === this.CLOSED) {
307:             this._connect();
308:         } else {
309:             this._disconnect(code, reason);
310:             this._connect();
311:         }
312:     }
313: 
314:     /**
315:      * Enqueue specified data to be transmitted to the server over the WebSocket connection
316:      */
317:     public send(data: ReconnectingWebSocket.Message): void {
318:         if (this._ws && this._ws.readyState === this.OPEN) {
319:             this._debug("send", data);
320:             this._ws.send(data);
321:         } else {
322:             const { maxEnqueuedMessages = DEFAULT_OPTIONS.maxEnqueuedMessages } = this._options;
323:             if (this._messageQueue.length < maxEnqueuedMessages) {
324:                 this._debug("enqueue", data);
325:                 this._messageQueue.push(data);
326:             }
327:         }
328:     }
329: 
330:     /**
331:      * Register an event handler of a specific event type
332:      */
333:     public addEventListener<T extends keyof Events.WebSocketEventListenerMap>(
334:         type: T,
335:         listener: Events.WebSocketEventListenerMap[T],
336:     ): void {
337:         if (this._listeners[type]) {
338:             // @ts-ignore
339:             this._listeners[type].push(listener);
340:         }
341:     }
342: 
343:     public dispatchEvent(event: Event) {
344:         const listeners = this._listeners[event.type as keyof Events.WebSocketEventListenerMap];
345:         if (listeners) {
346:             for (const listener of listeners) {
347:                 this._callEventListener(event, listener);
348:             }
349:         }
350:         return true;
351:     }
352: 
353:     /**
354:      * Removes an event listener
355:      */
356:     public removeEventListener<T extends keyof Events.WebSocketEventListenerMap>(
357:         type: T,
358:         listener: Events.WebSocketEventListenerMap[T],
359:     ): void {
360:         if (this._listeners[type]) {
361:             // @ts-ignore
362:             this._listeners[type] = this._listeners[type].filter(
363:                 // @ts-ignore
364:                 (l) => l !== listener,
365:             );
366:         }
367:     }
368: 
369:     private _debug(...args: any[]) {
370:         if (this._options.debug) {
371:             // not using spread because compiled version uses Symbols
372:             // tslint:disable-next-line
373:             // biome-ignore lint/suspicious/noConsole: allow console
374:             console.log.apply(console, ["RWS>", ...args]);
375:         }
376:     }
377: 
378:     private _getNextDelay() {
379:         const {
380:             reconnectionDelayGrowFactor = DEFAULT_OPTIONS.reconnectionDelayGrowFactor,
381:             minReconnectionDelay = DEFAULT_OPTIONS.minReconnectionDelay,
382:             maxReconnectionDelay = DEFAULT_OPTIONS.maxReconnectionDelay,
383:         } = this._options;
384:         let delay = 0;
385:         if (this._retryCount > 0) {
386:             delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
387:             if (delay > maxReconnectionDelay) {
388:                 delay = maxReconnectionDelay;
389:             }
390:         }
391:         this._debug("next delay", delay);
392:         return delay;
393:     }
394: 
395:     private _wait(): Promise<void> {
396:         return new Promise((resolve) => {
397:             setTimeout(resolve, this._getNextDelay());
398:         });
399:     }
400: 
401:     private _getNextUrl(urlProvider: ReconnectingWebSocket.UrlProvider): Promise<string> {
402:         if (typeof urlProvider === "string") {
403:             return Promise.resolve(urlProvider);
404:         }
405:         if (typeof urlProvider === "function") {
406:             const url = urlProvider();
407:             if (typeof url === "string") {
408:                 return Promise.resolve(url);
409:             }
410:             // @ts-ignore redundant check
411:             if (url.then) {
412:                 return url;
413:             }
414:         }
415:         throw Error("Invalid URL");
416:     }
417: 
418:     private _connect() {
419:         if (this._connectLock || !this._shouldReconnect) {
420:             return;
421:         }
422:         this._connectLock = true;
423: 
424:         const {
425:             maxRetries = DEFAULT_OPTIONS.maxRetries,
426:             connectionTimeout = DEFAULT_OPTIONS.connectionTimeout,
427:             WebSocket = getGlobalWebSocket(),
428:         } = this._options;
429: 
430:         if (this._retryCount >= maxRetries) {
431:             this._debug("max retries reached", this._retryCount, ">=", maxRetries);
432:             return;
433:         }
434: 
435:         this._retryCount++;
436: 
437:         this._debug("connect", this._retryCount);
438:         this._removeListeners();
439:         if (!isWebSocket(WebSocket)) {
440:             throw Error("No valid WebSocket class provided");
441:         }
442:         this._wait()
443:             .then(() => this._getNextUrl(this._url))
444:             .then((url) => {
445:                 if (this._closeCalled) {
446:                     return;
447:                 }
448:                 const options: Record<string, unknown> = {};
449:                 if (this._headers) {
450:                     options.headers = this._headers;
451:                 }
452:                 if (this._queryParameters && Object.keys(this._queryParameters).length > 0) {
453:                     const queryString = toQueryString(this._queryParameters, { arrayFormat: "repeat" });
454:                     if (queryString) {
455:                         url = `${url}?${queryString}`;
456:                     }
457:                 }
458:                 this._ws = new WebSocket(url, this._protocols, options);
459:                 this._ws!.binaryType = this._binaryType;
460:                 this._connectLock = false;
461:                 this._addListeners();
462: 
463:                 this._connectTimeout = setTimeout(() => this._handleTimeout(), connectionTimeout);
464:             });
465:     }
466: 
467:     private _handleTimeout() {
468:         this._debug("timeout event");
469:         this._handleError(new Events.ErrorEvent(Error("TIMEOUT"), this));
470:     }
471: 
472:     private _disconnect(code = 1000, reason?: string) {
473:         this._clearTimeouts();
474:         if (!this._ws) {
475:             return;
476:         }
477:         this._removeListeners();
478:         try {
479:             this._ws.close(code, reason);
480:             this._handleClose(new Events.CloseEvent(code, reason, this));
481:         } catch (error) {
482:             // ignore
483:         }
484:     }
485: 
486:     private _acceptOpen() {
487:         this._debug("accept open");
488:         this._retryCount = 0;
489:     }
490: 
491:     private _callEventListener<T extends keyof Events.WebSocketEventListenerMap>(
492:         event: Events.WebSocketEventMap[T],
493:         listener: Events.WebSocketEventListenerMap[T],
494:     ) {
495:         if ("handleEvent" in listener) {
496:             // @ts-ignore
497:             listener.handleEvent(event);
498:         } else {
499:             // @ts-ignore
500:             listener(event);
501:         }
502:     }
503: 
504:     private _handleOpen = (event: Event) => {
505:         this._debug("open event");
506:         const { minUptime = DEFAULT_OPTIONS.minUptime } = this._options;
507: 
508:         clearTimeout(this._connectTimeout);
509:         this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);
510: 
511:         this._ws!.binaryType = this._binaryType;
512: 
513:         // send enqueued messages (messages sent before websocket open event)
514:         this._messageQueue.forEach((message) => this._ws?.send(message));
515:         this._messageQueue = [];
516: 
517:         if (this.onopen) {
518:             this.onopen(event);
519:         }
520:         this._listeners.open.forEach((listener) => this._callEventListener(event, listener));
521:     };
522: 
523:     private _handleMessage = (event: MessageEvent) => {
524:         this._debug("message event");
525: 
526:         if (this.onmessage) {
527:             this.onmessage(event);
528:         }
529:         this._listeners.message.forEach((listener) => this._callEventListener(event, listener));
530:     };
531: 
532:     private _handleError = (event: Events.ErrorEvent) => {
533:         this._debug("error event", event.message);
534:         this._disconnect(undefined, event.message === "TIMEOUT" ? "timeout" : undefined);
535: 
536:         if (this.onerror) {
537:             this.onerror(event);
538:         }
539:         this._debug("exec error listeners");
540:         this._listeners.error.forEach((listener) => this._callEventListener(event, listener));
541: 
542:         this._connect();
543:     };
544: 
545:     private _handleClose = (event: Events.CloseEvent) => {
546:         this._debug("close event");
547:         this._clearTimeouts();
548: 
549:         if (event.code === 1000) {
550:             this._shouldReconnect = false;
551:         }
552: 
553:         if (this._shouldReconnect) {
554:             this._connect();
555:         }
556: 
557:         if (this.onclose) {
558:             this.onclose(event);
559:         }
560:         this._listeners.close.forEach((listener) => this._callEventListener(event, listener));
561:     };
562: 
563:     private _removeListeners() {
564:         if (!this._ws) {
565:             return;
566:         }
567:         this._debug("removeListeners");
568:         this._ws.removeEventListener("open", this._handleOpen);
569:         this._ws.removeEventListener("close", this._handleClose);
570:         this._ws.removeEventListener("message", this._handleMessage);
571:         // @ts-ignore
572:         this._ws.removeEventListener("error", this._handleError);
573:     }
574: 
575:     private _addListeners() {
576:         if (!this._ws) {
577:             return;
578:         }
579:         this._debug("addListeners");
580:         this._ws.addEventListener("open", this._handleOpen);
581:         this._ws.addEventListener("close", this._handleClose);
582:         this._ws.addEventListener("message", this._handleMessage);
583:         // @ts-ignore
584:         this._ws.addEventListener("error", this._handleError);
585:     }
586: 
587:     private _clearTimeouts() {
588:         clearTimeout(this._connectTimeout);
589:         clearTimeout(this._uptimeTimeout);
590:     }
591: }
````

## File: src/core/websocket/ws.ts.diff
````diff
  1: diff --git a/src/core/websocket/ws.ts b/src/core/websocket/ws.ts
  2: index 9a16477..6089558 100644
  3: --- a/src/core/websocket/ws.ts
  4: +++ b/src/core/websocket/ws.ts
  5: @@ -3,7 +3,6 @@ import { WebSocket as NodeWebSocket } from "ws";
  6:  import { RUNTIME } from "../runtime/index.js";
  7:  import { toQueryString } from "../url/qs.js";
  8:  import * as Events from "./events.js";
  9: -import { SDK_VERSION } from "../../version.js";
 10:  
 11:  const getGlobalWebSocket = (): WebSocket | undefined => {
 12:      if (typeof WebSocket !== "undefined") {
 13: @@ -30,7 +29,7 @@ export declare namespace ReconnectingWebSocket {
 14:          protocols?: string | string[];
 15:          options?: ReconnectingWebSocket.Options;
 16:          headers?: Record<string, unknown>;
 17: -        queryParameters?: Record<string, string | string[] | object | object[] | null | undefined>;
 18: +        queryParameters?: Record<string, unknown>;
 19:      }
 20:  
 21:      export type Options = {
 22: @@ -70,49 +69,6 @@ const DEFAULT_OPTIONS = {
 23:      debug: false,
 24:  };
 25:  
 26: -function addApiKeyFromHeader({
 27: -    headers,
 28: -    queryParameters,
 29: -}: {
 30: -    headers: Record<string, any> | undefined;
 31: -    queryParameters: Record<string, any> | undefined;
 32: -}) {
 33: -    const apiKeyValue = Object.entries(headers ?? {}).find(([k]) => k.toLowerCase() === "x-hume-api-key")?.[1];
 34: -    if (apiKeyValue && !queryParameters?.["api_key"]) {
 35: -        return { ...queryParameters, api_key: apiKeyValue };
 36: -    }
 37: -    return queryParameters;
 38: -}
 39: -
 40: -function addAccessTokenFromHeader({
 41: -    headers,
 42: -    queryParameters,
 43: -}: {
 44: -    headers: Record<string, any> | undefined;
 45: -    queryParameters: Record<string, any> | undefined;
 46: -}) {
 47: -    const authHeaderValue = headers?.["Authorization"] || headers?.["authorization"];
 48: -    if (!authHeaderValue) {
 49: -        return queryParameters;
 50: -    }
 51: -    if (!authHeaderValue.startsWith("Bearer ")) {
 52: -        return queryParameters;
 53: -    }
 54: -    if (queryParameters?.["access_token"]) {
 55: -        return queryParameters;
 56: -    }
 57: -    const token = authHeaderValue.substring("Bearer ".length);
 58: -    return { ...queryParameters, access_token: token };
 59: -}
 60: -
 61: -function addSdkTracking(queryParameters: Record<string, any> | undefined) {
 62: -    return {
 63: -        ...queryParameters,
 64: -        fernSdkLanguage: "JavaScript",
 65: -        fernSdkVersion: SDK_VERSION,
 66: -    };
 67: -}
 68: -
 69:  export class ReconnectingWebSocket {
 70:      private _ws?: WebSocket;
 71:      private _listeners: ReconnectingWebSocket.ListenersMap = {
 72: @@ -141,47 +97,22 @@ export class ReconnectingWebSocket {
 73:          this._protocols = protocols;
 74:          this._options = options ?? DEFAULT_OPTIONS;
 75:          this._headers = headers;
 76: -        this._queryParameters = addSdkTracking(
 77: -            addAccessTokenFromHeader({
 78: -                headers,
 79: -                queryParameters: addApiKeyFromHeader({
 80: -                    headers,
 81: -                    queryParameters,
 82: -                }),
 83: -            }),
 84: -        );
 85: -
 86: +        this._queryParameters = queryParameters;
 87:          if (this._options.startClosed) {
 88:              this._shouldReconnect = false;
 89:          }
 90:          this._connect();
 91:      }
 92:  
 93: -    static get CONNECTING() {
 94: -        return 0;
 95: -    }
 96: -    static get OPEN() {
 97: -        return 1;
 98: -    }
 99: -    static get CLOSING() {
100: -        return 2;
101: -    }
102: -    static get CLOSED() {
103: -        return 3;
104: -    }
105: +    public static readonly CONNECTING = 0;
106: +    public static readonly OPEN = 1;
107: +    public static readonly CLOSING = 2;
108: +    public static readonly CLOSED = 3;
109:  
110: -    get CONNECTING(): number {
111: -        return ReconnectingWebSocket.CONNECTING;
112: -    }
113: -    get OPEN(): number {
114: -        return ReconnectingWebSocket.OPEN;
115: -    }
116: -    get CLOSING(): number {
117: -        return ReconnectingWebSocket.CLOSING;
118: -    }
119: -    get CLOSED(): number {
120: -        return ReconnectingWebSocket.CLOSED;
121: -    }
122: +    public readonly CONNECTING: typeof ReconnectingWebSocket.CONNECTING = ReconnectingWebSocket.CONNECTING;
123: +    public readonly OPEN: typeof ReconnectingWebSocket.OPEN = ReconnectingWebSocket.OPEN;
124: +    public readonly CLOSING: typeof ReconnectingWebSocket.CLOSING = ReconnectingWebSocket.CLOSING;
125: +    public readonly CLOSED: typeof ReconnectingWebSocket.CLOSED = ReconnectingWebSocket.CLOSED;
126:  
127:      get binaryType() {
128:          return this._ws ? this._ws.binaryType : this._binaryType;
129: @@ -383,7 +314,7 @@ export class ReconnectingWebSocket {
130:          } = this._options;
131:          let delay = 0;
132:          if (this._retryCount > 0) {
133: -            delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
134: +            delay = minReconnectionDelay * reconnectionDelayGrowFactor ** (this._retryCount - 1);
135:              if (delay > maxReconnectionDelay) {
136:                  delay = maxReconnectionDelay;
137:              }
138: @@ -478,7 +409,7 @@ export class ReconnectingWebSocket {
139:          try {
140:              this._ws.close(code, reason);
141:              this._handleClose(new Events.CloseEvent(code, reason, this));
142: -        } catch (error) {
143: +        } catch (_error) {
144:              // ignore
145:          }
146:      }
````

## File: src/core/base64.ts
````typescript
 1: function base64ToBytes(base64: string): Uint8Array {
 2:     const binString = atob(base64);
 3:     return Uint8Array.from(binString, (m) => m.codePointAt(0)!);
 4: }
 5: 
 6: function bytesToBase64(bytes: Uint8Array): string {
 7:     const binString = String.fromCodePoint(...bytes);
 8:     return btoa(binString);
 9: }
10: 
11: export function base64Encode(input: string): string {
12:     if (typeof Buffer !== "undefined") {
13:         return Buffer.from(input, "utf8").toString("base64");
14:     }
15: 
16:     const bytes = new TextEncoder().encode(input);
17:     return bytesToBase64(bytes);
18: }
19: 
20: export function base64Decode(input: string): string {
21:     if (typeof Buffer !== "undefined") {
22:         return Buffer.from(input, "base64").toString("utf8");
23:     }
24: 
25:     const bytes = base64ToBytes(input);
26:     return new TextDecoder().decode(bytes);
27: }
````

## File: src/core/exports.ts
````typescript
1: export * from "./file/exports.js";
2: export * from "./logging/exports.js";
3: export * from "./pagination/exports.js";
4: export * from "./websocket/exports.js";
````

## File: src/core/headers.ts
````typescript
 1: export function mergeHeaders(...headersArray: (Record<string, unknown> | null | undefined)[]): Record<string, unknown> {
 2:     const result: Record<string, unknown> = {};
 3: 
 4:     for (const [key, value] of headersArray
 5:         .filter((headers) => headers != null)
 6:         .flatMap((headers) => Object.entries(headers))) {
 7:         const insensitiveKey = key.toLowerCase();
 8:         if (value != null) {
 9:             result[insensitiveKey] = value;
10:         } else if (insensitiveKey in result) {
11:             delete result[insensitiveKey];
12:         }
13:     }
14: 
15:     return result;
16: }
17: 
18: export function mergeOnlyDefinedHeaders(
19:     ...headersArray: (Record<string, unknown> | null | undefined)[]
20: ): Record<string, unknown> {
21:     const result: Record<string, unknown> = {};
22: 
23:     for (const [key, value] of headersArray
24:         .filter((headers) => headers != null)
25:         .flatMap((headers) => Object.entries(headers))) {
26:         const insensitiveKey = key.toLowerCase();
27:         if (value != null) {
28:             result[insensitiveKey] = value;
29:         }
30:     }
31: 
32:     return result;
33: }
````

## File: src/core/index.ts
````typescript
 1: export * from "./auth/index.js";
 2: export * from "./base64.js";
 3: export * from "./fetcher/index.js";
 4: export * as file from "./file/index.js";
 5: export * from "./form-data-utils/index.js";
 6: export * as logging from "./logging/index.js";
 7: export * from "./pagination/index.js";
 8: export * from "./runtime/index.js";
 9: export * as serialization from "./schemas/index.js";
10: export * from "./stream/index.js";
11: export * as url from "./url/index.js";
12: export * from "./utils/index.js";
13: export * from "./websocket/index.js";
````

## File: src/core/json.ts
````typescript
 1: /**
 2:  * Serialize a value to JSON
 3:  * @param value A JavaScript value, usually an object or array, to be converted.
 4:  * @param replacer A function that transforms the results.
 5:  * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
 6:  * @returns JSON string
 7:  */
 8: export const toJson = (
 9:     value: unknown,
10:     replacer?: (this: unknown, key: string, value: unknown) => unknown,
11:     space?: string | number,
12: ): string => {
13:     return JSON.stringify(value, replacer, space);
14: };
15: 
16: /**
17:  * Parse JSON string to object, array, or other type
18:  * @param text A valid JSON string.
19:  * @param reviver A function that transforms the results. This function is called for each member of the object. If a member contains nested objects, the nested objects are transformed before the parent object is.
20:  * @returns Parsed object, array, or other type
21:  */
22: export function fromJson<T = unknown>(
23:     text: string,
24:     reviver?: (this: unknown, key: string, value: unknown) => unknown,
25: ): T {
26:     return JSON.parse(text, reviver);
27: }
````

## File: src/errors/handleNonStatusCodeError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as core from "../core/index.js";
 4: import * as errors from "./index.js";
 5: 
 6: export function handleNonStatusCodeError(
 7:     error: core.Fetcher.Error,
 8:     rawResponse: core.RawResponse,
 9:     method: string,
10:     path: string,
11: ): never {
12:     switch (error.reason) {
13:         case "non-json":
14:             throw new errors.HumeError({
15:                 statusCode: error.statusCode,
16:                 body: error.rawBody,
17:                 rawResponse: rawResponse,
18:             });
19:         case "body-is-null":
20:             throw new errors.HumeError({
21:                 statusCode: error.statusCode,
22:                 rawResponse: rawResponse,
23:             });
24:         case "timeout":
25:             throw new errors.HumeTimeoutError(`Timeout exceeded when calling ${method} ${path}.`);
26:         case "unknown":
27:             throw new errors.HumeError({
28:                 message: error.errorMessage,
29:                 rawResponse: rawResponse,
30:             });
31:         default:
32:             throw new errors.HumeError({
33:                 message: "Unknown error",
34:                 rawResponse: rawResponse,
35:             });
36:     }
37: }
````

## File: src/errors/HumeError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as core from "../core/index.js";
 4: import { toJson } from "../core/json.js";
 5: 
 6: export class HumeError extends Error {
 7:     public readonly statusCode?: number;
 8:     public readonly body?: unknown;
 9:     public readonly rawResponse?: core.RawResponse;
10: 
11:     constructor({
12:         message,
13:         statusCode,
14:         body,
15:         rawResponse,
16:     }: {
17:         message?: string;
18:         statusCode?: number;
19:         body?: unknown;
20:         rawResponse?: core.RawResponse;
21:     }) {
22:         super(buildMessage({ message, statusCode, body }));
23:         Object.setPrototypeOf(this, new.target.prototype);
24:         if (Error.captureStackTrace) {
25:             Error.captureStackTrace(this, this.constructor);
26:         }
27: 
28:         this.name = this.constructor.name;
29:         this.statusCode = statusCode;
30:         this.body = body;
31:         this.rawResponse = rawResponse;
32:     }
33: }
34: 
35: function buildMessage({
36:     message,
37:     statusCode,
38:     body,
39: }: {
40:     message: string | undefined;
41:     statusCode: number | undefined;
42:     body: unknown | undefined;
43: }): string {
44:     const lines: string[] = [];
45:     if (message != null) {
46:         lines.push(message);
47:     }
48: 
49:     if (statusCode != null) {
50:         lines.push(`Status code: ${statusCode.toString()}`);
51:     }
52: 
53:     if (body != null) {
54:         lines.push(`Body: ${toJson(body, undefined, 2)}`);
55:     }
56: 
57:     return lines.join("\n");
58: }
````

## File: src/errors/HumeTimeoutError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export class HumeTimeoutError extends Error {
 4:     constructor(message: string) {
 5:         super(message);
 6:         Object.setPrototypeOf(this, new.target.prototype);
 7:         if (Error.captureStackTrace) {
 8:             Error.captureStackTrace(this, this.constructor);
 9:         }
10: 
11:         this.name = this.constructor.name;
12:     }
13: }
````

## File: src/errors/index.ts
````typescript
1: export { HumeError } from "./HumeError.js";
2: export { HumeTimeoutError } from "./HumeTimeoutError.js";
````

## File: src/serialization/resources/empathicVoice/resources/chat/client/socket/ChatSocketResponse.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: import { SubscribeEvent } from "../../../../types/SubscribeEvent.js";
 7: 
 8: export const ChatSocketResponse: core.serialization.Schema<
 9:     serializers.empathicVoice.ChatSocketResponse.Raw,
10:     Hume.empathicVoice.SubscribeEvent
11: > = core.serialization.undiscriminatedUnion([SubscribeEvent]);
12: 
13: export declare namespace ChatSocketResponse {
14:     export type Raw = SubscribeEvent.Raw;
15: }
````

## File: src/serialization/resources/empathicVoice/resources/chat/client/socket/index.ts
````typescript
1: export { ChatSocketResponse } from "./ChatSocketResponse.js";
````

## File: src/serialization/resources/empathicVoice/resources/chat/client/index.ts
````typescript
1: export * from "./socket/index.js";
````

## File: src/serialization/resources/empathicVoice/resources/chat/types/index.ts
````typescript
1: export * from "./PublishEvent.js";
````

## File: src/serialization/resources/empathicVoice/resources/chat/types/PublishEvent.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { AssistantInput } from "../../../types/AssistantInput.js";
 7: import { AudioInput } from "../../../types/AudioInput.js";
 8: import { PauseAssistantMessage } from "../../../types/PauseAssistantMessage.js";
 9: import { ResumeAssistantMessage } from "../../../types/ResumeAssistantMessage.js";
10: import { SessionSettings } from "../../../types/SessionSettings.js";
11: import { ToolErrorMessage } from "../../../types/ToolErrorMessage.js";
12: import { ToolResponseMessage } from "../../../types/ToolResponseMessage.js";
13: import { UserInput } from "../../../types/UserInput.js";
14: 
15: export const PublishEvent: core.serialization.Schema<
16:     serializers.empathicVoice.PublishEvent.Raw,
17:     Hume.empathicVoice.PublishEvent
18: > = core.serialization.undiscriminatedUnion([
19:     AudioInput,
20:     SessionSettings,
21:     UserInput,
22:     AssistantInput,
23:     ToolResponseMessage,
24:     ToolErrorMessage,
25:     PauseAssistantMessage,
26:     ResumeAssistantMessage,
27: ]);
28: 
29: export declare namespace PublishEvent {
30:     export type Raw =
31:         | AudioInput.Raw
32:         | SessionSettings.Raw
33:         | UserInput.Raw
34:         | AssistantInput.Raw
35:         | ToolResponseMessage.Raw
36:         | ToolErrorMessage.Raw
37:         | PauseAssistantMessage.Raw
38:         | ResumeAssistantMessage.Raw;
39: }
````

## File: src/serialization/resources/empathicVoice/resources/chat/types/SubscribeEvent.ts
````typescript
 1: /**
 2:  * This file was manually added to provide backward compatibility.
 3:  *
 4:  * @deprecated Use `serialization.empathicVoice.SubscribeEvent` instead.
 5:  * This serializer alias will be removed in a future version.
 6:  */
 7: 
 8: import { SubscribeEvent as NewSubscribeEvent } from "../../../types/SubscribeEvent.js";
 9: 
10: /**
11:  * @deprecated Use `serialization.empathicVoice.SubscribeEvent` instead.
12:  * This serializer alias will be removed in a future version.
13:  */
14: export const SubscribeEvent: typeof NewSubscribeEvent = NewSubscribeEvent;
15: 
16: export declare namespace SubscribeEvent {
17:     /**
18:      * @deprecated Use `serialization.empathicVoice.SubscribeEvent.Raw` instead.
19:      * This type alias will be removed in a future version.
20:      */
21:     export type Raw = NewSubscribeEvent.Raw;
22: }
````

## File: src/serialization/resources/empathicVoice/resources/chat/index.ts
````typescript
1: export * from "./client/index.js";
2: export * from "./types/index.js";
3: /**
4:  * @deprecated Use `serialization.empathicVoice.SubscribeEvent` instead.
5:  * This serializer alias will be removed in a future version.
6:  */
7: export { SubscribeEvent } from "./types/SubscribeEvent.js";
````

## File: src/serialization/resources/empathicVoice/resources/chat/index.ts.diff
````diff
 1: diff --git a/src/serialization/resources/empathicVoice/resources/chat/index.ts b/src/serialization/resources/empathicVoice/resources/chat/index.ts
 2: index f5ca113..d9adb1a 100644
 3: --- a/src/serialization/resources/empathicVoice/resources/chat/index.ts
 4: +++ b/src/serialization/resources/empathicVoice/resources/chat/index.ts
 5: @@ -1,7 +1,2 @@
 6:  export * from "./client/index.js";
 7:  export * from "./types/index.js";
 8: -/**
 9: - * @deprecated Use `serialization.empathicVoice.SubscribeEvent` instead.
10: - * This serializer alias will be removed in a future version.
11: - */
12: -export { SubscribeEvent } from "./types/SubscribeEvent.js";
````

## File: src/serialization/resources/empathicVoice/resources/configs/client/requests/index.ts
````typescript
1: export { PostedConfig } from "./PostedConfig.js";
2: export { PostedConfigName } from "./PostedConfigName.js";
3: export { PostedConfigVersion } from "./PostedConfigVersion.js";
4: export { PostedConfigVersionDescription } from "./PostedConfigVersionDescription.js";
````

## File: src/serialization/resources/empathicVoice/resources/configs/client/requests/PostedConfig.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: import { PostedBuiltinTool } from "../../../../types/PostedBuiltinTool.js";
 7: import { PostedConfigPromptSpec } from "../../../../types/PostedConfigPromptSpec.js";
 8: import { PostedEllmModel } from "../../../../types/PostedEllmModel.js";
 9: import { PostedEventMessageSpecs } from "../../../../types/PostedEventMessageSpecs.js";
10: import { PostedLanguageModel } from "../../../../types/PostedLanguageModel.js";
11: import { PostedNudgeSpec } from "../../../../types/PostedNudgeSpec.js";
12: import { PostedTimeoutSpecs } from "../../../../types/PostedTimeoutSpecs.js";
13: import { PostedUserDefinedToolSpec } from "../../../../types/PostedUserDefinedToolSpec.js";
14: import { PostedWebhookSpec } from "../../../../types/PostedWebhookSpec.js";
15: import { VoiceRef } from "../../../../types/VoiceRef.js";
16: 
17: export const PostedConfig: core.serialization.Schema<
18:     serializers.empathicVoice.PostedConfig.Raw,
19:     Hume.empathicVoice.PostedConfig
20: > = core.serialization.object({
21:     builtinTools: core.serialization.property(
22:         "builtin_tools",
23:         core.serialization.list(PostedBuiltinTool.optional()).optional(),
24:     ),
25:     ellmModel: core.serialization.property("ellm_model", PostedEllmModel.optional()),
26:     eventMessages: core.serialization.property("event_messages", PostedEventMessageSpecs.optional()),
27:     eviVersion: core.serialization.property("evi_version", core.serialization.string()),
28:     languageModel: core.serialization.property("language_model", PostedLanguageModel.optional()),
29:     name: core.serialization.string(),
30:     nudges: PostedNudgeSpec.optional(),
31:     prompt: PostedConfigPromptSpec.optional(),
32:     timeouts: PostedTimeoutSpecs.optional(),
33:     tools: core.serialization.list(PostedUserDefinedToolSpec.optional()).optional(),
34:     versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
35:     voice: VoiceRef.optional(),
36:     webhooks: core.serialization.list(PostedWebhookSpec.optional()).optional(),
37: });
38: 
39: export declare namespace PostedConfig {
40:     export interface Raw {
41:         builtin_tools?: (PostedBuiltinTool.Raw | null | undefined)[] | null;
42:         ellm_model?: PostedEllmModel.Raw | null;
43:         event_messages?: PostedEventMessageSpecs.Raw | null;
44:         evi_version: string;
45:         language_model?: PostedLanguageModel.Raw | null;
46:         name: string;
47:         nudges?: PostedNudgeSpec.Raw | null;
48:         prompt?: PostedConfigPromptSpec.Raw | null;
49:         timeouts?: PostedTimeoutSpecs.Raw | null;
50:         tools?: (PostedUserDefinedToolSpec.Raw | null | undefined)[] | null;
51:         version_description?: string | null;
52:         voice?: VoiceRef.Raw | null;
53:         webhooks?: (PostedWebhookSpec.Raw | null | undefined)[] | null;
54:     }
55: }
````

## File: src/serialization/resources/empathicVoice/resources/configs/client/requests/PostedConfigName.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: 
 7: export const PostedConfigName: core.serialization.Schema<
 8:     serializers.empathicVoice.PostedConfigName.Raw,
 9:     Hume.empathicVoice.PostedConfigName
10: > = core.serialization.object({
11:     name: core.serialization.string(),
12: });
13: 
14: export declare namespace PostedConfigName {
15:     export interface Raw {
16:         name: string;
17:     }
18: }
````

## File: src/serialization/resources/empathicVoice/resources/configs/client/requests/PostedConfigVersion.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: import { PostedBuiltinTool } from "../../../../types/PostedBuiltinTool.js";
 7: import { PostedConfigPromptSpec } from "../../../../types/PostedConfigPromptSpec.js";
 8: import { PostedEllmModel } from "../../../../types/PostedEllmModel.js";
 9: import { PostedEventMessageSpecs } from "../../../../types/PostedEventMessageSpecs.js";
10: import { PostedLanguageModel } from "../../../../types/PostedLanguageModel.js";
11: import { PostedNudgeSpec } from "../../../../types/PostedNudgeSpec.js";
12: import { PostedTimeoutSpecs } from "../../../../types/PostedTimeoutSpecs.js";
13: import { PostedUserDefinedToolSpec } from "../../../../types/PostedUserDefinedToolSpec.js";
14: import { PostedWebhookSpec } from "../../../../types/PostedWebhookSpec.js";
15: import { VoiceRef } from "../../../../types/VoiceRef.js";
16: 
17: export const PostedConfigVersion: core.serialization.Schema<
18:     serializers.empathicVoice.PostedConfigVersion.Raw,
19:     Hume.empathicVoice.PostedConfigVersion
20: > = core.serialization.object({
21:     builtinTools: core.serialization.property(
22:         "builtin_tools",
23:         core.serialization.list(PostedBuiltinTool.optional()).optional(),
24:     ),
25:     ellmModel: core.serialization.property("ellm_model", PostedEllmModel.optional()),
26:     eventMessages: core.serialization.property("event_messages", PostedEventMessageSpecs.optional()),
27:     eviVersion: core.serialization.property("evi_version", core.serialization.string()),
28:     languageModel: core.serialization.property("language_model", PostedLanguageModel.optional()),
29:     nudges: PostedNudgeSpec.optional(),
30:     prompt: PostedConfigPromptSpec.optional(),
31:     timeouts: PostedTimeoutSpecs.optional(),
32:     tools: core.serialization.list(PostedUserDefinedToolSpec.optional()).optional(),
33:     versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
34:     voice: VoiceRef.optional(),
35:     webhooks: core.serialization.list(PostedWebhookSpec.optional()).optional(),
36: });
37: 
38: export declare namespace PostedConfigVersion {
39:     export interface Raw {
40:         builtin_tools?: (PostedBuiltinTool.Raw | null | undefined)[] | null;
41:         ellm_model?: PostedEllmModel.Raw | null;
42:         event_messages?: PostedEventMessageSpecs.Raw | null;
43:         evi_version: string;
44:         language_model?: PostedLanguageModel.Raw | null;
45:         nudges?: PostedNudgeSpec.Raw | null;
46:         prompt?: PostedConfigPromptSpec.Raw | null;
47:         timeouts?: PostedTimeoutSpecs.Raw | null;
48:         tools?: (PostedUserDefinedToolSpec.Raw | null | undefined)[] | null;
49:         version_description?: string | null;
50:         voice?: VoiceRef.Raw | null;
51:         webhooks?: (PostedWebhookSpec.Raw | null | undefined)[] | null;
52:     }
53: }
````

## File: src/serialization/resources/empathicVoice/resources/configs/client/requests/PostedConfigVersionDescription.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: 
 7: export const PostedConfigVersionDescription: core.serialization.Schema<
 8:     serializers.empathicVoice.PostedConfigVersionDescription.Raw,
 9:     Hume.empathicVoice.PostedConfigVersionDescription
10: > = core.serialization.object({
11:     versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
12: });
13: 
14: export declare namespace PostedConfigVersionDescription {
15:     export interface Raw {
16:         version_description?: string | null;
17:     }
18: }
````

## File: src/serialization/resources/empathicVoice/resources/configs/client/index.ts
````typescript
1: export * from "./requests/index.js";
````

## File: src/serialization/resources/empathicVoice/resources/configs/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/serialization/resources/empathicVoice/resources/controlPlane/client/socket/ControlPlaneSocketResponse.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: import { SubscribeEvent } from "../../../../types/SubscribeEvent.js";
 7: 
 8: export const ControlPlaneSocketResponse: core.serialization.Schema<
 9:     serializers.empathicVoice.ControlPlaneSocketResponse.Raw,
10:     Hume.empathicVoice.SubscribeEvent
11: > = core.serialization.undiscriminatedUnion([SubscribeEvent]);
12: 
13: export declare namespace ControlPlaneSocketResponse {
14:     export type Raw = SubscribeEvent.Raw;
15: }
````

## File: src/serialization/resources/empathicVoice/resources/controlPlane/client/socket/index.ts
````typescript
1: export { ControlPlaneSocketResponse } from "./ControlPlaneSocketResponse.js";
````

## File: src/serialization/resources/empathicVoice/resources/controlPlane/client/index.ts
````typescript
1: export * from "./socket/index.js";
````

## File: src/serialization/resources/empathicVoice/resources/controlPlane/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/serialization/resources/empathicVoice/resources/prompts/client/requests/index.ts
````typescript
1: export { PostedPrompt } from "./PostedPrompt.js";
2: export { PostedPromptName } from "./PostedPromptName.js";
3: export { PostedPromptVersion } from "./PostedPromptVersion.js";
4: export { PostedPromptVersionDescription } from "./PostedPromptVersionDescription.js";
````

## File: src/serialization/resources/empathicVoice/resources/prompts/client/requests/PostedPrompt.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: 
 7: export const PostedPrompt: core.serialization.Schema<
 8:     serializers.empathicVoice.PostedPrompt.Raw,
 9:     Hume.empathicVoice.PostedPrompt
10: > = core.serialization.object({
11:     name: core.serialization.string(),
12:     text: core.serialization.string(),
13:     versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
14: });
15: 
16: export declare namespace PostedPrompt {
17:     export interface Raw {
18:         name: string;
19:         text: string;
20:         version_description?: string | null;
21:     }
22: }
````

## File: src/serialization/resources/empathicVoice/resources/prompts/client/requests/PostedPromptName.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: 
 7: export const PostedPromptName: core.serialization.Schema<
 8:     serializers.empathicVoice.PostedPromptName.Raw,
 9:     Hume.empathicVoice.PostedPromptName
10: > = core.serialization.object({
11:     name: core.serialization.string(),
12: });
13: 
14: export declare namespace PostedPromptName {
15:     export interface Raw {
16:         name: string;
17:     }
18: }
````

## File: src/serialization/resources/empathicVoice/resources/prompts/client/requests/PostedPromptVersion.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: 
 7: export const PostedPromptVersion: core.serialization.Schema<
 8:     serializers.empathicVoice.PostedPromptVersion.Raw,
 9:     Hume.empathicVoice.PostedPromptVersion
10: > = core.serialization.object({
11:     text: core.serialization.string(),
12:     versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
13: });
14: 
15: export declare namespace PostedPromptVersion {
16:     export interface Raw {
17:         text: string;
18:         version_description?: string | null;
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/resources/prompts/client/requests/PostedPromptVersionDescription.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: 
 7: export const PostedPromptVersionDescription: core.serialization.Schema<
 8:     serializers.empathicVoice.PostedPromptVersionDescription.Raw,
 9:     Hume.empathicVoice.PostedPromptVersionDescription
10: > = core.serialization.object({
11:     versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
12: });
13: 
14: export declare namespace PostedPromptVersionDescription {
15:     export interface Raw {
16:         version_description?: string | null;
17:     }
18: }
````

## File: src/serialization/resources/empathicVoice/resources/prompts/client/createPrompt.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import type * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { ReturnPrompt } from "../../../types/ReturnPrompt.js";
 7: 
 8: export const Response: core.serialization.Schema<
 9:     serializers.empathicVoice.prompts.createPrompt.Response.Raw,
10:     Hume.empathicVoice.ReturnPrompt | undefined
11: > = ReturnPrompt.optional();
12: 
13: export declare namespace Response {
14:     export type Raw = ReturnPrompt.Raw | null | undefined;
15: }
````

## File: src/serialization/resources/empathicVoice/resources/prompts/client/createPromptVersion.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import type * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { ReturnPrompt } from "../../../types/ReturnPrompt.js";
 7: 
 8: export const Response: core.serialization.Schema<
 9:     serializers.empathicVoice.prompts.createPromptVersion.Response.Raw,
10:     Hume.empathicVoice.ReturnPrompt | undefined
11: > = ReturnPrompt.optional();
12: 
13: export declare namespace Response {
14:     export type Raw = ReturnPrompt.Raw | null | undefined;
15: }
````

## File: src/serialization/resources/empathicVoice/resources/prompts/client/getPromptVersion.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import type * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { ReturnPrompt } from "../../../types/ReturnPrompt.js";
 7: 
 8: export const Response: core.serialization.Schema<
 9:     serializers.empathicVoice.prompts.getPromptVersion.Response.Raw,
10:     Hume.empathicVoice.ReturnPrompt | undefined
11: > = ReturnPrompt.optional();
12: 
13: export declare namespace Response {
14:     export type Raw = ReturnPrompt.Raw | null | undefined;
15: }
````

## File: src/serialization/resources/empathicVoice/resources/prompts/client/index.ts
````typescript
1: export * as createPrompt from "./createPrompt.js";
2: export * as createPromptVersion from "./createPromptVersion.js";
3: export * as getPromptVersion from "./getPromptVersion.js";
4: export * from "./requests/index.js";
5: export * as updatePromptDescription from "./updatePromptDescription.js";
````

## File: src/serialization/resources/empathicVoice/resources/prompts/client/updatePromptDescription.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import type * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { ReturnPrompt } from "../../../types/ReturnPrompt.js";
 7: 
 8: export const Response: core.serialization.Schema<
 9:     serializers.empathicVoice.prompts.updatePromptDescription.Response.Raw,
10:     Hume.empathicVoice.ReturnPrompt | undefined
11: > = ReturnPrompt.optional();
12: 
13: export declare namespace Response {
14:     export type Raw = ReturnPrompt.Raw | null | undefined;
15: }
````

## File: src/serialization/resources/empathicVoice/resources/prompts/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/serialization/resources/empathicVoice/resources/tools/client/requests/index.ts
````typescript
1: export { PostedUserDefinedTool } from "./PostedUserDefinedTool.js";
2: export { PostedUserDefinedToolName } from "./PostedUserDefinedToolName.js";
3: export { PostedUserDefinedToolVersion } from "./PostedUserDefinedToolVersion.js";
4: export { PostedUserDefinedToolVersionDescription } from "./PostedUserDefinedToolVersionDescription.js";
````

## File: src/serialization/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedTool.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: 
 7: export const PostedUserDefinedTool: core.serialization.Schema<
 8:     serializers.empathicVoice.PostedUserDefinedTool.Raw,
 9:     Hume.empathicVoice.PostedUserDefinedTool
10: > = core.serialization.object({
11:     description: core.serialization.string().optional(),
12:     fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
13:     name: core.serialization.string(),
14:     parameters: core.serialization.string(),
15:     versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
16: });
17: 
18: export declare namespace PostedUserDefinedTool {
19:     export interface Raw {
20:         description?: string | null;
21:         fallback_content?: string | null;
22:         name: string;
23:         parameters: string;
24:         version_description?: string | null;
25:     }
26: }
````

## File: src/serialization/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolName.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: 
 7: export const PostedUserDefinedToolName: core.serialization.Schema<
 8:     serializers.empathicVoice.PostedUserDefinedToolName.Raw,
 9:     Hume.empathicVoice.PostedUserDefinedToolName
10: > = core.serialization.object({
11:     name: core.serialization.string(),
12: });
13: 
14: export declare namespace PostedUserDefinedToolName {
15:     export interface Raw {
16:         name: string;
17:     }
18: }
````

## File: src/serialization/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolVersion.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: 
 7: export const PostedUserDefinedToolVersion: core.serialization.Schema<
 8:     serializers.empathicVoice.PostedUserDefinedToolVersion.Raw,
 9:     Hume.empathicVoice.PostedUserDefinedToolVersion
10: > = core.serialization.object({
11:     description: core.serialization.string().optional(),
12:     fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
13:     parameters: core.serialization.string(),
14:     versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
15: });
16: 
17: export declare namespace PostedUserDefinedToolVersion {
18:     export interface Raw {
19:         description?: string | null;
20:         fallback_content?: string | null;
21:         parameters: string;
22:         version_description?: string | null;
23:     }
24: }
````

## File: src/serialization/resources/empathicVoice/resources/tools/client/requests/PostedUserDefinedToolVersionDescription.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: 
 7: export const PostedUserDefinedToolVersionDescription: core.serialization.Schema<
 8:     serializers.empathicVoice.PostedUserDefinedToolVersionDescription.Raw,
 9:     Hume.empathicVoice.PostedUserDefinedToolVersionDescription
10: > = core.serialization.object({
11:     versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
12: });
13: 
14: export declare namespace PostedUserDefinedToolVersionDescription {
15:     export interface Raw {
16:         version_description?: string | null;
17:     }
18: }
````

## File: src/serialization/resources/empathicVoice/resources/tools/client/createTool.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import type * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { ReturnUserDefinedTool } from "../../../types/ReturnUserDefinedTool.js";
 7: 
 8: export const Response: core.serialization.Schema<
 9:     serializers.empathicVoice.tools.createTool.Response.Raw,
10:     Hume.empathicVoice.ReturnUserDefinedTool | undefined
11: > = ReturnUserDefinedTool.optional();
12: 
13: export declare namespace Response {
14:     export type Raw = ReturnUserDefinedTool.Raw | null | undefined;
15: }
````

## File: src/serialization/resources/empathicVoice/resources/tools/client/createToolVersion.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import type * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { ReturnUserDefinedTool } from "../../../types/ReturnUserDefinedTool.js";
 7: 
 8: export const Response: core.serialization.Schema<
 9:     serializers.empathicVoice.tools.createToolVersion.Response.Raw,
10:     Hume.empathicVoice.ReturnUserDefinedTool | undefined
11: > = ReturnUserDefinedTool.optional();
12: 
13: export declare namespace Response {
14:     export type Raw = ReturnUserDefinedTool.Raw | null | undefined;
15: }
````

## File: src/serialization/resources/empathicVoice/resources/tools/client/getToolVersion.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import type * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { ReturnUserDefinedTool } from "../../../types/ReturnUserDefinedTool.js";
 7: 
 8: export const Response: core.serialization.Schema<
 9:     serializers.empathicVoice.tools.getToolVersion.Response.Raw,
10:     Hume.empathicVoice.ReturnUserDefinedTool | undefined
11: > = ReturnUserDefinedTool.optional();
12: 
13: export declare namespace Response {
14:     export type Raw = ReturnUserDefinedTool.Raw | null | undefined;
15: }
````

## File: src/serialization/resources/empathicVoice/resources/tools/client/index.ts
````typescript
1: export * as createTool from "./createTool.js";
2: export * as createToolVersion from "./createToolVersion.js";
3: export * as getToolVersion from "./getToolVersion.js";
4: export * from "./requests/index.js";
5: export * as updateToolDescription from "./updateToolDescription.js";
````

## File: src/serialization/resources/empathicVoice/resources/tools/client/updateToolDescription.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import type * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { ReturnUserDefinedTool } from "../../../types/ReturnUserDefinedTool.js";
 7: 
 8: export const Response: core.serialization.Schema<
 9:     serializers.empathicVoice.tools.updateToolDescription.Response.Raw,
10:     Hume.empathicVoice.ReturnUserDefinedTool | undefined
11: > = ReturnUserDefinedTool.optional();
12: 
13: export declare namespace Response {
14:     export type Raw = ReturnUserDefinedTool.Raw | null | undefined;
15: }
````

## File: src/serialization/resources/empathicVoice/resources/tools/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/serialization/resources/empathicVoice/resources/index.ts
````typescript
 1: export * from "./chat/client/socket/index.js";
 2: export * as chat from "./chat/index.js";
 3: export * from "./chat/types/index.js";
 4: export * from "./configs/client/requests/index.js";
 5: export * as configs from "./configs/index.js";
 6: export * from "./controlPlane/client/socket/index.js";
 7: export * as controlPlane from "./controlPlane/index.js";
 8: export * from "./prompts/client/requests/index.js";
 9: export * as prompts from "./prompts/index.js";
10: export * from "./tools/client/requests/index.js";
11: export * as tools from "./tools/index.js";
````

## File: src/serialization/resources/empathicVoice/types/AssistantEnd.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const AssistantEnd: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.AssistantEnd.Raw,
 9:     Hume.empathicVoice.AssistantEnd
10: > = core.serialization.object({
11:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
12:     type: core.serialization.stringLiteral("assistant_end"),
13: });
14: 
15: export declare namespace AssistantEnd {
16:     export interface Raw {
17:         custom_session_id?: string | null;
18:         type: "assistant_end";
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/AssistantInput.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const AssistantInput: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.AssistantInput.Raw,
 9:     Hume.empathicVoice.AssistantInput
10: > = core.serialization.object({
11:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
12:     text: core.serialization.string(),
13:     type: core.serialization.stringLiteral("assistant_input"),
14: });
15: 
16: export declare namespace AssistantInput {
17:     export interface Raw {
18:         custom_session_id?: string | null;
19:         text: string;
20:         type: "assistant_input";
21:     }
22: }
````

## File: src/serialization/resources/empathicVoice/types/AssistantMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ChatMessage } from "./ChatMessage.js";
 7: import { Inference } from "./Inference.js";
 8: 
 9: export const AssistantMessage: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.AssistantMessage.Raw,
11:     Hume.empathicVoice.AssistantMessage
12: > = core.serialization.object({
13:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
14:     fromText: core.serialization.property("from_text", core.serialization.boolean()),
15:     id: core.serialization.string().optional(),
16:     isQuickResponse: core.serialization.property("is_quick_response", core.serialization.boolean()),
17:     language: core.serialization.string().optional(),
18:     message: ChatMessage,
19:     models: Inference,
20:     type: core.serialization.stringLiteral("assistant_message"),
21: });
22: 
23: export declare namespace AssistantMessage {
24:     export interface Raw {
25:         custom_session_id?: string | null;
26:         from_text: boolean;
27:         id?: string | null;
28:         is_quick_response: boolean;
29:         language?: string | null;
30:         message: ChatMessage.Raw;
31:         models: Inference.Raw;
32:         type: "assistant_message";
33:     }
34: }
````

## File: src/serialization/resources/empathicVoice/types/AssistantProsody.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { Inference } from "./Inference.js";
 7: 
 8: export const AssistantProsody: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.AssistantProsody.Raw,
10:     Hume.empathicVoice.AssistantProsody
11: > = core.serialization.object({
12:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
13:     id: core.serialization.string().optional(),
14:     models: Inference,
15:     type: core.serialization.stringLiteral("assistant_prosody"),
16: });
17: 
18: export declare namespace AssistantProsody {
19:     export interface Raw {
20:         custom_session_id?: string | null;
21:         id?: string | null;
22:         models: Inference.Raw;
23:         type: "assistant_prosody";
24:     }
25: }
````

## File: src/serialization/resources/empathicVoice/types/AudioConfiguration.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { Encoding } from "./Encoding.js";
 7: 
 8: export const AudioConfiguration: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.AudioConfiguration.Raw,
10:     Hume.empathicVoice.AudioConfiguration
11: > = core.serialization.object({
12:     channels: core.serialization.number(),
13:     codec: core.serialization.string().optional(),
14:     encoding: Encoding,
15:     sampleRate: core.serialization.property("sample_rate", core.serialization.number()),
16: });
17: 
18: export declare namespace AudioConfiguration {
19:     export interface Raw {
20:         channels: number;
21:         codec?: string | null;
22:         encoding: Encoding.Raw;
23:         sample_rate: number;
24:     }
25: }
````

## File: src/serialization/resources/empathicVoice/types/AudioInput.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const AudioInput: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.AudioInput.Raw,
 9:     Hume.empathicVoice.AudioInput
10: > = core.serialization.object({
11:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
12:     data: core.serialization.string(),
13:     type: core.serialization.stringLiteral("audio_input"),
14: });
15: 
16: export declare namespace AudioInput {
17:     export interface Raw {
18:         custom_session_id?: string | null;
19:         data: string;
20:         type: "audio_input";
21:     }
22: }
````

## File: src/serialization/resources/empathicVoice/types/AudioOutput.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const AudioOutput: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.AudioOutput.Raw,
 9:     Hume.empathicVoice.AudioOutput
10: > = core.serialization.object({
11:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
12:     data: core.serialization.string(),
13:     id: core.serialization.string(),
14:     index: core.serialization.number(),
15:     type: core.serialization.stringLiteral("audio_output"),
16: });
17: 
18: export declare namespace AudioOutput {
19:     export interface Raw {
20:         custom_session_id?: string | null;
21:         data: string;
22:         id: string;
23:         index: number;
24:         type: "audio_output";
25:     }
26: }
````

## File: src/serialization/resources/empathicVoice/types/BuiltInTool.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const BuiltInTool: core.serialization.Schema<
 8:     serializers.empathicVoice.BuiltInTool.Raw,
 9:     Hume.empathicVoice.BuiltInTool
10: > = core.serialization.enum_(["web_search", "hang_up"]);
11: 
12: export declare namespace BuiltInTool {
13:     export type Raw = "web_search" | "hang_up";
14: }
````

## File: src/serialization/resources/empathicVoice/types/BuiltinToolConfig.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { BuiltInTool } from "./BuiltInTool.js";
 7: 
 8: export const BuiltinToolConfig: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.BuiltinToolConfig.Raw,
10:     Hume.empathicVoice.BuiltinToolConfig
11: > = core.serialization.object({
12:     fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
13:     name: BuiltInTool,
14: });
15: 
16: export declare namespace BuiltinToolConfig {
17:     export interface Raw {
18:         fallback_content?: string | null;
19:         name: BuiltInTool.Raw;
20:     }
21: }
````

## File: src/serialization/resources/empathicVoice/types/ChatMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ChatMessageToolResult } from "./ChatMessageToolResult.js";
 7: import { Role } from "./Role.js";
 8: import { ToolCallMessage } from "./ToolCallMessage.js";
 9: 
10: export const ChatMessage: core.serialization.ObjectSchema<
11:     serializers.empathicVoice.ChatMessage.Raw,
12:     Hume.empathicVoice.ChatMessage
13: > = core.serialization.object({
14:     content: core.serialization.string().optional(),
15:     role: Role,
16:     toolCall: core.serialization.property("tool_call", ToolCallMessage.optional()),
17:     toolResult: core.serialization.property("tool_result", ChatMessageToolResult.optional()),
18: });
19: 
20: export declare namespace ChatMessage {
21:     export interface Raw {
22:         content?: string | null;
23:         role: Role.Raw;
24:         tool_call?: ToolCallMessage.Raw | null;
25:         tool_result?: ChatMessageToolResult.Raw | null;
26:     }
27: }
````

## File: src/serialization/resources/empathicVoice/types/ChatMessageToolResult.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ToolErrorMessage } from "./ToolErrorMessage.js";
 7: import { ToolResponseMessage } from "./ToolResponseMessage.js";
 8: 
 9: export const ChatMessageToolResult: core.serialization.Schema<
10:     serializers.empathicVoice.ChatMessageToolResult.Raw,
11:     Hume.empathicVoice.ChatMessageToolResult
12: > = core.serialization.undiscriminatedUnion([ToolResponseMessage, ToolErrorMessage]);
13: 
14: export declare namespace ChatMessageToolResult {
15:     export type Raw = ToolResponseMessage.Raw | ToolErrorMessage.Raw;
16: }
````

## File: src/serialization/resources/empathicVoice/types/ChatMetadata.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ChatMetadata: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.ChatMetadata.Raw,
 9:     Hume.empathicVoice.ChatMetadata
10: > = core.serialization.object({
11:     chatGroupId: core.serialization.property("chat_group_id", core.serialization.string()),
12:     chatId: core.serialization.property("chat_id", core.serialization.string()),
13:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
14:     requestId: core.serialization.property("request_id", core.serialization.string().optional()),
15:     type: core.serialization.stringLiteral("chat_metadata"),
16: });
17: 
18: export declare namespace ChatMetadata {
19:     export interface Raw {
20:         chat_group_id: string;
21:         chat_id: string;
22:         custom_session_id?: string | null;
23:         request_id?: string | null;
24:         type: "chat_metadata";
25:     }
26: }
````

## File: src/serialization/resources/empathicVoice/types/ConnectSessionSettings.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ConnectSessionSettingsAudio } from "./ConnectSessionSettingsAudio.js";
 7: import { ConnectSessionSettingsContext } from "./ConnectSessionSettingsContext.js";
 8: import { ConnectSessionSettingsVariablesValue } from "./ConnectSessionSettingsVariablesValue.js";
 9: 
10: export const ConnectSessionSettings: core.serialization.ObjectSchema<
11:     serializers.empathicVoice.ConnectSessionSettings.Raw,
12:     Hume.empathicVoice.ConnectSessionSettings
13: > = core.serialization.object({
14:     audio: ConnectSessionSettingsAudio.optional(),
15:     context: ConnectSessionSettingsContext.optional(),
16:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
17:     eventLimit: core.serialization.property("event_limit", core.serialization.number().optional()),
18:     languageModelApiKey: core.serialization.property("language_model_api_key", core.serialization.string().optional()),
19:     systemPrompt: core.serialization.property("system_prompt", core.serialization.string().optional()),
20:     voiceId: core.serialization.property("voice_id", core.serialization.string().optional()),
21:     variables: core.serialization.record(core.serialization.string(), ConnectSessionSettingsVariablesValue).optional(),
22: });
23: 
24: export declare namespace ConnectSessionSettings {
25:     export interface Raw {
26:         audio?: ConnectSessionSettingsAudio.Raw | null;
27:         context?: ConnectSessionSettingsContext.Raw | null;
28:         custom_session_id?: string | null;
29:         event_limit?: number | null;
30:         language_model_api_key?: string | null;
31:         system_prompt?: string | null;
32:         voice_id?: string | null;
33:         variables?: Record<string, ConnectSessionSettingsVariablesValue.Raw> | null;
34:     }
35: }
````

## File: src/serialization/resources/empathicVoice/types/ConnectSessionSettingsAudio.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { Encoding } from "./Encoding.js";
 7: 
 8: export const ConnectSessionSettingsAudio: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ConnectSessionSettingsAudio.Raw,
10:     Hume.empathicVoice.ConnectSessionSettingsAudio
11: > = core.serialization.object({
12:     channels: core.serialization.number().optional(),
13:     encoding: Encoding.optional(),
14:     sampleRate: core.serialization.property("sample_rate", core.serialization.number().optional()),
15: });
16: 
17: export declare namespace ConnectSessionSettingsAudio {
18:     export interface Raw {
19:         channels?: number | null;
20:         encoding?: Encoding.Raw | null;
21:         sample_rate?: number | null;
22:     }
23: }
````

## File: src/serialization/resources/empathicVoice/types/ConnectSessionSettingsContext.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ContextType } from "./ContextType.js";
 7: 
 8: export const ConnectSessionSettingsContext: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ConnectSessionSettingsContext.Raw,
10:     Hume.empathicVoice.ConnectSessionSettingsContext
11: > = core.serialization.object({
12:     text: core.serialization.string().optional(),
13:     type: ContextType.optional(),
14: });
15: 
16: export declare namespace ConnectSessionSettingsContext {
17:     export interface Raw {
18:         text?: string | null;
19:         type?: ContextType.Raw | null;
20:     }
21: }
````

## File: src/serialization/resources/empathicVoice/types/ConnectSessionSettingsVariablesValue.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ConnectSessionSettingsVariablesValue: core.serialization.Schema<
 8:     serializers.empathicVoice.ConnectSessionSettingsVariablesValue.Raw,
 9:     Hume.empathicVoice.ConnectSessionSettingsVariablesValue
10: > = core.serialization.undiscriminatedUnion([
11:     core.serialization.string(),
12:     core.serialization.number(),
13:     core.serialization.boolean(),
14: ]);
15: 
16: export declare namespace ConnectSessionSettingsVariablesValue {
17:     export type Raw = string | number | boolean;
18: }
````

## File: src/serialization/resources/empathicVoice/types/Context.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ContextType } from "./ContextType.js";
 7: 
 8: export const Context: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.Context.Raw,
10:     Hume.empathicVoice.Context
11: > = core.serialization.object({
12:     text: core.serialization.string(),
13:     type: ContextType.optional(),
14: });
15: 
16: export declare namespace Context {
17:     export interface Raw {
18:         text: string;
19:         type?: ContextType.Raw | null;
20:     }
21: }
````

## File: src/serialization/resources/empathicVoice/types/ContextType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ContextType: core.serialization.Schema<
 8:     serializers.empathicVoice.ContextType.Raw,
 9:     Hume.empathicVoice.ContextType
10: > = core.serialization.enum_(["persistent", "temporary"]);
11: 
12: export declare namespace ContextType {
13:     export type Raw = "persistent" | "temporary";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ControlPlanePublishEvent.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { AssistantInput } from "./AssistantInput.js";
 7: import { PauseAssistantMessage } from "./PauseAssistantMessage.js";
 8: import { ResumeAssistantMessage } from "./ResumeAssistantMessage.js";
 9: import { SessionSettings } from "./SessionSettings.js";
10: import { ToolErrorMessage } from "./ToolErrorMessage.js";
11: import { ToolResponseMessage } from "./ToolResponseMessage.js";
12: import { UserInput } from "./UserInput.js";
13: 
14: export const ControlPlanePublishEvent: core.serialization.Schema<
15:     serializers.empathicVoice.ControlPlanePublishEvent.Raw,
16:     Hume.empathicVoice.ControlPlanePublishEvent
17: > = core.serialization.undiscriminatedUnion([
18:     SessionSettings,
19:     UserInput,
20:     AssistantInput,
21:     ToolResponseMessage,
22:     ToolErrorMessage,
23:     PauseAssistantMessage,
24:     ResumeAssistantMessage,
25: ]);
26: 
27: export declare namespace ControlPlanePublishEvent {
28:     export type Raw =
29:         | SessionSettings.Raw
30:         | UserInput.Raw
31:         | AssistantInput.Raw
32:         | ToolResponseMessage.Raw
33:         | ToolErrorMessage.Raw
34:         | PauseAssistantMessage.Raw
35:         | ResumeAssistantMessage.Raw;
36: }
````

## File: src/serialization/resources/empathicVoice/types/EmotionScores.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import type * as Hume from "../../../../api/index.js";
  4: import * as core from "../../../../core/index.js";
  5: import type * as serializers from "../../../index.js";
  6: 
  7: export const EmotionScores: core.serialization.ObjectSchema<
  8:     serializers.empathicVoice.EmotionScores.Raw,
  9:     Hume.empathicVoice.EmotionScores
 10: > = core.serialization.object({
 11:     admiration: core.serialization.property("Admiration", core.serialization.number()),
 12:     adoration: core.serialization.property("Adoration", core.serialization.number()),
 13:     aestheticAppreciation: core.serialization.property("Aesthetic Appreciation", core.serialization.number()),
 14:     amusement: core.serialization.property("Amusement", core.serialization.number()),
 15:     anger: core.serialization.property("Anger", core.serialization.number()),
 16:     anxiety: core.serialization.property("Anxiety", core.serialization.number()),
 17:     awe: core.serialization.property("Awe", core.serialization.number()),
 18:     awkwardness: core.serialization.property("Awkwardness", core.serialization.number()),
 19:     boredom: core.serialization.property("Boredom", core.serialization.number()),
 20:     calmness: core.serialization.property("Calmness", core.serialization.number()),
 21:     concentration: core.serialization.property("Concentration", core.serialization.number()),
 22:     confusion: core.serialization.property("Confusion", core.serialization.number()),
 23:     contemplation: core.serialization.property("Contemplation", core.serialization.number()),
 24:     contempt: core.serialization.property("Contempt", core.serialization.number()),
 25:     contentment: core.serialization.property("Contentment", core.serialization.number()),
 26:     craving: core.serialization.property("Craving", core.serialization.number()),
 27:     desire: core.serialization.property("Desire", core.serialization.number()),
 28:     determination: core.serialization.property("Determination", core.serialization.number()),
 29:     disappointment: core.serialization.property("Disappointment", core.serialization.number()),
 30:     disgust: core.serialization.property("Disgust", core.serialization.number()),
 31:     distress: core.serialization.property("Distress", core.serialization.number()),
 32:     doubt: core.serialization.property("Doubt", core.serialization.number()),
 33:     ecstasy: core.serialization.property("Ecstasy", core.serialization.number()),
 34:     embarrassment: core.serialization.property("Embarrassment", core.serialization.number()),
 35:     empathicPain: core.serialization.property("Empathic Pain", core.serialization.number()),
 36:     entrancement: core.serialization.property("Entrancement", core.serialization.number()),
 37:     envy: core.serialization.property("Envy", core.serialization.number()),
 38:     excitement: core.serialization.property("Excitement", core.serialization.number()),
 39:     fear: core.serialization.property("Fear", core.serialization.number()),
 40:     guilt: core.serialization.property("Guilt", core.serialization.number()),
 41:     horror: core.serialization.property("Horror", core.serialization.number()),
 42:     interest: core.serialization.property("Interest", core.serialization.number()),
 43:     joy: core.serialization.property("Joy", core.serialization.number()),
 44:     love: core.serialization.property("Love", core.serialization.number()),
 45:     nostalgia: core.serialization.property("Nostalgia", core.serialization.number()),
 46:     pain: core.serialization.property("Pain", core.serialization.number()),
 47:     pride: core.serialization.property("Pride", core.serialization.number()),
 48:     realization: core.serialization.property("Realization", core.serialization.number()),
 49:     relief: core.serialization.property("Relief", core.serialization.number()),
 50:     romance: core.serialization.property("Romance", core.serialization.number()),
 51:     sadness: core.serialization.property("Sadness", core.serialization.number()),
 52:     satisfaction: core.serialization.property("Satisfaction", core.serialization.number()),
 53:     shame: core.serialization.property("Shame", core.serialization.number()),
 54:     surpriseNegative: core.serialization.property("Surprise (negative)", core.serialization.number()),
 55:     surprisePositive: core.serialization.property("Surprise (positive)", core.serialization.number()),
 56:     sympathy: core.serialization.property("Sympathy", core.serialization.number()),
 57:     tiredness: core.serialization.property("Tiredness", core.serialization.number()),
 58:     triumph: core.serialization.property("Triumph", core.serialization.number()),
 59: });
 60: 
 61: export declare namespace EmotionScores {
 62:     export interface Raw {
 63:         Admiration: number;
 64:         Adoration: number;
 65:         "Aesthetic Appreciation": number;
 66:         Amusement: number;
 67:         Anger: number;
 68:         Anxiety: number;
 69:         Awe: number;
 70:         Awkwardness: number;
 71:         Boredom: number;
 72:         Calmness: number;
 73:         Concentration: number;
 74:         Confusion: number;
 75:         Contemplation: number;
 76:         Contempt: number;
 77:         Contentment: number;
 78:         Craving: number;
 79:         Desire: number;
 80:         Determination: number;
 81:         Disappointment: number;
 82:         Disgust: number;
 83:         Distress: number;
 84:         Doubt: number;
 85:         Ecstasy: number;
 86:         Embarrassment: number;
 87:         "Empathic Pain": number;
 88:         Entrancement: number;
 89:         Envy: number;
 90:         Excitement: number;
 91:         Fear: number;
 92:         Guilt: number;
 93:         Horror: number;
 94:         Interest: number;
 95:         Joy: number;
 96:         Love: number;
 97:         Nostalgia: number;
 98:         Pain: number;
 99:         Pride: number;
100:         Realization: number;
101:         Relief: number;
102:         Romance: number;
103:         Sadness: number;
104:         Satisfaction: number;
105:         Shame: number;
106:         "Surprise (negative)": number;
107:         "Surprise (positive)": number;
108:         Sympathy: number;
109:         Tiredness: number;
110:         Triumph: number;
111:     }
112: }
````

## File: src/serialization/resources/empathicVoice/types/Encoding.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const Encoding: core.serialization.Schema<serializers.empathicVoice.Encoding.Raw, Hume.empathicVoice.Encoding> =
 8:     core.serialization.stringLiteral("linear16");
 9: 
10: export declare namespace Encoding {
11:     export type Raw = "linear16";
12: }
````

## File: src/serialization/resources/empathicVoice/types/ErrorLevel.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ErrorLevel: core.serialization.Schema<
 8:     serializers.empathicVoice.ErrorLevel.Raw,
 9:     Hume.empathicVoice.ErrorLevel
10: > = core.serialization.stringLiteral("warn");
11: 
12: export declare namespace ErrorLevel {
13:     export type Raw = "warn";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ErrorResponse.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ErrorResponse: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.ErrorResponse.Raw,
 9:     Hume.empathicVoice.ErrorResponse
10: > = core.serialization.object({
11:     code: core.serialization.string().optional(),
12:     error: core.serialization.string().optional(),
13:     message: core.serialization.string().optional(),
14: });
15: 
16: export declare namespace ErrorResponse {
17:     export interface Raw {
18:         code?: string | null;
19:         error?: string | null;
20:         message?: string | null;
21:     }
22: }
````

## File: src/serialization/resources/empathicVoice/types/HttpValidationError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ValidationError } from "./ValidationError.js";
 7: 
 8: export const HttpValidationError: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.HttpValidationError.Raw,
10:     Hume.empathicVoice.HttpValidationError
11: > = core.serialization.object({
12:     detail: core.serialization.list(ValidationError).optional(),
13: });
14: 
15: export declare namespace HttpValidationError {
16:     export interface Raw {
17:         detail?: ValidationError.Raw[] | null;
18:     }
19: }
````

## File: src/serialization/resources/empathicVoice/types/index.ts
````typescript
  1: export * from "./AssistantEnd.js";
  2: export * from "./AssistantInput.js";
  3: export * from "./AssistantMessage.js";
  4: export * from "./AssistantProsody.js";
  5: export * from "./AudioConfiguration.js";
  6: export * from "./AudioInput.js";
  7: export * from "./AudioOutput.js";
  8: export * from "./BuiltInTool.js";
  9: export * from "./BuiltinToolConfig.js";
 10: export * from "./ChatMessage.js";
 11: export * from "./ChatMessageToolResult.js";
 12: export * from "./ChatMetadata.js";
 13: export * from "./ConnectSessionSettings.js";
 14: export * from "./ConnectSessionSettingsAudio.js";
 15: export * from "./ConnectSessionSettingsContext.js";
 16: export * from "./ConnectSessionSettingsVariablesValue.js";
 17: export * from "./Context.js";
 18: export * from "./ContextType.js";
 19: export * from "./ControlPlanePublishEvent.js";
 20: export * from "./EmotionScores.js";
 21: export * from "./Encoding.js";
 22: export * from "./ErrorLevel.js";
 23: export * from "./ErrorResponse.js";
 24: export * from "./HttpValidationError.js";
 25: export * from "./Inference.js";
 26: export * from "./JsonMessage.js";
 27: export * from "./LanguageModelType.js";
 28: export * from "./MillisecondInterval.js";
 29: export * from "./ModelProviderEnum.js";
 30: export * from "./PauseAssistantMessage.js";
 31: export * from "./PostedBuiltinTool.js";
 32: export * from "./PostedBuiltinToolName.js";
 33: export * from "./PostedConfigPromptSpec.js";
 34: export * from "./PostedEllmModel.js";
 35: export * from "./PostedEventMessageSpec.js";
 36: export * from "./PostedEventMessageSpecs.js";
 37: export * from "./PostedLanguageModel.js";
 38: export * from "./PostedNudgeSpec.js";
 39: export * from "./PostedTimeoutSpec.js";
 40: export * from "./PostedTimeoutSpecs.js";
 41: export * from "./PostedTimeoutSpecsInactivity.js";
 42: export * from "./PostedTimeoutSpecsMaxDuration.js";
 43: export * from "./PostedUserDefinedToolSpec.js";
 44: export * from "./PostedWebhookEventType.js";
 45: export * from "./PostedWebhookSpec.js";
 46: export * from "./ProsodyInference.js";
 47: export * from "./ResumeAssistantMessage.js";
 48: export * from "./ReturnBuiltinTool.js";
 49: export * from "./ReturnBuiltinToolToolType.js";
 50: export * from "./ReturnChat.js";
 51: export * from "./ReturnChatAudioReconstruction.js";
 52: export * from "./ReturnChatAudioReconstructionStatus.js";
 53: export * from "./ReturnChatEvent.js";
 54: export * from "./ReturnChatEventRole.js";
 55: export * from "./ReturnChatEventType.js";
 56: export * from "./ReturnChatGroup.js";
 57: export * from "./ReturnChatGroupPagedAudioReconstructions.js";
 58: export * from "./ReturnChatGroupPagedAudioReconstructionsPaginationDirection.js";
 59: export * from "./ReturnChatGroupPagedChats.js";
 60: export * from "./ReturnChatGroupPagedChatsPaginationDirection.js";
 61: export * from "./ReturnChatGroupPagedEvents.js";
 62: export * from "./ReturnChatGroupPagedEventsPaginationDirection.js";
 63: export * from "./ReturnChatPagedEvents.js";
 64: export * from "./ReturnChatPagedEventsPaginationDirection.js";
 65: export * from "./ReturnChatPagedEventsStatus.js";
 66: export * from "./ReturnChatStatus.js";
 67: export * from "./ReturnConfig.js";
 68: export * from "./ReturnConfigSpec.js";
 69: export * from "./ReturnEllmModel.js";
 70: export * from "./ReturnEventMessageSpec.js";
 71: export * from "./ReturnEventMessageSpecs.js";
 72: export * from "./ReturnLanguageModel.js";
 73: export * from "./ReturnNudgeSpec.js";
 74: export * from "./ReturnPagedChatGroups.js";
 75: export * from "./ReturnPagedChatGroupsPaginationDirection.js";
 76: export * from "./ReturnPagedChats.js";
 77: export * from "./ReturnPagedChatsPaginationDirection.js";
 78: export * from "./ReturnPagedConfigs.js";
 79: export * from "./ReturnPagedPrompts.js";
 80: export * from "./ReturnPagedUserDefinedTools.js";
 81: export * from "./ReturnPrompt.js";
 82: export * from "./ReturnPromptVersionType.js";
 83: export * from "./ReturnTimeoutSpec.js";
 84: export * from "./ReturnTimeoutSpecs.js";
 85: export * from "./ReturnUserDefinedTool.js";
 86: export * from "./ReturnUserDefinedToolToolType.js";
 87: export * from "./ReturnUserDefinedToolVersionType.js";
 88: export * from "./ReturnVoice.js";
 89: export * from "./ReturnWebhookEventType.js";
 90: export * from "./ReturnWebhookSpec.js";
 91: export * from "./Role.js";
 92: export * from "./SessionSettings.js";
 93: export * from "./SessionSettingsVariablesValue.js";
 94: export * from "./SubscribeEvent.js";
 95: export * from "./Tool.js";
 96: export * from "./ToolCallMessage.js";
 97: export * from "./ToolErrorMessage.js";
 98: export * from "./ToolResponseMessage.js";
 99: export * from "./ToolType.js";
100: export * from "./UserInput.js";
101: export * from "./UserInterruption.js";
102: export * from "./UserMessage.js";
103: export * from "./ValidationError.js";
104: export * from "./ValidationErrorLocItem.js";
105: export * from "./VoiceId.js";
106: export * from "./VoiceName.js";
107: export * from "./VoiceProvider.js";
108: export * from "./VoiceRef.js";
109: export * from "./WebhookEvent.js";
110: export * from "./WebhookEventBase.js";
111: export * from "./WebhookEventChatEnded.js";
112: export * from "./WebhookEventChatStarted.js";
113: export * from "./WebhookEventChatStartType.js";
114: export * from "./WebhookEventChatStatus.js";
115: export * from "./WebhookEventToolCall.js";
116: export * from "./WebSocketError.js";
````

## File: src/serialization/resources/empathicVoice/types/Inference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ProsodyInference } from "./ProsodyInference.js";
 7: 
 8: export const Inference: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.Inference.Raw,
10:     Hume.empathicVoice.Inference
11: > = core.serialization.object({
12:     prosody: ProsodyInference.optional(),
13: });
14: 
15: export declare namespace Inference {
16:     export interface Raw {
17:         prosody?: ProsodyInference.Raw | null;
18:     }
19: }
````

## File: src/serialization/resources/empathicVoice/types/JsonMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { AssistantEnd } from "./AssistantEnd.js";
 7: import { AssistantMessage } from "./AssistantMessage.js";
 8: import { AssistantProsody } from "./AssistantProsody.js";
 9: import { ChatMetadata } from "./ChatMetadata.js";
10: import { SessionSettings } from "./SessionSettings.js";
11: import { ToolCallMessage } from "./ToolCallMessage.js";
12: import { ToolErrorMessage } from "./ToolErrorMessage.js";
13: import { ToolResponseMessage } from "./ToolResponseMessage.js";
14: import { UserInterruption } from "./UserInterruption.js";
15: import { UserMessage } from "./UserMessage.js";
16: import { WebSocketError } from "./WebSocketError.js";
17: 
18: export const JsonMessage: core.serialization.Schema<
19:     serializers.empathicVoice.JsonMessage.Raw,
20:     Hume.empathicVoice.JsonMessage
21: > = core.serialization.undiscriminatedUnion([
22:     AssistantEnd,
23:     AssistantMessage,
24:     AssistantProsody,
25:     ChatMetadata,
26:     WebSocketError,
27:     UserInterruption,
28:     UserMessage,
29:     ToolCallMessage,
30:     ToolResponseMessage,
31:     ToolErrorMessage,
32:     SessionSettings,
33: ]);
34: 
35: export declare namespace JsonMessage {
36:     export type Raw =
37:         | AssistantEnd.Raw
38:         | AssistantMessage.Raw
39:         | AssistantProsody.Raw
40:         | ChatMetadata.Raw
41:         | WebSocketError.Raw
42:         | UserInterruption.Raw
43:         | UserMessage.Raw
44:         | ToolCallMessage.Raw
45:         | ToolResponseMessage.Raw
46:         | ToolErrorMessage.Raw
47:         | SessionSettings.Raw;
48: }
````

## File: src/serialization/resources/empathicVoice/types/LanguageModelType.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import type * as Hume from "../../../../api/index.js";
  4: import * as core from "../../../../core/index.js";
  5: import type * as serializers from "../../../index.js";
  6: 
  7: export const LanguageModelType: core.serialization.Schema<
  8:     serializers.empathicVoice.LanguageModelType.Raw,
  9:     Hume.empathicVoice.LanguageModelType
 10: > = core.serialization.enum_([
 11:     "claude-3-7-sonnet-latest",
 12:     "claude-3-5-sonnet-latest",
 13:     "claude-3-5-haiku-latest",
 14:     "claude-3-5-sonnet-20240620",
 15:     "claude-3-opus-20240229",
 16:     "claude-3-sonnet-20240229",
 17:     "claude-3-haiku-20240307",
 18:     "claude-sonnet-4-20250514",
 19:     "claude-sonnet-4-5-20250929",
 20:     "claude-haiku-4-5-20251001",
 21:     "us.anthropic.claude-3-5-haiku-20241022-v1:0",
 22:     "us.anthropic.claude-3-5-sonnet-20240620-v1:0",
 23:     "us.anthropic.claude-3-haiku-20240307-v1:0",
 24:     "gpt-oss-120b",
 25:     "qwen-3-235b-a22b",
 26:     "qwen-3-235b-a22b-instruct-2507",
 27:     "qwen-3-235b-a22b-thinking-2507",
 28:     "gemini-1.5-pro",
 29:     "gemini-1.5-flash",
 30:     "gemini-1.5-pro-002",
 31:     "gemini-1.5-flash-002",
 32:     "gemini-2.0-flash",
 33:     "gemini-2.5-flash",
 34:     "gemini-2.5-flash-preview-04-17",
 35:     "gpt-4-turbo",
 36:     "gpt-4-turbo-preview",
 37:     "gpt-3.5-turbo-0125",
 38:     "gpt-3.5-turbo",
 39:     "gpt-4o",
 40:     "gpt-4o-mini",
 41:     "gpt-4.1",
 42:     "gpt-5",
 43:     "gpt-5-mini",
 44:     "gpt-5-nano",
 45:     "gpt-4o-priority",
 46:     "gpt-4o-mini-priority",
 47:     "gpt-4.1-priority",
 48:     "gpt-5-priority",
 49:     "gpt-5-mini-priority",
 50:     "gpt-5-nano-priority",
 51:     "gemma-7b-it",
 52:     "llama3-8b-8192",
 53:     "llama3-70b-8192",
 54:     "llama-3.1-70b-versatile",
 55:     "llama-3.3-70b-versatile",
 56:     "llama-3.1-8b-instant",
 57:     "moonshotai/kimi-k2-instruct",
 58:     "accounts/fireworks/models/mixtral-8x7b-instruct",
 59:     "accounts/fireworks/models/llama-v3p1-405b-instruct",
 60:     "accounts/fireworks/models/llama-v3p1-70b-instruct",
 61:     "accounts/fireworks/models/llama-v3p1-8b-instruct",
 62:     "sonar",
 63:     "sonar-pro",
 64:     "sambanova",
 65:     "DeepSeek-R1-Distill-Llama-70B",
 66:     "Llama-4-Maverick-17B-128E-Instruct",
 67:     "Qwen3-32B",
 68:     "grok-4-fast-non-reasoning-latest",
 69:     "ellm",
 70:     "custom-language-model",
 71:     "hume-evi-3-web-search",
 72: ]);
 73: 
 74: export declare namespace LanguageModelType {
 75:     export type Raw =
 76:         | "claude-3-7-sonnet-latest"
 77:         | "claude-3-5-sonnet-latest"
 78:         | "claude-3-5-haiku-latest"
 79:         | "claude-3-5-sonnet-20240620"
 80:         | "claude-3-opus-20240229"
 81:         | "claude-3-sonnet-20240229"
 82:         | "claude-3-haiku-20240307"
 83:         | "claude-sonnet-4-20250514"
 84:         | "claude-sonnet-4-5-20250929"
 85:         | "claude-haiku-4-5-20251001"
 86:         | "us.anthropic.claude-3-5-haiku-20241022-v1:0"
 87:         | "us.anthropic.claude-3-5-sonnet-20240620-v1:0"
 88:         | "us.anthropic.claude-3-haiku-20240307-v1:0"
 89:         | "gpt-oss-120b"
 90:         | "qwen-3-235b-a22b"
 91:         | "qwen-3-235b-a22b-instruct-2507"
 92:         | "qwen-3-235b-a22b-thinking-2507"
 93:         | "gemini-1.5-pro"
 94:         | "gemini-1.5-flash"
 95:         | "gemini-1.5-pro-002"
 96:         | "gemini-1.5-flash-002"
 97:         | "gemini-2.0-flash"
 98:         | "gemini-2.5-flash"
 99:         | "gemini-2.5-flash-preview-04-17"
100:         | "gpt-4-turbo"
101:         | "gpt-4-turbo-preview"
102:         | "gpt-3.5-turbo-0125"
103:         | "gpt-3.5-turbo"
104:         | "gpt-4o"
105:         | "gpt-4o-mini"
106:         | "gpt-4.1"
107:         | "gpt-5"
108:         | "gpt-5-mini"
109:         | "gpt-5-nano"
110:         | "gpt-4o-priority"
111:         | "gpt-4o-mini-priority"
112:         | "gpt-4.1-priority"
113:         | "gpt-5-priority"
114:         | "gpt-5-mini-priority"
115:         | "gpt-5-nano-priority"
116:         | "gemma-7b-it"
117:         | "llama3-8b-8192"
118:         | "llama3-70b-8192"
119:         | "llama-3.1-70b-versatile"
120:         | "llama-3.3-70b-versatile"
121:         | "llama-3.1-8b-instant"
122:         | "moonshotai/kimi-k2-instruct"
123:         | "accounts/fireworks/models/mixtral-8x7b-instruct"
124:         | "accounts/fireworks/models/llama-v3p1-405b-instruct"
125:         | "accounts/fireworks/models/llama-v3p1-70b-instruct"
126:         | "accounts/fireworks/models/llama-v3p1-8b-instruct"
127:         | "sonar"
128:         | "sonar-pro"
129:         | "sambanova"
130:         | "DeepSeek-R1-Distill-Llama-70B"
131:         | "Llama-4-Maverick-17B-128E-Instruct"
132:         | "Qwen3-32B"
133:         | "grok-4-fast-non-reasoning-latest"
134:         | "ellm"
135:         | "custom-language-model"
136:         | "hume-evi-3-web-search";
137: }
````

## File: src/serialization/resources/empathicVoice/types/MillisecondInterval.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const MillisecondInterval: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.MillisecondInterval.Raw,
 9:     Hume.empathicVoice.MillisecondInterval
10: > = core.serialization.object({
11:     begin: core.serialization.number(),
12:     end: core.serialization.number(),
13: });
14: 
15: export declare namespace MillisecondInterval {
16:     export interface Raw {
17:         begin: number;
18:         end: number;
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/ModelProviderEnum.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ModelProviderEnum: core.serialization.Schema<
 8:     serializers.empathicVoice.ModelProviderEnum.Raw,
 9:     Hume.empathicVoice.ModelProviderEnum
10: > = core.serialization.enum_([
11:     "GROQ",
12:     "OPEN_AI",
13:     "FIREWORKS",
14:     "ANTHROPIC",
15:     "CUSTOM_LANGUAGE_MODEL",
16:     "GOOGLE",
17:     "HUME_AI",
18:     "AMAZON_BEDROCK",
19:     "PERPLEXITY",
20:     "SAMBANOVA",
21:     "CEREBRAS",
22: ]);
23: 
24: export declare namespace ModelProviderEnum {
25:     export type Raw =
26:         | "GROQ"
27:         | "OPEN_AI"
28:         | "FIREWORKS"
29:         | "ANTHROPIC"
30:         | "CUSTOM_LANGUAGE_MODEL"
31:         | "GOOGLE"
32:         | "HUME_AI"
33:         | "AMAZON_BEDROCK"
34:         | "PERPLEXITY"
35:         | "SAMBANOVA"
36:         | "CEREBRAS";
37: }
````

## File: src/serialization/resources/empathicVoice/types/PauseAssistantMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const PauseAssistantMessage: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.PauseAssistantMessage.Raw,
 9:     Hume.empathicVoice.PauseAssistantMessage
10: > = core.serialization.object({
11:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
12:     type: core.serialization.stringLiteral("pause_assistant_message"),
13: });
14: 
15: export declare namespace PauseAssistantMessage {
16:     export interface Raw {
17:         custom_session_id?: string | null;
18:         type: "pause_assistant_message";
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/PostedBuiltinTool.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { PostedBuiltinToolName } from "./PostedBuiltinToolName.js";
 7: 
 8: export const PostedBuiltinTool: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.PostedBuiltinTool.Raw,
10:     Hume.empathicVoice.PostedBuiltinTool
11: > = core.serialization.object({
12:     fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
13:     name: PostedBuiltinToolName,
14: });
15: 
16: export declare namespace PostedBuiltinTool {
17:     export interface Raw {
18:         fallback_content?: string | null;
19:         name: PostedBuiltinToolName.Raw;
20:     }
21: }
````

## File: src/serialization/resources/empathicVoice/types/PostedBuiltinToolName.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const PostedBuiltinToolName: core.serialization.Schema<
 8:     serializers.empathicVoice.PostedBuiltinToolName.Raw,
 9:     Hume.empathicVoice.PostedBuiltinToolName
10: > = core.serialization.enum_(["web_search", "hang_up"]);
11: 
12: export declare namespace PostedBuiltinToolName {
13:     export type Raw = "web_search" | "hang_up";
14: }
````

## File: src/serialization/resources/empathicVoice/types/PostedConfigPromptSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const PostedConfigPromptSpec: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.PostedConfigPromptSpec.Raw,
 9:     Hume.empathicVoice.PostedConfigPromptSpec
10: > = core.serialization.object({
11:     id: core.serialization.string().optional(),
12:     text: core.serialization.string().optional(),
13:     version: core.serialization.number().optional(),
14: });
15: 
16: export declare namespace PostedConfigPromptSpec {
17:     export interface Raw {
18:         id?: string | null;
19:         text?: string | null;
20:         version?: number | null;
21:     }
22: }
````

## File: src/serialization/resources/empathicVoice/types/PostedEllmModel.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const PostedEllmModel: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.PostedEllmModel.Raw,
 9:     Hume.empathicVoice.PostedEllmModel
10: > = core.serialization.object({
11:     allowShortResponses: core.serialization.property("allow_short_responses", core.serialization.boolean().optional()),
12: });
13: 
14: export declare namespace PostedEllmModel {
15:     export interface Raw {
16:         allow_short_responses?: boolean | null;
17:     }
18: }
````

## File: src/serialization/resources/empathicVoice/types/PostedEventMessageSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const PostedEventMessageSpec: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.PostedEventMessageSpec.Raw,
 9:     Hume.empathicVoice.PostedEventMessageSpec
10: > = core.serialization.object({
11:     enabled: core.serialization.boolean(),
12:     text: core.serialization.string().optional(),
13: });
14: 
15: export declare namespace PostedEventMessageSpec {
16:     export interface Raw {
17:         enabled: boolean;
18:         text?: string | null;
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/PostedEventMessageSpecs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { PostedEventMessageSpec } from "./PostedEventMessageSpec.js";
 7: 
 8: export const PostedEventMessageSpecs: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.PostedEventMessageSpecs.Raw,
10:     Hume.empathicVoice.PostedEventMessageSpecs
11: > = core.serialization.object({
12:     onInactivityTimeout: core.serialization.property("on_inactivity_timeout", PostedEventMessageSpec.optional()),
13:     onMaxDurationTimeout: core.serialization.property("on_max_duration_timeout", PostedEventMessageSpec.optional()),
14:     onNewChat: core.serialization.property("on_new_chat", PostedEventMessageSpec.optional()),
15: });
16: 
17: export declare namespace PostedEventMessageSpecs {
18:     export interface Raw {
19:         on_inactivity_timeout?: PostedEventMessageSpec.Raw | null;
20:         on_max_duration_timeout?: PostedEventMessageSpec.Raw | null;
21:         on_new_chat?: PostedEventMessageSpec.Raw | null;
22:     }
23: }
````

## File: src/serialization/resources/empathicVoice/types/PostedLanguageModel.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { LanguageModelType } from "./LanguageModelType.js";
 7: import { ModelProviderEnum } from "./ModelProviderEnum.js";
 8: 
 9: export const PostedLanguageModel: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.PostedLanguageModel.Raw,
11:     Hume.empathicVoice.PostedLanguageModel
12: > = core.serialization.object({
13:     modelProvider: core.serialization.property("model_provider", ModelProviderEnum.optional()),
14:     modelResource: core.serialization.property("model_resource", LanguageModelType.optional()),
15:     temperature: core.serialization.number().optional(),
16: });
17: 
18: export declare namespace PostedLanguageModel {
19:     export interface Raw {
20:         model_provider?: ModelProviderEnum.Raw | null;
21:         model_resource?: LanguageModelType.Raw | null;
22:         temperature?: number | null;
23:     }
24: }
````

## File: src/serialization/resources/empathicVoice/types/PostedNudgeSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const PostedNudgeSpec: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.PostedNudgeSpec.Raw,
 9:     Hume.empathicVoice.PostedNudgeSpec
10: > = core.serialization.object({
11:     enabled: core.serialization.boolean().optional(),
12:     intervalSecs: core.serialization.property("interval_secs", core.serialization.number().optional()),
13: });
14: 
15: export declare namespace PostedNudgeSpec {
16:     export interface Raw {
17:         enabled?: boolean | null;
18:         interval_secs?: number | null;
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/PostedTimeoutSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const PostedTimeoutSpec: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.PostedTimeoutSpec.Raw,
 9:     Hume.empathicVoice.PostedTimeoutSpec
10: > = core.serialization.object({
11:     durationSecs: core.serialization.property("duration_secs", core.serialization.number().optional()),
12:     enabled: core.serialization.boolean(),
13: });
14: 
15: export declare namespace PostedTimeoutSpec {
16:     export interface Raw {
17:         duration_secs?: number | null;
18:         enabled: boolean;
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/PostedTimeoutSpecs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { PostedTimeoutSpecsInactivity } from "./PostedTimeoutSpecsInactivity.js";
 7: import { PostedTimeoutSpecsMaxDuration } from "./PostedTimeoutSpecsMaxDuration.js";
 8: 
 9: export const PostedTimeoutSpecs: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.PostedTimeoutSpecs.Raw,
11:     Hume.empathicVoice.PostedTimeoutSpecs
12: > = core.serialization.object({
13:     inactivity: PostedTimeoutSpecsInactivity.optional(),
14:     maxDuration: core.serialization.property("max_duration", PostedTimeoutSpecsMaxDuration.optional()),
15: });
16: 
17: export declare namespace PostedTimeoutSpecs {
18:     export interface Raw {
19:         inactivity?: PostedTimeoutSpecsInactivity.Raw | null;
20:         max_duration?: PostedTimeoutSpecsMaxDuration.Raw | null;
21:     }
22: }
````

## File: src/serialization/resources/empathicVoice/types/PostedTimeoutSpecsInactivity.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const PostedTimeoutSpecsInactivity: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.PostedTimeoutSpecsInactivity.Raw,
 9:     Hume.empathicVoice.PostedTimeoutSpecsInactivity
10: > = core.serialization.object({
11:     durationSecs: core.serialization.property("duration_secs", core.serialization.number().optional()),
12:     enabled: core.serialization.boolean(),
13: });
14: 
15: export declare namespace PostedTimeoutSpecsInactivity {
16:     export interface Raw {
17:         duration_secs?: number | null;
18:         enabled: boolean;
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/PostedTimeoutSpecsMaxDuration.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const PostedTimeoutSpecsMaxDuration: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.PostedTimeoutSpecsMaxDuration.Raw,
 9:     Hume.empathicVoice.PostedTimeoutSpecsMaxDuration
10: > = core.serialization.object({
11:     durationSecs: core.serialization.property("duration_secs", core.serialization.number().optional()),
12:     enabled: core.serialization.boolean(),
13: });
14: 
15: export declare namespace PostedTimeoutSpecsMaxDuration {
16:     export interface Raw {
17:         duration_secs?: number | null;
18:         enabled: boolean;
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/PostedUserDefinedToolSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const PostedUserDefinedToolSpec: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.PostedUserDefinedToolSpec.Raw,
 9:     Hume.empathicVoice.PostedUserDefinedToolSpec
10: > = core.serialization.object({
11:     id: core.serialization.string(),
12:     version: core.serialization.number().optional(),
13: });
14: 
15: export declare namespace PostedUserDefinedToolSpec {
16:     export interface Raw {
17:         id: string;
18:         version?: number | null;
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/PostedWebhookEventType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const PostedWebhookEventType: core.serialization.Schema<
 8:     serializers.empathicVoice.PostedWebhookEventType.Raw,
 9:     Hume.empathicVoice.PostedWebhookEventType
10: > = core.serialization.enum_(["chat_started", "chat_ended", "tool_call"]);
11: 
12: export declare namespace PostedWebhookEventType {
13:     export type Raw = "chat_started" | "chat_ended" | "tool_call";
14: }
````

## File: src/serialization/resources/empathicVoice/types/PostedWebhookSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { PostedWebhookEventType } from "./PostedWebhookEventType.js";
 7: 
 8: export const PostedWebhookSpec: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.PostedWebhookSpec.Raw,
10:     Hume.empathicVoice.PostedWebhookSpec
11: > = core.serialization.object({
12:     events: core.serialization.list(PostedWebhookEventType),
13:     url: core.serialization.string(),
14: });
15: 
16: export declare namespace PostedWebhookSpec {
17:     export interface Raw {
18:         events: PostedWebhookEventType.Raw[];
19:         url: string;
20:     }
21: }
````

## File: src/serialization/resources/empathicVoice/types/ProsodyInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { EmotionScores } from "./EmotionScores.js";
 7: 
 8: export const ProsodyInference: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ProsodyInference.Raw,
10:     Hume.empathicVoice.ProsodyInference
11: > = core.serialization.object({
12:     scores: EmotionScores,
13: });
14: 
15: export declare namespace ProsodyInference {
16:     export interface Raw {
17:         scores: EmotionScores.Raw;
18:     }
19: }
````

## File: src/serialization/resources/empathicVoice/types/ResumeAssistantMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ResumeAssistantMessage: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.ResumeAssistantMessage.Raw,
 9:     Hume.empathicVoice.ResumeAssistantMessage
10: > = core.serialization.object({
11:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
12:     type: core.serialization.stringLiteral("resume_assistant_message"),
13: });
14: 
15: export declare namespace ResumeAssistantMessage {
16:     export interface Raw {
17:         custom_session_id?: string | null;
18:         type: "resume_assistant_message";
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnBuiltinTool.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnBuiltinToolToolType } from "./ReturnBuiltinToolToolType.js";
 7: 
 8: export const ReturnBuiltinTool: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ReturnBuiltinTool.Raw,
10:     Hume.empathicVoice.ReturnBuiltinTool
11: > = core.serialization.object({
12:     fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
13:     name: core.serialization.string(),
14:     toolType: core.serialization.property("tool_type", ReturnBuiltinToolToolType),
15: });
16: 
17: export declare namespace ReturnBuiltinTool {
18:     export interface Raw {
19:         fallback_content?: string | null;
20:         name: string;
21:         tool_type: ReturnBuiltinToolToolType.Raw;
22:     }
23: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnBuiltinToolToolType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnBuiltinToolToolType: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnBuiltinToolToolType.Raw,
 9:     Hume.empathicVoice.ReturnBuiltinToolToolType
10: > = core.serialization.enum_(["BUILTIN", "FUNCTION"]);
11: 
12: export declare namespace ReturnBuiltinToolToolType {
13:     export type Raw = "BUILTIN" | "FUNCTION";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChat.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnChatStatus } from "./ReturnChatStatus.js";
 7: import { ReturnConfigSpec } from "./ReturnConfigSpec.js";
 8: 
 9: export const ReturnChat: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.ReturnChat.Raw,
11:     Hume.empathicVoice.ReturnChat
12: > = core.serialization.object({
13:     chatGroupId: core.serialization.property("chat_group_id", core.serialization.string()),
14:     config: ReturnConfigSpec.optional(),
15:     endTimestamp: core.serialization.property("end_timestamp", core.serialization.number().optional()),
16:     eventCount: core.serialization.property("event_count", core.serialization.number().optional()),
17:     id: core.serialization.string(),
18:     metadata: core.serialization.string().optional(),
19:     startTimestamp: core.serialization.property("start_timestamp", core.serialization.number()),
20:     status: ReturnChatStatus,
21: });
22: 
23: export declare namespace ReturnChat {
24:     export interface Raw {
25:         chat_group_id: string;
26:         config?: ReturnConfigSpec.Raw | null;
27:         end_timestamp?: number | null;
28:         event_count?: number | null;
29:         id: string;
30:         metadata?: string | null;
31:         start_timestamp: number;
32:         status: ReturnChatStatus.Raw;
33:     }
34: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatAudioReconstruction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnChatAudioReconstructionStatus } from "./ReturnChatAudioReconstructionStatus.js";
 7: 
 8: export const ReturnChatAudioReconstruction: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ReturnChatAudioReconstruction.Raw,
10:     Hume.empathicVoice.ReturnChatAudioReconstruction
11: > = core.serialization.object({
12:     filename: core.serialization.string().optional(),
13:     id: core.serialization.string(),
14:     modifiedAt: core.serialization.property("modified_at", core.serialization.number().optional()),
15:     signedAudioUrl: core.serialization.property("signed_audio_url", core.serialization.string().optional()),
16:     signedUrlExpirationTimestampMillis: core.serialization.property(
17:         "signed_url_expiration_timestamp_millis",
18:         core.serialization.number().optional(),
19:     ),
20:     status: ReturnChatAudioReconstructionStatus,
21:     userId: core.serialization.property("user_id", core.serialization.string()),
22: });
23: 
24: export declare namespace ReturnChatAudioReconstruction {
25:     export interface Raw {
26:         filename?: string | null;
27:         id: string;
28:         modified_at?: number | null;
29:         signed_audio_url?: string | null;
30:         signed_url_expiration_timestamp_millis?: number | null;
31:         status: ReturnChatAudioReconstructionStatus.Raw;
32:         user_id: string;
33:     }
34: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatAudioReconstructionStatus.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnChatAudioReconstructionStatus: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnChatAudioReconstructionStatus.Raw,
 9:     Hume.empathicVoice.ReturnChatAudioReconstructionStatus
10: > = core.serialization.enum_(["QUEUED", "IN_PROGRESS", "COMPLETE", "ERROR", "CANCELLED"]);
11: 
12: export declare namespace ReturnChatAudioReconstructionStatus {
13:     export type Raw = "QUEUED" | "IN_PROGRESS" | "COMPLETE" | "ERROR" | "CANCELLED";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatEvent.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnChatEventRole } from "./ReturnChatEventRole.js";
 7: import { ReturnChatEventType } from "./ReturnChatEventType.js";
 8: 
 9: export const ReturnChatEvent: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.ReturnChatEvent.Raw,
11:     Hume.empathicVoice.ReturnChatEvent
12: > = core.serialization.object({
13:     chatId: core.serialization.property("chat_id", core.serialization.string()),
14:     emotionFeatures: core.serialization.property("emotion_features", core.serialization.string().optional()),
15:     id: core.serialization.string(),
16:     messageText: core.serialization.property("message_text", core.serialization.string().optional()),
17:     metadata: core.serialization.string().optional(),
18:     relatedEventId: core.serialization.property("related_event_id", core.serialization.string().optional()),
19:     role: ReturnChatEventRole,
20:     timestamp: core.serialization.number(),
21:     type: ReturnChatEventType,
22: });
23: 
24: export declare namespace ReturnChatEvent {
25:     export interface Raw {
26:         chat_id: string;
27:         emotion_features?: string | null;
28:         id: string;
29:         message_text?: string | null;
30:         metadata?: string | null;
31:         related_event_id?: string | null;
32:         role: ReturnChatEventRole.Raw;
33:         timestamp: number;
34:         type: ReturnChatEventType.Raw;
35:     }
36: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatEventRole.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnChatEventRole: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnChatEventRole.Raw,
 9:     Hume.empathicVoice.ReturnChatEventRole
10: > = core.serialization.enum_(["USER", "AGENT", "SYSTEM", "TOOL"]);
11: 
12: export declare namespace ReturnChatEventRole {
13:     export type Raw = "USER" | "AGENT" | "SYSTEM" | "TOOL";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatEventType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnChatEventType: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnChatEventType.Raw,
 9:     Hume.empathicVoice.ReturnChatEventType
10: > = core.serialization.enum_([
11:     "FUNCTION_CALL",
12:     "FUNCTION_CALL_RESPONSE",
13:     "CHAT_END_MESSAGE",
14:     "AGENT_MESSAGE",
15:     "SYSTEM_PROMPT",
16:     "USER_RECORDING_START_MESSAGE",
17:     "RESUME_ONSET",
18:     "USER_INTERRUPTION",
19:     "CHAT_START_MESSAGE",
20:     "PAUSE_ONSET",
21:     "USER_MESSAGE",
22: ]);
23: 
24: export declare namespace ReturnChatEventType {
25:     export type Raw =
26:         | "FUNCTION_CALL"
27:         | "FUNCTION_CALL_RESPONSE"
28:         | "CHAT_END_MESSAGE"
29:         | "AGENT_MESSAGE"
30:         | "SYSTEM_PROMPT"
31:         | "USER_RECORDING_START_MESSAGE"
32:         | "RESUME_ONSET"
33:         | "USER_INTERRUPTION"
34:         | "CHAT_START_MESSAGE"
35:         | "PAUSE_ONSET"
36:         | "USER_MESSAGE";
37: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatGroup.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnConfigSpec } from "./ReturnConfigSpec.js";
 7: 
 8: export const ReturnChatGroup: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ReturnChatGroup.Raw,
10:     Hume.empathicVoice.ReturnChatGroup
11: > = core.serialization.object({
12:     active: core.serialization.boolean().optional(),
13:     firstStartTimestamp: core.serialization.property("first_start_timestamp", core.serialization.number()),
14:     id: core.serialization.string(),
15:     mostRecentChatId: core.serialization.property("most_recent_chat_id", core.serialization.string().optional()),
16:     mostRecentConfig: core.serialization.property("most_recent_config", ReturnConfigSpec.optional()),
17:     mostRecentStartTimestamp: core.serialization.property("most_recent_start_timestamp", core.serialization.number()),
18:     numChats: core.serialization.property("num_chats", core.serialization.number()),
19: });
20: 
21: export declare namespace ReturnChatGroup {
22:     export interface Raw {
23:         active?: boolean | null;
24:         first_start_timestamp: number;
25:         id: string;
26:         most_recent_chat_id?: string | null;
27:         most_recent_config?: ReturnConfigSpec.Raw | null;
28:         most_recent_start_timestamp: number;
29:         num_chats: number;
30:     }
31: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedAudioReconstructions.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnChatAudioReconstruction } from "./ReturnChatAudioReconstruction.js";
 7: import { ReturnChatGroupPagedAudioReconstructionsPaginationDirection } from "./ReturnChatGroupPagedAudioReconstructionsPaginationDirection.js";
 8: 
 9: export const ReturnChatGroupPagedAudioReconstructions: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.ReturnChatGroupPagedAudioReconstructions.Raw,
11:     Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructions
12: > = core.serialization.object({
13:     audioReconstructionsPage: core.serialization.property(
14:         "audio_reconstructions_page",
15:         core.serialization.list(ReturnChatAudioReconstruction),
16:     ),
17:     id: core.serialization.string(),
18:     numChats: core.serialization.property("num_chats", core.serialization.number()),
19:     pageNumber: core.serialization.property("page_number", core.serialization.number()),
20:     pageSize: core.serialization.property("page_size", core.serialization.number()),
21:     paginationDirection: core.serialization.property(
22:         "pagination_direction",
23:         ReturnChatGroupPagedAudioReconstructionsPaginationDirection,
24:     ),
25:     totalPages: core.serialization.property("total_pages", core.serialization.number()),
26:     userId: core.serialization.property("user_id", core.serialization.string()),
27: });
28: 
29: export declare namespace ReturnChatGroupPagedAudioReconstructions {
30:     export interface Raw {
31:         audio_reconstructions_page: ReturnChatAudioReconstruction.Raw[];
32:         id: string;
33:         num_chats: number;
34:         page_number: number;
35:         page_size: number;
36:         pagination_direction: ReturnChatGroupPagedAudioReconstructionsPaginationDirection.Raw;
37:         total_pages: number;
38:         user_id: string;
39:     }
40: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedAudioReconstructionsPaginationDirection.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnChatGroupPagedAudioReconstructionsPaginationDirection: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnChatGroupPagedAudioReconstructionsPaginationDirection.Raw,
 9:     Hume.empathicVoice.ReturnChatGroupPagedAudioReconstructionsPaginationDirection
10: > = core.serialization.enum_(["ASC", "DESC"]);
11: 
12: export declare namespace ReturnChatGroupPagedAudioReconstructionsPaginationDirection {
13:     export type Raw = "ASC" | "DESC";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedChats.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnChat } from "./ReturnChat.js";
 7: import { ReturnChatGroupPagedChatsPaginationDirection } from "./ReturnChatGroupPagedChatsPaginationDirection.js";
 8: 
 9: export const ReturnChatGroupPagedChats: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.ReturnChatGroupPagedChats.Raw,
11:     Hume.empathicVoice.ReturnChatGroupPagedChats
12: > = core.serialization.object({
13:     active: core.serialization.boolean().optional(),
14:     chatsPage: core.serialization.property("chats_page", core.serialization.list(ReturnChat)),
15:     firstStartTimestamp: core.serialization.property("first_start_timestamp", core.serialization.number()),
16:     id: core.serialization.string(),
17:     mostRecentStartTimestamp: core.serialization.property("most_recent_start_timestamp", core.serialization.number()),
18:     numChats: core.serialization.property("num_chats", core.serialization.number()),
19:     pageNumber: core.serialization.property("page_number", core.serialization.number()),
20:     pageSize: core.serialization.property("page_size", core.serialization.number()),
21:     paginationDirection: core.serialization.property(
22:         "pagination_direction",
23:         ReturnChatGroupPagedChatsPaginationDirection,
24:     ),
25:     totalPages: core.serialization.property("total_pages", core.serialization.number()),
26: });
27: 
28: export declare namespace ReturnChatGroupPagedChats {
29:     export interface Raw {
30:         active?: boolean | null;
31:         chats_page: ReturnChat.Raw[];
32:         first_start_timestamp: number;
33:         id: string;
34:         most_recent_start_timestamp: number;
35:         num_chats: number;
36:         page_number: number;
37:         page_size: number;
38:         pagination_direction: ReturnChatGroupPagedChatsPaginationDirection.Raw;
39:         total_pages: number;
40:     }
41: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedChatsPaginationDirection.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnChatGroupPagedChatsPaginationDirection: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnChatGroupPagedChatsPaginationDirection.Raw,
 9:     Hume.empathicVoice.ReturnChatGroupPagedChatsPaginationDirection
10: > = core.serialization.enum_(["ASC", "DESC"]);
11: 
12: export declare namespace ReturnChatGroupPagedChatsPaginationDirection {
13:     export type Raw = "ASC" | "DESC";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedEvents.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnChatEvent } from "./ReturnChatEvent.js";
 7: import { ReturnChatGroupPagedEventsPaginationDirection } from "./ReturnChatGroupPagedEventsPaginationDirection.js";
 8: 
 9: export const ReturnChatGroupPagedEvents: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.ReturnChatGroupPagedEvents.Raw,
11:     Hume.empathicVoice.ReturnChatGroupPagedEvents
12: > = core.serialization.object({
13:     eventsPage: core.serialization.property("events_page", core.serialization.list(ReturnChatEvent)),
14:     id: core.serialization.string(),
15:     pageNumber: core.serialization.property("page_number", core.serialization.number()),
16:     pageSize: core.serialization.property("page_size", core.serialization.number()),
17:     paginationDirection: core.serialization.property(
18:         "pagination_direction",
19:         ReturnChatGroupPagedEventsPaginationDirection,
20:     ),
21:     totalPages: core.serialization.property("total_pages", core.serialization.number()),
22: });
23: 
24: export declare namespace ReturnChatGroupPagedEvents {
25:     export interface Raw {
26:         events_page: ReturnChatEvent.Raw[];
27:         id: string;
28:         page_number: number;
29:         page_size: number;
30:         pagination_direction: ReturnChatGroupPagedEventsPaginationDirection.Raw;
31:         total_pages: number;
32:     }
33: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatGroupPagedEventsPaginationDirection.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnChatGroupPagedEventsPaginationDirection: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnChatGroupPagedEventsPaginationDirection.Raw,
 9:     Hume.empathicVoice.ReturnChatGroupPagedEventsPaginationDirection
10: > = core.serialization.enum_(["ASC", "DESC"]);
11: 
12: export declare namespace ReturnChatGroupPagedEventsPaginationDirection {
13:     export type Raw = "ASC" | "DESC";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatPagedEvents.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnChatEvent } from "./ReturnChatEvent.js";
 7: import { ReturnChatPagedEventsPaginationDirection } from "./ReturnChatPagedEventsPaginationDirection.js";
 8: import { ReturnChatPagedEventsStatus } from "./ReturnChatPagedEventsStatus.js";
 9: import { ReturnConfigSpec } from "./ReturnConfigSpec.js";
10: 
11: export const ReturnChatPagedEvents: core.serialization.ObjectSchema<
12:     serializers.empathicVoice.ReturnChatPagedEvents.Raw,
13:     Hume.empathicVoice.ReturnChatPagedEvents
14: > = core.serialization.object({
15:     chatGroupId: core.serialization.property("chat_group_id", core.serialization.string()),
16:     config: ReturnConfigSpec.optional(),
17:     endTimestamp: core.serialization.property("end_timestamp", core.serialization.number().optional()),
18:     eventsPage: core.serialization.property("events_page", core.serialization.list(ReturnChatEvent)),
19:     id: core.serialization.string(),
20:     metadata: core.serialization.string().optional(),
21:     pageNumber: core.serialization.property("page_number", core.serialization.number()),
22:     pageSize: core.serialization.property("page_size", core.serialization.number()),
23:     paginationDirection: core.serialization.property("pagination_direction", ReturnChatPagedEventsPaginationDirection),
24:     startTimestamp: core.serialization.property("start_timestamp", core.serialization.number()),
25:     status: ReturnChatPagedEventsStatus,
26:     totalPages: core.serialization.property("total_pages", core.serialization.number()),
27: });
28: 
29: export declare namespace ReturnChatPagedEvents {
30:     export interface Raw {
31:         chat_group_id: string;
32:         config?: ReturnConfigSpec.Raw | null;
33:         end_timestamp?: number | null;
34:         events_page: ReturnChatEvent.Raw[];
35:         id: string;
36:         metadata?: string | null;
37:         page_number: number;
38:         page_size: number;
39:         pagination_direction: ReturnChatPagedEventsPaginationDirection.Raw;
40:         start_timestamp: number;
41:         status: ReturnChatPagedEventsStatus.Raw;
42:         total_pages: number;
43:     }
44: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatPagedEventsPaginationDirection.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnChatPagedEventsPaginationDirection: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnChatPagedEventsPaginationDirection.Raw,
 9:     Hume.empathicVoice.ReturnChatPagedEventsPaginationDirection
10: > = core.serialization.enum_(["ASC", "DESC"]);
11: 
12: export declare namespace ReturnChatPagedEventsPaginationDirection {
13:     export type Raw = "ASC" | "DESC";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatPagedEventsStatus.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnChatPagedEventsStatus: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnChatPagedEventsStatus.Raw,
 9:     Hume.empathicVoice.ReturnChatPagedEventsStatus
10: > = core.serialization.enum_([
11:     "ACTIVE",
12:     "USER_ENDED",
13:     "USER_TIMEOUT",
14:     "MAX_DURATION_TIMEOUT",
15:     "INACTIVITY_TIMEOUT",
16:     "ERROR",
17: ]);
18: 
19: export declare namespace ReturnChatPagedEventsStatus {
20:     export type Raw =
21:         | "ACTIVE"
22:         | "USER_ENDED"
23:         | "USER_TIMEOUT"
24:         | "MAX_DURATION_TIMEOUT"
25:         | "INACTIVITY_TIMEOUT"
26:         | "ERROR";
27: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnChatStatus.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnChatStatus: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnChatStatus.Raw,
 9:     Hume.empathicVoice.ReturnChatStatus
10: > = core.serialization.enum_([
11:     "ACTIVE",
12:     "USER_ENDED",
13:     "USER_TIMEOUT",
14:     "MAX_DURATION_TIMEOUT",
15:     "INACTIVITY_TIMEOUT",
16:     "ERROR",
17: ]);
18: 
19: export declare namespace ReturnChatStatus {
20:     export type Raw =
21:         | "ACTIVE"
22:         | "USER_ENDED"
23:         | "USER_TIMEOUT"
24:         | "MAX_DURATION_TIMEOUT"
25:         | "INACTIVITY_TIMEOUT"
26:         | "ERROR";
27: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnConfig.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnBuiltinTool } from "./ReturnBuiltinTool.js";
 7: import { ReturnEllmModel } from "./ReturnEllmModel.js";
 8: import { ReturnEventMessageSpecs } from "./ReturnEventMessageSpecs.js";
 9: import { ReturnLanguageModel } from "./ReturnLanguageModel.js";
10: import { ReturnNudgeSpec } from "./ReturnNudgeSpec.js";
11: import { ReturnPrompt } from "./ReturnPrompt.js";
12: import { ReturnTimeoutSpecs } from "./ReturnTimeoutSpecs.js";
13: import { ReturnUserDefinedTool } from "./ReturnUserDefinedTool.js";
14: import { ReturnVoice } from "./ReturnVoice.js";
15: import { ReturnWebhookSpec } from "./ReturnWebhookSpec.js";
16: 
17: export const ReturnConfig: core.serialization.ObjectSchema<
18:     serializers.empathicVoice.ReturnConfig.Raw,
19:     Hume.empathicVoice.ReturnConfig
20: > = core.serialization.object({
21:     builtinTools: core.serialization.property(
22:         "builtin_tools",
23:         core.serialization.list(ReturnBuiltinTool.optional()).optional(),
24:     ),
25:     createdOn: core.serialization.property("created_on", core.serialization.number().optional()),
26:     ellmModel: core.serialization.property("ellm_model", ReturnEllmModel.optional()),
27:     eventMessages: core.serialization.property("event_messages", ReturnEventMessageSpecs.optional()),
28:     eviVersion: core.serialization.property("evi_version", core.serialization.string().optional()),
29:     id: core.serialization.string().optional(),
30:     languageModel: core.serialization.property("language_model", ReturnLanguageModel.optional()),
31:     modifiedOn: core.serialization.property("modified_on", core.serialization.number().optional()),
32:     name: core.serialization.string().optional(),
33:     nudges: ReturnNudgeSpec.optional(),
34:     prompt: ReturnPrompt.optional(),
35:     timeouts: ReturnTimeoutSpecs.optional(),
36:     tools: core.serialization.list(ReturnUserDefinedTool.optional()).optional(),
37:     version: core.serialization.number().optional(),
38:     versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
39:     voice: ReturnVoice.optional(),
40:     webhooks: core.serialization.list(ReturnWebhookSpec.optional()).optional(),
41: });
42: 
43: export declare namespace ReturnConfig {
44:     export interface Raw {
45:         builtin_tools?: (ReturnBuiltinTool.Raw | null | undefined)[] | null;
46:         created_on?: number | null;
47:         ellm_model?: ReturnEllmModel.Raw | null;
48:         event_messages?: ReturnEventMessageSpecs.Raw | null;
49:         evi_version?: string | null;
50:         id?: string | null;
51:         language_model?: ReturnLanguageModel.Raw | null;
52:         modified_on?: number | null;
53:         name?: string | null;
54:         nudges?: ReturnNudgeSpec.Raw | null;
55:         prompt?: ReturnPrompt.Raw | null;
56:         timeouts?: ReturnTimeoutSpecs.Raw | null;
57:         tools?: (ReturnUserDefinedTool.Raw | null | undefined)[] | null;
58:         version?: number | null;
59:         version_description?: string | null;
60:         voice?: ReturnVoice.Raw | null;
61:         webhooks?: (ReturnWebhookSpec.Raw | null | undefined)[] | null;
62:     }
63: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnConfigSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnConfigSpec: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.ReturnConfigSpec.Raw,
 9:     Hume.empathicVoice.ReturnConfigSpec
10: > = core.serialization.object({
11:     id: core.serialization.string(),
12:     version: core.serialization.number().optional(),
13: });
14: 
15: export declare namespace ReturnConfigSpec {
16:     export interface Raw {
17:         id: string;
18:         version?: number | null;
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnEllmModel.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnEllmModel: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.ReturnEllmModel.Raw,
 9:     Hume.empathicVoice.ReturnEllmModel
10: > = core.serialization.object({
11:     allowShortResponses: core.serialization.property("allow_short_responses", core.serialization.boolean()),
12: });
13: 
14: export declare namespace ReturnEllmModel {
15:     export interface Raw {
16:         allow_short_responses: boolean;
17:     }
18: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnEventMessageSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnEventMessageSpec: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.ReturnEventMessageSpec.Raw,
 9:     Hume.empathicVoice.ReturnEventMessageSpec
10: > = core.serialization.object({
11:     enabled: core.serialization.boolean(),
12:     text: core.serialization.string().optional(),
13: });
14: 
15: export declare namespace ReturnEventMessageSpec {
16:     export interface Raw {
17:         enabled: boolean;
18:         text?: string | null;
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnEventMessageSpecs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnEventMessageSpec } from "./ReturnEventMessageSpec.js";
 7: 
 8: export const ReturnEventMessageSpecs: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ReturnEventMessageSpecs.Raw,
10:     Hume.empathicVoice.ReturnEventMessageSpecs
11: > = core.serialization.object({
12:     onInactivityTimeout: core.serialization.property("on_inactivity_timeout", ReturnEventMessageSpec.optional()),
13:     onMaxDurationTimeout: core.serialization.property("on_max_duration_timeout", ReturnEventMessageSpec.optional()),
14:     onNewChat: core.serialization.property("on_new_chat", ReturnEventMessageSpec.optional()),
15: });
16: 
17: export declare namespace ReturnEventMessageSpecs {
18:     export interface Raw {
19:         on_inactivity_timeout?: ReturnEventMessageSpec.Raw | null;
20:         on_max_duration_timeout?: ReturnEventMessageSpec.Raw | null;
21:         on_new_chat?: ReturnEventMessageSpec.Raw | null;
22:     }
23: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnLanguageModel.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { LanguageModelType } from "./LanguageModelType.js";
 7: import { ModelProviderEnum } from "./ModelProviderEnum.js";
 8: 
 9: export const ReturnLanguageModel: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.ReturnLanguageModel.Raw,
11:     Hume.empathicVoice.ReturnLanguageModel
12: > = core.serialization.object({
13:     modelProvider: core.serialization.property("model_provider", ModelProviderEnum.optional()),
14:     modelResource: core.serialization.property("model_resource", LanguageModelType.optional()),
15:     temperature: core.serialization.number().optional(),
16: });
17: 
18: export declare namespace ReturnLanguageModel {
19:     export interface Raw {
20:         model_provider?: ModelProviderEnum.Raw | null;
21:         model_resource?: LanguageModelType.Raw | null;
22:         temperature?: number | null;
23:     }
24: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnNudgeSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnNudgeSpec: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.ReturnNudgeSpec.Raw,
 9:     Hume.empathicVoice.ReturnNudgeSpec
10: > = core.serialization.object({
11:     enabled: core.serialization.boolean(),
12:     intervalSecs: core.serialization.property("interval_secs", core.serialization.number().optional()),
13: });
14: 
15: export declare namespace ReturnNudgeSpec {
16:     export interface Raw {
17:         enabled: boolean;
18:         interval_secs?: number | null;
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnPagedChatGroups.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnChatGroup } from "./ReturnChatGroup.js";
 7: import { ReturnPagedChatGroupsPaginationDirection } from "./ReturnPagedChatGroupsPaginationDirection.js";
 8: 
 9: export const ReturnPagedChatGroups: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.ReturnPagedChatGroups.Raw,
11:     Hume.empathicVoice.ReturnPagedChatGroups
12: > = core.serialization.object({
13:     chatGroupsPage: core.serialization.property("chat_groups_page", core.serialization.list(ReturnChatGroup)),
14:     pageNumber: core.serialization.property("page_number", core.serialization.number()),
15:     pageSize: core.serialization.property("page_size", core.serialization.number()),
16:     paginationDirection: core.serialization.property("pagination_direction", ReturnPagedChatGroupsPaginationDirection),
17:     totalPages: core.serialization.property("total_pages", core.serialization.number()),
18: });
19: 
20: export declare namespace ReturnPagedChatGroups {
21:     export interface Raw {
22:         chat_groups_page: ReturnChatGroup.Raw[];
23:         page_number: number;
24:         page_size: number;
25:         pagination_direction: ReturnPagedChatGroupsPaginationDirection.Raw;
26:         total_pages: number;
27:     }
28: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnPagedChatGroupsPaginationDirection.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnPagedChatGroupsPaginationDirection: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnPagedChatGroupsPaginationDirection.Raw,
 9:     Hume.empathicVoice.ReturnPagedChatGroupsPaginationDirection
10: > = core.serialization.enum_(["ASC", "DESC"]);
11: 
12: export declare namespace ReturnPagedChatGroupsPaginationDirection {
13:     export type Raw = "ASC" | "DESC";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnPagedChats.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnChat } from "./ReturnChat.js";
 7: import { ReturnPagedChatsPaginationDirection } from "./ReturnPagedChatsPaginationDirection.js";
 8: 
 9: export const ReturnPagedChats: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.ReturnPagedChats.Raw,
11:     Hume.empathicVoice.ReturnPagedChats
12: > = core.serialization.object({
13:     chatsPage: core.serialization.property("chats_page", core.serialization.list(ReturnChat)),
14:     pageNumber: core.serialization.property("page_number", core.serialization.number()),
15:     pageSize: core.serialization.property("page_size", core.serialization.number()),
16:     paginationDirection: core.serialization.property("pagination_direction", ReturnPagedChatsPaginationDirection),
17:     totalPages: core.serialization.property("total_pages", core.serialization.number()),
18: });
19: 
20: export declare namespace ReturnPagedChats {
21:     export interface Raw {
22:         chats_page: ReturnChat.Raw[];
23:         page_number: number;
24:         page_size: number;
25:         pagination_direction: ReturnPagedChatsPaginationDirection.Raw;
26:         total_pages: number;
27:     }
28: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnPagedChatsPaginationDirection.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnPagedChatsPaginationDirection: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnPagedChatsPaginationDirection.Raw,
 9:     Hume.empathicVoice.ReturnPagedChatsPaginationDirection
10: > = core.serialization.enum_(["ASC", "DESC"]);
11: 
12: export declare namespace ReturnPagedChatsPaginationDirection {
13:     export type Raw = "ASC" | "DESC";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnPagedConfigs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnConfig } from "./ReturnConfig.js";
 7: 
 8: export const ReturnPagedConfigs: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ReturnPagedConfigs.Raw,
10:     Hume.empathicVoice.ReturnPagedConfigs
11: > = core.serialization.object({
12:     configsPage: core.serialization.property("configs_page", core.serialization.list(ReturnConfig).optional()),
13:     pageNumber: core.serialization.property("page_number", core.serialization.number().optional()),
14:     pageSize: core.serialization.property("page_size", core.serialization.number().optional()),
15:     totalPages: core.serialization.property("total_pages", core.serialization.number()),
16: });
17: 
18: export declare namespace ReturnPagedConfigs {
19:     export interface Raw {
20:         configs_page?: ReturnConfig.Raw[] | null;
21:         page_number?: number | null;
22:         page_size?: number | null;
23:         total_pages: number;
24:     }
25: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnPagedPrompts.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnPrompt } from "./ReturnPrompt.js";
 7: 
 8: export const ReturnPagedPrompts: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ReturnPagedPrompts.Raw,
10:     Hume.empathicVoice.ReturnPagedPrompts
11: > = core.serialization.object({
12:     pageNumber: core.serialization.property("page_number", core.serialization.number()),
13:     pageSize: core.serialization.property("page_size", core.serialization.number()),
14:     promptsPage: core.serialization.property("prompts_page", core.serialization.list(ReturnPrompt.optional())),
15:     totalPages: core.serialization.property("total_pages", core.serialization.number()),
16: });
17: 
18: export declare namespace ReturnPagedPrompts {
19:     export interface Raw {
20:         page_number: number;
21:         page_size: number;
22:         prompts_page: (ReturnPrompt.Raw | null | undefined)[];
23:         total_pages: number;
24:     }
25: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnPagedUserDefinedTools.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnUserDefinedTool } from "./ReturnUserDefinedTool.js";
 7: 
 8: export const ReturnPagedUserDefinedTools: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ReturnPagedUserDefinedTools.Raw,
10:     Hume.empathicVoice.ReturnPagedUserDefinedTools
11: > = core.serialization.object({
12:     pageNumber: core.serialization.property("page_number", core.serialization.number()),
13:     pageSize: core.serialization.property("page_size", core.serialization.number()),
14:     toolsPage: core.serialization.property("tools_page", core.serialization.list(ReturnUserDefinedTool.optional())),
15:     totalPages: core.serialization.property("total_pages", core.serialization.number()),
16: });
17: 
18: export declare namespace ReturnPagedUserDefinedTools {
19:     export interface Raw {
20:         page_number: number;
21:         page_size: number;
22:         tools_page: (ReturnUserDefinedTool.Raw | null | undefined)[];
23:         total_pages: number;
24:     }
25: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnPrompt.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnPrompt: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.ReturnPrompt.Raw,
 9:     Hume.empathicVoice.ReturnPrompt
10: > = core.serialization.object({
11:     createdOn: core.serialization.property("created_on", core.serialization.number()),
12:     id: core.serialization.string(),
13:     modifiedOn: core.serialization.property("modified_on", core.serialization.number()),
14:     name: core.serialization.string(),
15:     text: core.serialization.string(),
16:     version: core.serialization.number(),
17:     versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
18:     versionType: core.serialization.property("version_type", core.serialization.string()),
19: });
20: 
21: export declare namespace ReturnPrompt {
22:     export interface Raw {
23:         created_on: number;
24:         id: string;
25:         modified_on: number;
26:         name: string;
27:         text: string;
28:         version: number;
29:         version_description?: string | null;
30:         version_type: string;
31:     }
32: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnPromptVersionType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnPromptVersionType: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnPromptVersionType.Raw,
 9:     Hume.empathicVoice.ReturnPromptVersionType
10: > = core.serialization.enum_(["FIXED", "LATEST"]);
11: 
12: export declare namespace ReturnPromptVersionType {
13:     export type Raw = "FIXED" | "LATEST";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnTimeoutSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnTimeoutSpec: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.ReturnTimeoutSpec.Raw,
 9:     Hume.empathicVoice.ReturnTimeoutSpec
10: > = core.serialization.object({
11:     durationSecs: core.serialization.property("duration_secs", core.serialization.number().optional()),
12:     enabled: core.serialization.boolean(),
13: });
14: 
15: export declare namespace ReturnTimeoutSpec {
16:     export interface Raw {
17:         duration_secs?: number | null;
18:         enabled: boolean;
19:     }
20: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnTimeoutSpecs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnTimeoutSpec } from "./ReturnTimeoutSpec.js";
 7: 
 8: export const ReturnTimeoutSpecs: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ReturnTimeoutSpecs.Raw,
10:     Hume.empathicVoice.ReturnTimeoutSpecs
11: > = core.serialization.object({
12:     inactivity: ReturnTimeoutSpec,
13:     maxDuration: core.serialization.property("max_duration", ReturnTimeoutSpec),
14: });
15: 
16: export declare namespace ReturnTimeoutSpecs {
17:     export interface Raw {
18:         inactivity: ReturnTimeoutSpec.Raw;
19:         max_duration: ReturnTimeoutSpec.Raw;
20:     }
21: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnUserDefinedTool.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnUserDefinedToolToolType } from "./ReturnUserDefinedToolToolType.js";
 7: import { ReturnUserDefinedToolVersionType } from "./ReturnUserDefinedToolVersionType.js";
 8: 
 9: export const ReturnUserDefinedTool: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.ReturnUserDefinedTool.Raw,
11:     Hume.empathicVoice.ReturnUserDefinedTool
12: > = core.serialization.object({
13:     createdOn: core.serialization.property("created_on", core.serialization.number()),
14:     description: core.serialization.string().optional(),
15:     fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
16:     id: core.serialization.string(),
17:     modifiedOn: core.serialization.property("modified_on", core.serialization.number()),
18:     name: core.serialization.string(),
19:     parameters: core.serialization.string(),
20:     toolType: core.serialization.property("tool_type", ReturnUserDefinedToolToolType),
21:     version: core.serialization.number(),
22:     versionDescription: core.serialization.property("version_description", core.serialization.string().optional()),
23:     versionType: core.serialization.property("version_type", ReturnUserDefinedToolVersionType),
24: });
25: 
26: export declare namespace ReturnUserDefinedTool {
27:     export interface Raw {
28:         created_on: number;
29:         description?: string | null;
30:         fallback_content?: string | null;
31:         id: string;
32:         modified_on: number;
33:         name: string;
34:         parameters: string;
35:         tool_type: ReturnUserDefinedToolToolType.Raw;
36:         version: number;
37:         version_description?: string | null;
38:         version_type: ReturnUserDefinedToolVersionType.Raw;
39:     }
40: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnUserDefinedToolToolType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnUserDefinedToolToolType: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnUserDefinedToolToolType.Raw,
 9:     Hume.empathicVoice.ReturnUserDefinedToolToolType
10: > = core.serialization.enum_(["BUILTIN", "FUNCTION"]);
11: 
12: export declare namespace ReturnUserDefinedToolToolType {
13:     export type Raw = "BUILTIN" | "FUNCTION";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnUserDefinedToolVersionType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnUserDefinedToolVersionType: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnUserDefinedToolVersionType.Raw,
 9:     Hume.empathicVoice.ReturnUserDefinedToolVersionType
10: > = core.serialization.enum_(["FIXED", "LATEST"]);
11: 
12: export declare namespace ReturnUserDefinedToolVersionType {
13:     export type Raw = "FIXED" | "LATEST";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnVoice.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { VoiceProvider } from "./VoiceProvider.js";
 7: 
 8: export const ReturnVoice: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ReturnVoice.Raw,
10:     Hume.empathicVoice.ReturnVoice
11: > = core.serialization.object({
12:     compatibleOctaveModels: core.serialization.property(
13:         "compatible_octave_models",
14:         core.serialization.list(core.serialization.string()).optional(),
15:     ),
16:     id: core.serialization.string(),
17:     name: core.serialization.string(),
18:     provider: VoiceProvider,
19: });
20: 
21: export declare namespace ReturnVoice {
22:     export interface Raw {
23:         compatible_octave_models?: string[] | null;
24:         id: string;
25:         name: string;
26:         provider: VoiceProvider.Raw;
27:     }
28: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnWebhookEventType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ReturnWebhookEventType: core.serialization.Schema<
 8:     serializers.empathicVoice.ReturnWebhookEventType.Raw,
 9:     Hume.empathicVoice.ReturnWebhookEventType
10: > = core.serialization.enum_(["chat_started", "chat_ended", "tool_call"]);
11: 
12: export declare namespace ReturnWebhookEventType {
13:     export type Raw = "chat_started" | "chat_ended" | "tool_call";
14: }
````

## File: src/serialization/resources/empathicVoice/types/ReturnWebhookSpec.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnWebhookEventType } from "./ReturnWebhookEventType.js";
 7: 
 8: export const ReturnWebhookSpec: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ReturnWebhookSpec.Raw,
10:     Hume.empathicVoice.ReturnWebhookSpec
11: > = core.serialization.object({
12:     events: core.serialization.list(ReturnWebhookEventType),
13:     url: core.serialization.string(),
14: });
15: 
16: export declare namespace ReturnWebhookSpec {
17:     export interface Raw {
18:         events: ReturnWebhookEventType.Raw[];
19:         url: string;
20:     }
21: }
````

## File: src/serialization/resources/empathicVoice/types/Role.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const Role: core.serialization.Schema<serializers.empathicVoice.Role.Raw, Hume.empathicVoice.Role> =
 8:     core.serialization.enum_(["assistant", "system", "user", "all", "tool", "context"]);
 9: 
10: export declare namespace Role {
11:     export type Raw = "assistant" | "system" | "user" | "all" | "tool" | "context";
12: }
````

## File: src/serialization/resources/empathicVoice/types/SessionSettings.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { AudioConfiguration } from "./AudioConfiguration.js";
 7: import { BuiltinToolConfig } from "./BuiltinToolConfig.js";
 8: import { Context } from "./Context.js";
 9: import { SessionSettingsVariablesValue } from "./SessionSettingsVariablesValue.js";
10: import { Tool } from "./Tool.js";
11: 
12: export const SessionSettings: core.serialization.ObjectSchema<
13:     serializers.empathicVoice.SessionSettings.Raw,
14:     Hume.empathicVoice.SessionSettings
15: > = core.serialization.object({
16:     audio: AudioConfiguration.optional(),
17:     builtinTools: core.serialization.property("builtin_tools", core.serialization.list(BuiltinToolConfig).optional()),
18:     context: Context.optional(),
19:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
20:     languageModelApiKey: core.serialization.property("language_model_api_key", core.serialization.string().optional()),
21:     metadata: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
22:     systemPrompt: core.serialization.property("system_prompt", core.serialization.string().optional()),
23:     tools: core.serialization.list(Tool).optional(),
24:     type: core.serialization.stringLiteral("session_settings"),
25:     variables: core.serialization.record(core.serialization.string(), SessionSettingsVariablesValue).optional(),
26:     voiceId: core.serialization.property("voice_id", core.serialization.string().optional()),
27: });
28: 
29: export declare namespace SessionSettings {
30:     export interface Raw {
31:         audio?: AudioConfiguration.Raw | null;
32:         builtin_tools?: BuiltinToolConfig.Raw[] | null;
33:         context?: Context.Raw | null;
34:         custom_session_id?: string | null;
35:         language_model_api_key?: string | null;
36:         metadata?: Record<string, unknown> | null;
37:         system_prompt?: string | null;
38:         tools?: Tool.Raw[] | null;
39:         type: "session_settings";
40:         variables?: Record<string, SessionSettingsVariablesValue.Raw> | null;
41:         voice_id?: string | null;
42:     }
43: }
````

## File: src/serialization/resources/empathicVoice/types/SessionSettingsVariablesValue.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const SessionSettingsVariablesValue: core.serialization.Schema<
 8:     serializers.empathicVoice.SessionSettingsVariablesValue.Raw,
 9:     Hume.empathicVoice.SessionSettingsVariablesValue
10: > = core.serialization.undiscriminatedUnion([
11:     core.serialization.string(),
12:     core.serialization.number(),
13:     core.serialization.boolean(),
14: ]);
15: 
16: export declare namespace SessionSettingsVariablesValue {
17:     export type Raw = string | number | boolean;
18: }
````

## File: src/serialization/resources/empathicVoice/types/SubscribeEvent.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { AssistantEnd } from "./AssistantEnd.js";
 7: import { AssistantMessage } from "./AssistantMessage.js";
 8: import { AssistantProsody } from "./AssistantProsody.js";
 9: import { AudioOutput } from "./AudioOutput.js";
10: import { ChatMetadata } from "./ChatMetadata.js";
11: import { SessionSettings } from "./SessionSettings.js";
12: import { ToolCallMessage } from "./ToolCallMessage.js";
13: import { ToolErrorMessage } from "./ToolErrorMessage.js";
14: import { ToolResponseMessage } from "./ToolResponseMessage.js";
15: import { UserInterruption } from "./UserInterruption.js";
16: import { UserMessage } from "./UserMessage.js";
17: import { WebSocketError } from "./WebSocketError.js";
18: 
19: export const SubscribeEvent: core.serialization.Schema<
20:     serializers.empathicVoice.SubscribeEvent.Raw,
21:     Hume.empathicVoice.SubscribeEvent
22: > = core.serialization.undiscriminatedUnion([
23:     AssistantEnd,
24:     AssistantMessage,
25:     AssistantProsody,
26:     AudioOutput,
27:     ChatMetadata,
28:     WebSocketError,
29:     UserInterruption,
30:     UserMessage,
31:     ToolCallMessage,
32:     ToolResponseMessage,
33:     ToolErrorMessage,
34:     SessionSettings,
35: ]);
36: 
37: export declare namespace SubscribeEvent {
38:     export type Raw =
39:         | AssistantEnd.Raw
40:         | AssistantMessage.Raw
41:         | AssistantProsody.Raw
42:         | AudioOutput.Raw
43:         | ChatMetadata.Raw
44:         | WebSocketError.Raw
45:         | UserInterruption.Raw
46:         | UserMessage.Raw
47:         | ToolCallMessage.Raw
48:         | ToolResponseMessage.Raw
49:         | ToolErrorMessage.Raw
50:         | SessionSettings.Raw;
51: }
````

## File: src/serialization/resources/empathicVoice/types/Tool.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ToolType } from "./ToolType.js";
 7: 
 8: export const Tool: core.serialization.ObjectSchema<serializers.empathicVoice.Tool.Raw, Hume.empathicVoice.Tool> =
 9:     core.serialization.object({
10:         description: core.serialization.string().optional(),
11:         fallbackContent: core.serialization.property("fallback_content", core.serialization.string().optional()),
12:         name: core.serialization.string(),
13:         parameters: core.serialization.string(),
14:         type: ToolType,
15:     });
16: 
17: export declare namespace Tool {
18:     export interface Raw {
19:         description?: string | null;
20:         fallback_content?: string | null;
21:         name: string;
22:         parameters: string;
23:         type: ToolType.Raw;
24:     }
25: }
````

## File: src/serialization/resources/empathicVoice/types/ToolCallMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ToolType } from "./ToolType.js";
 7: 
 8: export const ToolCallMessage: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ToolCallMessage.Raw,
10:     Hume.empathicVoice.ToolCallMessage
11: > = core.serialization.object({
12:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
13:     name: core.serialization.string(),
14:     parameters: core.serialization.string(),
15:     responseRequired: core.serialization.property("response_required", core.serialization.boolean()),
16:     toolCallId: core.serialization.property("tool_call_id", core.serialization.string()),
17:     toolType: core.serialization.property("tool_type", ToolType),
18:     type: core.serialization.stringLiteral("tool_call"),
19: });
20: 
21: export declare namespace ToolCallMessage {
22:     export interface Raw {
23:         custom_session_id?: string | null;
24:         name: string;
25:         parameters: string;
26:         response_required: boolean;
27:         tool_call_id: string;
28:         tool_type: ToolType.Raw;
29:         type: "tool_call";
30:     }
31: }
````

## File: src/serialization/resources/empathicVoice/types/ToolErrorMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ErrorLevel } from "./ErrorLevel.js";
 7: import { ToolType } from "./ToolType.js";
 8: 
 9: export const ToolErrorMessage: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.ToolErrorMessage.Raw,
11:     Hume.empathicVoice.ToolErrorMessage
12: > = core.serialization.object({
13:     code: core.serialization.string().optional(),
14:     content: core.serialization.string().optional(),
15:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
16:     error: core.serialization.string(),
17:     level: ErrorLevel.optional(),
18:     toolCallId: core.serialization.property("tool_call_id", core.serialization.string()),
19:     toolType: core.serialization.property("tool_type", ToolType.optional()),
20:     type: core.serialization.stringLiteral("tool_error"),
21: });
22: 
23: export declare namespace ToolErrorMessage {
24:     export interface Raw {
25:         code?: string | null;
26:         content?: string | null;
27:         custom_session_id?: string | null;
28:         error: string;
29:         level?: ErrorLevel.Raw | null;
30:         tool_call_id: string;
31:         tool_type?: ToolType.Raw | null;
32:         type: "tool_error";
33:     }
34: }
````

## File: src/serialization/resources/empathicVoice/types/ToolResponseMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ToolType } from "./ToolType.js";
 7: 
 8: export const ToolResponseMessage: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ToolResponseMessage.Raw,
10:     Hume.empathicVoice.ToolResponseMessage
11: > = core.serialization.object({
12:     content: core.serialization.string(),
13:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
14:     toolCallId: core.serialization.property("tool_call_id", core.serialization.string()),
15:     toolName: core.serialization.property("tool_name", core.serialization.string().optional()),
16:     toolType: core.serialization.property("tool_type", ToolType.optional()),
17:     type: core.serialization.stringLiteral("tool_response"),
18: });
19: 
20: export declare namespace ToolResponseMessage {
21:     export interface Raw {
22:         content: string;
23:         custom_session_id?: string | null;
24:         tool_call_id: string;
25:         tool_name?: string | null;
26:         tool_type?: ToolType.Raw | null;
27:         type: "tool_response";
28:     }
29: }
````

## File: src/serialization/resources/empathicVoice/types/ToolType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ToolType: core.serialization.Schema<serializers.empathicVoice.ToolType.Raw, Hume.empathicVoice.ToolType> =
 8:     core.serialization.enum_(["builtin", "function"]);
 9: 
10: export declare namespace ToolType {
11:     export type Raw = "builtin" | "function";
12: }
````

## File: src/serialization/resources/empathicVoice/types/UserInput.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const UserInput: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.UserInput.Raw,
 9:     Hume.empathicVoice.UserInput
10: > = core.serialization.object({
11:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
12:     text: core.serialization.string(),
13:     type: core.serialization.stringLiteral("user_input"),
14: });
15: 
16: export declare namespace UserInput {
17:     export interface Raw {
18:         custom_session_id?: string | null;
19:         text: string;
20:         type: "user_input";
21:     }
22: }
````

## File: src/serialization/resources/empathicVoice/types/UserInterruption.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const UserInterruption: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.UserInterruption.Raw,
 9:     Hume.empathicVoice.UserInterruption
10: > = core.serialization.object({
11:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
12:     time: core.serialization.number(),
13:     type: core.serialization.stringLiteral("user_interruption"),
14: });
15: 
16: export declare namespace UserInterruption {
17:     export interface Raw {
18:         custom_session_id?: string | null;
19:         time: number;
20:         type: "user_interruption";
21:     }
22: }
````

## File: src/serialization/resources/empathicVoice/types/UserMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ChatMessage } from "./ChatMessage.js";
 7: import { Inference } from "./Inference.js";
 8: import { MillisecondInterval } from "./MillisecondInterval.js";
 9: 
10: export const UserMessage: core.serialization.ObjectSchema<
11:     serializers.empathicVoice.UserMessage.Raw,
12:     Hume.empathicVoice.UserMessage
13: > = core.serialization.object({
14:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
15:     fromText: core.serialization.property("from_text", core.serialization.boolean()),
16:     interim: core.serialization.boolean(),
17:     language: core.serialization.string().optional(),
18:     message: ChatMessage,
19:     models: Inference,
20:     time: MillisecondInterval,
21:     type: core.serialization.stringLiteral("user_message"),
22: });
23: 
24: export declare namespace UserMessage {
25:     export interface Raw {
26:         custom_session_id?: string | null;
27:         from_text: boolean;
28:         interim: boolean;
29:         language?: string | null;
30:         message: ChatMessage.Raw;
31:         models: Inference.Raw;
32:         time: MillisecondInterval.Raw;
33:         type: "user_message";
34:     }
35: }
````

## File: src/serialization/resources/empathicVoice/types/ValidationError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ValidationErrorLocItem } from "./ValidationErrorLocItem.js";
 7: 
 8: export const ValidationError: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.ValidationError.Raw,
10:     Hume.empathicVoice.ValidationError
11: > = core.serialization.object({
12:     loc: core.serialization.list(ValidationErrorLocItem),
13:     msg: core.serialization.string(),
14:     type: core.serialization.string(),
15: });
16: 
17: export declare namespace ValidationError {
18:     export interface Raw {
19:         loc: ValidationErrorLocItem.Raw[];
20:         msg: string;
21:         type: string;
22:     }
23: }
````

## File: src/serialization/resources/empathicVoice/types/ValidationErrorLocItem.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ValidationErrorLocItem: core.serialization.Schema<
 8:     serializers.empathicVoice.ValidationErrorLocItem.Raw,
 9:     Hume.empathicVoice.ValidationErrorLocItem
10: > = core.serialization.undiscriminatedUnion([core.serialization.string(), core.serialization.number()]);
11: 
12: export declare namespace ValidationErrorLocItem {
13:     export type Raw = string | number;
14: }
````

## File: src/serialization/resources/empathicVoice/types/VoiceId.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { VoiceProvider } from "./VoiceProvider.js";
 7: 
 8: export const VoiceId: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.VoiceId.Raw,
10:     Hume.empathicVoice.VoiceId
11: > = core.serialization.object({
12:     id: core.serialization.string(),
13:     provider: VoiceProvider.optional(),
14: });
15: 
16: export declare namespace VoiceId {
17:     export interface Raw {
18:         id: string;
19:         provider?: VoiceProvider.Raw | null;
20:     }
21: }
````

## File: src/serialization/resources/empathicVoice/types/VoiceName.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { VoiceProvider } from "./VoiceProvider.js";
 7: 
 8: export const VoiceName: core.serialization.ObjectSchema<
 9:     serializers.empathicVoice.VoiceName.Raw,
10:     Hume.empathicVoice.VoiceName
11: > = core.serialization.object({
12:     name: core.serialization.string(),
13:     provider: VoiceProvider.optional(),
14: });
15: 
16: export declare namespace VoiceName {
17:     export interface Raw {
18:         name: string;
19:         provider?: VoiceProvider.Raw | null;
20:     }
21: }
````

## File: src/serialization/resources/empathicVoice/types/VoiceProvider.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const VoiceProvider: core.serialization.Schema<
 8:     serializers.empathicVoice.VoiceProvider.Raw,
 9:     Hume.empathicVoice.VoiceProvider
10: > = core.serialization.enum_(["HUME_AI", "CUSTOM_VOICE"]);
11: 
12: export declare namespace VoiceProvider {
13:     export type Raw = "HUME_AI" | "CUSTOM_VOICE";
14: }
````

## File: src/serialization/resources/empathicVoice/types/VoiceRef.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { VoiceId } from "./VoiceId.js";
 7: import { VoiceName } from "./VoiceName.js";
 8: 
 9: export const VoiceRef: core.serialization.Schema<serializers.empathicVoice.VoiceRef.Raw, Hume.empathicVoice.VoiceRef> =
10:     core.serialization.undiscriminatedUnion([VoiceId, VoiceName]);
11: 
12: export declare namespace VoiceRef {
13:     export type Raw = VoiceId.Raw | VoiceName.Raw;
14: }
````

## File: src/serialization/resources/empathicVoice/types/WebhookEvent.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { WebhookEventChatEnded } from "./WebhookEventChatEnded.js";
 7: import { WebhookEventChatStarted } from "./WebhookEventChatStarted.js";
 8: import { WebhookEventToolCall } from "./WebhookEventToolCall.js";
 9: 
10: export const WebhookEvent: core.serialization.Schema<
11:     serializers.empathicVoice.WebhookEvent.Raw,
12:     Hume.empathicVoice.WebhookEvent
13: > = core.serialization.undiscriminatedUnion([WebhookEventChatStarted, WebhookEventChatEnded, WebhookEventToolCall]);
14: 
15: export declare namespace WebhookEvent {
16:     export type Raw = WebhookEventChatStarted.Raw | WebhookEventChatEnded.Raw | WebhookEventToolCall.Raw;
17: }
````

## File: src/serialization/resources/empathicVoice/types/WebhookEventBase.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const WebhookEventBase: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.WebhookEventBase.Raw,
 9:     Hume.empathicVoice.WebhookEventBase
10: > = core.serialization.object({
11:     chatGroupId: core.serialization.property("chat_group_id", core.serialization.string()),
12:     chatId: core.serialization.property("chat_id", core.serialization.string()),
13:     configId: core.serialization.property("config_id", core.serialization.string().optional()),
14: });
15: 
16: export declare namespace WebhookEventBase {
17:     export interface Raw {
18:         chat_group_id: string;
19:         chat_id: string;
20:         config_id?: string | null;
21:     }
22: }
````

## File: src/serialization/resources/empathicVoice/types/WebhookEventChatEnded.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { WebhookEventBase } from "./WebhookEventBase.js";
 7: import { WebhookEventChatStatus } from "./WebhookEventChatStatus.js";
 8: 
 9: export const WebhookEventChatEnded: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.WebhookEventChatEnded.Raw,
11:     Hume.empathicVoice.WebhookEventChatEnded
12: > = core.serialization
13:     .object({
14:         callerNumber: core.serialization.property("caller_number", core.serialization.string().optional()),
15:         customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
16:         durationSeconds: core.serialization.property("duration_seconds", core.serialization.number()),
17:         endReason: core.serialization.property("end_reason", WebhookEventChatStatus),
18:         endTime: core.serialization.property("end_time", core.serialization.number()),
19:         eventName: core.serialization.property("event_name", core.serialization.stringLiteral("chat_ended").optional()),
20:     })
21:     .extend(WebhookEventBase);
22: 
23: export declare namespace WebhookEventChatEnded {
24:     export interface Raw extends WebhookEventBase.Raw {
25:         caller_number?: string | null;
26:         custom_session_id?: string | null;
27:         duration_seconds: number;
28:         end_reason: WebhookEventChatStatus.Raw;
29:         end_time: number;
30:         event_name?: "chat_ended" | null;
31:     }
32: }
````

## File: src/serialization/resources/empathicVoice/types/WebhookEventChatStarted.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { WebhookEventBase } from "./WebhookEventBase.js";
 7: import { WebhookEventChatStartType } from "./WebhookEventChatStartType.js";
 8: 
 9: export const WebhookEventChatStarted: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.WebhookEventChatStarted.Raw,
11:     Hume.empathicVoice.WebhookEventChatStarted
12: > = core.serialization
13:     .object({
14:         callerNumber: core.serialization.property("caller_number", core.serialization.string().optional()),
15:         chatStartType: core.serialization.property("chat_start_type", WebhookEventChatStartType),
16:         customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
17:         eventName: core.serialization.property(
18:             "event_name",
19:             core.serialization.stringLiteral("chat_started").optional(),
20:         ),
21:         startTime: core.serialization.property("start_time", core.serialization.number()),
22:     })
23:     .extend(WebhookEventBase);
24: 
25: export declare namespace WebhookEventChatStarted {
26:     export interface Raw extends WebhookEventBase.Raw {
27:         caller_number?: string | null;
28:         chat_start_type: WebhookEventChatStartType.Raw;
29:         custom_session_id?: string | null;
30:         event_name?: "chat_started" | null;
31:         start_time: number;
32:     }
33: }
````

## File: src/serialization/resources/empathicVoice/types/WebhookEventChatStartType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const WebhookEventChatStartType: core.serialization.Schema<
 8:     serializers.empathicVoice.WebhookEventChatStartType.Raw,
 9:     Hume.empathicVoice.WebhookEventChatStartType
10: > = core.serialization.enum_(["new_chat_group", "resumed_chat_group"]);
11: 
12: export declare namespace WebhookEventChatStartType {
13:     export type Raw = "new_chat_group" | "resumed_chat_group";
14: }
````

## File: src/serialization/resources/empathicVoice/types/WebhookEventChatStatus.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const WebhookEventChatStatus: core.serialization.Schema<
 8:     serializers.empathicVoice.WebhookEventChatStatus.Raw,
 9:     Hume.empathicVoice.WebhookEventChatStatus
10: > = core.serialization.enum_([
11:     "ACTIVE",
12:     "USER_ENDED",
13:     "USER_TIMEOUT",
14:     "INACTIVITY_TIMEOUT",
15:     "MAX_DURATION_TIMEOUT",
16:     "SILENCE_TIMEOUT",
17:     "ERROR",
18: ]);
19: 
20: export declare namespace WebhookEventChatStatus {
21:     export type Raw =
22:         | "ACTIVE"
23:         | "USER_ENDED"
24:         | "USER_TIMEOUT"
25:         | "INACTIVITY_TIMEOUT"
26:         | "MAX_DURATION_TIMEOUT"
27:         | "SILENCE_TIMEOUT"
28:         | "ERROR";
29: }
````

## File: src/serialization/resources/empathicVoice/types/WebhookEventToolCall.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ToolCallMessage } from "./ToolCallMessage.js";
 7: import { WebhookEventBase } from "./WebhookEventBase.js";
 8: 
 9: export const WebhookEventToolCall: core.serialization.ObjectSchema<
10:     serializers.empathicVoice.WebhookEventToolCall.Raw,
11:     Hume.empathicVoice.WebhookEventToolCall
12: > = core.serialization
13:     .object({
14:         callerNumber: core.serialization.property("caller_number", core.serialization.string().optional()),
15:         customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
16:         eventName: core.serialization.property("event_name", core.serialization.stringLiteral("tool_call").optional()),
17:         timestamp: core.serialization.number(),
18:         toolCallMessage: core.serialization.property("tool_call_message", ToolCallMessage),
19:     })
20:     .extend(WebhookEventBase);
21: 
22: export declare namespace WebhookEventToolCall {
23:     export interface Raw extends WebhookEventBase.Raw {
24:         caller_number?: string | null;
25:         custom_session_id?: string | null;
26:         event_name?: "tool_call" | null;
27:         timestamp: number;
28:         tool_call_message: ToolCallMessage.Raw;
29:     }
30: }
````

## File: src/serialization/resources/empathicVoice/types/WebSocketError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const WebSocketError: core.serialization.ObjectSchema<
 8:     serializers.empathicVoice.WebSocketError.Raw,
 9:     Hume.empathicVoice.WebSocketError
10: > = core.serialization.object({
11:     code: core.serialization.string(),
12:     customSessionId: core.serialization.property("custom_session_id", core.serialization.string().optional()),
13:     message: core.serialization.string(),
14:     requestId: core.serialization.property("request_id", core.serialization.string().optional()),
15:     slug: core.serialization.string(),
16:     type: core.serialization.stringLiteral("error"),
17: });
18: 
19: export declare namespace WebSocketError {
20:     export interface Raw {
21:         code: string;
22:         custom_session_id?: string | null;
23:         message: string;
24:         request_id?: string | null;
25:         slug: string;
26:         type: "error";
27:     }
28: }
````

## File: src/serialization/resources/empathicVoice/index.ts
````typescript
1: export * from "./resources/index.js";
2: export * from "./types/index.js";
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/client/getJobPredictions.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { UnionPredictResult } from "../types/UnionPredictResult.js";
 7: 
 8: export const Response: core.serialization.Schema<
 9:     serializers.expressionMeasurement.batch.getJobPredictions.Response.Raw,
10:     Hume.expressionMeasurement.batch.UnionPredictResult[]
11: > = core.serialization.list(UnionPredictResult);
12: 
13: export declare namespace Response {
14:     export type Raw = UnionPredictResult.Raw[];
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/client/index.ts
````typescript
1: export * as getJobPredictions from "./getJobPredictions.js";
2: export * as listJobs from "./listJobs.js";
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/client/listJobs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { UnionJob } from "../types/UnionJob.js";
 7: 
 8: export const Response: core.serialization.Schema<
 9:     serializers.expressionMeasurement.batch.listJobs.Response.Raw,
10:     Hume.expressionMeasurement.batch.UnionJob[]
11: > = core.serialization.list(UnionJob);
12: 
13: export declare namespace Response {
14:     export type Raw = UnionJob.Raw[];
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Alternative.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Alternative: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.Alternative.Raw,
 9:     Hume.expressionMeasurement.batch.Alternative
10: > = core.serialization.stringLiteral("language_only");
11: 
12: export declare namespace Alternative {
13:     export type Raw = "language_only";
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Bcp47Tag.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Bcp47Tag: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.Bcp47Tag.Raw,
 9:     Hume.expressionMeasurement.batch.Bcp47Tag
10: > = core.serialization.enum_([
11:     "zh",
12:     "da",
13:     "nl",
14:     "en",
15:     "en-AU",
16:     "en-IN",
17:     "en-NZ",
18:     "en-GB",
19:     "fr",
20:     "fr-CA",
21:     "de",
22:     "hi",
23:     "hi-Latn",
24:     "id",
25:     "it",
26:     "ja",
27:     "ko",
28:     "no",
29:     "pl",
30:     "pt",
31:     "pt-BR",
32:     "pt-PT",
33:     "ru",
34:     "es",
35:     "es-419",
36:     "sv",
37:     "ta",
38:     "tr",
39:     "uk",
40: ]);
41: 
42: export declare namespace Bcp47Tag {
43:     export type Raw =
44:         | "zh"
45:         | "da"
46:         | "nl"
47:         | "en"
48:         | "en-AU"
49:         | "en-IN"
50:         | "en-NZ"
51:         | "en-GB"
52:         | "fr"
53:         | "fr-CA"
54:         | "de"
55:         | "hi"
56:         | "hi-Latn"
57:         | "id"
58:         | "it"
59:         | "ja"
60:         | "ko"
61:         | "no"
62:         | "pl"
63:         | "pt"
64:         | "pt-BR"
65:         | "pt-PT"
66:         | "ru"
67:         | "es"
68:         | "es-419"
69:         | "sv"
70:         | "ta"
71:         | "tr"
72:         | "uk";
73: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/BoundingBox.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const BoundingBox: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.BoundingBox.Raw,
 9:     Hume.expressionMeasurement.batch.BoundingBox
10: > = core.serialization.object({
11:     x: core.serialization.number(),
12:     y: core.serialization.number(),
13:     w: core.serialization.number(),
14:     h: core.serialization.number(),
15: });
16: 
17: export declare namespace BoundingBox {
18:     export interface Raw {
19:         x: number;
20:         y: number;
21:         w: number;
22:         h: number;
23:     }
24: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/BurstPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { DescriptionsScore } from "./DescriptionsScore.js";
 7: import { EmotionScore } from "./EmotionScore.js";
 8: import { TimeInterval } from "./TimeInterval.js";
 9: 
10: export const BurstPrediction: core.serialization.ObjectSchema<
11:     serializers.expressionMeasurement.batch.BurstPrediction.Raw,
12:     Hume.expressionMeasurement.batch.BurstPrediction
13: > = core.serialization.object({
14:     time: TimeInterval,
15:     emotions: core.serialization.list(EmotionScore),
16:     descriptions: core.serialization.list(DescriptionsScore),
17: });
18: 
19: export declare namespace BurstPrediction {
20:     export interface Raw {
21:         time: TimeInterval.Raw;
22:         emotions: EmotionScore.Raw[];
23:         descriptions: DescriptionsScore.Raw[];
24:     }
25: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Classification.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Classification: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.Classification.Raw,
 9:     Hume.expressionMeasurement.batch.Classification
10: > = core.serialization.record(core.serialization.string(), core.serialization.unknown());
11: 
12: export declare namespace Classification {
13:     export type Raw = Record<string, unknown>;
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedEmbeddingGeneration.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const CompletedEmbeddingGeneration: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.CompletedEmbeddingGeneration.Raw,
 9:     Hume.expressionMeasurement.batch.CompletedEmbeddingGeneration
10: > = core.serialization.object({
11:     createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
12:     startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
13:     endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
14: });
15: 
16: export declare namespace CompletedEmbeddingGeneration {
17:     export interface Raw {
18:         created_timestamp_ms: number;
19:         started_timestamp_ms: number;
20:         ended_timestamp_ms: number;
21:     }
22: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const CompletedInference: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.CompletedInference.Raw,
 9:     Hume.expressionMeasurement.batch.CompletedInference
10: > = core.serialization.object({
11:     createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
12:     startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
13:     endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
14:     numPredictions: core.serialization.property("num_predictions", core.serialization.number()),
15:     numErrors: core.serialization.property("num_errors", core.serialization.number()),
16: });
17: 
18: export declare namespace CompletedInference {
19:     export interface Raw {
20:         created_timestamp_ms: number;
21:         started_timestamp_ms: number;
22:         ended_timestamp_ms: number;
23:         num_predictions: number;
24:         num_errors: number;
25:     }
26: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedState.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { CompletedInference } from "./CompletedInference.js";
 7: 
 8: export const CompletedState: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.CompletedState.Raw,
10:     Hume.expressionMeasurement.batch.CompletedState
11: > = core.serialization.object({}).extend(CompletedInference);
12: 
13: export declare namespace CompletedState {
14:     export interface Raw extends CompletedInference.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedTlInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const CompletedTlInference: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.CompletedTlInference.Raw,
 9:     Hume.expressionMeasurement.batch.CompletedTlInference
10: > = core.serialization.object({
11:     createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
12:     startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
13:     endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
14:     numPredictions: core.serialization.property("num_predictions", core.serialization.number()),
15:     numErrors: core.serialization.property("num_errors", core.serialization.number()),
16: });
17: 
18: export declare namespace CompletedTlInference {
19:     export interface Raw {
20:         created_timestamp_ms: number;
21:         started_timestamp_ms: number;
22:         ended_timestamp_ms: number;
23:         num_predictions: number;
24:         num_errors: number;
25:     }
26: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/CompletedTraining.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { TrainingCustomModel } from "./TrainingCustomModel.js";
 7: 
 8: export const CompletedTraining: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.CompletedTraining.Raw,
10:     Hume.expressionMeasurement.batch.CompletedTraining
11: > = core.serialization.object({
12:     createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
13:     startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
14:     endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
15:     customModel: core.serialization.property("custom_model", TrainingCustomModel),
16:     alternatives: core.serialization.record(core.serialization.string(), TrainingCustomModel).optional(),
17: });
18: 
19: export declare namespace CompletedTraining {
20:     export interface Raw {
21:         created_timestamp_ms: number;
22:         started_timestamp_ms: number;
23:         ended_timestamp_ms: number;
24:         custom_model: TrainingCustomModel.Raw;
25:         alternatives?: Record<string, TrainingCustomModel.Raw> | null;
26:     }
27: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModel.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { CustomModelId } from "./CustomModelId.js";
 7: import { CustomModelVersionId } from "./CustomModelVersionId.js";
 8: 
 9: export const CustomModel: core.serialization.Schema<
10:     serializers.expressionMeasurement.batch.CustomModel.Raw,
11:     Hume.expressionMeasurement.batch.CustomModel
12: > = core.serialization.undiscriminatedUnion([CustomModelId, CustomModelVersionId]);
13: 
14: export declare namespace CustomModel {
15:     export type Raw = CustomModelId.Raw | CustomModelVersionId.Raw;
16: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelId.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const CustomModelId: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.CustomModelId.Raw,
 9:     Hume.expressionMeasurement.batch.CustomModelId
10: > = core.serialization.object({
11:     id: core.serialization.string(),
12: });
13: 
14: export declare namespace CustomModelId {
15:     export interface Raw {
16:         id: string;
17:     }
18: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const CustomModelPrediction: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.CustomModelPrediction.Raw,
 9:     Hume.expressionMeasurement.batch.CustomModelPrediction
10: > = core.serialization.object({
11:     output: core.serialization.record(core.serialization.string(), core.serialization.number()),
12:     error: core.serialization.string(),
13:     taskType: core.serialization.property("task_type", core.serialization.string()),
14: });
15: 
16: export declare namespace CustomModelPrediction {
17:     export interface Raw {
18:         output: Record<string, number>;
19:         error: string;
20:         task_type: string;
21:     }
22: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Tag } from "./Tag.js";
 7: 
 8: export const CustomModelRequest: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.CustomModelRequest.Raw,
10:     Hume.expressionMeasurement.batch.CustomModelRequest
11: > = core.serialization.object({
12:     name: core.serialization.string(),
13:     description: core.serialization.string().optional(),
14:     tags: core.serialization.list(Tag).optional(),
15: });
16: 
17: export declare namespace CustomModelRequest {
18:     export interface Raw {
19:         name: string;
20:         description?: string | null;
21:         tags?: Tag.Raw[] | null;
22:     }
23: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelsInferenceJob.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { JobTlInference } from "./JobTlInference.js";
 7: 
 8: export const CustomModelsInferenceJob: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.CustomModelsInferenceJob.Raw,
10:     Hume.expressionMeasurement.batch.CustomModelsInferenceJob
11: > = core.serialization
12:     .object({
13:         type: core.serialization.string(),
14:     })
15:     .extend(JobTlInference);
16: 
17: export declare namespace CustomModelsInferenceJob {
18:     export interface Raw extends JobTlInference.Raw {
19:         type: string;
20:     }
21: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelsTrainingJob.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { JobTraining } from "./JobTraining.js";
 7: 
 8: export const CustomModelsTrainingJob: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.CustomModelsTrainingJob.Raw,
10:     Hume.expressionMeasurement.batch.CustomModelsTrainingJob
11: > = core.serialization
12:     .object({
13:         type: core.serialization.string(),
14:     })
15:     .extend(JobTraining);
16: 
17: export declare namespace CustomModelsTrainingJob {
18:     export interface Raw extends JobTraining.Raw {
19:         type: string;
20:     }
21: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/CustomModelVersionId.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const CustomModelVersionId: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.CustomModelVersionId.Raw,
 9:     Hume.expressionMeasurement.batch.CustomModelVersionId
10: > = core.serialization.object({
11:     versionId: core.serialization.property("version_id", core.serialization.string()),
12: });
13: 
14: export declare namespace CustomModelVersionId {
15:     export interface Raw {
16:         version_id: string;
17:     }
18: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Dataset.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { DatasetId } from "./DatasetId.js";
 7: import { DatasetVersionId } from "./DatasetVersionId.js";
 8: 
 9: export const Dataset: core.serialization.Schema<
10:     serializers.expressionMeasurement.batch.Dataset.Raw,
11:     Hume.expressionMeasurement.batch.Dataset
12: > = core.serialization.undiscriminatedUnion([DatasetId, DatasetVersionId]);
13: 
14: export declare namespace Dataset {
15:     export type Raw = DatasetId.Raw | DatasetVersionId.Raw;
16: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/DatasetId.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const DatasetId: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.DatasetId.Raw,
 9:     Hume.expressionMeasurement.batch.DatasetId
10: > = core.serialization.object({
11:     id: core.serialization.string(),
12: });
13: 
14: export declare namespace DatasetId {
15:     export interface Raw {
16:         id: string;
17:     }
18: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/DatasetVersionId.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const DatasetVersionId: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.DatasetVersionId.Raw,
 9:     Hume.expressionMeasurement.batch.DatasetVersionId
10: > = core.serialization.object({
11:     versionId: core.serialization.property("version_id", core.serialization.string()),
12: });
13: 
14: export declare namespace DatasetVersionId {
15:     export interface Raw {
16:         version_id: string;
17:     }
18: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/DescriptionsScore.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const DescriptionsScore: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.DescriptionsScore.Raw,
 9:     Hume.expressionMeasurement.batch.DescriptionsScore
10: > = core.serialization.object({
11:     name: core.serialization.string(),
12:     score: core.serialization.number(),
13: });
14: 
15: export declare namespace DescriptionsScore {
16:     export interface Raw {
17:         name: string;
18:         score: number;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Direction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Direction: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.Direction.Raw,
 9:     Hume.expressionMeasurement.batch.Direction
10: > = core.serialization.enum_(["asc", "desc"]);
11: 
12: export declare namespace Direction {
13:     export type Raw = "asc" | "desc";
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/EmbeddingGenerationBaseRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { RegistryFileDetail } from "./RegistryFileDetail.js";
 7: 
 8: export const EmbeddingGenerationBaseRequest: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.EmbeddingGenerationBaseRequest.Raw,
10:     Hume.expressionMeasurement.batch.EmbeddingGenerationBaseRequest
11: > = core.serialization.object({
12:     registryFileDetails: core.serialization.property(
13:         "registry_file_details",
14:         core.serialization.list(RegistryFileDetail).optional(),
15:     ),
16: });
17: 
18: export declare namespace EmbeddingGenerationBaseRequest {
19:     export interface Raw {
20:         registry_file_details?: RegistryFileDetail.Raw[] | null;
21:     }
22: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/EmbeddingGenerationJob.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { JobEmbeddingGeneration } from "./JobEmbeddingGeneration.js";
 7: 
 8: export const EmbeddingGenerationJob: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.EmbeddingGenerationJob.Raw,
10:     Hume.expressionMeasurement.batch.EmbeddingGenerationJob
11: > = core.serialization
12:     .object({
13:         type: core.serialization.string(),
14:     })
15:     .extend(JobEmbeddingGeneration);
16: 
17: export declare namespace EmbeddingGenerationJob {
18:     export interface Raw extends JobEmbeddingGeneration.Raw {
19:         type: string;
20:     }
21: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/EmotionScore.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const EmotionScore: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.EmotionScore.Raw,
 9:     Hume.expressionMeasurement.batch.EmotionScore
10: > = core.serialization.object({
11:     name: core.serialization.string(),
12:     score: core.serialization.number(),
13: });
14: 
15: export declare namespace EmotionScore {
16:     export interface Raw {
17:         name: string;
18:         score: number;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Error_.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Error_: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.Error_.Raw,
 9:     Hume.expressionMeasurement.batch.Error_
10: > = core.serialization.object({
11:     message: core.serialization.string(),
12:     file: core.serialization.string(),
13: });
14: 
15: export declare namespace Error_ {
16:     export interface Raw {
17:         message: string;
18:         file: string;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/EvaluationArgs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { ValidationArgs } from "./ValidationArgs.js";
 7: 
 8: export const EvaluationArgs: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.EvaluationArgs.Raw,
10:     Hume.expressionMeasurement.batch.EvaluationArgs
11: > = core.serialization.object({
12:     validation: ValidationArgs.optional(),
13: });
14: 
15: export declare namespace EvaluationArgs {
16:     export interface Raw {
17:         validation?: ValidationArgs.Raw | null;
18:     }
19: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Face.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Unconfigurable } from "./Unconfigurable.js";
 7: 
 8: export const Face: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.Face.Raw,
10:     Hume.expressionMeasurement.batch.Face
11: > = core.serialization.object({
12:     fpsPred: core.serialization.property("fps_pred", core.serialization.number().optional()),
13:     probThreshold: core.serialization.property("prob_threshold", core.serialization.number().optional()),
14:     identifyFaces: core.serialization.property("identify_faces", core.serialization.boolean().optional()),
15:     minFaceSize: core.serialization.property("min_face_size", core.serialization.number().optional()),
16:     facs: Unconfigurable.optional(),
17:     descriptions: Unconfigurable.optional(),
18:     saveFaces: core.serialization.property("save_faces", core.serialization.boolean().optional()),
19: });
20: 
21: export declare namespace Face {
22:     export interface Raw {
23:         fps_pred?: number | null;
24:         prob_threshold?: number | null;
25:         identify_faces?: boolean | null;
26:         min_face_size?: number | null;
27:         facs?: Unconfigurable.Raw | null;
28:         descriptions?: Unconfigurable.Raw | null;
29:         save_faces?: boolean | null;
30:     }
31: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/FacemeshPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { EmotionScore } from "./EmotionScore.js";
 7: 
 8: export const FacemeshPrediction: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.FacemeshPrediction.Raw,
10:     Hume.expressionMeasurement.batch.FacemeshPrediction
11: > = core.serialization.object({
12:     emotions: core.serialization.list(EmotionScore),
13: });
14: 
15: export declare namespace FacemeshPrediction {
16:     export interface Raw {
17:         emotions: EmotionScore.Raw[];
18:     }
19: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/FacePrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { BoundingBox } from "./BoundingBox.js";
 7: import { DescriptionsScore } from "./DescriptionsScore.js";
 8: import { EmotionScore } from "./EmotionScore.js";
 9: import { FacsScore } from "./FacsScore.js";
10: 
11: export const FacePrediction: core.serialization.ObjectSchema<
12:     serializers.expressionMeasurement.batch.FacePrediction.Raw,
13:     Hume.expressionMeasurement.batch.FacePrediction
14: > = core.serialization.object({
15:     frame: core.serialization.number(),
16:     time: core.serialization.number(),
17:     prob: core.serialization.number(),
18:     box: BoundingBox,
19:     emotions: core.serialization.list(EmotionScore),
20:     facs: core.serialization.list(FacsScore).optional(),
21:     descriptions: core.serialization.list(DescriptionsScore).optional(),
22: });
23: 
24: export declare namespace FacePrediction {
25:     export interface Raw {
26:         frame: number;
27:         time: number;
28:         prob: number;
29:         box: BoundingBox.Raw;
30:         emotions: EmotionScore.Raw[];
31:         facs?: FacsScore.Raw[] | null;
32:         descriptions?: DescriptionsScore.Raw[] | null;
33:     }
34: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/FacsScore.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const FacsScore: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.FacsScore.Raw,
 9:     Hume.expressionMeasurement.batch.FacsScore
10: > = core.serialization.object({
11:     name: core.serialization.string(),
12:     score: core.serialization.number(),
13: });
14: 
15: export declare namespace FacsScore {
16:     export interface Raw {
17:         name: string;
18:         score: number;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Failed.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Failed: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.Failed.Raw,
 9:     Hume.expressionMeasurement.batch.Failed
10: > = core.serialization.object({
11:     createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
12:     startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
13:     endedTimestampMs: core.serialization.property("ended_timestamp_ms", core.serialization.number()),
14:     message: core.serialization.string(),
15: });
16: 
17: export declare namespace Failed {
18:     export interface Raw {
19:         created_timestamp_ms: number;
20:         started_timestamp_ms: number;
21:         ended_timestamp_ms: number;
22:         message: string;
23:     }
24: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/FailedState.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Failed } from "./Failed.js";
 7: 
 8: export const FailedState: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.FailedState.Raw,
10:     Hume.expressionMeasurement.batch.FailedState
11: > = core.serialization.object({}).extend(Failed);
12: 
13: export declare namespace FailedState {
14:     export interface Raw extends Failed.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/File_.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const File_: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.File_.Raw,
 9:     Hume.expressionMeasurement.batch.File_
10: > = core.serialization.object({
11:     filename: core.serialization.string().optional(),
12:     contentType: core.serialization.property("content_type", core.serialization.string().optional()),
13:     md5Sum: core.serialization.property("md5sum", core.serialization.string()),
14: });
15: 
16: export declare namespace File_ {
17:     export interface Raw {
18:         filename?: string | null;
19:         content_type?: string | null;
20:         md5sum: string;
21:     }
22: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Granularity.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Granularity: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.Granularity.Raw,
 9:     Hume.expressionMeasurement.batch.Granularity
10: > = core.serialization.enum_(["word", "sentence", "utterance", "conversational_turn"]);
11: 
12: export declare namespace Granularity {
13:     export type Raw = "word" | "sentence" | "utterance" | "conversational_turn";
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsBurstPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { BurstPrediction } from "./BurstPrediction.js";
 7: 
 8: export const GroupedPredictionsBurstPrediction: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.GroupedPredictionsBurstPrediction.Raw,
10:     Hume.expressionMeasurement.batch.GroupedPredictionsBurstPrediction
11: > = core.serialization.object({
12:     id: core.serialization.string(),
13:     predictions: core.serialization.list(BurstPrediction),
14: });
15: 
16: export declare namespace GroupedPredictionsBurstPrediction {
17:     export interface Raw {
18:         id: string;
19:         predictions: BurstPrediction.Raw[];
20:     }
21: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsFacemeshPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { FacemeshPrediction } from "./FacemeshPrediction.js";
 7: 
 8: export const GroupedPredictionsFacemeshPrediction: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.GroupedPredictionsFacemeshPrediction.Raw,
10:     Hume.expressionMeasurement.batch.GroupedPredictionsFacemeshPrediction
11: > = core.serialization.object({
12:     id: core.serialization.string(),
13:     predictions: core.serialization.list(FacemeshPrediction),
14: });
15: 
16: export declare namespace GroupedPredictionsFacemeshPrediction {
17:     export interface Raw {
18:         id: string;
19:         predictions: FacemeshPrediction.Raw[];
20:     }
21: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsFacePrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { FacePrediction } from "./FacePrediction.js";
 7: 
 8: export const GroupedPredictionsFacePrediction: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.GroupedPredictionsFacePrediction.Raw,
10:     Hume.expressionMeasurement.batch.GroupedPredictionsFacePrediction
11: > = core.serialization.object({
12:     id: core.serialization.string(),
13:     predictions: core.serialization.list(FacePrediction),
14: });
15: 
16: export declare namespace GroupedPredictionsFacePrediction {
17:     export interface Raw {
18:         id: string;
19:         predictions: FacePrediction.Raw[];
20:     }
21: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsLanguagePrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { LanguagePrediction } from "./LanguagePrediction.js";
 7: 
 8: export const GroupedPredictionsLanguagePrediction: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.GroupedPredictionsLanguagePrediction.Raw,
10:     Hume.expressionMeasurement.batch.GroupedPredictionsLanguagePrediction
11: > = core.serialization.object({
12:     id: core.serialization.string(),
13:     predictions: core.serialization.list(LanguagePrediction),
14: });
15: 
16: export declare namespace GroupedPredictionsLanguagePrediction {
17:     export interface Raw {
18:         id: string;
19:         predictions: LanguagePrediction.Raw[];
20:     }
21: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsNerPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { NerPrediction } from "./NerPrediction.js";
 7: 
 8: export const GroupedPredictionsNerPrediction: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.GroupedPredictionsNerPrediction.Raw,
10:     Hume.expressionMeasurement.batch.GroupedPredictionsNerPrediction
11: > = core.serialization.object({
12:     id: core.serialization.string(),
13:     predictions: core.serialization.list(NerPrediction),
14: });
15: 
16: export declare namespace GroupedPredictionsNerPrediction {
17:     export interface Raw {
18:         id: string;
19:         predictions: NerPrediction.Raw[];
20:     }
21: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/GroupedPredictionsProsodyPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { ProsodyPrediction } from "./ProsodyPrediction.js";
 7: 
 8: export const GroupedPredictionsProsodyPrediction: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.GroupedPredictionsProsodyPrediction.Raw,
10:     Hume.expressionMeasurement.batch.GroupedPredictionsProsodyPrediction
11: > = core.serialization.object({
12:     id: core.serialization.string(),
13:     predictions: core.serialization.list(ProsodyPrediction),
14: });
15: 
16: export declare namespace GroupedPredictionsProsodyPrediction {
17:     export interface Raw {
18:         id: string;
19:         predictions: ProsodyPrediction.Raw[];
20:     }
21: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/index.ts
````typescript
  1: export * from "./Alternative.js";
  2: export * from "./Bcp47Tag.js";
  3: export * from "./BoundingBox.js";
  4: export * from "./BurstPrediction.js";
  5: export * from "./Classification.js";
  6: export * from "./CompletedEmbeddingGeneration.js";
  7: export * from "./CompletedInference.js";
  8: export * from "./CompletedState.js";
  9: export * from "./CompletedTlInference.js";
 10: export * from "./CompletedTraining.js";
 11: export * from "./CustomModel.js";
 12: export * from "./CustomModelId.js";
 13: export * from "./CustomModelPrediction.js";
 14: export * from "./CustomModelRequest.js";
 15: export * from "./CustomModelsInferenceJob.js";
 16: export * from "./CustomModelsTrainingJob.js";
 17: export * from "./CustomModelVersionId.js";
 18: export * from "./Dataset.js";
 19: export * from "./DatasetId.js";
 20: export * from "./DatasetVersionId.js";
 21: export * from "./DescriptionsScore.js";
 22: export * from "./Direction.js";
 23: export * from "./EmbeddingGenerationBaseRequest.js";
 24: export * from "./EmbeddingGenerationJob.js";
 25: export * from "./EmotionScore.js";
 26: export * from "./Error_.js";
 27: export * from "./EvaluationArgs.js";
 28: export * from "./Face.js";
 29: export * from "./FacemeshPrediction.js";
 30: export * from "./FacePrediction.js";
 31: export * from "./FacsScore.js";
 32: export * from "./Failed.js";
 33: export * from "./FailedState.js";
 34: export * from "./File_.js";
 35: export * from "./Granularity.js";
 36: export * from "./GroupedPredictionsBurstPrediction.js";
 37: export * from "./GroupedPredictionsFacemeshPrediction.js";
 38: export * from "./GroupedPredictionsFacePrediction.js";
 39: export * from "./GroupedPredictionsLanguagePrediction.js";
 40: export * from "./GroupedPredictionsNerPrediction.js";
 41: export * from "./GroupedPredictionsProsodyPrediction.js";
 42: export * from "./InferenceBaseRequest.js";
 43: export * from "./InferenceJob.js";
 44: export * from "./InferencePrediction.js";
 45: export * from "./InferenceRequest.js";
 46: export * from "./InferenceResults.js";
 47: export * from "./InferenceSourcePredictResult.js";
 48: export * from "./InProgress.js";
 49: export * from "./InProgressState.js";
 50: export * from "./JobEmbeddingGeneration.js";
 51: export * from "./JobId.js";
 52: export * from "./JobInference.js";
 53: export * from "./JobTlInference.js";
 54: export * from "./JobTraining.js";
 55: export * from "./Language.js";
 56: export * from "./LanguagePrediction.js";
 57: export * from "./Models.js";
 58: export * from "./ModelsPredictions.js";
 59: export * from "./Ner.js";
 60: export * from "./NerPrediction.js";
 61: export * from "./Null.js";
 62: export * from "./PositionInterval.js";
 63: export * from "./PredictionsOptionalNullBurstPrediction.js";
 64: export * from "./PredictionsOptionalNullFacemeshPrediction.js";
 65: export * from "./PredictionsOptionalNullFacePrediction.js";
 66: export * from "./PredictionsOptionalTranscriptionMetadataLanguagePrediction.js";
 67: export * from "./PredictionsOptionalTranscriptionMetadataNerPrediction.js";
 68: export * from "./PredictionsOptionalTranscriptionMetadataProsodyPrediction.js";
 69: export * from "./Prosody.js";
 70: export * from "./ProsodyPrediction.js";
 71: export * from "./Queued.js";
 72: export * from "./QueuedState.js";
 73: export * from "./RegistryFileDetail.js";
 74: export * from "./Regression.js";
 75: export * from "./SentimentScore.js";
 76: export * from "./SortBy.js";
 77: export * from "./Source.js";
 78: export * from "./SourceFile.js";
 79: export * from "./SourceTextSource.js";
 80: export * from "./SourceUrl.js";
 81: export * from "./StateEmbeddingGeneration.js";
 82: export * from "./StateEmbeddingGenerationCompletedEmbeddingGeneration.js";
 83: export * from "./StateEmbeddingGenerationFailed.js";
 84: export * from "./StateEmbeddingGenerationInProgress.js";
 85: export * from "./StateEmbeddingGenerationQueued.js";
 86: export * from "./StateInference.js";
 87: export * from "./StateTlInference.js";
 88: export * from "./StateTlInferenceCompletedTlInference.js";
 89: export * from "./StateTlInferenceFailed.js";
 90: export * from "./StateTlInferenceInProgress.js";
 91: export * from "./StateTlInferenceQueued.js";
 92: export * from "./StateTraining.js";
 93: export * from "./StateTrainingCompletedTraining.js";
 94: export * from "./StateTrainingFailed.js";
 95: export * from "./StateTrainingInProgress.js";
 96: export * from "./StateTrainingQueued.js";
 97: export * from "./Status.js";
 98: export * from "./Tag.js";
 99: export * from "./Target.js";
100: export * from "./Task.js";
101: export * from "./TaskClassification.js";
102: export * from "./TaskRegression.js";
103: export * from "./TextSource.js";
104: export * from "./TimeInterval.js";
105: export * from "./TlInferenceBaseRequest.js";
106: export * from "./TlInferencePrediction.js";
107: export * from "./TlInferenceResults.js";
108: export * from "./TlInferenceSourcePredictResult.js";
109: export * from "./ToxicityScore.js";
110: export * from "./TrainingBaseRequest.js";
111: export * from "./TrainingCustomModel.js";
112: export * from "./Transcription.js";
113: export * from "./TranscriptionMetadata.js";
114: export * from "./Type.js";
115: export * from "./Unconfigurable.js";
116: export * from "./UnionJob.js";
117: export * from "./UnionPredictResult.js";
118: export * from "./Url.js";
119: export * from "./ValidationArgs.js";
120: export * from "./When.js";
121: export * from "./Window.js";
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceBaseRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Models } from "./Models.js";
 7: import { Transcription } from "./Transcription.js";
 8: 
 9: export const InferenceBaseRequest: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.InferenceBaseRequest.Raw,
11:     Hume.expressionMeasurement.batch.InferenceBaseRequest
12: > = core.serialization.object({
13:     models: Models.optional(),
14:     transcription: Transcription.optional(),
15:     urls: core.serialization.list(core.serialization.string()).optional(),
16:     text: core.serialization.list(core.serialization.string()).optional(),
17:     callbackUrl: core.serialization.property("callback_url", core.serialization.string().optional()),
18:     notify: core.serialization.boolean().optional(),
19: });
20: 
21: export declare namespace InferenceBaseRequest {
22:     export interface Raw {
23:         models?: Models.Raw | null;
24:         transcription?: Transcription.Raw | null;
25:         urls?: string[] | null;
26:         text?: string[] | null;
27:         callback_url?: string | null;
28:         notify?: boolean | null;
29:     }
30: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceJob.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { JobInference } from "./JobInference.js";
 7: 
 8: export const InferenceJob: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.InferenceJob.Raw,
10:     Hume.expressionMeasurement.batch.InferenceJob
11: > = core.serialization
12:     .object({
13:         type: core.serialization.string(),
14:     })
15:     .extend(JobInference);
16: 
17: export declare namespace InferenceJob {
18:     export interface Raw extends JobInference.Raw {
19:         type: string;
20:     }
21: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/InferencePrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { ModelsPredictions } from "./ModelsPredictions.js";
 7: 
 8: export const InferencePrediction: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.InferencePrediction.Raw,
10:     Hume.expressionMeasurement.batch.InferencePrediction
11: > = core.serialization.object({
12:     file: core.serialization.string(),
13:     models: ModelsPredictions,
14: });
15: 
16: export declare namespace InferencePrediction {
17:     export interface Raw {
18:         file: string;
19:         models: ModelsPredictions.Raw;
20:     }
21: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { File_ } from "./File_.js";
 7: import { Models } from "./Models.js";
 8: import { Transcription } from "./Transcription.js";
 9: 
10: export const InferenceRequest: core.serialization.ObjectSchema<
11:     serializers.expressionMeasurement.batch.InferenceRequest.Raw,
12:     Hume.expressionMeasurement.batch.InferenceRequest
13: > = core.serialization.object({
14:     models: Models.optional(),
15:     transcription: Transcription.optional(),
16:     urls: core.serialization.list(core.serialization.string()).optional(),
17:     text: core.serialization.list(core.serialization.string()).optional(),
18:     callbackUrl: core.serialization.property("callback_url", core.serialization.string().optional()),
19:     notify: core.serialization.boolean().optional(),
20:     files: core.serialization.list(File_),
21: });
22: 
23: export declare namespace InferenceRequest {
24:     export interface Raw {
25:         models?: Models.Raw | null;
26:         transcription?: Transcription.Raw | null;
27:         urls?: string[] | null;
28:         text?: string[] | null;
29:         callback_url?: string | null;
30:         notify?: boolean | null;
31:         files: File_.Raw[];
32:     }
33: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceResults.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Error_ } from "./Error_.js";
 7: import { InferencePrediction } from "./InferencePrediction.js";
 8: 
 9: export const InferenceResults: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.InferenceResults.Raw,
11:     Hume.expressionMeasurement.batch.InferenceResults
12: > = core.serialization.object({
13:     predictions: core.serialization.list(InferencePrediction),
14:     errors: core.serialization.list(Error_),
15: });
16: 
17: export declare namespace InferenceResults {
18:     export interface Raw {
19:         predictions: InferencePrediction.Raw[];
20:         errors: Error_.Raw[];
21:     }
22: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/InferenceSourcePredictResult.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { InferenceResults } from "./InferenceResults.js";
 7: import { Source } from "./Source.js";
 8: 
 9: export const InferenceSourcePredictResult: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.InferenceSourcePredictResult.Raw,
11:     Hume.expressionMeasurement.batch.InferenceSourcePredictResult
12: > = core.serialization.object({
13:     source: Source,
14:     results: InferenceResults.optional(),
15:     error: core.serialization.string().optional(),
16: });
17: 
18: export declare namespace InferenceSourcePredictResult {
19:     export interface Raw {
20:         source: Source.Raw;
21:         results?: InferenceResults.Raw | null;
22:         error?: string | null;
23:     }
24: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/InProgress.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const InProgress: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.InProgress.Raw,
 9:     Hume.expressionMeasurement.batch.InProgress
10: > = core.serialization.object({
11:     createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
12:     startedTimestampMs: core.serialization.property("started_timestamp_ms", core.serialization.number()),
13: });
14: 
15: export declare namespace InProgress {
16:     export interface Raw {
17:         created_timestamp_ms: number;
18:         started_timestamp_ms: number;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/InProgressState.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { InProgress } from "./InProgress.js";
 7: 
 8: export const InProgressState: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.InProgressState.Raw,
10:     Hume.expressionMeasurement.batch.InProgressState
11: > = core.serialization.object({}).extend(InProgress);
12: 
13: export declare namespace InProgressState {
14:     export interface Raw extends InProgress.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/JobEmbeddingGeneration.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { EmbeddingGenerationBaseRequest } from "./EmbeddingGenerationBaseRequest.js";
 7: import { StateEmbeddingGeneration } from "./StateEmbeddingGeneration.js";
 8: 
 9: export const JobEmbeddingGeneration: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.JobEmbeddingGeneration.Raw,
11:     Hume.expressionMeasurement.batch.JobEmbeddingGeneration
12: > = core.serialization.object({
13:     jobId: core.serialization.property("job_id", core.serialization.string()),
14:     userId: core.serialization.property("user_id", core.serialization.string()),
15:     request: EmbeddingGenerationBaseRequest,
16:     state: StateEmbeddingGeneration,
17: });
18: 
19: export declare namespace JobEmbeddingGeneration {
20:     export interface Raw {
21:         job_id: string;
22:         user_id: string;
23:         request: EmbeddingGenerationBaseRequest.Raw;
24:         state: StateEmbeddingGeneration.Raw;
25:     }
26: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/JobId.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const JobId: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.JobId.Raw,
 9:     Hume.expressionMeasurement.batch.JobId
10: > = core.serialization.object({
11:     jobId: core.serialization.property("job_id", core.serialization.string()),
12: });
13: 
14: export declare namespace JobId {
15:     export interface Raw {
16:         job_id: string;
17:     }
18: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/JobInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { InferenceRequest } from "./InferenceRequest.js";
 7: import { StateInference } from "./StateInference.js";
 8: 
 9: export const JobInference: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.JobInference.Raw,
11:     Hume.expressionMeasurement.batch.JobInference
12: > = core.serialization.object({
13:     jobId: core.serialization.property("job_id", core.serialization.string()),
14:     request: InferenceRequest,
15:     state: StateInference,
16: });
17: 
18: export declare namespace JobInference {
19:     export interface Raw {
20:         job_id: string;
21:         request: InferenceRequest.Raw;
22:         state: StateInference.Raw;
23:     }
24: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/JobTlInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { StateTlInference } from "./StateTlInference.js";
 7: import { TlInferenceBaseRequest } from "./TlInferenceBaseRequest.js";
 8: 
 9: export const JobTlInference: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.JobTlInference.Raw,
11:     Hume.expressionMeasurement.batch.JobTlInference
12: > = core.serialization.object({
13:     jobId: core.serialization.property("job_id", core.serialization.string()),
14:     userId: core.serialization.property("user_id", core.serialization.string()),
15:     request: TlInferenceBaseRequest,
16:     state: StateTlInference,
17: });
18: 
19: export declare namespace JobTlInference {
20:     export interface Raw {
21:         job_id: string;
22:         user_id: string;
23:         request: TlInferenceBaseRequest.Raw;
24:         state: StateTlInference.Raw;
25:     }
26: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/JobTraining.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { StateTraining } from "./StateTraining.js";
 7: import { TrainingBaseRequest } from "./TrainingBaseRequest.js";
 8: 
 9: export const JobTraining: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.JobTraining.Raw,
11:     Hume.expressionMeasurement.batch.JobTraining
12: > = core.serialization.object({
13:     jobId: core.serialization.property("job_id", core.serialization.string()),
14:     userId: core.serialization.property("user_id", core.serialization.string()),
15:     request: TrainingBaseRequest,
16:     state: StateTraining,
17: });
18: 
19: export declare namespace JobTraining {
20:     export interface Raw {
21:         job_id: string;
22:         user_id: string;
23:         request: TrainingBaseRequest.Raw;
24:         state: StateTraining.Raw;
25:     }
26: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Language.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Granularity } from "./Granularity.js";
 7: import { Unconfigurable } from "./Unconfigurable.js";
 8: 
 9: export const Language: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.Language.Raw,
11:     Hume.expressionMeasurement.batch.Language
12: > = core.serialization.object({
13:     granularity: Granularity.optional(),
14:     sentiment: Unconfigurable.optional(),
15:     toxicity: Unconfigurable.optional(),
16:     identifySpeakers: core.serialization.property("identify_speakers", core.serialization.boolean().optional()),
17: });
18: 
19: export declare namespace Language {
20:     export interface Raw {
21:         granularity?: Granularity.Raw | null;
22:         sentiment?: Unconfigurable.Raw | null;
23:         toxicity?: Unconfigurable.Raw | null;
24:         identify_speakers?: boolean | null;
25:     }
26: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/LanguagePrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { EmotionScore } from "./EmotionScore.js";
 7: import { PositionInterval } from "./PositionInterval.js";
 8: import { SentimentScore } from "./SentimentScore.js";
 9: import { TimeInterval } from "./TimeInterval.js";
10: import { ToxicityScore } from "./ToxicityScore.js";
11: 
12: export const LanguagePrediction: core.serialization.ObjectSchema<
13:     serializers.expressionMeasurement.batch.LanguagePrediction.Raw,
14:     Hume.expressionMeasurement.batch.LanguagePrediction
15: > = core.serialization.object({
16:     text: core.serialization.string(),
17:     position: PositionInterval,
18:     time: TimeInterval.optional(),
19:     confidence: core.serialization.number().optional(),
20:     speakerConfidence: core.serialization.property("speaker_confidence", core.serialization.number().optional()),
21:     emotions: core.serialization.list(EmotionScore),
22:     sentiment: core.serialization.list(SentimentScore).optional(),
23:     toxicity: core.serialization.list(ToxicityScore).optional(),
24: });
25: 
26: export declare namespace LanguagePrediction {
27:     export interface Raw {
28:         text: string;
29:         position: PositionInterval.Raw;
30:         time?: TimeInterval.Raw | null;
31:         confidence?: number | null;
32:         speaker_confidence?: number | null;
33:         emotions: EmotionScore.Raw[];
34:         sentiment?: SentimentScore.Raw[] | null;
35:         toxicity?: ToxicityScore.Raw[] | null;
36:     }
37: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Models.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Face } from "./Face.js";
 7: import { Language } from "./Language.js";
 8: import { Ner } from "./Ner.js";
 9: import { Prosody } from "./Prosody.js";
10: import { Unconfigurable } from "./Unconfigurable.js";
11: 
12: export const Models: core.serialization.ObjectSchema<
13:     serializers.expressionMeasurement.batch.Models.Raw,
14:     Hume.expressionMeasurement.batch.Models
15: > = core.serialization.object({
16:     face: Face.optional(),
17:     burst: Unconfigurable.optional(),
18:     prosody: Prosody.optional(),
19:     language: Language.optional(),
20:     ner: Ner.optional(),
21:     facemesh: Unconfigurable.optional(),
22: });
23: 
24: export declare namespace Models {
25:     export interface Raw {
26:         face?: Face.Raw | null;
27:         burst?: Unconfigurable.Raw | null;
28:         prosody?: Prosody.Raw | null;
29:         language?: Language.Raw | null;
30:         ner?: Ner.Raw | null;
31:         facemesh?: Unconfigurable.Raw | null;
32:     }
33: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/ModelsPredictions.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { PredictionsOptionalNullBurstPrediction } from "./PredictionsOptionalNullBurstPrediction.js";
 7: import { PredictionsOptionalNullFacemeshPrediction } from "./PredictionsOptionalNullFacemeshPrediction.js";
 8: import { PredictionsOptionalNullFacePrediction } from "./PredictionsOptionalNullFacePrediction.js";
 9: import { PredictionsOptionalTranscriptionMetadataLanguagePrediction } from "./PredictionsOptionalTranscriptionMetadataLanguagePrediction.js";
10: import { PredictionsOptionalTranscriptionMetadataNerPrediction } from "./PredictionsOptionalTranscriptionMetadataNerPrediction.js";
11: import { PredictionsOptionalTranscriptionMetadataProsodyPrediction } from "./PredictionsOptionalTranscriptionMetadataProsodyPrediction.js";
12: 
13: export const ModelsPredictions: core.serialization.ObjectSchema<
14:     serializers.expressionMeasurement.batch.ModelsPredictions.Raw,
15:     Hume.expressionMeasurement.batch.ModelsPredictions
16: > = core.serialization.object({
17:     face: PredictionsOptionalNullFacePrediction.optional(),
18:     burst: PredictionsOptionalNullBurstPrediction.optional(),
19:     prosody: PredictionsOptionalTranscriptionMetadataProsodyPrediction.optional(),
20:     language: PredictionsOptionalTranscriptionMetadataLanguagePrediction.optional(),
21:     ner: PredictionsOptionalTranscriptionMetadataNerPrediction.optional(),
22:     facemesh: PredictionsOptionalNullFacemeshPrediction.optional(),
23: });
24: 
25: export declare namespace ModelsPredictions {
26:     export interface Raw {
27:         face?: PredictionsOptionalNullFacePrediction.Raw | null;
28:         burst?: PredictionsOptionalNullBurstPrediction.Raw | null;
29:         prosody?: PredictionsOptionalTranscriptionMetadataProsodyPrediction.Raw | null;
30:         language?: PredictionsOptionalTranscriptionMetadataLanguagePrediction.Raw | null;
31:         ner?: PredictionsOptionalTranscriptionMetadataNerPrediction.Raw | null;
32:         facemesh?: PredictionsOptionalNullFacemeshPrediction.Raw | null;
33:     }
34: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Ner.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Ner: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.Ner.Raw,
 9:     Hume.expressionMeasurement.batch.Ner
10: > = core.serialization.object({
11:     identifySpeakers: core.serialization.property("identify_speakers", core.serialization.boolean().optional()),
12: });
13: 
14: export declare namespace Ner {
15:     export interface Raw {
16:         identify_speakers?: boolean | null;
17:     }
18: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/NerPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { EmotionScore } from "./EmotionScore.js";
 7: import { PositionInterval } from "./PositionInterval.js";
 8: import { TimeInterval } from "./TimeInterval.js";
 9: 
10: export const NerPrediction: core.serialization.ObjectSchema<
11:     serializers.expressionMeasurement.batch.NerPrediction.Raw,
12:     Hume.expressionMeasurement.batch.NerPrediction
13: > = core.serialization.object({
14:     entity: core.serialization.string(),
15:     position: PositionInterval,
16:     entityConfidence: core.serialization.property("entity_confidence", core.serialization.number()),
17:     support: core.serialization.number(),
18:     uri: core.serialization.string(),
19:     linkWord: core.serialization.property("link_word", core.serialization.string()),
20:     time: TimeInterval.optional(),
21:     confidence: core.serialization.number().optional(),
22:     speakerConfidence: core.serialization.property("speaker_confidence", core.serialization.number().optional()),
23:     emotions: core.serialization.list(EmotionScore),
24: });
25: 
26: export declare namespace NerPrediction {
27:     export interface Raw {
28:         entity: string;
29:         position: PositionInterval.Raw;
30:         entity_confidence: number;
31:         support: number;
32:         uri: string;
33:         link_word: string;
34:         time?: TimeInterval.Raw | null;
35:         confidence?: number | null;
36:         speaker_confidence?: number | null;
37:         emotions: EmotionScore.Raw[];
38:     }
39: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Null.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Null: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.Null.Raw,
 9:     Hume.expressionMeasurement.batch.Null
10: > = core.serialization.record(core.serialization.string(), core.serialization.unknown());
11: 
12: export declare namespace Null {
13:     export type Raw = Record<string, unknown>;
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/PositionInterval.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const PositionInterval: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.PositionInterval.Raw,
 9:     Hume.expressionMeasurement.batch.PositionInterval
10: > = core.serialization.object({
11:     begin: core.serialization.number(),
12:     end: core.serialization.number(),
13: });
14: 
15: export declare namespace PositionInterval {
16:     export interface Raw {
17:         begin: number;
18:         end: number;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullBurstPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { GroupedPredictionsBurstPrediction } from "./GroupedPredictionsBurstPrediction.js";
 7: import { Null } from "./Null.js";
 8: 
 9: export const PredictionsOptionalNullBurstPrediction: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.PredictionsOptionalNullBurstPrediction.Raw,
11:     Hume.expressionMeasurement.batch.PredictionsOptionalNullBurstPrediction
12: > = core.serialization.object({
13:     metadata: Null.optional(),
14:     groupedPredictions: core.serialization.property(
15:         "grouped_predictions",
16:         core.serialization.list(GroupedPredictionsBurstPrediction),
17:     ),
18: });
19: 
20: export declare namespace PredictionsOptionalNullBurstPrediction {
21:     export interface Raw {
22:         metadata?: Null.Raw | null;
23:         grouped_predictions: GroupedPredictionsBurstPrediction.Raw[];
24:     }
25: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullFacemeshPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { GroupedPredictionsFacemeshPrediction } from "./GroupedPredictionsFacemeshPrediction.js";
 7: import { Null } from "./Null.js";
 8: 
 9: export const PredictionsOptionalNullFacemeshPrediction: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.PredictionsOptionalNullFacemeshPrediction.Raw,
11:     Hume.expressionMeasurement.batch.PredictionsOptionalNullFacemeshPrediction
12: > = core.serialization.object({
13:     metadata: Null.optional(),
14:     groupedPredictions: core.serialization.property(
15:         "grouped_predictions",
16:         core.serialization.list(GroupedPredictionsFacemeshPrediction),
17:     ),
18: });
19: 
20: export declare namespace PredictionsOptionalNullFacemeshPrediction {
21:     export interface Raw {
22:         metadata?: Null.Raw | null;
23:         grouped_predictions: GroupedPredictionsFacemeshPrediction.Raw[];
24:     }
25: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalNullFacePrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { GroupedPredictionsFacePrediction } from "./GroupedPredictionsFacePrediction.js";
 7: import { Null } from "./Null.js";
 8: 
 9: export const PredictionsOptionalNullFacePrediction: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.PredictionsOptionalNullFacePrediction.Raw,
11:     Hume.expressionMeasurement.batch.PredictionsOptionalNullFacePrediction
12: > = core.serialization.object({
13:     metadata: Null.optional(),
14:     groupedPredictions: core.serialization.property(
15:         "grouped_predictions",
16:         core.serialization.list(GroupedPredictionsFacePrediction),
17:     ),
18: });
19: 
20: export declare namespace PredictionsOptionalNullFacePrediction {
21:     export interface Raw {
22:         metadata?: Null.Raw | null;
23:         grouped_predictions: GroupedPredictionsFacePrediction.Raw[];
24:     }
25: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataLanguagePrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { GroupedPredictionsLanguagePrediction } from "./GroupedPredictionsLanguagePrediction.js";
 7: import { TranscriptionMetadata } from "./TranscriptionMetadata.js";
 8: 
 9: export const PredictionsOptionalTranscriptionMetadataLanguagePrediction: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataLanguagePrediction.Raw,
11:     Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataLanguagePrediction
12: > = core.serialization.object({
13:     metadata: TranscriptionMetadata.optional(),
14:     groupedPredictions: core.serialization.property(
15:         "grouped_predictions",
16:         core.serialization.list(GroupedPredictionsLanguagePrediction),
17:     ),
18: });
19: 
20: export declare namespace PredictionsOptionalTranscriptionMetadataLanguagePrediction {
21:     export interface Raw {
22:         metadata?: TranscriptionMetadata.Raw | null;
23:         grouped_predictions: GroupedPredictionsLanguagePrediction.Raw[];
24:     }
25: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataNerPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { GroupedPredictionsNerPrediction } from "./GroupedPredictionsNerPrediction.js";
 7: import { TranscriptionMetadata } from "./TranscriptionMetadata.js";
 8: 
 9: export const PredictionsOptionalTranscriptionMetadataNerPrediction: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataNerPrediction.Raw,
11:     Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataNerPrediction
12: > = core.serialization.object({
13:     metadata: TranscriptionMetadata.optional(),
14:     groupedPredictions: core.serialization.property(
15:         "grouped_predictions",
16:         core.serialization.list(GroupedPredictionsNerPrediction),
17:     ),
18: });
19: 
20: export declare namespace PredictionsOptionalTranscriptionMetadataNerPrediction {
21:     export interface Raw {
22:         metadata?: TranscriptionMetadata.Raw | null;
23:         grouped_predictions: GroupedPredictionsNerPrediction.Raw[];
24:     }
25: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/PredictionsOptionalTranscriptionMetadataProsodyPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { GroupedPredictionsProsodyPrediction } from "./GroupedPredictionsProsodyPrediction.js";
 7: import { TranscriptionMetadata } from "./TranscriptionMetadata.js";
 8: 
 9: export const PredictionsOptionalTranscriptionMetadataProsodyPrediction: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataProsodyPrediction.Raw,
11:     Hume.expressionMeasurement.batch.PredictionsOptionalTranscriptionMetadataProsodyPrediction
12: > = core.serialization.object({
13:     metadata: TranscriptionMetadata.optional(),
14:     groupedPredictions: core.serialization.property(
15:         "grouped_predictions",
16:         core.serialization.list(GroupedPredictionsProsodyPrediction),
17:     ),
18: });
19: 
20: export declare namespace PredictionsOptionalTranscriptionMetadataProsodyPrediction {
21:     export interface Raw {
22:         metadata?: TranscriptionMetadata.Raw | null;
23:         grouped_predictions: GroupedPredictionsProsodyPrediction.Raw[];
24:     }
25: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Prosody.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Granularity } from "./Granularity.js";
 7: import { Window } from "./Window.js";
 8: 
 9: export const Prosody: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.Prosody.Raw,
11:     Hume.expressionMeasurement.batch.Prosody
12: > = core.serialization.object({
13:     granularity: Granularity.optional(),
14:     window: Window.optional(),
15:     identifySpeakers: core.serialization.property("identify_speakers", core.serialization.boolean().optional()),
16: });
17: 
18: export declare namespace Prosody {
19:     export interface Raw {
20:         granularity?: Granularity.Raw | null;
21:         window?: Window.Raw | null;
22:         identify_speakers?: boolean | null;
23:     }
24: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/ProsodyPrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { EmotionScore } from "./EmotionScore.js";
 7: import { TimeInterval } from "./TimeInterval.js";
 8: 
 9: export const ProsodyPrediction: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.ProsodyPrediction.Raw,
11:     Hume.expressionMeasurement.batch.ProsodyPrediction
12: > = core.serialization.object({
13:     text: core.serialization.string().optional(),
14:     time: TimeInterval,
15:     confidence: core.serialization.number().optional(),
16:     speakerConfidence: core.serialization.property("speaker_confidence", core.serialization.number().optional()),
17:     emotions: core.serialization.list(EmotionScore),
18: });
19: 
20: export declare namespace ProsodyPrediction {
21:     export interface Raw {
22:         text?: string | null;
23:         time: TimeInterval.Raw;
24:         confidence?: number | null;
25:         speaker_confidence?: number | null;
26:         emotions: EmotionScore.Raw[];
27:     }
28: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Queued.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Queued: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.Queued.Raw,
 9:     Hume.expressionMeasurement.batch.Queued
10: > = core.serialization.object({
11:     createdTimestampMs: core.serialization.property("created_timestamp_ms", core.serialization.number()),
12: });
13: 
14: export declare namespace Queued {
15:     export interface Raw {
16:         created_timestamp_ms: number;
17:     }
18: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/QueuedState.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Queued } from "./Queued.js";
 7: 
 8: export const QueuedState: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.QueuedState.Raw,
10:     Hume.expressionMeasurement.batch.QueuedState
11: > = core.serialization.object({}).extend(Queued);
12: 
13: export declare namespace QueuedState {
14:     export interface Raw extends Queued.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/RegistryFileDetail.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const RegistryFileDetail: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.RegistryFileDetail.Raw,
 9:     Hume.expressionMeasurement.batch.RegistryFileDetail
10: > = core.serialization.object({
11:     fileId: core.serialization.property("file_id", core.serialization.string()),
12:     fileUrl: core.serialization.property("file_url", core.serialization.string()),
13: });
14: 
15: export declare namespace RegistryFileDetail {
16:     export interface Raw {
17:         file_id: string;
18:         file_url: string;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Regression.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Regression: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.Regression.Raw,
 9:     Hume.expressionMeasurement.batch.Regression
10: > = core.serialization.record(core.serialization.string(), core.serialization.unknown());
11: 
12: export declare namespace Regression {
13:     export type Raw = Record<string, unknown>;
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/SentimentScore.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const SentimentScore: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.SentimentScore.Raw,
 9:     Hume.expressionMeasurement.batch.SentimentScore
10: > = core.serialization.object({
11:     name: core.serialization.string(),
12:     score: core.serialization.number(),
13: });
14: 
15: export declare namespace SentimentScore {
16:     export interface Raw {
17:         name: string;
18:         score: number;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/SortBy.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const SortBy: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.SortBy.Raw,
 9:     Hume.expressionMeasurement.batch.SortBy
10: > = core.serialization.enum_(["created", "started", "ended"]);
11: 
12: export declare namespace SortBy {
13:     export type Raw = "created" | "started" | "ended";
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Source.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { SourceFile } from "./SourceFile.js";
 7: import { SourceTextSource } from "./SourceTextSource.js";
 8: import { SourceUrl } from "./SourceUrl.js";
 9: 
10: export const Source: core.serialization.Schema<
11:     serializers.expressionMeasurement.batch.Source.Raw,
12:     Hume.expressionMeasurement.batch.Source
13: > = core.serialization
14:     .union("type", {
15:         url: SourceUrl,
16:         file: SourceFile,
17:         text: SourceTextSource,
18:     })
19:     .transform<Hume.expressionMeasurement.batch.Source>({
20:         transform: (value) => value,
21:         untransform: (value) => value,
22:     });
23: 
24: export declare namespace Source {
25:     export type Raw = Source.Url | Source.File | Source.Text;
26: 
27:     export interface Url extends SourceUrl.Raw {
28:         type: "url";
29:     }
30: 
31:     export interface File extends SourceFile.Raw {
32:         type: "file";
33:     }
34: 
35:     export interface Text extends SourceTextSource.Raw {
36:         type: "text";
37:     }
38: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/SourceFile.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { File_ } from "./File_.js";
 7: 
 8: export const SourceFile: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.SourceFile.Raw,
10:     Hume.expressionMeasurement.batch.SourceFile
11: > = core.serialization.object({}).extend(File_);
12: 
13: export declare namespace SourceFile {
14:     export interface Raw extends File_.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/SourceTextSource.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const SourceTextSource: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.SourceTextSource.Raw,
 9:     Hume.expressionMeasurement.batch.SourceTextSource
10: > = core.serialization.object({});
11: 
12: export declare namespace SourceTextSource {
13:     export type Raw = {};
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/SourceUrl.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Url } from "./Url.js";
 7: 
 8: export const SourceUrl: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.SourceUrl.Raw,
10:     Hume.expressionMeasurement.batch.SourceUrl
11: > = core.serialization.object({}).extend(Url);
12: 
13: export declare namespace SourceUrl {
14:     export interface Raw extends Url.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGeneration.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { StateEmbeddingGenerationCompletedEmbeddingGeneration } from "./StateEmbeddingGenerationCompletedEmbeddingGeneration.js";
 7: import { StateEmbeddingGenerationFailed } from "./StateEmbeddingGenerationFailed.js";
 8: import { StateEmbeddingGenerationInProgress } from "./StateEmbeddingGenerationInProgress.js";
 9: import { StateEmbeddingGenerationQueued } from "./StateEmbeddingGenerationQueued.js";
10: 
11: export const StateEmbeddingGeneration: core.serialization.Schema<
12:     serializers.expressionMeasurement.batch.StateEmbeddingGeneration.Raw,
13:     Hume.expressionMeasurement.batch.StateEmbeddingGeneration
14: > = core.serialization
15:     .union("status", {
16:         QUEUED: StateEmbeddingGenerationQueued,
17:         IN_PROGRESS: StateEmbeddingGenerationInProgress,
18:         COMPLETED: StateEmbeddingGenerationCompletedEmbeddingGeneration,
19:         FAILED: StateEmbeddingGenerationFailed,
20:     })
21:     .transform<Hume.expressionMeasurement.batch.StateEmbeddingGeneration>({
22:         transform: (value) => value,
23:         untransform: (value) => value,
24:     });
25: 
26: export declare namespace StateEmbeddingGeneration {
27:     export type Raw =
28:         | StateEmbeddingGeneration.Queued
29:         | StateEmbeddingGeneration.InProgress
30:         | StateEmbeddingGeneration.Completed
31:         | StateEmbeddingGeneration.Failed;
32: 
33:     export interface Queued extends StateEmbeddingGenerationQueued.Raw {
34:         status: "QUEUED";
35:     }
36: 
37:     export interface InProgress extends StateEmbeddingGenerationInProgress.Raw {
38:         status: "IN_PROGRESS";
39:     }
40: 
41:     export interface Completed extends StateEmbeddingGenerationCompletedEmbeddingGeneration.Raw {
42:         status: "COMPLETED";
43:     }
44: 
45:     export interface Failed extends StateEmbeddingGenerationFailed.Raw {
46:         status: "FAILED";
47:     }
48: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationCompletedEmbeddingGeneration.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { CompletedEmbeddingGeneration } from "./CompletedEmbeddingGeneration.js";
 7: 
 8: export const StateEmbeddingGenerationCompletedEmbeddingGeneration: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.StateEmbeddingGenerationCompletedEmbeddingGeneration.Raw,
10:     Hume.expressionMeasurement.batch.StateEmbeddingGenerationCompletedEmbeddingGeneration
11: > = core.serialization.object({}).extend(CompletedEmbeddingGeneration);
12: 
13: export declare namespace StateEmbeddingGenerationCompletedEmbeddingGeneration {
14:     export interface Raw extends CompletedEmbeddingGeneration.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationFailed.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Failed } from "./Failed.js";
 7: 
 8: export const StateEmbeddingGenerationFailed: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.StateEmbeddingGenerationFailed.Raw,
10:     Hume.expressionMeasurement.batch.StateEmbeddingGenerationFailed
11: > = core.serialization.object({}).extend(Failed);
12: 
13: export declare namespace StateEmbeddingGenerationFailed {
14:     export interface Raw extends Failed.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationInProgress.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { InProgress } from "./InProgress.js";
 7: 
 8: export const StateEmbeddingGenerationInProgress: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.StateEmbeddingGenerationInProgress.Raw,
10:     Hume.expressionMeasurement.batch.StateEmbeddingGenerationInProgress
11: > = core.serialization.object({}).extend(InProgress);
12: 
13: export declare namespace StateEmbeddingGenerationInProgress {
14:     export interface Raw extends InProgress.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateEmbeddingGenerationQueued.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Queued } from "./Queued.js";
 7: 
 8: export const StateEmbeddingGenerationQueued: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.StateEmbeddingGenerationQueued.Raw,
10:     Hume.expressionMeasurement.batch.StateEmbeddingGenerationQueued
11: > = core.serialization.object({}).extend(Queued);
12: 
13: export declare namespace StateEmbeddingGenerationQueued {
14:     export interface Raw extends Queued.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { CompletedState } from "./CompletedState.js";
 7: import { FailedState } from "./FailedState.js";
 8: import { InProgressState } from "./InProgressState.js";
 9: import { QueuedState } from "./QueuedState.js";
10: 
11: export const StateInference: core.serialization.Schema<
12:     serializers.expressionMeasurement.batch.StateInference.Raw,
13:     Hume.expressionMeasurement.batch.StateInference
14: > = core.serialization
15:     .union("status", {
16:         QUEUED: QueuedState,
17:         IN_PROGRESS: InProgressState,
18:         COMPLETED: CompletedState,
19:         FAILED: FailedState,
20:     })
21:     .transform<Hume.expressionMeasurement.batch.StateInference>({
22:         transform: (value) => value,
23:         untransform: (value) => value,
24:     });
25: 
26: export declare namespace StateInference {
27:     export type Raw =
28:         | StateInference.Queued
29:         | StateInference.InProgress
30:         | StateInference.Completed
31:         | StateInference.Failed;
32: 
33:     export interface Queued extends QueuedState.Raw {
34:         status: "QUEUED";
35:     }
36: 
37:     export interface InProgress extends InProgressState.Raw {
38:         status: "IN_PROGRESS";
39:     }
40: 
41:     export interface Completed extends CompletedState.Raw {
42:         status: "COMPLETED";
43:     }
44: 
45:     export interface Failed extends FailedState.Raw {
46:         status: "FAILED";
47:     }
48: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { StateTlInferenceCompletedTlInference } from "./StateTlInferenceCompletedTlInference.js";
 7: import { StateTlInferenceFailed } from "./StateTlInferenceFailed.js";
 8: import { StateTlInferenceInProgress } from "./StateTlInferenceInProgress.js";
 9: import { StateTlInferenceQueued } from "./StateTlInferenceQueued.js";
10: 
11: export const StateTlInference: core.serialization.Schema<
12:     serializers.expressionMeasurement.batch.StateTlInference.Raw,
13:     Hume.expressionMeasurement.batch.StateTlInference
14: > = core.serialization
15:     .union("status", {
16:         QUEUED: StateTlInferenceQueued,
17:         IN_PROGRESS: StateTlInferenceInProgress,
18:         COMPLETED: StateTlInferenceCompletedTlInference,
19:         FAILED: StateTlInferenceFailed,
20:     })
21:     .transform<Hume.expressionMeasurement.batch.StateTlInference>({
22:         transform: (value) => value,
23:         untransform: (value) => value,
24:     });
25: 
26: export declare namespace StateTlInference {
27:     export type Raw =
28:         | StateTlInference.Queued
29:         | StateTlInference.InProgress
30:         | StateTlInference.Completed
31:         | StateTlInference.Failed;
32: 
33:     export interface Queued extends StateTlInferenceQueued.Raw {
34:         status: "QUEUED";
35:     }
36: 
37:     export interface InProgress extends StateTlInferenceInProgress.Raw {
38:         status: "IN_PROGRESS";
39:     }
40: 
41:     export interface Completed extends StateTlInferenceCompletedTlInference.Raw {
42:         status: "COMPLETED";
43:     }
44: 
45:     export interface Failed extends StateTlInferenceFailed.Raw {
46:         status: "FAILED";
47:     }
48: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInferenceCompletedTlInference.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { CompletedTlInference } from "./CompletedTlInference.js";
 7: 
 8: export const StateTlInferenceCompletedTlInference: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.StateTlInferenceCompletedTlInference.Raw,
10:     Hume.expressionMeasurement.batch.StateTlInferenceCompletedTlInference
11: > = core.serialization.object({}).extend(CompletedTlInference);
12: 
13: export declare namespace StateTlInferenceCompletedTlInference {
14:     export interface Raw extends CompletedTlInference.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInferenceFailed.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Failed } from "./Failed.js";
 7: 
 8: export const StateTlInferenceFailed: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.StateTlInferenceFailed.Raw,
10:     Hume.expressionMeasurement.batch.StateTlInferenceFailed
11: > = core.serialization.object({}).extend(Failed);
12: 
13: export declare namespace StateTlInferenceFailed {
14:     export interface Raw extends Failed.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInferenceInProgress.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { InProgress } from "./InProgress.js";
 7: 
 8: export const StateTlInferenceInProgress: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.StateTlInferenceInProgress.Raw,
10:     Hume.expressionMeasurement.batch.StateTlInferenceInProgress
11: > = core.serialization.object({}).extend(InProgress);
12: 
13: export declare namespace StateTlInferenceInProgress {
14:     export interface Raw extends InProgress.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTlInferenceQueued.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Queued } from "./Queued.js";
 7: 
 8: export const StateTlInferenceQueued: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.StateTlInferenceQueued.Raw,
10:     Hume.expressionMeasurement.batch.StateTlInferenceQueued
11: > = core.serialization.object({}).extend(Queued);
12: 
13: export declare namespace StateTlInferenceQueued {
14:     export interface Raw extends Queued.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTraining.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { StateTrainingCompletedTraining } from "./StateTrainingCompletedTraining.js";
 7: import { StateTrainingFailed } from "./StateTrainingFailed.js";
 8: import { StateTrainingInProgress } from "./StateTrainingInProgress.js";
 9: import { StateTrainingQueued } from "./StateTrainingQueued.js";
10: 
11: export const StateTraining: core.serialization.Schema<
12:     serializers.expressionMeasurement.batch.StateTraining.Raw,
13:     Hume.expressionMeasurement.batch.StateTraining
14: > = core.serialization
15:     .union("status", {
16:         QUEUED: StateTrainingQueued,
17:         IN_PROGRESS: StateTrainingInProgress,
18:         COMPLETED: StateTrainingCompletedTraining,
19:         FAILED: StateTrainingFailed,
20:     })
21:     .transform<Hume.expressionMeasurement.batch.StateTraining>({
22:         transform: (value) => value,
23:         untransform: (value) => value,
24:     });
25: 
26: export declare namespace StateTraining {
27:     export type Raw = StateTraining.Queued | StateTraining.InProgress | StateTraining.Completed | StateTraining.Failed;
28: 
29:     export interface Queued extends StateTrainingQueued.Raw {
30:         status: "QUEUED";
31:     }
32: 
33:     export interface InProgress extends StateTrainingInProgress.Raw {
34:         status: "IN_PROGRESS";
35:     }
36: 
37:     export interface Completed extends StateTrainingCompletedTraining.Raw {
38:         status: "COMPLETED";
39:     }
40: 
41:     export interface Failed extends StateTrainingFailed.Raw {
42:         status: "FAILED";
43:     }
44: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTrainingCompletedTraining.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { CompletedTraining } from "./CompletedTraining.js";
 7: 
 8: export const StateTrainingCompletedTraining: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.StateTrainingCompletedTraining.Raw,
10:     Hume.expressionMeasurement.batch.StateTrainingCompletedTraining
11: > = core.serialization.object({}).extend(CompletedTraining);
12: 
13: export declare namespace StateTrainingCompletedTraining {
14:     export interface Raw extends CompletedTraining.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTrainingFailed.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Failed } from "./Failed.js";
 7: 
 8: export const StateTrainingFailed: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.StateTrainingFailed.Raw,
10:     Hume.expressionMeasurement.batch.StateTrainingFailed
11: > = core.serialization.object({}).extend(Failed);
12: 
13: export declare namespace StateTrainingFailed {
14:     export interface Raw extends Failed.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTrainingInProgress.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { InProgress } from "./InProgress.js";
 7: 
 8: export const StateTrainingInProgress: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.StateTrainingInProgress.Raw,
10:     Hume.expressionMeasurement.batch.StateTrainingInProgress
11: > = core.serialization.object({}).extend(InProgress);
12: 
13: export declare namespace StateTrainingInProgress {
14:     export interface Raw extends InProgress.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/StateTrainingQueued.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Queued } from "./Queued.js";
 7: 
 8: export const StateTrainingQueued: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.StateTrainingQueued.Raw,
10:     Hume.expressionMeasurement.batch.StateTrainingQueued
11: > = core.serialization.object({}).extend(Queued);
12: 
13: export declare namespace StateTrainingQueued {
14:     export interface Raw extends Queued.Raw {}
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Status.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Status: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.Status.Raw,
 9:     Hume.expressionMeasurement.batch.Status
10: > = core.serialization.enum_(["QUEUED", "IN_PROGRESS", "COMPLETED", "FAILED"]);
11: 
12: export declare namespace Status {
13:     export type Raw = "QUEUED" | "IN_PROGRESS" | "COMPLETED" | "FAILED";
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Tag.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Tag: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.Tag.Raw,
 9:     Hume.expressionMeasurement.batch.Tag
10: > = core.serialization.object({
11:     key: core.serialization.string(),
12:     value: core.serialization.string(),
13: });
14: 
15: export declare namespace Tag {
16:     export interface Raw {
17:         key: string;
18:         value: string;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Target.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Target: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.Target.Raw,
 9:     Hume.expressionMeasurement.batch.Target
10: > = core.serialization.undiscriminatedUnion([
11:     core.serialization.number(),
12:     core.serialization.number(),
13:     core.serialization.string(),
14: ]);
15: 
16: export declare namespace Target {
17:     export type Raw = number | number | string;
18: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Task.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { TaskClassification } from "./TaskClassification.js";
 7: import { TaskRegression } from "./TaskRegression.js";
 8: 
 9: export const Task: core.serialization.Schema<
10:     serializers.expressionMeasurement.batch.Task.Raw,
11:     Hume.expressionMeasurement.batch.Task
12: > = core.serialization
13:     .union("type", {
14:         classification: TaskClassification,
15:         regression: TaskRegression,
16:     })
17:     .transform<Hume.expressionMeasurement.batch.Task>({
18:         transform: (value) => value,
19:         untransform: (value) => value,
20:     });
21: 
22: export declare namespace Task {
23:     export type Raw = Task.Classification | Task.Regression;
24: 
25:     export interface Classification extends TaskClassification.Raw {
26:         type: "classification";
27:     }
28: 
29:     export interface Regression extends TaskRegression.Raw {
30:         type: "regression";
31:     }
32: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/TaskClassification.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const TaskClassification: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.TaskClassification.Raw,
 9:     Hume.expressionMeasurement.batch.TaskClassification
10: > = core.serialization.object({});
11: 
12: export declare namespace TaskClassification {
13:     export type Raw = {};
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/TaskRegression.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const TaskRegression: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.TaskRegression.Raw,
 9:     Hume.expressionMeasurement.batch.TaskRegression
10: > = core.serialization.object({});
11: 
12: export declare namespace TaskRegression {
13:     export type Raw = {};
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/TextSource.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const TextSource: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.TextSource.Raw,
 9:     Hume.expressionMeasurement.batch.TextSource
10: > = core.serialization.record(core.serialization.string(), core.serialization.unknown());
11: 
12: export declare namespace TextSource {
13:     export type Raw = Record<string, unknown>;
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/TimeInterval.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const TimeInterval: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.TimeInterval.Raw,
 9:     Hume.expressionMeasurement.batch.TimeInterval
10: > = core.serialization.object({
11:     begin: core.serialization.number(),
12:     end: core.serialization.number(),
13: });
14: 
15: export declare namespace TimeInterval {
16:     export interface Raw {
17:         begin: number;
18:         end: number;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/TlInferenceBaseRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { CustomModel } from "./CustomModel.js";
 7: 
 8: export const TlInferenceBaseRequest: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.TlInferenceBaseRequest.Raw,
10:     Hume.expressionMeasurement.batch.TlInferenceBaseRequest
11: > = core.serialization.object({
12:     customModel: core.serialization.property("custom_model", CustomModel),
13:     urls: core.serialization.list(core.serialization.string()).optional(),
14:     callbackUrl: core.serialization.property("callback_url", core.serialization.string().optional()),
15:     notify: core.serialization.boolean().optional(),
16: });
17: 
18: export declare namespace TlInferenceBaseRequest {
19:     export interface Raw {
20:         custom_model: CustomModel.Raw;
21:         urls?: string[] | null;
22:         callback_url?: string | null;
23:         notify?: boolean | null;
24:     }
25: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/TlInferencePrediction.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { CustomModelPrediction } from "./CustomModelPrediction.js";
 7: 
 8: export const TlInferencePrediction: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.TlInferencePrediction.Raw,
10:     Hume.expressionMeasurement.batch.TlInferencePrediction
11: > = core.serialization.object({
12:     file: core.serialization.string(),
13:     fileType: core.serialization.property("file_type", core.serialization.string()),
14:     customModels: core.serialization.property(
15:         "custom_models",
16:         core.serialization.record(core.serialization.string(), CustomModelPrediction),
17:     ),
18: });
19: 
20: export declare namespace TlInferencePrediction {
21:     export interface Raw {
22:         file: string;
23:         file_type: string;
24:         custom_models: Record<string, CustomModelPrediction.Raw>;
25:     }
26: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/TlInferenceResults.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Error_ } from "./Error_.js";
 7: import { TlInferencePrediction } from "./TlInferencePrediction.js";
 8: 
 9: export const TlInferenceResults: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.TlInferenceResults.Raw,
11:     Hume.expressionMeasurement.batch.TlInferenceResults
12: > = core.serialization.object({
13:     predictions: core.serialization.list(TlInferencePrediction),
14:     errors: core.serialization.list(Error_),
15: });
16: 
17: export declare namespace TlInferenceResults {
18:     export interface Raw {
19:         predictions: TlInferencePrediction.Raw[];
20:         errors: Error_.Raw[];
21:     }
22: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/TlInferenceSourcePredictResult.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Source } from "./Source.js";
 7: import { TlInferenceResults } from "./TlInferenceResults.js";
 8: 
 9: export const TlInferenceSourcePredictResult: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.batch.TlInferenceSourcePredictResult.Raw,
11:     Hume.expressionMeasurement.batch.TlInferenceSourcePredictResult
12: > = core.serialization.object({
13:     source: Source,
14:     results: TlInferenceResults.optional(),
15:     error: core.serialization.string().optional(),
16: });
17: 
18: export declare namespace TlInferenceSourcePredictResult {
19:     export interface Raw {
20:         source: Source.Raw;
21:         results?: TlInferenceResults.Raw | null;
22:         error?: string | null;
23:     }
24: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/ToxicityScore.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const ToxicityScore: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.ToxicityScore.Raw,
 9:     Hume.expressionMeasurement.batch.ToxicityScore
10: > = core.serialization.object({
11:     name: core.serialization.string(),
12:     score: core.serialization.number(),
13: });
14: 
15: export declare namespace ToxicityScore {
16:     export interface Raw {
17:         name: string;
18:         score: number;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/TrainingBaseRequest.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Alternative } from "./Alternative.js";
 7: import { CustomModelRequest } from "./CustomModelRequest.js";
 8: import { Dataset } from "./Dataset.js";
 9: import { EvaluationArgs } from "./EvaluationArgs.js";
10: import { Task } from "./Task.js";
11: 
12: export const TrainingBaseRequest: core.serialization.ObjectSchema<
13:     serializers.expressionMeasurement.batch.TrainingBaseRequest.Raw,
14:     Hume.expressionMeasurement.batch.TrainingBaseRequest
15: > = core.serialization.object({
16:     customModel: core.serialization.property("custom_model", CustomModelRequest),
17:     dataset: Dataset,
18:     targetFeature: core.serialization.property("target_feature", core.serialization.string().optional()),
19:     task: Task.optional(),
20:     evaluation: EvaluationArgs.optional(),
21:     alternatives: core.serialization.list(Alternative).optional(),
22:     callbackUrl: core.serialization.property("callback_url", core.serialization.string().optional()),
23:     notify: core.serialization.boolean().optional(),
24: });
25: 
26: export declare namespace TrainingBaseRequest {
27:     export interface Raw {
28:         custom_model: CustomModelRequest.Raw;
29:         dataset: Dataset.Raw;
30:         target_feature?: string | null;
31:         task?: Task.Raw | null;
32:         evaluation?: EvaluationArgs.Raw | null;
33:         alternatives?: Alternative.Raw[] | null;
34:         callback_url?: string | null;
35:         notify?: boolean | null;
36:     }
37: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/TrainingCustomModel.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const TrainingCustomModel: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.TrainingCustomModel.Raw,
 9:     Hume.expressionMeasurement.batch.TrainingCustomModel
10: > = core.serialization.object({
11:     id: core.serialization.string(),
12:     versionId: core.serialization.property("version_id", core.serialization.string().optional()),
13: });
14: 
15: export declare namespace TrainingCustomModel {
16:     export interface Raw {
17:         id: string;
18:         version_id?: string | null;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Transcription.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Bcp47Tag } from "./Bcp47Tag.js";
 7: 
 8: export const Transcription: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.Transcription.Raw,
10:     Hume.expressionMeasurement.batch.Transcription
11: > = core.serialization.object({
12:     language: Bcp47Tag.optional(),
13:     identifySpeakers: core.serialization.property("identify_speakers", core.serialization.boolean().optional()),
14:     confidenceThreshold: core.serialization.property("confidence_threshold", core.serialization.number().optional()),
15: });
16: 
17: export declare namespace Transcription {
18:     export interface Raw {
19:         language?: Bcp47Tag.Raw | null;
20:         identify_speakers?: boolean | null;
21:         confidence_threshold?: number | null;
22:     }
23: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/TranscriptionMetadata.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Bcp47Tag } from "./Bcp47Tag.js";
 7: 
 8: export const TranscriptionMetadata: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.TranscriptionMetadata.Raw,
10:     Hume.expressionMeasurement.batch.TranscriptionMetadata
11: > = core.serialization.object({
12:     confidence: core.serialization.number(),
13:     detectedLanguage: core.serialization.property("detected_language", Bcp47Tag.optional()),
14: });
15: 
16: export declare namespace TranscriptionMetadata {
17:     export interface Raw {
18:         confidence: number;
19:         detected_language?: Bcp47Tag.Raw | null;
20:     }
21: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Type.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Type: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.Type.Raw,
 9:     Hume.expressionMeasurement.batch.Type
10: > = core.serialization.enum_(["EMBEDDING_GENERATION", "INFERENCE", "TL_INFERENCE", "TRAINING"]);
11: 
12: export declare namespace Type {
13:     export type Raw = "EMBEDDING_GENERATION" | "INFERENCE" | "TL_INFERENCE" | "TRAINING";
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Unconfigurable.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Unconfigurable: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.Unconfigurable.Raw,
 9:     Hume.expressionMeasurement.batch.Unconfigurable
10: > = core.serialization.record(core.serialization.string(), core.serialization.unknown());
11: 
12: export declare namespace Unconfigurable {
13:     export type Raw = Record<string, unknown>;
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/UnionJob.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import type * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { InferenceJob } from "./InferenceJob.js";
 7: 
 8: export const UnionJob: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.UnionJob.Raw,
10:     Hume.expressionMeasurement.batch.UnionJob
11: > = InferenceJob;
12: 
13: export declare namespace UnionJob {
14:     export type Raw = InferenceJob.Raw;
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/UnionPredictResult.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import type * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { InferenceSourcePredictResult } from "./InferenceSourcePredictResult.js";
 7: 
 8: export const UnionPredictResult: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.UnionPredictResult.Raw,
10:     Hume.expressionMeasurement.batch.UnionPredictResult
11: > = InferenceSourcePredictResult;
12: 
13: export declare namespace UnionPredictResult {
14:     export type Raw = InferenceSourcePredictResult.Raw;
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Url.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Url: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.Url.Raw,
 9:     Hume.expressionMeasurement.batch.Url
10: > = core.serialization.object({
11:     url: core.serialization.string(),
12: });
13: 
14: export declare namespace Url {
15:     export interface Raw {
16:         url: string;
17:     }
18: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/ValidationArgs.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { Target } from "./Target.js";
 7: 
 8: export const ValidationArgs: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.batch.ValidationArgs.Raw,
10:     Hume.expressionMeasurement.batch.ValidationArgs
11: > = core.serialization.object({
12:     positiveLabel: core.serialization.property("positive_label", Target.optional()),
13: });
14: 
15: export declare namespace ValidationArgs {
16:     export interface Raw {
17:         positive_label?: Target.Raw | null;
18:     }
19: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/When.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const When: core.serialization.Schema<
 8:     serializers.expressionMeasurement.batch.When.Raw,
 9:     Hume.expressionMeasurement.batch.When
10: > = core.serialization.enum_(["created_before", "created_after"]);
11: 
12: export declare namespace When {
13:     export type Raw = "created_before" | "created_after";
14: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/types/Window.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const Window: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.batch.Window.Raw,
 9:     Hume.expressionMeasurement.batch.Window
10: > = core.serialization.object({
11:     length: core.serialization.number().optional(),
12:     step: core.serialization.number().optional(),
13: });
14: 
15: export declare namespace Window {
16:     export interface Raw {
17:         length?: number | null;
18:         step?: number | null;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/batch/index.ts
````typescript
1: export * from "./client/index.js";
2: export * from "./types/index.js";
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/client/socket/index.ts
````typescript
1: export { StreamSocketResponse } from "./StreamSocketResponse.js";
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/client/socket/StreamSocketResponse.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../../index.js";
 6: import { SubscribeEvent } from "../../types/SubscribeEvent.js";
 7: 
 8: export const StreamSocketResponse: core.serialization.Schema<
 9:     serializers.expressionMeasurement.stream.StreamSocketResponse.Raw,
10:     Hume.expressionMeasurement.stream.SubscribeEvent
11: > = core.serialization.undiscriminatedUnion([SubscribeEvent]);
12: 
13: export declare namespace StreamSocketResponse {
14:     export type Raw = SubscribeEvent.Raw;
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/client/index.ts
````typescript
1: export * from "./socket/index.js";
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/Config.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { StreamFace } from "./StreamFace.js";
 7: import { StreamLanguage } from "./StreamLanguage.js";
 8: 
 9: export const Config: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.stream.Config.Raw,
11:     Hume.expressionMeasurement.stream.Config
12: > = core.serialization.object({
13:     burst: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
14:     face: StreamFace.optional(),
15:     facemesh: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
16:     language: StreamLanguage.optional(),
17:     prosody: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
18: });
19: 
20: export declare namespace Config {
21:     export interface Raw {
22:         burst?: Record<string, unknown> | null;
23:         face?: StreamFace.Raw | null;
24:         facemesh?: Record<string, unknown> | null;
25:         language?: StreamLanguage.Raw | null;
26:         prosody?: Record<string, unknown> | null;
27:     }
28: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/index.ts
````typescript
 1: export * from "./Config.js";
 2: export * from "./JobDetails.js";
 3: export * from "./StreamErrorMessage.js";
 4: export * from "./StreamFace.js";
 5: export * from "./StreamLanguage.js";
 6: export * from "./StreamModelPredictions.js";
 7: export * from "./StreamModelPredictionsBurst.js";
 8: export * from "./StreamModelPredictionsBurstPredictionsItem.js";
 9: export * from "./StreamModelPredictionsFace.js";
10: export * from "./StreamModelPredictionsFacemesh.js";
11: export * from "./StreamModelPredictionsFacemeshPredictionsItem.js";
12: export * from "./StreamModelPredictionsFacePredictionsItem.js";
13: export * from "./StreamModelPredictionsJobDetails.js";
14: export * from "./StreamModelPredictionsLanguage.js";
15: export * from "./StreamModelPredictionsLanguagePredictionsItem.js";
16: export * from "./StreamModelPredictionsProsody.js";
17: export * from "./StreamModelPredictionsProsodyPredictionsItem.js";
18: export * from "./StreamModelsEndpointPayload.js";
19: export * from "./StreamWarningMessage.js";
20: export * from "./StreamWarningMessageJobDetails.js";
21: export * from "./SubscribeEvent.js";
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/JobDetails.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: 
 7: export const JobDetails: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.stream.JobDetails.Raw,
 9:     Hume.expressionMeasurement.stream.JobDetails
10: > = core.serialization.object({
11:     jobId: core.serialization.property("job_id", core.serialization.string().optional()),
12: });
13: 
14: export declare namespace JobDetails {
15:     export interface Raw {
16:         job_id?: string | null;
17:     }
18: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamErrorMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { JobDetails } from "./JobDetails.js";
 7: 
 8: export const StreamErrorMessage: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.stream.StreamErrorMessage.Raw,
10:     Hume.expressionMeasurement.stream.StreamErrorMessage
11: > = core.serialization.object({
12:     error: core.serialization.string().optional(),
13:     code: core.serialization.string().optional(),
14:     payloadId: core.serialization.property("payload_id", core.serialization.string().optional()),
15:     jobDetails: core.serialization.property("job_details", JobDetails.optional()),
16: });
17: 
18: export declare namespace StreamErrorMessage {
19:     export interface Raw {
20:         error?: string | null;
21:         code?: string | null;
22:         payload_id?: string | null;
23:         job_details?: JobDetails.Raw | null;
24:     }
25: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamFace.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: 
 7: export const StreamFace: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.stream.StreamFace.Raw,
 9:     Hume.expressionMeasurement.stream.StreamFace
10: > = core.serialization.object({
11:     facs: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
12:     descriptions: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
13:     identifyFaces: core.serialization.property("identify_faces", core.serialization.boolean().optional()),
14:     fpsPred: core.serialization.property("fps_pred", core.serialization.number().optional()),
15:     probThreshold: core.serialization.property("prob_threshold", core.serialization.number().optional()),
16:     minFaceSize: core.serialization.property("min_face_size", core.serialization.number().optional()),
17: });
18: 
19: export declare namespace StreamFace {
20:     export interface Raw {
21:         facs?: Record<string, unknown> | null;
22:         descriptions?: Record<string, unknown> | null;
23:         identify_faces?: boolean | null;
24:         fps_pred?: number | null;
25:         prob_threshold?: number | null;
26:         min_face_size?: number | null;
27:     }
28: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamLanguage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: 
 7: export const StreamLanguage: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.stream.StreamLanguage.Raw,
 9:     Hume.expressionMeasurement.stream.StreamLanguage
10: > = core.serialization.object({
11:     sentiment: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
12:     toxicity: core.serialization.record(core.serialization.string(), core.serialization.unknown()).optional(),
13:     granularity: core.serialization.string().optional(),
14: });
15: 
16: export declare namespace StreamLanguage {
17:     export interface Raw {
18:         sentiment?: Record<string, unknown> | null;
19:         toxicity?: Record<string, unknown> | null;
20:         granularity?: string | null;
21:     }
22: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictions.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { StreamModelPredictionsBurst } from "./StreamModelPredictionsBurst.js";
 7: import { StreamModelPredictionsFace } from "./StreamModelPredictionsFace.js";
 8: import { StreamModelPredictionsFacemesh } from "./StreamModelPredictionsFacemesh.js";
 9: import { StreamModelPredictionsJobDetails } from "./StreamModelPredictionsJobDetails.js";
10: import { StreamModelPredictionsLanguage } from "./StreamModelPredictionsLanguage.js";
11: import { StreamModelPredictionsProsody } from "./StreamModelPredictionsProsody.js";
12: 
13: export const StreamModelPredictions: core.serialization.ObjectSchema<
14:     serializers.expressionMeasurement.stream.StreamModelPredictions.Raw,
15:     Hume.expressionMeasurement.stream.StreamModelPredictions
16: > = core.serialization.object({
17:     payloadId: core.serialization.property("payload_id", core.serialization.string().optional()),
18:     jobDetails: core.serialization.property("job_details", StreamModelPredictionsJobDetails.optional()),
19:     burst: StreamModelPredictionsBurst.optional(),
20:     face: StreamModelPredictionsFace.optional(),
21:     facemesh: StreamModelPredictionsFacemesh.optional(),
22:     language: StreamModelPredictionsLanguage.optional(),
23:     prosody: StreamModelPredictionsProsody.optional(),
24: });
25: 
26: export declare namespace StreamModelPredictions {
27:     export interface Raw {
28:         payload_id?: string | null;
29:         job_details?: StreamModelPredictionsJobDetails.Raw | null;
30:         burst?: StreamModelPredictionsBurst.Raw | null;
31:         face?: StreamModelPredictionsFace.Raw | null;
32:         facemesh?: StreamModelPredictionsFacemesh.Raw | null;
33:         language?: StreamModelPredictionsLanguage.Raw | null;
34:         prosody?: StreamModelPredictionsProsody.Raw | null;
35:     }
36: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsBurst.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { StreamModelPredictionsBurstPredictionsItem } from "./StreamModelPredictionsBurstPredictionsItem.js";
 7: 
 8: export const StreamModelPredictionsBurst: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.stream.StreamModelPredictionsBurst.Raw,
10:     Hume.expressionMeasurement.stream.StreamModelPredictionsBurst
11: > = core.serialization.object({
12:     predictions: core.serialization.list(StreamModelPredictionsBurstPredictionsItem).optional(),
13: });
14: 
15: export declare namespace StreamModelPredictionsBurst {
16:     export interface Raw {
17:         predictions?: StreamModelPredictionsBurstPredictionsItem.Raw[] | null;
18:     }
19: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsBurstPredictionsItem.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
 7: import { TimeRange } from "../../../types/TimeRange.js";
 8: 
 9: export const StreamModelPredictionsBurstPredictionsItem: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.stream.StreamModelPredictionsBurstPredictionsItem.Raw,
11:     Hume.expressionMeasurement.stream.StreamModelPredictionsBurstPredictionsItem
12: > = core.serialization.object({
13:     time: TimeRange.optional(),
14:     emotions: EmotionEmbedding.optional(),
15: });
16: 
17: export declare namespace StreamModelPredictionsBurstPredictionsItem {
18:     export interface Raw {
19:         time?: TimeRange.Raw | null;
20:         emotions?: EmotionEmbedding.Raw | null;
21:     }
22: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFace.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { StreamModelPredictionsFacePredictionsItem } from "./StreamModelPredictionsFacePredictionsItem.js";
 7: 
 8: export const StreamModelPredictionsFace: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.stream.StreamModelPredictionsFace.Raw,
10:     Hume.expressionMeasurement.stream.StreamModelPredictionsFace
11: > = core.serialization.object({
12:     predictions: core.serialization.list(StreamModelPredictionsFacePredictionsItem).optional(),
13: });
14: 
15: export declare namespace StreamModelPredictionsFace {
16:     export interface Raw {
17:         predictions?: StreamModelPredictionsFacePredictionsItem.Raw[] | null;
18:     }
19: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacemesh.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { StreamModelPredictionsFacemeshPredictionsItem } from "./StreamModelPredictionsFacemeshPredictionsItem.js";
 7: 
 8: export const StreamModelPredictionsFacemesh: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.stream.StreamModelPredictionsFacemesh.Raw,
10:     Hume.expressionMeasurement.stream.StreamModelPredictionsFacemesh
11: > = core.serialization.object({
12:     predictions: core.serialization.list(StreamModelPredictionsFacemeshPredictionsItem).optional(),
13: });
14: 
15: export declare namespace StreamModelPredictionsFacemesh {
16:     export interface Raw {
17:         predictions?: StreamModelPredictionsFacemeshPredictionsItem.Raw[] | null;
18:     }
19: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacemeshPredictionsItem.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
 7: 
 8: export const StreamModelPredictionsFacemeshPredictionsItem: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.stream.StreamModelPredictionsFacemeshPredictionsItem.Raw,
10:     Hume.expressionMeasurement.stream.StreamModelPredictionsFacemeshPredictionsItem
11: > = core.serialization.object({
12:     emotions: EmotionEmbedding.optional(),
13: });
14: 
15: export declare namespace StreamModelPredictionsFacemeshPredictionsItem {
16:     export interface Raw {
17:         emotions?: EmotionEmbedding.Raw | null;
18:     }
19: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsFacePredictionsItem.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
 7: import { StreamBoundingBox } from "../../../types/StreamBoundingBox.js";
 8: 
 9: export const StreamModelPredictionsFacePredictionsItem: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.stream.StreamModelPredictionsFacePredictionsItem.Raw,
11:     Hume.expressionMeasurement.stream.StreamModelPredictionsFacePredictionsItem
12: > = core.serialization.object({
13:     frame: core.serialization.number().optional(),
14:     time: core.serialization.number().optional(),
15:     bbox: StreamBoundingBox.optional(),
16:     prob: core.serialization.number().optional(),
17:     faceId: core.serialization.property("face_id", core.serialization.string().optional()),
18:     emotions: EmotionEmbedding.optional(),
19:     facs: EmotionEmbedding.optional(),
20:     descriptions: EmotionEmbedding.optional(),
21: });
22: 
23: export declare namespace StreamModelPredictionsFacePredictionsItem {
24:     export interface Raw {
25:         frame?: number | null;
26:         time?: number | null;
27:         bbox?: StreamBoundingBox.Raw | null;
28:         prob?: number | null;
29:         face_id?: string | null;
30:         emotions?: EmotionEmbedding.Raw | null;
31:         facs?: EmotionEmbedding.Raw | null;
32:         descriptions?: EmotionEmbedding.Raw | null;
33:     }
34: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsJobDetails.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: 
 7: export const StreamModelPredictionsJobDetails: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.stream.StreamModelPredictionsJobDetails.Raw,
 9:     Hume.expressionMeasurement.stream.StreamModelPredictionsJobDetails
10: > = core.serialization.object({
11:     jobId: core.serialization.property("job_id", core.serialization.string().optional()),
12: });
13: 
14: export declare namespace StreamModelPredictionsJobDetails {
15:     export interface Raw {
16:         job_id?: string | null;
17:     }
18: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsLanguage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { StreamModelPredictionsLanguagePredictionsItem } from "./StreamModelPredictionsLanguagePredictionsItem.js";
 7: 
 8: export const StreamModelPredictionsLanguage: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.stream.StreamModelPredictionsLanguage.Raw,
10:     Hume.expressionMeasurement.stream.StreamModelPredictionsLanguage
11: > = core.serialization.object({
12:     predictions: core.serialization.list(StreamModelPredictionsLanguagePredictionsItem).optional(),
13: });
14: 
15: export declare namespace StreamModelPredictionsLanguage {
16:     export interface Raw {
17:         predictions?: StreamModelPredictionsLanguagePredictionsItem.Raw[] | null;
18:     }
19: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsLanguagePredictionsItem.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
 7: import { Sentiment } from "../../../types/Sentiment.js";
 8: import { TextPosition } from "../../../types/TextPosition.js";
 9: import { Toxicity } from "../../../types/Toxicity.js";
10: 
11: export const StreamModelPredictionsLanguagePredictionsItem: core.serialization.ObjectSchema<
12:     serializers.expressionMeasurement.stream.StreamModelPredictionsLanguagePredictionsItem.Raw,
13:     Hume.expressionMeasurement.stream.StreamModelPredictionsLanguagePredictionsItem
14: > = core.serialization.object({
15:     text: core.serialization.string().optional(),
16:     position: TextPosition.optional(),
17:     emotions: EmotionEmbedding.optional(),
18:     sentiment: Sentiment.optional(),
19:     toxicity: Toxicity.optional(),
20: });
21: 
22: export declare namespace StreamModelPredictionsLanguagePredictionsItem {
23:     export interface Raw {
24:         text?: string | null;
25:         position?: TextPosition.Raw | null;
26:         emotions?: EmotionEmbedding.Raw | null;
27:         sentiment?: Sentiment.Raw | null;
28:         toxicity?: Toxicity.Raw | null;
29:     }
30: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsProsody.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { StreamModelPredictionsProsodyPredictionsItem } from "./StreamModelPredictionsProsodyPredictionsItem.js";
 7: 
 8: export const StreamModelPredictionsProsody: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.stream.StreamModelPredictionsProsody.Raw,
10:     Hume.expressionMeasurement.stream.StreamModelPredictionsProsody
11: > = core.serialization.object({
12:     predictions: core.serialization.list(StreamModelPredictionsProsodyPredictionsItem).optional(),
13: });
14: 
15: export declare namespace StreamModelPredictionsProsody {
16:     export interface Raw {
17:         predictions?: StreamModelPredictionsProsodyPredictionsItem.Raw[] | null;
18:     }
19: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelPredictionsProsodyPredictionsItem.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { EmotionEmbedding } from "../../../types/EmotionEmbedding.js";
 7: import { TimeRange } from "../../../types/TimeRange.js";
 8: 
 9: export const StreamModelPredictionsProsodyPredictionsItem: core.serialization.ObjectSchema<
10:     serializers.expressionMeasurement.stream.StreamModelPredictionsProsodyPredictionsItem.Raw,
11:     Hume.expressionMeasurement.stream.StreamModelPredictionsProsodyPredictionsItem
12: > = core.serialization.object({
13:     time: TimeRange.optional(),
14:     emotions: EmotionEmbedding.optional(),
15: });
16: 
17: export declare namespace StreamModelPredictionsProsodyPredictionsItem {
18:     export interface Raw {
19:         time?: TimeRange.Raw | null;
20:         emotions?: EmotionEmbedding.Raw | null;
21:     }
22: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamModelsEndpointPayload.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { Config } from "./Config.js";
 7: 
 8: export const StreamModelsEndpointPayload: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.stream.StreamModelsEndpointPayload.Raw,
10:     Hume.expressionMeasurement.stream.StreamModelsEndpointPayload
11: > = core.serialization.object({
12:     data: core.serialization.string().optional(),
13:     models: Config.optional(),
14:     streamWindowMs: core.serialization.property("stream_window_ms", core.serialization.number().optional()),
15:     resetStream: core.serialization.property("reset_stream", core.serialization.boolean().optional()),
16:     rawText: core.serialization.property("raw_text", core.serialization.boolean().optional()),
17:     jobDetails: core.serialization.property("job_details", core.serialization.boolean().optional()),
18:     payloadId: core.serialization.property("payload_id", core.serialization.string().optional()),
19: });
20: 
21: export declare namespace StreamModelsEndpointPayload {
22:     export interface Raw {
23:         data?: string | null;
24:         models?: Config.Raw | null;
25:         stream_window_ms?: number | null;
26:         reset_stream?: boolean | null;
27:         raw_text?: boolean | null;
28:         job_details?: boolean | null;
29:         payload_id?: string | null;
30:     }
31: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamWarningMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { StreamWarningMessageJobDetails } from "./StreamWarningMessageJobDetails.js";
 7: 
 8: export const StreamWarningMessage: core.serialization.ObjectSchema<
 9:     serializers.expressionMeasurement.stream.StreamWarningMessage.Raw,
10:     Hume.expressionMeasurement.stream.StreamWarningMessage
11: > = core.serialization.object({
12:     warning: core.serialization.string().optional(),
13:     code: core.serialization.string().optional(),
14:     payloadId: core.serialization.property("payload_id", core.serialization.string().optional()),
15:     jobDetails: core.serialization.property("job_details", StreamWarningMessageJobDetails.optional()),
16: });
17: 
18: export declare namespace StreamWarningMessage {
19:     export interface Raw {
20:         warning?: string | null;
21:         code?: string | null;
22:         payload_id?: string | null;
23:         job_details?: StreamWarningMessageJobDetails.Raw | null;
24:     }
25: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/StreamWarningMessageJobDetails.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: 
 7: export const StreamWarningMessageJobDetails: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.stream.StreamWarningMessageJobDetails.Raw,
 9:     Hume.expressionMeasurement.stream.StreamWarningMessageJobDetails
10: > = core.serialization.object({
11:     jobId: core.serialization.property("job_id", core.serialization.string().optional()),
12: });
13: 
14: export declare namespace StreamWarningMessageJobDetails {
15:     export interface Raw {
16:         job_id?: string | null;
17:     }
18: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/types/SubscribeEvent.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../../index.js";
 6: import { StreamErrorMessage } from "./StreamErrorMessage.js";
 7: import { StreamModelPredictions } from "./StreamModelPredictions.js";
 8: import { StreamWarningMessage } from "./StreamWarningMessage.js";
 9: 
10: export const SubscribeEvent: core.serialization.Schema<
11:     serializers.expressionMeasurement.stream.SubscribeEvent.Raw,
12:     Hume.expressionMeasurement.stream.SubscribeEvent
13: > = core.serialization.undiscriminatedUnion([StreamModelPredictions, StreamErrorMessage, StreamWarningMessage]);
14: 
15: export declare namespace SubscribeEvent {
16:     export type Raw = StreamModelPredictions.Raw | StreamErrorMessage.Raw | StreamWarningMessage.Raw;
17: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/stream/index.ts
````typescript
1: export * from "./client/index.js";
2: export * from "./types/index.js";
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/resources/index.ts
````typescript
1: export * from "./stream/client/socket/index.js";
2: export * as stream from "./stream/index.js";
3: export * from "./stream/types/index.js";
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/types/EmotionEmbedding.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { EmotionEmbeddingItem } from "./EmotionEmbeddingItem.js";
 7: 
 8: export const EmotionEmbedding: core.serialization.Schema<
 9:     serializers.expressionMeasurement.stream.EmotionEmbedding.Raw,
10:     Hume.expressionMeasurement.stream.EmotionEmbedding
11: > = core.serialization.list(EmotionEmbeddingItem);
12: 
13: export declare namespace EmotionEmbedding {
14:     export type Raw = EmotionEmbeddingItem.Raw[];
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/types/EmotionEmbeddingItem.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const EmotionEmbeddingItem: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.stream.EmotionEmbeddingItem.Raw,
 9:     Hume.expressionMeasurement.stream.EmotionEmbeddingItem
10: > = core.serialization.object({
11:     name: core.serialization.string().optional(),
12:     score: core.serialization.number().optional(),
13: });
14: 
15: export declare namespace EmotionEmbeddingItem {
16:     export interface Raw {
17:         name?: string | null;
18:         score?: number | null;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/types/index.ts
````typescript
1: export * from "./EmotionEmbedding.js";
2: export * from "./EmotionEmbeddingItem.js";
3: export * from "./Sentiment.js";
4: export * from "./SentimentItem.js";
5: export * from "./StreamBoundingBox.js";
6: export * from "./TextPosition.js";
7: export * from "./TimeRange.js";
8: export * from "./Toxicity.js";
9: export * from "./ToxicityItem.js";
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/types/Sentiment.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { SentimentItem } from "./SentimentItem.js";
 7: 
 8: export const Sentiment: core.serialization.Schema<
 9:     serializers.expressionMeasurement.stream.Sentiment.Raw,
10:     Hume.expressionMeasurement.stream.Sentiment
11: > = core.serialization.list(SentimentItem);
12: 
13: export declare namespace Sentiment {
14:     export type Raw = SentimentItem.Raw[];
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/types/SentimentItem.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const SentimentItem: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.stream.SentimentItem.Raw,
 9:     Hume.expressionMeasurement.stream.SentimentItem
10: > = core.serialization.object({
11:     name: core.serialization.string().optional(),
12:     score: core.serialization.number().optional(),
13: });
14: 
15: export declare namespace SentimentItem {
16:     export interface Raw {
17:         name?: string | null;
18:         score?: number | null;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/types/StreamBoundingBox.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const StreamBoundingBox: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.stream.StreamBoundingBox.Raw,
 9:     Hume.expressionMeasurement.stream.StreamBoundingBox
10: > = core.serialization.object({
11:     x: core.serialization.number().optional(),
12:     y: core.serialization.number().optional(),
13:     w: core.serialization.number().optional(),
14:     h: core.serialization.number().optional(),
15: });
16: 
17: export declare namespace StreamBoundingBox {
18:     export interface Raw {
19:         x?: number | null;
20:         y?: number | null;
21:         w?: number | null;
22:         h?: number | null;
23:     }
24: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/types/TextPosition.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const TextPosition: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.stream.TextPosition.Raw,
 9:     Hume.expressionMeasurement.stream.TextPosition
10: > = core.serialization.object({
11:     begin: core.serialization.number().optional(),
12:     end: core.serialization.number().optional(),
13: });
14: 
15: export declare namespace TextPosition {
16:     export interface Raw {
17:         begin?: number | null;
18:         end?: number | null;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/types/TimeRange.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const TimeRange: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.stream.TimeRange.Raw,
 9:     Hume.expressionMeasurement.stream.TimeRange
10: > = core.serialization.object({
11:     begin: core.serialization.number().optional(),
12:     end: core.serialization.number().optional(),
13: });
14: 
15: export declare namespace TimeRange {
16:     export interface Raw {
17:         begin?: number | null;
18:         end?: number | null;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/types/Toxicity.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: import { ToxicityItem } from "./ToxicityItem.js";
 7: 
 8: export const Toxicity: core.serialization.Schema<
 9:     serializers.expressionMeasurement.stream.Toxicity.Raw,
10:     Hume.expressionMeasurement.stream.Toxicity
11: > = core.serialization.list(ToxicityItem);
12: 
13: export declare namespace Toxicity {
14:     export type Raw = ToxicityItem.Raw[];
15: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/types/ToxicityItem.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../api/index.js";
 4: import * as core from "../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../index.js";
 6: 
 7: export const ToxicityItem: core.serialization.ObjectSchema<
 8:     serializers.expressionMeasurement.stream.ToxicityItem.Raw,
 9:     Hume.expressionMeasurement.stream.ToxicityItem
10: > = core.serialization.object({
11:     name: core.serialization.string().optional(),
12:     score: core.serialization.number().optional(),
13: });
14: 
15: export declare namespace ToxicityItem {
16:     export interface Raw {
17:         name?: string | null;
18:         score?: number | null;
19:     }
20: }
````

## File: src/serialization/resources/expressionMeasurement/resources/stream/index.ts
````typescript
1: export * from "./resources/index.js";
2: export * from "./types/index.js";
````

## File: src/serialization/resources/expressionMeasurement/resources/index.ts
````typescript
1: export * as batch from "./batch/index.js";
2: export * as stream from "./stream/index.js";
````

## File: src/serialization/resources/expressionMeasurement/index.ts
````typescript
1: export * from "./resources/index.js";
````

## File: src/serialization/resources/tts/resources/streamInput/client/socket/index.ts
````typescript
1: export { StreamInputSocketResponse } from "./StreamInputSocketResponse.js";
````

## File: src/serialization/resources/tts/resources/streamInput/client/socket/StreamInputSocketResponse.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: import { TtsOutput } from "../../../../types/TtsOutput.js";
 7: 
 8: export const StreamInputSocketResponse: core.serialization.Schema<
 9:     serializers.tts.StreamInputSocketResponse.Raw,
10:     Hume.tts.TtsOutput
11: > = core.serialization.undiscriminatedUnion([TtsOutput]);
12: 
13: export declare namespace StreamInputSocketResponse {
14:     export type Raw = TtsOutput.Raw;
15: }
````

## File: src/serialization/resources/tts/resources/streamInput/client/index.ts
````typescript
1: export * from "./socket/index.js";
````

## File: src/serialization/resources/tts/resources/streamInput/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/serialization/resources/tts/resources/voices/client/requests/index.ts
````typescript
1: export { PostedVoice } from "./PostedVoice.js";
````

## File: src/serialization/resources/tts/resources/voices/client/requests/PostedVoice.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../../../../api/index.js";
 4: import * as core from "../../../../../../../core/index.js";
 5: import type * as serializers from "../../../../../../index.js";
 6: 
 7: export const PostedVoice: core.serialization.Schema<serializers.tts.PostedVoice.Raw, Hume.tts.PostedVoice> =
 8:     core.serialization.object({
 9:         generationId: core.serialization.property("generation_id", core.serialization.string()),
10:         name: core.serialization.string(),
11:     });
12: 
13: export declare namespace PostedVoice {
14:     export interface Raw {
15:         generation_id: string;
16:         name: string;
17:     }
18: }
````

## File: src/serialization/resources/tts/resources/voices/client/index.ts
````typescript
1: export * from "./requests/index.js";
````

## File: src/serialization/resources/tts/resources/voices/index.ts
````typescript
1: export * from "./client/index.js";
````

## File: src/serialization/resources/tts/resources/index.ts
````typescript
1: export * from "./streamInput/client/socket/index.js";
2: export * as streamInput from "./streamInput/index.js";
3: export * from "./voices/client/requests/index.js";
4: export * as voices from "./voices/index.js";
````

## File: src/serialization/resources/tts/types/AudioEncoding.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { AudioFormatType } from "./AudioFormatType.js";
 7: 
 8: export const AudioEncoding: core.serialization.ObjectSchema<serializers.tts.AudioEncoding.Raw, Hume.tts.AudioEncoding> =
 9:     core.serialization.object({
10:         format: AudioFormatType,
11:         sampleRate: core.serialization.property("sample_rate", core.serialization.number()),
12:     });
13: 
14: export declare namespace AudioEncoding {
15:     export interface Raw {
16:         format: AudioFormatType.Raw;
17:         sample_rate: number;
18:     }
19: }
````

## File: src/serialization/resources/tts/types/AudioFormatType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const AudioFormatType: core.serialization.Schema<serializers.tts.AudioFormatType.Raw, Hume.tts.AudioFormatType> =
 8:     core.serialization.enum_(["mp3", "pcm", "wav"]);
 9: 
10: export declare namespace AudioFormatType {
11:     export type Raw = "mp3" | "pcm" | "wav";
12: }
````

## File: src/serialization/resources/tts/types/ErrorResponse.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ErrorResponse: core.serialization.ObjectSchema<serializers.tts.ErrorResponse.Raw, Hume.tts.ErrorResponse> =
 8:     core.serialization.object({
 9:         code: core.serialization.string().optional(),
10:         error: core.serialization.string().optional(),
11:         message: core.serialization.string().optional(),
12:     });
13: 
14: export declare namespace ErrorResponse {
15:     export interface Raw {
16:         code?: string | null;
17:         error?: string | null;
18:         message?: string | null;
19:     }
20: }
````

## File: src/serialization/resources/tts/types/Format.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { FormatMp3 } from "./FormatMp3.js";
 7: import { FormatPcm } from "./FormatPcm.js";
 8: import { FormatWav } from "./FormatWav.js";
 9: 
10: export const Format: core.serialization.Schema<serializers.tts.Format.Raw, Hume.tts.Format> =
11:     core.serialization.undiscriminatedUnion([FormatMp3, FormatPcm, FormatWav]);
12: 
13: export declare namespace Format {
14:     export type Raw = FormatMp3.Raw | FormatPcm.Raw | FormatWav.Raw;
15: }
````

## File: src/serialization/resources/tts/types/FormatMp3.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const FormatMp3: core.serialization.ObjectSchema<serializers.tts.FormatMp3.Raw, Hume.tts.FormatMp3> =
 8:     core.serialization.object({
 9:         type: core.serialization.stringLiteral("mp3"),
10:     });
11: 
12: export declare namespace FormatMp3 {
13:     export interface Raw {
14:         type: "mp3";
15:     }
16: }
````

## File: src/serialization/resources/tts/types/FormatPcm.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const FormatPcm: core.serialization.ObjectSchema<serializers.tts.FormatPcm.Raw, Hume.tts.FormatPcm> =
 8:     core.serialization.object({
 9:         type: core.serialization.stringLiteral("pcm"),
10:     });
11: 
12: export declare namespace FormatPcm {
13:     export interface Raw {
14:         type: "pcm";
15:     }
16: }
````

## File: src/serialization/resources/tts/types/FormatWav.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const FormatWav: core.serialization.ObjectSchema<serializers.tts.FormatWav.Raw, Hume.tts.FormatWav> =
 8:     core.serialization.object({
 9:         type: core.serialization.stringLiteral("wav"),
10:     });
11: 
12: export declare namespace FormatWav {
13:     export interface Raw {
14:         type: "wav";
15:     }
16: }
````

## File: src/serialization/resources/tts/types/HttpValidationError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ValidationError } from "./ValidationError.js";
 7: 
 8: export const HttpValidationError: core.serialization.ObjectSchema<
 9:     serializers.tts.HttpValidationError.Raw,
10:     Hume.tts.HttpValidationError
11: > = core.serialization.object({
12:     detail: core.serialization.list(ValidationError).optional(),
13: });
14: 
15: export declare namespace HttpValidationError {
16:     export interface Raw {
17:         detail?: ValidationError.Raw[] | null;
18:     }
19: }
````

## File: src/serialization/resources/tts/types/index.ts
````typescript
 1: export * from "./AudioEncoding.js";
 2: export * from "./AudioFormatType.js";
 3: export * from "./ErrorResponse.js";
 4: export * from "./Format.js";
 5: export * from "./FormatMp3.js";
 6: export * from "./FormatPcm.js";
 7: export * from "./FormatWav.js";
 8: export * from "./HttpValidationError.js";
 9: export * from "./MillisecondInterval.js";
10: export * from "./OctaveVersion.js";
11: export * from "./PostedContext.js";
12: export * from "./PostedContextWithGenerationId.js";
13: export * from "./PostedContextWithUtterances.js";
14: export * from "./PostedTts.js";
15: export * from "./PostedUtterance.js";
16: export * from "./PostedUtteranceVoice.js";
17: export * from "./PostedUtteranceVoiceWithId.js";
18: export * from "./PostedUtteranceVoiceWithName.js";
19: export * from "./PublishTts.js";
20: export * from "./ReturnGeneration.js";
21: export * from "./ReturnPagedVoices.js";
22: export * from "./ReturnTts.js";
23: export * from "./ReturnVoice.js";
24: export * from "./Snippet.js";
25: export * from "./SnippetAudioChunk.js";
26: export * from "./Timestamp.js";
27: export * from "./TimestampMessage.js";
28: export * from "./TimestampType.js";
29: export * from "./TtsOutput.js";
30: export * from "./ValidationError.js";
31: export * from "./ValidationErrorLocItem.js";
32: export * from "./VoiceProvider.js";
````

## File: src/serialization/resources/tts/types/MillisecondInterval.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const MillisecondInterval: core.serialization.ObjectSchema<
 8:     serializers.tts.MillisecondInterval.Raw,
 9:     Hume.tts.MillisecondInterval
10: > = core.serialization.object({
11:     begin: core.serialization.number(),
12:     end: core.serialization.number(),
13: });
14: 
15: export declare namespace MillisecondInterval {
16:     export interface Raw {
17:         begin: number;
18:         end: number;
19:     }
20: }
````

## File: src/serialization/resources/tts/types/OctaveVersion.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const OctaveVersion: core.serialization.Schema<serializers.tts.OctaveVersion.Raw, Hume.tts.OctaveVersion> =
 8:     core.serialization.enum_(["1", "2"]);
 9: 
10: export declare namespace OctaveVersion {
11:     export type Raw = "1" | "2";
12: }
````

## File: src/serialization/resources/tts/types/PostedContext.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { PostedContextWithGenerationId } from "./PostedContextWithGenerationId.js";
 7: import { PostedContextWithUtterances } from "./PostedContextWithUtterances.js";
 8: 
 9: export const PostedContext: core.serialization.Schema<serializers.tts.PostedContext.Raw, Hume.tts.PostedContext> =
10:     core.serialization.undiscriminatedUnion([PostedContextWithGenerationId, PostedContextWithUtterances]);
11: 
12: export declare namespace PostedContext {
13:     export type Raw = PostedContextWithGenerationId.Raw | PostedContextWithUtterances.Raw;
14: }
````

## File: src/serialization/resources/tts/types/PostedContextWithGenerationId.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const PostedContextWithGenerationId: core.serialization.ObjectSchema<
 8:     serializers.tts.PostedContextWithGenerationId.Raw,
 9:     Hume.tts.PostedContextWithGenerationId
10: > = core.serialization.object({
11:     generationId: core.serialization.property("generation_id", core.serialization.string()),
12: });
13: 
14: export declare namespace PostedContextWithGenerationId {
15:     export interface Raw {
16:         generation_id: string;
17:     }
18: }
````

## File: src/serialization/resources/tts/types/PostedContextWithUtterances.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { PostedUtterance } from "./PostedUtterance.js";
 7: 
 8: export const PostedContextWithUtterances: core.serialization.ObjectSchema<
 9:     serializers.tts.PostedContextWithUtterances.Raw,
10:     Hume.tts.PostedContextWithUtterances
11: > = core.serialization.object({
12:     utterances: core.serialization.list(PostedUtterance),
13: });
14: 
15: export declare namespace PostedContextWithUtterances {
16:     export interface Raw {
17:         utterances: PostedUtterance.Raw[];
18:     }
19: }
````

## File: src/serialization/resources/tts/types/PostedTts.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { Format } from "./Format.js";
 7: import { OctaveVersion } from "./OctaveVersion.js";
 8: import { PostedContext } from "./PostedContext.js";
 9: import { PostedUtterance } from "./PostedUtterance.js";
10: import { TimestampType } from "./TimestampType.js";
11: 
12: export const PostedTts: core.serialization.ObjectSchema<serializers.tts.PostedTts.Raw, Hume.tts.PostedTts> =
13:     core.serialization.object({
14:         context: PostedContext.optional(),
15:         format: Format.optional(),
16:         includeTimestampTypes: core.serialization.property(
17:             "include_timestamp_types",
18:             core.serialization.list(TimestampType).optional(),
19:         ),
20:         numGenerations: core.serialization.property("num_generations", core.serialization.number().optional()),
21:         splitUtterances: core.serialization.property("split_utterances", core.serialization.boolean().optional()),
22:         stripHeaders: core.serialization.property("strip_headers", core.serialization.boolean().optional()),
23:         utterances: core.serialization.list(PostedUtterance),
24:         version: OctaveVersion.optional(),
25:         instantMode: core.serialization.property("instant_mode", core.serialization.boolean().optional()),
26:     });
27: 
28: export declare namespace PostedTts {
29:     export interface Raw {
30:         context?: PostedContext.Raw | null;
31:         format?: Format.Raw | null;
32:         include_timestamp_types?: TimestampType.Raw[] | null;
33:         num_generations?: number | null;
34:         split_utterances?: boolean | null;
35:         strip_headers?: boolean | null;
36:         utterances: PostedUtterance.Raw[];
37:         version?: OctaveVersion.Raw | null;
38:         instant_mode?: boolean | null;
39:     }
40: }
````

## File: src/serialization/resources/tts/types/PostedUtterance.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { PostedUtteranceVoice } from "./PostedUtteranceVoice.js";
 7: 
 8: export const PostedUtterance: core.serialization.ObjectSchema<
 9:     serializers.tts.PostedUtterance.Raw,
10:     Hume.tts.PostedUtterance
11: > = core.serialization.object({
12:     description: core.serialization.string().optional(),
13:     speed: core.serialization.number().optional(),
14:     text: core.serialization.string(),
15:     trailingSilence: core.serialization.property("trailing_silence", core.serialization.number().optional()),
16:     voice: PostedUtteranceVoice.optional(),
17: });
18: 
19: export declare namespace PostedUtterance {
20:     export interface Raw {
21:         description?: string | null;
22:         speed?: number | null;
23:         text: string;
24:         trailing_silence?: number | null;
25:         voice?: PostedUtteranceVoice.Raw | null;
26:     }
27: }
````

## File: src/serialization/resources/tts/types/PostedUtteranceVoice.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { PostedUtteranceVoiceWithId } from "./PostedUtteranceVoiceWithId.js";
 7: import { PostedUtteranceVoiceWithName } from "./PostedUtteranceVoiceWithName.js";
 8: 
 9: export const PostedUtteranceVoice: core.serialization.Schema<
10:     serializers.tts.PostedUtteranceVoice.Raw,
11:     Hume.tts.PostedUtteranceVoice
12: > = core.serialization.undiscriminatedUnion([PostedUtteranceVoiceWithId, PostedUtteranceVoiceWithName]);
13: 
14: export declare namespace PostedUtteranceVoice {
15:     export type Raw = PostedUtteranceVoiceWithId.Raw | PostedUtteranceVoiceWithName.Raw;
16: }
````

## File: src/serialization/resources/tts/types/PostedUtteranceVoiceWithId.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { VoiceProvider } from "./VoiceProvider.js";
 7: 
 8: export const PostedUtteranceVoiceWithId: core.serialization.ObjectSchema<
 9:     serializers.tts.PostedUtteranceVoiceWithId.Raw,
10:     Hume.tts.PostedUtteranceVoiceWithId
11: > = core.serialization.object({
12:     id: core.serialization.string(),
13:     provider: VoiceProvider.optional(),
14: });
15: 
16: export declare namespace PostedUtteranceVoiceWithId {
17:     export interface Raw {
18:         id: string;
19:         provider?: VoiceProvider.Raw | null;
20:     }
21: }
````

## File: src/serialization/resources/tts/types/PostedUtteranceVoiceWithName.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { VoiceProvider } from "./VoiceProvider.js";
 7: 
 8: export const PostedUtteranceVoiceWithName: core.serialization.ObjectSchema<
 9:     serializers.tts.PostedUtteranceVoiceWithName.Raw,
10:     Hume.tts.PostedUtteranceVoiceWithName
11: > = core.serialization.object({
12:     name: core.serialization.string(),
13:     provider: VoiceProvider.optional(),
14: });
15: 
16: export declare namespace PostedUtteranceVoiceWithName {
17:     export interface Raw {
18:         name: string;
19:         provider?: VoiceProvider.Raw | null;
20:     }
21: }
````

## File: src/serialization/resources/tts/types/PublishTts.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { PostedUtteranceVoice } from "./PostedUtteranceVoice.js";
 7: 
 8: export const PublishTts: core.serialization.ObjectSchema<serializers.tts.PublishTts.Raw, Hume.tts.PublishTts> =
 9:     core.serialization.object({
10:         close: core.serialization.boolean().optional(),
11:         description: core.serialization.string().optional(),
12:         flush: core.serialization.boolean().optional(),
13:         speed: core.serialization.number().optional(),
14:         text: core.serialization.string().optional(),
15:         trailingSilence: core.serialization.property("trailing_silence", core.serialization.number().optional()),
16:         voice: PostedUtteranceVoice.optional(),
17:     });
18: 
19: export declare namespace PublishTts {
20:     export interface Raw {
21:         close?: boolean | null;
22:         description?: string | null;
23:         flush?: boolean | null;
24:         speed?: number | null;
25:         text?: string | null;
26:         trailing_silence?: number | null;
27:         voice?: PostedUtteranceVoice.Raw | null;
28:     }
29: }
````

## File: src/serialization/resources/tts/types/ReturnGeneration.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { AudioEncoding } from "./AudioEncoding.js";
 7: import { Snippet } from "./Snippet.js";
 8: 
 9: export const ReturnGeneration: core.serialization.ObjectSchema<
10:     serializers.tts.ReturnGeneration.Raw,
11:     Hume.tts.ReturnGeneration
12: > = core.serialization.object({
13:     audio: core.serialization.string(),
14:     duration: core.serialization.number(),
15:     encoding: AudioEncoding,
16:     fileSize: core.serialization.property("file_size", core.serialization.number()),
17:     generationId: core.serialization.property("generation_id", core.serialization.string()),
18:     snippets: core.serialization.list(core.serialization.list(Snippet)),
19: });
20: 
21: export declare namespace ReturnGeneration {
22:     export interface Raw {
23:         audio: string;
24:         duration: number;
25:         encoding: AudioEncoding.Raw;
26:         file_size: number;
27:         generation_id: string;
28:         snippets: Snippet.Raw[][];
29:     }
30: }
````

## File: src/serialization/resources/tts/types/ReturnPagedVoices.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnVoice } from "./ReturnVoice.js";
 7: 
 8: export const ReturnPagedVoices: core.serialization.ObjectSchema<
 9:     serializers.tts.ReturnPagedVoices.Raw,
10:     Hume.tts.ReturnPagedVoices
11: > = core.serialization.object({
12:     pageNumber: core.serialization.property("page_number", core.serialization.number()),
13:     pageSize: core.serialization.property("page_size", core.serialization.number()),
14:     totalPages: core.serialization.property("total_pages", core.serialization.number()),
15:     voicesPage: core.serialization.property("voices_page", core.serialization.list(ReturnVoice)),
16: });
17: 
18: export declare namespace ReturnPagedVoices {
19:     export interface Raw {
20:         page_number: number;
21:         page_size: number;
22:         total_pages: number;
23:         voices_page: ReturnVoice.Raw[];
24:     }
25: }
````

## File: src/serialization/resources/tts/types/ReturnTts.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ReturnGeneration } from "./ReturnGeneration.js";
 7: 
 8: export const ReturnTts: core.serialization.ObjectSchema<serializers.tts.ReturnTts.Raw, Hume.tts.ReturnTts> =
 9:     core.serialization.object({
10:         generations: core.serialization.list(ReturnGeneration),
11:         requestId: core.serialization.property("request_id", core.serialization.string().optional()),
12:     });
13: 
14: export declare namespace ReturnTts {
15:     export interface Raw {
16:         generations: ReturnGeneration.Raw[];
17:         request_id?: string | null;
18:     }
19: }
````

## File: src/serialization/resources/tts/types/ReturnVoice.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { VoiceProvider } from "./VoiceProvider.js";
 7: 
 8: export const ReturnVoice: core.serialization.ObjectSchema<serializers.tts.ReturnVoice.Raw, Hume.tts.ReturnVoice> =
 9:     core.serialization.object({
10:         compatibleOctaveModels: core.serialization.property(
11:             "compatible_octave_models",
12:             core.serialization.list(core.serialization.string()).optional(),
13:         ),
14:         id: core.serialization.string(),
15:         name: core.serialization.string(),
16:         provider: VoiceProvider,
17:     });
18: 
19: export declare namespace ReturnVoice {
20:     export interface Raw {
21:         compatible_octave_models?: string[] | null;
22:         id: string;
23:         name: string;
24:         provider: VoiceProvider.Raw;
25:     }
26: }
````

## File: src/serialization/resources/tts/types/Snippet.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { Timestamp } from "./Timestamp.js";
 7: 
 8: export const Snippet: core.serialization.ObjectSchema<serializers.tts.Snippet.Raw, Hume.tts.Snippet> =
 9:     core.serialization.object({
10:         audio: core.serialization.string(),
11:         generationId: core.serialization.property("generation_id", core.serialization.string()),
12:         id: core.serialization.string(),
13:         text: core.serialization.string(),
14:         timestamps: core.serialization.list(Timestamp),
15:         transcribedText: core.serialization.property("transcribed_text", core.serialization.string().optional()),
16:         utteranceIndex: core.serialization.property("utterance_index", core.serialization.number().optional()),
17:     });
18: 
19: export declare namespace Snippet {
20:     export interface Raw {
21:         audio: string;
22:         generation_id: string;
23:         id: string;
24:         text: string;
25:         timestamps: Timestamp.Raw[];
26:         transcribed_text?: string | null;
27:         utterance_index?: number | null;
28:     }
29: }
````

## File: src/serialization/resources/tts/types/SnippetAudioChunk.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { AudioFormatType } from "./AudioFormatType.js";
 7: import { Snippet } from "./Snippet.js";
 8: 
 9: export const SnippetAudioChunk: core.serialization.ObjectSchema<
10:     serializers.tts.SnippetAudioChunk.Raw,
11:     Hume.tts.SnippetAudioChunk
12: > = core.serialization.object({
13:     audio: core.serialization.string(),
14:     audioFormat: core.serialization.property("audio_format", AudioFormatType),
15:     chunkIndex: core.serialization.property("chunk_index", core.serialization.number()),
16:     generationId: core.serialization.property("generation_id", core.serialization.string()),
17:     isLastChunk: core.serialization.property("is_last_chunk", core.serialization.boolean()),
18:     requestId: core.serialization.property("request_id", core.serialization.string()),
19:     snippet: Snippet.optional(),
20:     snippetId: core.serialization.property("snippet_id", core.serialization.string()),
21:     text: core.serialization.string(),
22:     transcribedText: core.serialization.property("transcribed_text", core.serialization.string().optional()),
23:     type: core.serialization.stringLiteral("audio"),
24:     utteranceIndex: core.serialization.property("utterance_index", core.serialization.number().optional()),
25: });
26: 
27: export declare namespace SnippetAudioChunk {
28:     export interface Raw {
29:         audio: string;
30:         audio_format: AudioFormatType.Raw;
31:         chunk_index: number;
32:         generation_id: string;
33:         is_last_chunk: boolean;
34:         request_id: string;
35:         snippet?: Snippet.Raw | null;
36:         snippet_id: string;
37:         text: string;
38:         transcribed_text?: string | null;
39:         type: "audio";
40:         utterance_index?: number | null;
41:     }
42: }
````

## File: src/serialization/resources/tts/types/Timestamp.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { MillisecondInterval } from "./MillisecondInterval.js";
 7: import { TimestampType } from "./TimestampType.js";
 8: 
 9: export const Timestamp: core.serialization.ObjectSchema<serializers.tts.Timestamp.Raw, Hume.tts.Timestamp> =
10:     core.serialization.object({
11:         text: core.serialization.string(),
12:         time: MillisecondInterval,
13:         type: TimestampType,
14:     });
15: 
16: export declare namespace Timestamp {
17:     export interface Raw {
18:         text: string;
19:         time: MillisecondInterval.Raw;
20:         type: TimestampType.Raw;
21:     }
22: }
````

## File: src/serialization/resources/tts/types/TimestampMessage.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { Timestamp } from "./Timestamp.js";
 7: 
 8: export const TimestampMessage: core.serialization.ObjectSchema<
 9:     serializers.tts.TimestampMessage.Raw,
10:     Hume.tts.TimestampMessage
11: > = core.serialization.object({
12:     generationId: core.serialization.property("generation_id", core.serialization.string()),
13:     requestId: core.serialization.property("request_id", core.serialization.string()),
14:     snippetId: core.serialization.property("snippet_id", core.serialization.string()),
15:     timestamp: Timestamp,
16:     type: core.serialization.stringLiteral("timestamp"),
17: });
18: 
19: export declare namespace TimestampMessage {
20:     export interface Raw {
21:         generation_id: string;
22:         request_id: string;
23:         snippet_id: string;
24:         timestamp: Timestamp.Raw;
25:         type: "timestamp";
26:     }
27: }
````

## File: src/serialization/resources/tts/types/TimestampType.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const TimestampType: core.serialization.Schema<serializers.tts.TimestampType.Raw, Hume.tts.TimestampType> =
 8:     core.serialization.enum_(["word", "phoneme"]);
 9: 
10: export declare namespace TimestampType {
11:     export type Raw = "word" | "phoneme";
12: }
````

## File: src/serialization/resources/tts/types/TtsOutput.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { SnippetAudioChunk } from "./SnippetAudioChunk.js";
 7: import { TimestampMessage } from "./TimestampMessage.js";
 8: 
 9: export const TtsOutput: core.serialization.Schema<serializers.tts.TtsOutput.Raw, Hume.tts.TtsOutput> =
10:     core.serialization.undiscriminatedUnion([SnippetAudioChunk, TimestampMessage]);
11: 
12: export declare namespace TtsOutput {
13:     export type Raw = SnippetAudioChunk.Raw | TimestampMessage.Raw;
14: }
````

## File: src/serialization/resources/tts/types/ValidationError.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: import { ValidationErrorLocItem } from "./ValidationErrorLocItem.js";
 7: 
 8: export const ValidationError: core.serialization.ObjectSchema<
 9:     serializers.tts.ValidationError.Raw,
10:     Hume.tts.ValidationError
11: > = core.serialization.object({
12:     loc: core.serialization.list(ValidationErrorLocItem),
13:     msg: core.serialization.string(),
14:     type: core.serialization.string(),
15: });
16: 
17: export declare namespace ValidationError {
18:     export interface Raw {
19:         loc: ValidationErrorLocItem.Raw[];
20:         msg: string;
21:         type: string;
22:     }
23: }
````

## File: src/serialization/resources/tts/types/ValidationErrorLocItem.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const ValidationErrorLocItem: core.serialization.Schema<
 8:     serializers.tts.ValidationErrorLocItem.Raw,
 9:     Hume.tts.ValidationErrorLocItem
10: > = core.serialization.undiscriminatedUnion([core.serialization.string(), core.serialization.number()]);
11: 
12: export declare namespace ValidationErrorLocItem {
13:     export type Raw = string | number;
14: }
````

## File: src/serialization/resources/tts/types/VoiceProvider.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import type * as Hume from "../../../../api/index.js";
 4: import * as core from "../../../../core/index.js";
 5: import type * as serializers from "../../../index.js";
 6: 
 7: export const VoiceProvider: core.serialization.Schema<serializers.tts.VoiceProvider.Raw, Hume.tts.VoiceProvider> =
 8:     core.serialization.enum_(["HUME_AI", "CUSTOM_VOICE"]);
 9: 
10: export declare namespace VoiceProvider {
11:     export type Raw = "HUME_AI" | "CUSTOM_VOICE";
12: }
````

## File: src/serialization/resources/tts/index.ts
````typescript
1: export * from "./resources/index.js";
2: export * from "./types/index.js";
````

## File: src/serialization/resources/index.ts
````typescript
1: export * as empathicVoice from "./empathicVoice/index.js";
2: export * as expressionMeasurement from "./expressionMeasurement/index.js";
3: export * as tts from "./tts/index.js";
````

## File: src/serialization/index.ts
````typescript
1: export * from "./resources/index.js";
````

## File: src/wrapper/expressionMeasurement/batch/BatchClient.ts
````typescript
 1: import { BatchClient as FernClient } from "../../../api/resources/expressionMeasurement/resources/batch/client/Client.js";
 2: import * as Hume from "../../../api/index.js";
 3: import { Job } from "./Job.js";
 4: import * as core from "../../../core/index.js";
 5: 
 6: export class BatchClient extends FernClient {
 7:     // This just wraps the return value of the base class's `startInferenceJob` and `startInferenceJobFromLocalFile` methods
 8:     // and returns a `Job` instance (has helper functions to await the job's result) instead of a raw job ID.
 9:     public startInferenceJob(
10:         request: Hume.expressionMeasurement.batch.InferenceBaseRequest = {},
11:         requestOptions?: FernClient.RequestOptions,
12:     ): core.HttpResponsePromise<Job> {
13:         return core.HttpResponsePromise.fromPromise(
14:             super
15:                 .startInferenceJob(request, requestOptions)
16:                 .withRawResponse()
17:                 .then((result) => {
18:                     return { data: new Job(result.data.jobId, this), rawResponse: result.rawResponse };
19:                 }),
20:         );
21:     }
22: 
23:     public startInferenceJobFromLocalFile(
24:         request: Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest,
25:         requestOptions?: FernClient.RequestOptions,
26:     ): core.HttpResponsePromise<Job> {
27:         return core.HttpResponsePromise.fromPromise(
28:             super
29:                 .startInferenceJobFromLocalFile(request, requestOptions)
30:                 .withRawResponse()
31:                 .then((result) => {
32:                     return { data: new Job(result.data.jobId, this), rawResponse: result.rawResponse };
33:                 }),
34:         );
35:     }
36: }
````

## File: src/wrapper/expressionMeasurement/batch/Job.ts
````typescript
 1: import * as Hume from "../../../api/index.js";
 2: import * as errors from "../../../errors/index.js";
 3: import { BatchClient } from "./BatchClient.js";
 4: 
 5: export class Job implements Hume.expressionMeasurement.batch.JobId {
 6:     constructor(
 7:         public readonly jobId: string,
 8:         private readonly client: BatchClient,
 9:     ) {}
10: 
11:     public async awaitCompletion(timeoutInSeconds = 300): Promise<void> {
12:         return new Promise((resolve, reject) => {
13:             const poller = new JobCompletionPoller(this.jobId, this.client);
14:             poller.start(resolve);
15:             setTimeout(() => {
16:                 poller.stop();
17:                 reject(new errors.HumeTimeoutError("Timeout exceeded when polling for job completion"));
18:             }, timeoutInSeconds * 1_000);
19:         });
20:     }
21: }
22: 
23: class JobCompletionPoller {
24:     private isPolling = true;
25:     constructor(
26:         private readonly jobId: string,
27:         private readonly client: BatchClient,
28:     ) {}
29: 
30:     public start(onTerminal: () => void) {
31:         this.isPolling = true;
32:         this.poll(onTerminal);
33:     }
34: 
35:     public stop() {
36:         this.isPolling = false;
37:     }
38: 
39:     private async poll(onTerminal: () => void): Promise<void> {
40:         try {
41:             const jobDetails = await this.client.getJobDetails(this.jobId);
42:             if (jobDetails.state.status === "COMPLETED" || jobDetails.state.status === "FAILED") {
43:                 onTerminal();
44:                 this.stop();
45:             }
46:         } catch {
47:             // swallow errors while polling
48:         }
49: 
50:         if (this.isPolling) {
51:             setTimeout(() => this.poll(onTerminal), 1_000);
52:         }
53:     }
54: }
````

## File: src/wrapper/expressionMeasurement/streaming/StreamingClient.ts
````typescript
 1: import * as Hume from "../../../api/index.js";
 2: import * as serializers from "../../../serialization/index.js";
 3: import * as core from "../../../core/index.js";
 4: import { StreamSocket } from "./StreamSocket.js";
 5: import WebSocket from "ws";
 6: 
 7: export declare namespace StreamClient {
 8:     interface Options {
 9:         apiKey?: core.Supplier<string | undefined>;
10:     }
11: 
12:     interface ConnectArgs {
13:         /* Job config */
14:         config: Hume.expressionMeasurement.stream.Config;
15:         /* Length of the sliding window in milliseconds to use when 
16:             aggregating media across streaming payloads within one WebSocket connection. */
17:         streamWindowMs?: number;
18: 
19:         onOpen?: (event: WebSocket.Event) => void;
20:         onMessage?: (message: Hume.expressionMeasurement.stream.Config) => void;
21:         onError?: (error: Hume.expressionMeasurement.stream.StreamErrorMessage) => void;
22:         onClose?: (event: WebSocket.Event) => void;
23:     }
24: }
25: 
26: export class StreamClient {
27:     constructor(protected readonly _options: StreamClient.Options) {}
28: 
29:     public connect(args: StreamClient.ConnectArgs): StreamSocket {
30:         const websocket = new WebSocket(`wss://api.hume.ai/v0/stream/models`, {
31:             headers: {
32:                 "X-Hume-Api-Key": typeof this._options.apiKey === "string" ? this._options.apiKey : "",
33:             },
34:             timeout: 10,
35:         });
36: 
37:         websocket.addEventListener("open", (event) => {
38:             args.onOpen?.(event);
39:         });
40: 
41:         websocket.addEventListener("error", (e) => {
42:             args.onError?.({
43:                 code: e.type,
44:                 error: e.message,
45:             });
46:         });
47: 
48:         websocket.addEventListener("message", async ({ data }) => {
49:             parse(data, {
50:                 onMessage: args.onMessage,
51:                 onError: args.onError,
52:             });
53:         });
54: 
55:         websocket.addEventListener("close", (event) => {
56:             args.onClose?.(event);
57:         });
58: 
59:         return new StreamSocket({
60:             websocket,
61:             streamWindowMs: args.streamWindowMs,
62:             config: args.config,
63:         });
64:     }
65: }
66: 
67: export function parse(
68:     data: WebSocket.Data,
69:     args: {
70:         onMessage?: (message: Hume.expressionMeasurement.stream.Config) => void;
71:         onError?: (error: Hume.expressionMeasurement.stream.StreamErrorMessage) => void;
72:     } = {},
73: ): Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage | undefined {
74:     const message = JSON.parse(data as string);
75: 
76:     const parsedResponse = serializers.expressionMeasurement.stream.Config.parse(message, {
77:         unrecognizedObjectKeys: "passthrough",
78:         allowUnrecognizedUnionMembers: true,
79:         allowUnrecognizedEnumValues: true,
80:         breadcrumbsPrefix: ["response"],
81:     });
82:     if (parsedResponse.ok) {
83:         args.onMessage?.(parsedResponse.value);
84:         return parsedResponse.value;
85:     }
86: 
87:     const parsedError = serializers.expressionMeasurement.stream.StreamErrorMessage.parse(message, {
88:         unrecognizedObjectKeys: "passthrough",
89:         allowUnrecognizedUnionMembers: true,
90:         allowUnrecognizedEnumValues: true,
91:         breadcrumbsPrefix: ["response"],
92:     });
93:     if (parsedError.ok) {
94:         args.onError?.(parsedError.value);
95:         return parsedError.value;
96:     }
97: }
````

## File: src/wrapper/expressionMeasurement/streaming/StreamSocket.ts
````typescript
  1: import WebSocket from "ws";
  2: import { v4 as uuid } from "uuid";
  3: import { parse } from "./StreamingClient.js";
  4: import { base64Encode } from "../../base64Encode.js";
  5: import * as Hume from "../../../api/index.js";
  6: import * as errors from "../../../errors/index.js";
  7: import * as serializers from "../../../serialization/index.js";
  8: import * as fs from "fs";
  9: 
 10: export declare namespace StreamSocket {
 11:     interface Args {
 12:         websocket: WebSocket;
 13:         config: Hume.expressionMeasurement.stream.Config;
 14:         streamWindowMs?: number;
 15:     }
 16: }
 17: 
 18: export class StreamSocket {
 19:     readonly websocket: WebSocket;
 20:     private readonly streamWindowMs?: number;
 21:     private config: Hume.expressionMeasurement.stream.Config;
 22: 
 23:     constructor({ websocket, config, streamWindowMs }: StreamSocket.Args) {
 24:         this.websocket = websocket;
 25:         this.config = config;
 26:         this.streamWindowMs = streamWindowMs;
 27:     }
 28: 
 29:     /**
 30:      * Send file on the `StreamSocket`
 31:      *
 32:      * @param file A fs.ReadStream | File | Blob
 33:      * @param config This method is intended for use with a `LanguageConfig`.
 34:      * When the socket is configured for other modalities this method will fail.
 35:      */
 36:     public async sendFile({
 37:         file,
 38:         config,
 39:     }: {
 40:         file: fs.ReadStream | Blob;
 41:         config?: Hume.expressionMeasurement.stream.Config;
 42:     }): Promise<Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage> {
 43:         if (config != null) {
 44:             this.config = config;
 45:         }
 46:         let contents = "";
 47:         if (file instanceof fs.ReadStream) {
 48:             const chunks: Buffer[] = [];
 49:             for await (const chunk of file) {
 50:                 chunks.push(Buffer.from(chunk));
 51:             }
 52:             contents = Buffer.concat(chunks).toString("base64");
 53:         } else if (file instanceof Blob) {
 54:             const toBase64 = (file: Blob): Promise<string> =>
 55:                 new Promise((res) => {
 56:                     const reader = new FileReader();
 57:                     reader.readAsDataURL(file);
 58:                     reader.onload = () => res(reader.result as string);
 59:                 });
 60:             contents = await toBase64(file);
 61:         } else {
 62:             throw new errors.HumeError({
 63:                 message: `file must be one of ReadStream or Blob.`,
 64:             });
 65:         }
 66:         const request: Hume.expressionMeasurement.stream.StreamModelsEndpointPayload = {
 67:             payloadId: uuid(),
 68:             data: contents,
 69:             models: this.config,
 70:             rawText: false,
 71:         };
 72:         if (this.streamWindowMs != null) {
 73:             request.streamWindowMs = this.streamWindowMs;
 74:         }
 75:         const response = await this.send(request);
 76:         if (response == null) {
 77:             throw new errors.HumeError({
 78:                 message: `Received no response after sending file: ${file}`,
 79:             });
 80:         }
 81:         return response;
 82:     }
 83: 
 84:     /**
 85:      * Send text on the `StreamSocket`
 86:      *
 87:      * @param text Text to send to the language model.
 88:      * @param config This method is intended for use with a `LanguageConfig`.
 89:      * When the socket is configured for other modalities this method will fail.
 90:      */
 91:     public async sendText({
 92:         text,
 93:         config,
 94:     }: {
 95:         text: string;
 96:         config?: Hume.expressionMeasurement.stream.Config;
 97:     }): Promise<Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage> {
 98:         if (config != null) {
 99:             this.config = config;
100:         }
101:         const request: Hume.expressionMeasurement.stream.StreamModelsEndpointPayload = {
102:             payloadId: uuid(),
103:             data: text,
104:             rawText: true,
105:             models: this.config,
106:         };
107:         if (this.streamWindowMs != null) {
108:             request.streamWindowMs = this.streamWindowMs;
109:         }
110:         const response = await this.send(request);
111:         if (response == null) {
112:             throw new errors.HumeError({
113:                 message: `Received no response after sending text: ${text}`,
114:             });
115:         }
116:         return response;
117:     }
118: 
119:     /**
120:      * Send facemesh landmarks on the `StreamSocket`
121:      *
122:      * @param landmarks List of landmark points for multiple faces.
123:      * The shape of this 3-dimensional list should be (n, 478, 3) where n is the number
124:      * of faces to be processed, 478 is the number of MediaPipe landmarks per face and 3
125:      * represents the (x, y, z) coordinates of each landmark.
126:      * @param config List of model configurations.
127:      * If set these configurations will overwrite existing configurations
128:      */
129:     public async sendFacemesh({
130:         landmarks,
131:         config,
132:     }: {
133:         landmarks: number[][][];
134:         config?: Hume.expressionMeasurement.stream.Config;
135:     }): Promise<Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage> {
136:         const response = this.sendText({
137:             text: base64Encode(JSON.stringify(landmarks)),
138:             config,
139:         });
140:         return response;
141:     }
142: 
143:     /**
144:      *
145:      * Reset the streaming sliding window.
146:      *
147:      * Call this method when some media has been fully processed and you want to continue using the same
148:      * streaming connection without leaking context across media samples.
149:      */
150:     public async reset(): Promise<void> {
151:         await this.send({
152:             resetStream: true,
153:         });
154:     }
155: 
156:     /**
157:      *
158:      * Get details associated with the current streaming connection.
159:      *
160:      */
161:     public async getJobDetails(): Promise<void> {
162:         await this.send({
163:             jobDetails: true,
164:         });
165:     }
166: 
167:     /**
168:      * Closes the underlying socket.
169:      */
170:     public close(): void {
171:         this.websocket.close();
172:     }
173: 
174:     private async send(
175:         payload: Hume.expressionMeasurement.stream.StreamModelsEndpointPayload,
176:     ): Promise<Hume.expressionMeasurement.stream.Config | void> {
177:         await this.tillSocketOpen();
178:         const jsonPayload = serializers.expressionMeasurement.stream.StreamModelsEndpointPayload.jsonOrThrow(payload, {
179:             unrecognizedObjectKeys: "strip",
180:         });
181:         this.websocket.send(JSON.stringify(jsonPayload));
182:         const response = await new Promise<
183:             Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage | undefined
184:         >((resolve) => {
185:             this.websocket.addEventListener("message", (event) => {
186:                 const response = parse(event.data);
187:                 resolve(response);
188:             });
189:         });
190:         if (response != null && isError(response)) {
191:             throw new errors.HumeError({
192:                 message: `CODE ${response.code}: ${response.error}`,
193:             });
194:         }
195:         return response;
196:     }
197: 
198:     private async tillSocketOpen(): Promise<WebSocket> {
199:         if (this.websocket.readyState === WebSocket.OPEN) {
200:             return this.websocket;
201:         }
202:         return new Promise((resolve, reject) => {
203:             this.websocket.addEventListener("open", () => {
204:                 resolve(this.websocket);
205:             });
206: 
207:             this.websocket.addEventListener("error", (event) => {
208:                 reject(event);
209:             });
210:         });
211:     }
212: }
213: 
214: function isError(
215:     response: Hume.expressionMeasurement.stream.Config | Hume.expressionMeasurement.stream.StreamErrorMessage,
216: ): response is Hume.expressionMeasurement.stream.StreamErrorMessage {
217:     return (response as Hume.expressionMeasurement.stream.StreamErrorMessage).error != null;
218: }
````

## File: src/wrapper/expressionMeasurement/ExpressionMeasurementClient.ts
````typescript
 1: import { ExpressionMeasurementClient as FernClient } from "../../api/resources/expressionMeasurement/client/Client.js";
 2: import { BatchClient } from "./batch/BatchClient.js";
 3: import { StreamClient } from "./streaming/StreamingClient.js";
 4: 
 5: export class ExpressionMeasurement extends FernClient {
 6:     protected _batch: BatchClient | undefined;
 7: 
 8:     // BatchClient here is overridden from the generated version, we wrap expression measurement jobs in
 9:     // a helper that makes it easier to await the result of a job.
10:     public get batch(): BatchClient {
11:         return (this._batch ??= new BatchClient(this._options));
12:     }
13: 
14:     // Streamclient here is an addition -- not present on the base FernClient.
15:     protected _stream: StreamClient | undefined;
16: 
17:     public get stream(): StreamClient {
18:         return (this._stream ??= new StreamClient(this._options));
19:     }
20: }
````

## File: src/wrapper/base64Decode.ts
````typescript
 1: export function base64Decode(str: string): string | Buffer {
 2:     if (typeof Buffer === "function") {
 3:         // Node.js environment
 4:         return Buffer.from(str, "base64");
 5:     } else if (typeof atob === "function") {
 6:         // Browser environment
 7:         return atob(str);
 8:     } else {
 9:         throw new Error("Base64 encoding not supported in this environment.");
10:     }
11: }
````

## File: src/wrapper/base64Encode.ts
````typescript
 1: export function base64Encode(str: string): string {
 2:     if (typeof Buffer === "function") {
 3:         // Node.js environment
 4:         return Buffer.from(str).toString("base64");
 5:     } else if (typeof btoa === "function") {
 6:         // Browser environment
 7:         return btoa(str);
 8:     } else {
 9:         throw new Error("Base64 encoding not supported in this environment.");
10:     }
11: }
````

## File: src/wrapper/checkForAudioTracks.ts
````typescript
 1: /**
 2:  * @name checkForAudioTracks
 3:  * @description
 4:  * Check if a MediaStream has audio tracks.
 5:  * @param stream
 6:  * The MediaStream to check
 7:  */
 8: export const checkForAudioTracks = (stream: MediaStream): void => {
 9:     const tracks = stream.getAudioTracks();
10: 
11:     if (tracks.length === 0) {
12:         throw new Error("No audio tracks");
13:     }
14:     if (tracks.length > 1) {
15:         throw new Error("Multiple audio tracks");
16:     }
17:     const track = tracks[0];
18:     if (!track) {
19:         throw new Error("No audio track");
20:     }
21: };
````

## File: src/wrapper/collate.ts
````typescript
 1: /**
 2:  * Takes an async iterator that yields interleaved items from different groups
 3:  * and produces an iterator that yields items in group order.
 4:  *
 5:  * Example:
 6:  *   Input:  A1, B1, A2, A3 (final), C1, C2, C3 (final), B2 (final)
 7:  *   Output: A1, A2, A3, B1, B2, C1, C2, C3
 8:  *
 9:  * This is useful when using synthesizeJsonStreaming with num_generations > 1
10:  *
11:  * @example
12:  * ```typescript
13:  *
14:  * import { collate } from 'hume';
15:  *
16:  * const stream = hume.synthesizeJsonStreaming({
17:  *   ...
18:  * })
19:  *
20:  * const contiguous = collate(
21:  *   stream
22:  *   (chunk) => chunk.generationId,
23:  *   (chunk) => chunk.isLastChunk
24:  * );
25:  *
26:  * for await (const item of contiguous) {
27:  *   audioPlayer.write(item.audio)
28:  * }
29:  * ```
30:  *
31:  * @param source - Async iterable that yields interleaved items.
32:  * @param groupBy - Function to determine a "key" that determines the group identity for each item.
33:  * @param isFinal - Function to determine if an item is the final item in its group.
34:  * @returns An async iterable that yields items in group order.
35:  */
36: export async function* collate<TItem, TKey>(
37:     source: AsyncIterable<TItem>,
38:     groupBy: (x: TItem) => TKey,
39:     isFinal: (x: TItem) => boolean,
40: ): AsyncIterable<TItem> {
41:     const buffers = new Map<TKey, TItem[]>();
42:     const order: TKey[] = [];
43:     let current: TKey | undefined;
44: 
45:     const ensure = (k: TKey) => {
46:         if (!buffers.has(k)) {
47:             buffers.set(k, []);
48:             order.push(k);
49:         }
50:     };
51: 
52:     const flushGroup = function* (k: TKey) {
53:         const buf = buffers.get(k);
54:         if (!buf) return;
55:         for (const item of buf) yield item;
56:         buffers.delete(k);
57:     };
58: 
59:     const nextGroup = (): TKey | undefined => {
60:         // pop the next group in first-seen order that still has a buffer
61:         while (order.length && !buffers.has(order[0])) order.shift();
62:         return order.shift();
63:     };
64: 
65:     for await (const item of source) {
66:         const k = groupBy(item);
67: 
68:         if (current === undefined) current = k;
69:         ensure(k);
70:         buffers.get(k)!.push(item);
71: 
72:         // if we just saw the final item for the current group, flush it and advance
73:         if (k === current && isFinal(item)) {
74:             yield* flushGroup(current);
75:             current = nextGroup();
76:         }
77:     }
78: 
79:     // stream ended; flush remaining groups in first-seen order
80:     if (current !== undefined) {
81:         if (buffers.has(current)) yield* flushGroup(current);
82:         while (true) {
83:             const k = nextGroup();
84:             if (k === undefined) break;
85:             yield* flushGroup(k);
86:         }
87:     }
88: }
````

## File: src/wrapper/convertBase64ToBlob.ts
````typescript
 1: /**
 2:  * Converts a base64-encoded string into a `Blob` object with the specified content type.
 3:  *
 4:  * @param {string} base64 - The base64-encoded string representing binary data.
 5:  * @param {string} contentType - The MIME type to assign to the resulting `Blob`.
 6:  * @returns {Blob} A `Blob` object containing the binary data from the base64 string.
 7:  */
 8: export function convertBase64ToBlob(base64: string, contentType?: string): Blob {
 9:     // Decode base64 string to a binary string
10:     const binaryString = window.atob(base64);
11: 
12:     // Create a Uint8Array with the same length as the binary string
13:     const byteArray = new Uint8Array(binaryString.length);
14: 
15:     // Fill the Uint8Array by converting each character's Unicode value to a byte
16:     for (let i = 0; i < binaryString.length; i++) {
17:         byteArray[i] = binaryString.charCodeAt(i);
18:     }
19: 
20:     // Create and return a Blob with the specified content type
21:     return new Blob([byteArray], { type: contentType });
22: }
````

## File: src/wrapper/convertBlobToBase64.ts
````typescript
 1: /**
 2:  * Converts a `Blob` object into a base64-encoded string.
 3:  * The resulting string contains the binary data from the `Blob`.
 4:  *
 5:  * @param {Blob} blob - The `Blob` object to convert to base64.
 6:  * @returns {Promise<string>} A promise that resolves to a base64-encoded string representing the `Blob` data.
 7:  */
 8: export function convertBlobToBase64(blob: Blob): Promise<string> {
 9:     return new Promise((resolve, reject) => {
10:         const reader = new FileReader();
11: 
12:         // Handle the load event which is triggered when readAsDataURL completes
13:         reader.onloadend = () => {
14:             // Ensure reader.result is not null and is a string
15:             if (typeof reader.result === "string") {
16:                 // Extract the Base64 encoded string, skipping the data URL prefix (e.g., "data:image/png;base64,")
17:                 const base64Data = reader.result.split(",")[1];
18:                 if (base64Data) {
19:                     resolve(base64Data);
20:                 } else {
21:                     reject(new Error("Failed to split the result into Base64 data."));
22:                 }
23:             } else {
24:                 reject(new Error("FileReader result is null or not a string."));
25:             }
26:         };
27: 
28:         // Handle errors during the read process
29:         reader.onerror = () => {
30:             reject(new Error(`Error reading blob: ${reader.error?.message}`));
31:         };
32: 
33:         // Initiate reading the blob as a data URL
34:         reader.readAsDataURL(blob);
35:     });
36: }
````

## File: src/wrapper/convertFrequencyScale.ts
````typescript
 1: // This function converts linear-scaled frequency decibels from an AnalyserNode's frequncy data to Bark scale [https://en.wikipedia.org/wiki/Bark_scale]
 2: // This implementation uses a simple approach of mapping indices in the linear-scaled array to the closest
 3: // Bark scale center frequency and is not intended to be an accurate representation, but rather "close-enough" for visualization purposes
 4: const barkCenterFrequencies = [
 5:     50, 150, 250, 350, 450, 570, 700, 840, 1000, 1170, 1370, 1600, 1850, 2150, 2500, 2900, 3400, 4000, 4800, 5800, 7000,
 6:     8500, 10500, 13500,
 7: ]; // Center frequency value in Hz
 8: 
 9: // Min/max values from https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
10: const minValue = 0;
11: const maxValue = 255;
12: 
13: export function convertLinearFrequenciesToBark(linearData: Uint8Array, sampleRate: number): number[] {
14:     const maxFrequency = sampleRate / 2;
15:     const frequencyResolution = maxFrequency / linearData.length;
16: 
17:     const barkFrequencies = barkCenterFrequencies.map((barkFreq) => {
18:         const linearDataIndex = Math.round(barkFreq / frequencyResolution);
19:         if (linearDataIndex >= 0 && linearDataIndex < linearData.length) {
20:             return (((linearData[linearDataIndex] ?? 0) - minValue) / (maxValue - minValue)) * 2;
21:         } else {
22:             return 0;
23:         }
24:     });
25: 
26:     return barkFrequencies;
27: }
````

## File: src/wrapper/ensureSingleValidAudioTrack.ts
````typescript
 1: /**
 2:  * Ensures that the given media stream contains exactly one valid audio track.
 3:  * Throws an error if no audio tracks are found, if there is more than one audio track,
 4:  * or if the sole audio track is falsy.
 5:  *
 6:  * @param {MediaStream} stream - The media stream object containing audio tracks to validate.
 7:  * @throws {Error} "No audio tracks" if the stream contains zero audio tracks.
 8:  * @throws {Error} "Multiple audio tracks" if the stream contains more than one audio track.
 9:  * @throws {Error} "No audio track" if the sole audio track is falsy.
10:  */
11: export const ensureSingleValidAudioTrack = (stream: MediaStream): void => {
12:     const tracks = stream.getAudioTracks();
13: 
14:     if (tracks.length === 0) {
15:         throw new Error("No audio tracks available");
16:     } else if (tracks.length > 1) {
17:         throw new Error("Multiple audio tracks found");
18:     } else if (!tracks[0]) {
19:         throw new Error("The audio track is invalid");
20:     }
21: };
````

## File: src/wrapper/EVIWebAudioPlayer.ts
````typescript
  1: import { convertBase64ToBlob } from "./convertBase64ToBlob.js";
  2: import type { AudioOutput } from "api/resources/empathicVoice";
  3: import { convertLinearFrequenciesToBark } from "./convertFrequencyScale.js";
  4: import { generateEmptyFft } from "./generateEmptyFft.js";
  5: 
  6: /**
  7:  * Options for configuring an {@link EVIWebAudioPlayer}.
  8:  *
  9:  * @default `{}` for sensible defaults.
 10:  */
 11: export interface EVIWebAudioPlayerOptions {
 12:     /**
 13:      * Initial master gain, via a `GainNode`, from `0` (_silent_) to `1` (_full volume_).
 14:      * Values outside this range are clamped.
 15:      *
 16:      * @default 1
 17:      */
 18:     volume?: number;
 19:     /**
 20:      * Disable AudioWorklet Mode and use Regular Buffer Mode instead.
 21:      * Regular Buffer Mode falls back to AudioBufferSourceNode in the main thread if worklets aren't available.
 22:      * @default false (AudioWorklet Mode enabled)
 23:      */
 24:     disableAudioWorklet?: boolean;
 25:     /**
 26:      * Real-time FFT (frequency-domain) settings **only** for visualization.
 27:      *
 28:      * - **Disable**: omit or `{ enabled: false }` – no `AnalyserNode` is created.
 29:      * - **Defaults**: `{ enabled: true }` → 2048-point FFT at 16 ms (~60 Hz), mapped to 24 Bark bands.
 30:      * - **Custom**: supply {@link EVIWebAudioPlayerFFTOptions} to override `size`, `interval`, or `transform`.
 31:      */
 32:     fft?: EVIWebAudioPlayerFFTOptions;
 33: }
 34: 
 35: /**
 36:  * FFT (frequency-domain) options for visualization.
 37:  *
 38:  * Pass `{ enabled: true }` for defaults, or omit/disable entirely for zero overhead.
 39:  */
 40: export type EVIWebAudioPlayerFFTOptions = FftEnabled | FftDisabled;
 41: 
 42: type FftDisabled = {
 43:     /**
 44:      * Turn visualization data OFF—skip analyser creation entirely (zero extra CPU).
 45:      */
 46:     enabled: false;
 47: };
 48: 
 49: type FftEnabled = {
 50:     /**
 51:      * Turn visualization data ON—create an `AnalyserNode`, poll it, and emit `'fft'` events.
 52:      */
 53:     enabled: true;
 54:     /**
 55:      * FFT size (power-of-two, 32 – 32768).
 56:      * Defaults to 2048 → 1024 bins (~ 23 Hz at 48 kHz).
 57:      * @default 2048
 58:      */
 59:     size?: number;
 60:     /**
 61:      * Polling interval, in **milliseconds**.
 62:      * Default 16 ms (~ 60 Hz) to sync with `requestAnimationFrame()`.
 63:      * @default 16
 64:      */
 65:     interval?: number;
 66:     /**
 67:      * Custom post-processing for raw magnitude data. Omit for built-in 24-band Bark mapping.
 68:      *
 69:      * @param bins PCM byte magnitudes (0 – 255) from `AnalyserNode`.
 70:      * @param sampleRate `AudioContext` sample rate in Hz.
 71:      * @returns Payload emitted with each `'fft'` event.
 72:      */
 73:     transform?: (bins: Uint8Array, sampleRate: number) => number[];
 74: };
 75: 
 76: type ResolvedFftOptions = {
 77:     readonly size: number;
 78:     readonly interval: number;
 79:     readonly transform: (bins: Uint8Array, sampleRate: number) => number[];
 80: };
 81: 
 82: type PlayerEventMap = {
 83:     play: CustomEvent<{ id: string }>;
 84:     stop: CustomEvent<{ id: string }>;
 85:     fft: CustomEvent<{ fft: number[] }>;
 86:     error: CustomEvent<{ message: string }>;
 87: };
 88: 
 89: /**
 90:  * A sequential, glitch-free Web-Audio player for **EVI** audio output.
 91:  *
 92:  * - **Decoding & playback**: base-64 PCM chunks feed an `AudioWorkletNode` and play in order, without gaps.
 93:  * - **One-time init**: await {@link init} in a user-gesture to build audio graph and unlock the browser’s
 94:  *  `AudioContext`; later calls are no-ops.
 95:  * - **Optional FFT**: `{ fft: { enabled: true } }` adds an `AnalyserNode` and emits `'fft'` events; omit to skip.
 96:  * - **Controls**: {@link setVolume}, {@link mute}, {@link unmute}, {@link stop}, {@link dispose}.
 97:  * - **Events**: listen for `'play'`, `'stop'`, `'fft'`, `'error'`.
 98:  */
 99: export class EVIWebAudioPlayer extends EventTarget {
100:     /** Default URL of the `audio-worklet.js` processor module, fetched from Hume AI’s CDN. */
101:     static #DEFAULT_WORKLET_URL = "https://storage.googleapis.com/evi-react-sdk-assets/audio-worklet-20250506.js";
102:     /** Default FFT size (power-of-two). */
103:     static #DEFAULT_FFT_SIZE = 2048;
104:     /** Default analyser poll interval (16 ms). */
105:     static #DEFAULT_FFT_INTERVAL = 16;
106: 
107:     /** `true` while any clip is currently audible. */
108:     get playing(): boolean {
109:         return this.#playing;
110:     }
111:     /** `true` if gain is set to 0 via {@link mute}. */
112:     get muted(): boolean {
113:         return this.#muted;
114:     }
115:     /** Current output gain (0‑1). */
116:     get volume(): number {
117:         return this.#volume;
118:     }
119:     /** Most recent FFT frame (empty when analyser disabled). */
120:     get fft(): number[] {
121:         return this.#fft;
122:     }
123: 
124:     #ctx: AudioContext | null = null;
125:     #workletNode: AudioWorkletNode | null = null;
126:     #analyserNode: AnalyserNode | null = null;
127:     #gainNode: GainNode | null = null;
128: 
129:     #initialized = false;
130:     #playing = false;
131:     #muted = false;
132:     #volume: number;
133:     #disableAudioWorklet: boolean;
134: 
135:     #fft: number[] = generateEmptyFft();
136:     #fftTimer: number | null = null;
137:     #fftOptions: ResolvedFftOptions | null = null;
138: 
139:     #clipQueue: Array<{ id: string; buffer: AudioBuffer; index: number }> = [];
140:     #currentlyPlayingAudioBuffer: AudioBufferSourceNode | null = null;
141:     #isProcessing = false;
142:     // chunkBufferQueues and #lastQueuedChunk are used to make sure that
143:     // we don't play chunks out of order. #chunkBufferQueues is NOT the
144:     // audio playback queue.
145:     #lastQueuedChunk: { id: string; index: number } | null = null;
146:     #chunkBufferQueues: Record<string, Array<AudioBuffer | undefined>> = {};
147: 
148:     constructor(private readonly opts: EVIWebAudioPlayerOptions = {}) {
149:         super();
150:         this.#volume = opts.volume ?? 1.0;
151:         this.#disableAudioWorklet = opts.disableAudioWorklet ?? false;
152: 
153:         // Resolve FFT options if enabled
154:         if (opts.fft?.enabled) {
155:             const { size, interval, transform } = opts.fft;
156:             this.#fftOptions = {
157:                 size: size ?? EVIWebAudioPlayer.#DEFAULT_FFT_SIZE,
158:                 interval: interval ?? EVIWebAudioPlayer.#DEFAULT_FFT_INTERVAL,
159:                 transform: transform ?? ((bins, sampleRate) => convertLinearFrequenciesToBark(bins, sampleRate)),
160:             };
161:         }
162:     }
163: 
164:     /**
165:      * * Subscribes to a player event and returns `this` for chaining.
166:      *
167:      * @param type One of `'play'`, `'stop'`, `'fft'`, or `'error'`.
168:      * @param fn Handler invoked with the event’s typed `detail` payload.
169:      * @param opts Optional `AddEventListenerOptions` (e.g. `{ once: true }`).
170:      *
171:      * @example
172:      *  ```ts
173:      *  const player = new EVIWebAudioPlayer();
174:      *  player
175:      *    .on('play', e => console.log('play',  e.detail.id))
176:      *    .on('stop', e => console.log('stop',  e.detail.id))
177:      *    .on('fft', e => console.log('stop',  e.detail.fft))
178:      *    .on('error', e => console.error('error', e.detail.message));
179:      *  ```
180:      */
181:     on<K extends keyof PlayerEventMap>(
182:         type: K,
183:         fn: (e: PlayerEventMap[K]) => void,
184:         opts?: AddEventListenerOptions,
185:     ): this {
186:         super.addEventListener(type, fn as EventListener, opts);
187:         return this;
188:     }
189: 
190:     /**
191:      * Set up and start the player’s Web-Audio pipeline.
192:      *
193:      * - Creates a **suspended** `AudioContext`, loads the worklet processor, wires `AudioWorkletNode → (AnalyserNode?) → GainNode → destination`, then calls `resume()`.
194:      * - Must be awaited inside a user-gesture (click/tap/key); later calls are no-ops.
195:      * - If `fft.enabled` is `false` (or `fft` is omitted), no `AnalyserNode` or polling timer is created.
196:      *
197:      * **Safari quirk:** Safari locks an `AudioContext` to the device’s current sample rate at creation.
198:      * If you open a Bluetooth headset mic afterward, the OS may switch to the 16 kHz HFP profile and down-sample playback, which sounds “telephone-y.”
199:      * To avoid this, call `getUserMedia()` (or otherwise open audio input) **before** `init()`.
200:      *
201:      * @throws {Error} If the browser lacks `AudioWorklet` support, or if `AudioContext.resume()` is rejected (autoplay policy, device error).
202:      */
203:     async init(): Promise<void> {
204:         if (this.#initialized) return;
205: 
206:         // Create the AudioContext
207:         this.#ctx = new AudioContext();
208: 
209:         // Fail fast if AudioWorklet isn’t supported
210:         if (!this.#ctx.audioWorklet) {
211:             console.warn("AudioWorklet is not supported in this browser. Falling back to Regular Buffer Mode.");
212:             this.#disableAudioWorklet = true;
213:         }
214: 
215:         try {
216:             // Build GainNode
217:             this.#gainNode = this.#ctx.createGain();
218:             this.#gainNode.gain.value = this.#volume;
219: 
220:             // Build AnalyserNode (optional)
221:             if (this.#fftOptions) {
222:                 this.#analyserNode = this.#ctx.createAnalyser();
223:                 this.#analyserNode.fftSize = this.#fftOptions.size;
224:             } else {
225:                 // Always create AnalyserNode, even if FFT is disabled, to avoid null checks in Buffer Mode
226:                 this.#analyserNode = this.#ctx.createAnalyser();
227:                 this.#analyserNode.fftSize = EVIWebAudioPlayer.#DEFAULT_FFT_SIZE;
228:             }
229: 
230:             if (!this.#disableAudioWorklet) {
231:                 // Loads the AudioWorklet processor module.
232:                 await this.#ctx.audioWorklet.addModule(EVIWebAudioPlayer.#DEFAULT_WORKLET_URL);
233: 
234:                 // Build AudioWorkletNode
235:                 this.#workletNode = new AudioWorkletNode(this.#ctx, "audio-processor");
236: 
237:                 // When the worklet posts { type: "ended" }, mark playback stopped and emit a `'stop'` event.
238:                 this.#workletNode.port.onmessage = (e: MessageEvent) => {
239:                     if ((e.data as { type?: string }).type === "ended") {
240:                         this.#playing = false;
241:                         this.dispatchEvent(new CustomEvent("stop", { detail: { id: "stream" } }));
242:                     }
243:                 };
244: 
245:                 // Audio graph nodes
246:                 const workletNode = this.#workletNode; // AudioWorkletNode (PCM processor)
247:                 const analyserNode = this.#analyserNode; // Optional AnalyserNode (FFT)
248:                 const gainNode = this.#gainNode; // GainNode (volume control)
249:                 const destination = this.#ctx.destination; // AudioDestinationNode (speakers)
250: 
251:                 // Analyser node is filtered out of audio graph if null (FFT disabled)
252:                 const audioGraph = [workletNode, analyserNode, gainNode, destination].filter(Boolean) as AudioNode[];
253: 
254:                 // Wire nodes: AudioWorkletNode → (AnalyserNode?) → GainNode → AudioDestinationNode
255:                 audioGraph.reduce((prev, next) => (prev.connect(next), next));
256:             } else {
257:                 // Regular Buffer Mode
258:                 const analyserNode = this.#analyserNode;
259:                 const gainNode = this.#gainNode;
260:                 const destination = this.#ctx.destination;
261: 
262:                 // Wire nodes: (AnalyserNode?) → GainNode → AudioDestinationNode
263:                 const audioGraph = [analyserNode, gainNode, destination].filter(Boolean) as AudioNode[];
264:                 audioGraph.reduce((prev, next) => (prev.connect(next), next));
265:             }
266: 
267:             // If an analyser is configured, begin polling it at the resolved interval and dispatching `'fft'` events for each frame.
268:             this.#startAnalyserPollingIfEnabled();
269: 
270:             // Resume the AudioContext now that the audio graph is fully wired.
271:             // Browsers allow `resume()` only inside a user-gesture callback.
272:             // Any rejection (autoplay policy, hardware issue, etc.) is caught by the outer catch-block below, which emits an 'error' event and re-throws.
273:             await this.#ctx.resume();
274: 
275:             this.#initialized = true;
276:         } catch (err) {
277:             const suffix = err instanceof Error ? `: ${err.message}` : String(err);
278:             this.#emitError(`Failed to initialize audio player${suffix}`);
279:             throw err;
280:         }
281:     }
282: 
283:     /**
284:      * Queue one {@link AudioOutput} message for playback.
285:      *
286:      * Decodes the base-64 PCM data, sends it to the `AudioWorkletNode` for glitch-free, in-order playback, and emits `'play'` for the first chunk of a new stream.
287:      *
288:      * @param message The `AudioOutput` message received from EVI’s WebSocket.
289:      *
290:      * @see {@link https://dev.hume.ai/reference/empathic-voice-interface-evi/chat/chat#receive.Audio-Output.type API Reference}
291:      */
292:     async enqueue(message: AudioOutput): Promise<void> {
293:         if (!this.#initialized || !this.#ctx) {
294:             this.#emitError("Audio player is not initialized");
295:             return;
296:         }
297: 
298:         if (!this.#disableAudioWorklet) {
299:             try {
300:                 const { data, id } = message;
301: 
302:                 const blob = convertBase64ToBlob(data);
303:                 const buffer = await blob.arrayBuffer();
304: 
305:                 const audio = await this.#ctx.decodeAudioData(buffer);
306:                 const pcmData = audio.getChannelData(0);
307: 
308:                 this.#workletNode!.port.postMessage({ type: "audio", data: pcmData });
309: 
310:                 this.#playing = true;
311:                 this.dispatchEvent(new CustomEvent("play", { detail: { id } }));
312:             } catch (err) {
313:                 const msg = err instanceof Error ? err.message : "Unknown error";
314:                 this.#emitError(`Failed to queue clip: ${msg}`);
315:             }
316:         } else {
317:             // Regular Buffer Mode
318:             try {
319:                 const audioBuffer = await this.#convertToAudioBuffer(message);
320:                 if (!audioBuffer) {
321:                     this.#emitError("Failed to convert data to audio buffer");
322:                     return;
323:                 }
324: 
325:                 const playableBuffers = this.#getNextAudioBuffers(message, audioBuffer);
326:                 if (playableBuffers.length === 0) {
327:                     return;
328:                 }
329: 
330:                 for (const nextAudioBufferToPlay of playableBuffers) {
331:                     this.#clipQueue.push({
332:                         id: nextAudioBufferToPlay.id,
333:                         buffer: nextAudioBufferToPlay.buffer,
334:                         index: nextAudioBufferToPlay.index,
335:                     });
336:                     if (this.#clipQueue.length === 1) {
337:                         this.#playNextClip();
338:                     }
339:                 }
340:             } catch (e) {
341:                 const eMessage = e instanceof Error ? e.message : "Unknown error";
342:                 this.#emitError(`Failed to add clip to queue: ${eMessage}`);
343:             }
344:         }
345:     }
346: 
347:     /**
348:      * Flush the worklet queue and output silence.
349:      */
350:     stop(): void {
351:         if (!this.#disableAudioWorklet) {
352:             // Clear buffered audio from the worklet queue
353:             this.#workletNode?.port.postMessage({ type: "fadeAndClear" });
354:         } else {
355:             // Regular Buffer mode
356:             if (this.#currentlyPlayingAudioBuffer) {
357:                 this.#currentlyPlayingAudioBuffer.stop();
358:                 this.#currentlyPlayingAudioBuffer.disconnect();
359:                 this.#currentlyPlayingAudioBuffer = null;
360:             }
361:             this.#clipQueue = [];
362:             this.#isProcessing = false;
363:         }
364: 
365:         // Restart analyser polling so fft events continue after stopping or clearing the queue
366:         this.#startAnalyserPollingIfEnabled();
367: 
368:         this.#playing = false;
369:         this.dispatchEvent(new CustomEvent("stop", { detail: { id: "manual" } }));
370:     }
371: 
372:     /**
373:      * Set the master gain ({@link volume}) to a value between `0` (_silent_) and `1` (_full volume_).
374:      *
375:      * - Clamps out-of-range values.
376:      * - If called before {@link init}, stores volume for when `AudioContext` is created.
377:      * - If currently {@link muted}, updates stored volume but keeps output silent until {@link unmute}.
378:      *
379:      * @param volume Desired gain; clamped to [0, 1].
380:      */
381:     setVolume(volume: number): void {
382:         const clampedVolume = Math.max(0, Math.min(volume, 1));
383:         this.#volume = clampedVolume;
384: 
385:         if (this.#gainNode && this.#ctx && !this.#muted) {
386:             this.#gainNode.gain.setValueAtTime(clampedVolume, this.#ctx.currentTime);
387:         }
388:     }
389: 
390:     /**
391:      * Mute output instantly by setting the gain to 0. Retains the last volume internally for later restore.
392:      */
393:     mute(): void {
394:         if (!this.#gainNode || !this.#ctx) return;
395:         this.#gainNode.gain.setValueAtTime(0, this.#ctx.currentTime);
396:         this.#muted = true;
397:     }
398: 
399:     /**
400:      * Restore output gain to the last set volume (via setVolume).
401:      */
402:     unmute(): void {
403:         if (!this.#gainNode || !this.#ctx) return;
404:         this.#gainNode.gain.setValueAtTime(this.#volume, this.#ctx.currentTime);
405:         this.#muted = false;
406:     }
407: 
408:     /**
409:      * Tear down all Web-Audio resources (worklet, analyser, gain, context) and reset state so {@link init} can be called again.
410:      */
411:     dispose(): void {
412:         if (this.#fftTimer != null) {
413:             clearInterval(this.#fftTimer);
414:             this.#fftTimer = null;
415:         }
416: 
417:         if (!this.#disableAudioWorklet) {
418:             this.#workletNode?.port.postMessage({ type: "fadeAndClear" });
419:             this.#workletNode?.port.postMessage({ type: "end" });
420:             this.#workletNode?.port.close();
421:             this.#workletNode?.disconnect();
422:         } else {
423:             // Regular Buffer mode
424:             if (this.#currentlyPlayingAudioBuffer) {
425:                 this.#currentlyPlayingAudioBuffer.stop();
426:                 this.#currentlyPlayingAudioBuffer.disconnect();
427:                 this.#currentlyPlayingAudioBuffer = null;
428:             }
429:             this.#clipQueue = [];
430:             this.#isProcessing = false;
431:         }
432: 
433:         this.#analyserNode?.disconnect();
434: 
435:         this.#gainNode?.disconnect();
436:         this.#ctx?.close().catch(() => void 0);
437: 
438:         this.#initialized = false;
439:         this.#playing = false;
440:         this.#fft = generateEmptyFft();
441:     }
442: 
443:     /**
444:      * Polls the AnalyserNode at the configured interval, applies the FFT transform, and emits `'fft'` events.
445:      * No-ops if no analyser is present.
446:      */
447:     #startAnalyserPollingIfEnabled() {
448:         if (!this.#fftOptions || !this.#analyserNode) return;
449:         if (this.#fftTimer) clearInterval(this.#fftTimer);
450: 
451:         const { interval, transform } = this.#fftOptions;
452: 
453:         this.#fftTimer = window.setInterval(() => {
454:             const bins = new Uint8Array(this.#analyserNode!.frequencyBinCount);
455:             this.#analyserNode!.getByteFrequencyData(bins);
456:             this.#fft = transform(bins, this.#ctx!.sampleRate);
457:             this.dispatchEvent(new CustomEvent("fft", { detail: { fft: this.#fft } }));
458:         }, interval);
459:     }
460: 
461:     /**
462:      * Emit an `error` event with the supplied message.
463:      */
464:     #emitError(message: string) {
465:         this.dispatchEvent(new CustomEvent("error", { detail: { message } }));
466:     }
467: 
468:     /**
469:      * Converts a base64 encoded audio data message to an AudioBuffer.
470:      */
471:     async #convertToAudioBuffer(message: AudioOutput): Promise<AudioBuffer | undefined> {
472:         if (!this.#initialized || !this.#ctx) {
473:             this.#emitError("Audio player has not been initialized");
474:             return;
475:         }
476:         const blob = convertBase64ToBlob(message.data);
477:         const arrayBuffer = await blob.arrayBuffer();
478:         const audioBuffer = await this.#ctx.decodeAudioData(arrayBuffer);
479:         return audioBuffer;
480:     }
481: 
482:     /**
483:      * Manages incoming audio chunks to ensure they are processed in the correct order.
484:      */
485:     #getNextAudioBuffers(
486:         message: AudioOutput,
487:         audioBuffer: AudioBuffer,
488:     ): Array<{ id: string; index: number; buffer: AudioBuffer }> {
489:         // Prevent prototype pollution by restricting dangerous property names.
490:         if (message.id === "__proto__" || message.id === "constructor" || message.id === "prototype") {
491:             this.#emitError(`Attempted to use a dangerous property name as message ID: ${message.id}`);
492:             return [];
493:         }
494:         //1. Add the current buffer to the queue
495:         if (!this.#chunkBufferQueues[message.id]) {
496:             this.#chunkBufferQueues[message.id] = [];
497:         }
498: 
499:         // Ensure message.index is a safe, non-negative integer to prevent prototype pollution.
500:         if (!Number.isInteger(message.index) || message.index < 0) {
501:             this.#emitError(`Attempted to use an invalid index: ${message.index}`);
502:             return [];
503:         }
504: 
505:         const queueForCurrMessage = this.#chunkBufferQueues[message.id] || [];
506:         queueForCurrMessage[message.index] = audioBuffer;
507: 
508:         // 2. Now collect buffers that are ready to be played
509:         const lastId = this.#lastQueuedChunk?.id;
510:         const buffers: Array<{ id: string; index: number; buffer: AudioBuffer }> = [];
511: 
512:         // If the current message ID is different from the last one that was added
513:         // to the queue, that means that we're playing a new message now, so the first chunk
514:         // we play needs to be at index 0.
515:         if (message.id !== lastId) {
516:             if (queueForCurrMessage[0]) {
517:                 this.#lastQueuedChunk = { id: message.id, index: 0 };
518:                 buffers.push({
519:                     id: message.id,
520:                     index: 0,
521:                     buffer: queueForCurrMessage[0],
522:                 });
523:                 queueForCurrMessage[0] = undefined;
524:             } else {
525:                 return [];
526:             }
527:         }
528: 
529:         // Drain the queue - basically if any chunks were received out of order previously,
530:         // and they're now ready to be played because the earlier chunks
531:         // have been received, we can add them to the buffers array.
532:         let nextIdx = (this.#lastQueuedChunk?.index || 0) + 1;
533:         let nextBuf = queueForCurrMessage[nextIdx];
534:         while (nextBuf) {
535:             buffers.push({ index: nextIdx, buffer: nextBuf, id: message.id });
536:             queueForCurrMessage[nextIdx] = undefined;
537:             this.#lastQueuedChunk = { id: message.id, index: nextIdx };
538:             nextIdx += 1;
539:             nextBuf = queueForCurrMessage[nextIdx];
540:         }
541: 
542:         return buffers;
543:     }
544: 
545:     /**
546:      * Only for Regular Buffer mode.
547:      * This function is called when the current audio clip ends.
548:      * It will play the next clip in the queue if there is one.
549:      */
550:     #playNextClip() {
551:         if (this.#clipQueue.length === 0 || this.#isProcessing) {
552:             return;
553:         }
554: 
555:         if (this.#analyserNode === null || this.#ctx === null) {
556:             this.#emitError("Audio player is not initialized");
557:             return;
558:         }
559: 
560:         const nextClip = this.#clipQueue.shift();
561: 
562:         if (!nextClip) {
563:             return;
564:         }
565: 
566:         this.#isProcessing = true;
567:         this.#playing = true;
568: 
569:         const bufferSource = this.#ctx.createBufferSource();
570: 
571:         bufferSource.buffer = nextClip.buffer;
572: 
573:         if (this.#analyserNode) {
574:             bufferSource.connect(this.#analyserNode);
575:         }
576: 
577:         if (this.#gainNode) {
578:             this.#analyserNode?.connect(this.#gainNode);
579:             this.#gainNode.connect(this.#ctx.destination);
580:         } else {
581:             this.#analyserNode?.connect(this.#ctx.destination);
582:         }
583: 
584:         this.#currentlyPlayingAudioBuffer = bufferSource;
585: 
586:         this.#startAnalyserPollingIfEnabled();
587: 
588:         bufferSource.start(0);
589:         if (nextClip.index === 0) {
590:             this.dispatchEvent(new CustomEvent("play", { detail: { id: nextClip.id } }));
591:         }
592: 
593:         bufferSource.onended = () => {
594:             if (this.#fftTimer) {
595:                 clearInterval(this.#fftTimer);
596:                 this.#fftTimer = null;
597:             }
598:             this.#fft = generateEmptyFft();
599:             bufferSource.disconnect();
600:             this.#isProcessing = false;
601:             this.#playing = false;
602:             this.dispatchEvent(new CustomEvent("stop", { detail: { id: nextClip.id } }));
603:             this.#currentlyPlayingAudioBuffer = null;
604:             this.#playNextClip();
605:         };
606:     }
607: }
````

## File: src/wrapper/fetchAccessToken.ts
````typescript
 1: import { base64Encode } from "./base64Encode.js";
 2: import { z } from "zod";
 3: 
 4: /**
 5:  * Fetches a new access token from the Hume API using the provided API key and Secret key.
 6:  *
 7:  * @param args - The arguments for the request.
 8:  * @example
 9:  * ```typescript
10:  * async function getToken() {
11:  *   const accessToken = await fetchAccessToken({
12:  *     apiKey: 'test',
13:  *     secretKey: 'test',
14:  *   });
15:  *
16:  *   console.log(accessToken); // Outputs the access token
17:  * }
18:  * ```
19:  */
20: export const fetchAccessToken = async ({
21:     apiKey,
22:     secretKey,
23:     host = "api.hume.ai",
24: }: {
25:     apiKey: string;
26:     secretKey: string;
27:     host?: string;
28: }): Promise<string> => {
29:     const authString = `${apiKey}:${secretKey}`;
30:     const encoded = base64Encode(authString);
31: 
32:     const res = await fetch(`https://${host}/oauth2-cc/token`, {
33:         method: "POST",
34:         headers: {
35:             "Content-Type": "application/x-www-form-urlencoded",
36:             Authorization: `Basic ${encoded}`,
37:         },
38:         body: new URLSearchParams({
39:             grant_type: "client_credentials",
40:         }).toString(),
41:     });
42:     if (!res.ok) {
43:         throw new Error(`Failed to fetch access token: (${res.status} ${res.statusText})\n ${await res.text()}`);
44:     }
45:     return z
46:         .object({
47:             access_token: z.string(),
48:         })
49:         .transform((data) => {
50:             return data.access_token;
51:         })
52:         .parse(await res.json());
53: };
````

## File: src/wrapper/generateEmptyFft.ts
````typescript
1: export function generateEmptyFft(): number[] {
2:     return Array.from({ length: 24 }).map(() => 0);
3: }
````

## File: src/wrapper/getAudioStream.ts
````typescript
 1: export type AudioStreamOptions = {
 2:     echoCancellation?: boolean;
 3:     noiseSuppression?: boolean;
 4:     autoGainControl?: boolean;
 5: };
 6: 
 7: /**
 8:  * Requests an audio stream from the user's device using the `getUserMedia` API.
 9:  * The stream will have echo cancellation, noise suppression, and auto gain control enabled.
10:  *
11:  * @returns {Promise<MediaStream>} A promise that resolves to a `MediaStream` containing audio data only.
12:  * @throws {DOMException} If the user denies access or no audio input devices are found.
13:  */
14: export const getAudioStream = async (audioStreamOptions: AudioStreamOptions = {}): Promise<MediaStream> => {
15:     const { echoCancellation = true, noiseSuppression = true, autoGainControl = true } = audioStreamOptions;
16:     return navigator.mediaDevices.getUserMedia({
17:         audio: {
18:             echoCancellation,
19:             noiseSuppression,
20:             autoGainControl,
21:         },
22:         video: false,
23:     });
24: };
````

## File: src/wrapper/getBrowserSupportedMimeType.ts
````typescript
 1: /**
 2:  * Enum representing the supported MIME types for audio recording.
 3:  */
 4: export enum MimeType {
 5:     WEBM = "audio/webm",
 6:     MP4 = "audio/mp4",
 7:     WAV = "audio/wav",
 8: }
 9: 
10: /**
11:  * Represents a successful result where a compatible MIME type was found.
12:  * @property {true} success - Indicates a successful result.
13:  * @property {MimeType} mimeType - The MIME type supported by the browser.
14:  */
15: type MimeTypeSuccessResult = { success: true; mimeType: MimeType };
16: 
17: /**
18:  * Represents a failure result when no compatible MIME type is supported or an error occurs.
19:  * @property {false} success - Indicates a failure result.
20:  * @property {Error} error - The error explaining why a compatible MIME type was not found.
21:  */
22: type MimeTypeFailureResult = { success: false; error: Error };
23: 
24: /**
25:  * Union type representing the possible outcomes of checking for a supported MIME type.
26:  * Could either be a successful or failure result.
27:  */
28: type MimeTypeResult = MimeTypeSuccessResult | MimeTypeFailureResult;
29: 
30: /**
31:  * Checks whether the `MediaRecorder` API is supported in the current environment.
32:  *
33:  * @returns {boolean} Returns `true` if the `MediaRecorder` API is supported, otherwise `false`.
34:  */
35: function isMediaRecorderSupported(): boolean {
36:     return typeof MediaRecorder !== "undefined";
37: }
38: 
39: /**
40:  * Finds and returns the first MIME type from the given array that is supported by the `MediaRecorder`.
41:  *
42:  * @param {MimeType[]} mimeTypes - An array of MIME types to check for compatibility.
43:  * @returns {MimeType | null} The first supported MIME type or `null` if none are supported.
44:  */
45: function getSupportedMimeType(mimeTypes: MimeType[]): MimeType | null {
46:     return mimeTypes.find((type) => MediaRecorder.isTypeSupported(type)) || null;
47: }
48: 
49: /**
50:  * Determines if the current browser supports any of the predefined audio MIME types
51:  * (WEBM, MP4, or WAV) via the `MediaRecorder` API.
52:  *
53:  * @returns {MimeTypeResult} An object containing the success status and either a supported MIME type or an error.
54:  * @throws {Error} If the `MediaRecorder` API is not supported by the browser or no compatible types are found.
55:  */
56: export function getBrowserSupportedMimeType(): MimeTypeResult {
57:     // Check if the MediaRecorder API is supported in the current environment.
58:     if (!isMediaRecorderSupported()) {
59:         return {
60:             success: false,
61:             error: new Error("MediaRecorder is not supported"),
62:         };
63:     }
64: 
65:     const COMPATIBLE_MIME_TYPES = [MimeType.WEBM, MimeType.MP4, MimeType.WAV];
66: 
67:     // Find the first compatible MIME type that the browser's MediaRecorder supports.
68:     const supportedMimeType = getSupportedMimeType(COMPATIBLE_MIME_TYPES);
69: 
70:     // If no compatible MIME type is found, return a failure result with an appropriate error message.
71:     if (!supportedMimeType) {
72:         return {
73:             success: false,
74:             error: new Error("Browser does not support any compatible mime types"),
75:         };
76:     }
77: 
78:     // If a compatible MIME type is found, return a success result with the supported MIME type.
79:     return {
80:         success: true,
81:         mimeType: supportedMimeType,
82:     };
83: }
````

## File: src/wrapper/HumeClient.ts
````typescript
 1: import { HumeClient as FernClient } from "../Client.js";
 2: import * as core from "../core/index.js";
 3: import { ExpressionMeasurement } from "./expressionMeasurement/ExpressionMeasurementClient.js";
 4: import * as environments from "../environments.js";
 5: import { SDK_VERSION } from "../version.js";
 6: 
 7: export declare namespace HumeClient {
 8:     type Options = Omit<FernClient.Options, "environment"> & { accessToken?: string } & (
 9:             | { accessToken: NonNullable<core.Supplier<string>> }
10:             | { apiKey: NonNullable<FernClient.Options["apiKey"]> }
11:         ) & {
12:             environment?: core.Supplier<environments.HumeEnvironment | environments.HumeEnvironmentUrls | string>;
13:         };
14: }
15: 
16: export class HumeClient extends FernClient {
17:     constructor(_options: HumeClient.Options) {
18:         let options: FernClient.Options;
19:         let oldEnvironment: HumeClient.Options["environment"];
20:         ({ environment: oldEnvironment, ...options } = _options || {});
21: 
22:         // Check if both accessToken and Authorization header are provided (case-insensitive)
23:         if (_options.accessToken && _options.headers) {
24:             const hasAuthHeader = Object.keys(_options.headers).some((key) => key.toLowerCase() === "authorization");
25:             if (hasAuthHeader) {
26:                 throw new Error("Cannot provide both 'accessToken' and 'headers.Authorization'. Please use only one.");
27:             }
28:         }
29: 
30:         if (_options.accessToken) {
31:             options.headers = {
32:                 ...options.headers,
33:                 Authorization: core.Supplier.map(_options.accessToken, (token) => `Bearer ${token}`),
34:             };
35:         }
36: 
37:         // Add telemetry headers
38:         options.headers = {
39:             ...options.headers,
40:             "X-Hume-Client-Name": "typescript_sdk",
41:             "X-Hume-Client-Version": SDK_VERSION,
42:         };
43: 
44:         // Allow setting a single url http://... or https://... for environment'
45:         if (oldEnvironment) {
46:             const environment: FernClient.Options["environment"] = _options.environment
47:                 ? core.Supplier.map(
48:                       _options.environment,
49:                       (e): environments.HumeEnvironment | environments.HumeEnvironmentUrls => {
50:                           if (typeof e === "string") {
51:                               if (e.startsWith("http://")) {
52:                                   return {
53:                                       base: e,
54:                                       evi: e.replace("http://", "ws://") + "/v0/evi",
55:                                       tts: e.replace("http://", "ws://") + "/v0/tts",
56:                                       stream: e.replace("http://", "ws://") + "/v0/stream",
57:                                   };
58:                               }
59:                               if (e.startsWith("https://")) {
60:                                   return {
61:                                       base: e,
62:                                       evi: e.replace("https://", "wss://") + "/v0/evi",
63:                                       tts: e.replace("https://", "wss://") + "/v0/tts",
64:                                       stream: e.replace("https://", "wss://") + "/v0/stream",
65:                                   };
66:                               }
67:                               return {
68:                                   base: "https://" + e,
69:                                   evi: "wss://" + e + "/v0/evi",
70:                                   tts: "wss://" + e + "/v0/tts",
71:                                   stream: "wss://" + e + "/v0/stream",
72:                               };
73:                           } else {
74:                               return e;
75:                           }
76:                       },
77:                   )
78:                 : undefined;
79:             options.environment = environment;
80:         }
81: 
82:         super(options);
83:     }
84: 
85:     // We need to override this from FernClient to use the extended
86:     // `ExpressionMeasurement` from `wrapper` and not `api/resources/`
87:     protected _expressionMeasurement: ExpressionMeasurement | undefined;
88: 
89:     public get expressionMeasurement(): ExpressionMeasurement {
90:         return (this._expressionMeasurement ??= new ExpressionMeasurement(this._options));
91:     }
92: }
````

## File: src/wrapper/index.ts
````typescript
 1: export { base64Decode } from "./base64Decode.js";
 2: export { base64Encode } from "./base64Encode.js";
 3: export { convertBase64ToBlob } from "./convertBase64ToBlob.js";
 4: export { convertBlobToBase64 } from "./convertBlobToBase64.js";
 5: export { ensureSingleValidAudioTrack } from "./ensureSingleValidAudioTrack.js";
 6: export { checkForAudioTracks } from "./checkForAudioTracks.js";
 7: export { fetchAccessToken } from "./fetchAccessToken.js";
 8: export { getAudioStream } from "./getAudioStream.js";
 9: export { MimeType, getBrowserSupportedMimeType } from "./getBrowserSupportedMimeType.js";
10: export { HumeClient } from "./HumeClient.js";
11: export { ExpressionMeasurement } from "./expressionMeasurement/ExpressionMeasurementClient.js";
12: export { EVIWebAudioPlayer } from "./EVIWebAudioPlayer.js";
13: export type { EVIWebAudioPlayerFFTOptions, EVIWebAudioPlayerOptions } from "./EVIWebAudioPlayer.js";
14: export { collate } from "./collate.js";
15: export { SilenceFiller } from "./SilenceFiller.js";
16: export type { PipeDestination } from "./SilenceFiller.js";
17: 
18: /**
19:  * @deprecated SilenceFiller no longer requires dynamic import. Use `import { SilenceFiller } from 'hume'` directly.
20:  */
21: export const createSilenceFiller = async (): Promise<typeof import("./SilenceFiller.js").SilenceFiller> => {
22:     const { SilenceFiller } = await import("./SilenceFiller.js");
23:     return SilenceFiller;
24: };
````

## File: src/wrapper/SilenceFiller.ts
````typescript
  1: /**
  2:  * A minimal Writable-like interface that SilenceFiller can pipe to.
  3:  * This matches the subset of Node.js Writable that we need.
  4:  */
  5: export interface PipeDestination {
  6:     write(chunk: Uint8Array): boolean;
  7:     end?(): void;
  8:     on?(event: "drain", listener: () => void): this;
  9:     once?(event: "drain", listener: () => void): this;
 10:     removeListener?(event: "drain", listener: () => void): this;
 11: }
 12: 
 13: type EventListener = (...args: unknown[]) => void;
 14: 
 15: /**
 16:  * SilenceFiller is a pipeable stream that intersperses incoming audio data
 17:  * with bytes of silence. This is important in some cases to keep an audio
 18:  * stream "alive". Audio players, such as ffmpeg, can interpret inactivity as
 19:  * meaning the stream is ended, or disconnected.
 20:  *
 21:  * This implementation does not depend on Node.js built-ins and can work in
 22:  * any JavaScript environment, while still being pipeable to Node.js streams.
 23:  *
 24:  * @example
 25:  * ```typescript
 26:  * import { SilenceFiller } from 'hume';
 27:  *
 28:  * const BYTES_PER_SAMPLE = 2; // 16-bit samples
 29:  * const SAMPLE_RATE = 48000;
 30:  * const BUFFER_SIZE = Math.floor(SAMPLE_RATE * 0.1 * BYTES_PER_SAMPLE); // 100ms buffer
 31:  * const silenceFiller = new SilenceFiller(BUFFER_SIZE, SAMPLE_RATE, BYTES_PER_SAMPLE, 10);
 32:  *
 33:  * // Pipe silence filler output to audio player stdin
 34:  * silenceFiller.pipe(audioPlayer.stdin);
 35:  *
 36:  * // Handle pipe errors
 37:  * silenceFiller.on('error', (err) => {
 38:  *   console.error("SilenceFiller error:", err);
 39:  * });
 40:  *
 41:  * // Write audio data as it arrives
 42:  * silenceFiller.writeAudio(audioBuffer);
 43:  *
 44:  * // End the stream when done
 45:  * await silenceFiller.endStream();
 46:  * ```
 47:  */
 48: export class SilenceFiller {
 49:     private unclockedSilenceFiller: UnclockedSilenceFiller;
 50:     private isStarted: boolean = false;
 51:     private pushIntervalId: ReturnType<typeof setInterval> | null = null;
 52:     private bytesPerSample: number;
 53:     private pushIntervalMs: number;
 54:     private destination: PipeDestination | null = null;
 55:     private eventListeners: Map<string, Set<EventListener>> = new Map();
 56:     private ended: boolean = false;
 57: 
 58:     /**
 59:      * Creates a new SilenceFiller instance.
 60:      *
 61:      * @param pushIntervalMs - The interval in milliseconds for pushing audio data (default: 5ms).
 62:      * @param sampleRate - The sample rate of the audio (e.g., 48000).
 63:      * @param bytesPerSample - The number of bytes per audio sample (e.g., 2 for 16-bit).
 64:      * @param bufferSize - How much to 'prebuffer'. If you set this too low there
 65:      * is a chance that playback will stutter, but if you set it too high
 66:      * playback will take longer to start.
 67:      */
 68:     constructor(
 69:         pushIntervalMs: number = 5,
 70:         sampleRate: number = 48000,
 71:         bytesPerSample: number = 2,
 72:         bufferSize: number = 9600,
 73:     ) {
 74:         this.unclockedSilenceFiller = new UnclockedSilenceFiller(bufferSize, sampleRate, bytesPerSample);
 75:         this.bytesPerSample = bytesPerSample;
 76:         this.pushIntervalMs = pushIntervalMs;
 77:     }
 78: 
 79:     /**
 80:      * Pipes the output of this SilenceFiller to a writable destination.
 81:      *
 82:      * @param destination - The destination to pipe to (e.g., a Node.js Writable stream).
 83:      * @returns The destination, for chaining.
 84:      */
 85:     pipe<T extends PipeDestination>(destination: T): T {
 86:         this.destination = destination;
 87:         return destination;
 88:     }
 89: 
 90:     /**
 91:      * Registers an event listener.
 92:      *
 93:      * @param event - The event name ('error', 'end').
 94:      * @param listener - The listener function.
 95:      * @returns This instance, for chaining.
 96:      */
 97:     on(event: string, listener: EventListener): this {
 98:         if (!this.eventListeners.has(event)) {
 99:             this.eventListeners.set(event, new Set());
100:         }
101:         this.eventListeners.get(event)!.add(listener);
102:         return this;
103:     }
104: 
105:     /**
106:      * Registers a one-time event listener.
107:      *
108:      * @param event - The event name ('error', 'end').
109:      * @param listener - The listener function.
110:      * @returns This instance, for chaining.
111:      */
112:     once(event: string, listener: EventListener): this {
113:         const onceWrapper: EventListener = (...args: unknown[]) => {
114:             this.off(event, onceWrapper);
115:             listener(...args);
116:         };
117:         return this.on(event, onceWrapper);
118:     }
119: 
120:     /**
121:      * Removes an event listener.
122:      *
123:      * @param event - The event name.
124:      * @param listener - The listener function to remove.
125:      * @returns This instance, for chaining.
126:      */
127:     off(event: string, listener: EventListener): this {
128:         const listeners = this.eventListeners.get(event);
129:         if (listeners) {
130:             listeners.delete(listener);
131:         }
132:         return this;
133:     }
134: 
135:     /**
136:      * Emits an event to all registered listeners.
137:      *
138:      * @param event - The event name.
139:      * @param args - Arguments to pass to listeners.
140:      */
141:     private emit(event: string, ...args: unknown[]): void {
142:         const listeners = this.eventListeners.get(event);
143:         if (listeners) {
144:             for (const listener of listeners) {
145:                 try {
146:                     listener(...args);
147:                 } catch {
148:                     // Ignore errors in listeners
149:                 }
150:             }
151:         }
152:     }
153: 
154:     /**
155:      * Writes audio data to the silence filler.
156:      *
157:      * @param audioBuffer - The audio buffer to write (Uint8Array or Buffer).
158:      */
159:     writeAudio(audioBuffer: Uint8Array): void {
160:         const now = Date.now();
161:         try {
162:             this.unclockedSilenceFiller.writeAudio(audioBuffer, now);
163:             if (!this.isStarted && this.unclockedSilenceFiller.donePrebuffering) {
164:                 this.isStarted = true;
165:                 this.startPushInterval();
166:             }
167:         } catch (error) {
168:             console.error(`[SilenceFiller] Error writing audio:`, error);
169:             this.emit("error", error);
170:         }
171:     }
172: 
173:     private startPushInterval(): void {
174:         this.pushIntervalId = setInterval(() => {
175:             this.pushData();
176:         }, this.pushIntervalMs);
177:     }
178: 
179:     private pushData(): void {
180:         if (!this.isStarted || !this.destination) return;
181: 
182:         try {
183:             const now = Date.now();
184:             const audioChunk = this.unclockedSilenceFiller.readAudio(now);
185: 
186:             if (audioChunk && audioChunk.length > 0) {
187:                 // Ensure chunk size is aligned to bytesPerSample
188:                 const alignedChunkSize = Math.floor(audioChunk.length / this.bytesPerSample) * this.bytesPerSample;
189: 
190:                 if (alignedChunkSize > 0) {
191:                     const chunk = audioChunk.subarray(0, alignedChunkSize);
192:                     this.destination.write(chunk);
193:                 }
194:             }
195:         } catch (error) {
196:             console.error(`[SilenceFiller] Error pushing data:`, error);
197:             this.emit("error", error);
198:         }
199:     }
200: 
201:     /**
202:      * Ends the stream and drains all remaining audio data.
203:      *
204:      * @returns A promise that resolves when the stream has ended.
205:      */
206:     endStream(): Promise<void> {
207:         return new Promise((resolve) => {
208:             if (this.ended) {
209:                 resolve();
210:                 return;
211:             }
212:             this.ended = true;
213: 
214:             // Stop pushing data
215:             if (this.pushIntervalId) {
216:                 clearInterval(this.pushIntervalId);
217:                 this.pushIntervalId = null;
218:             }
219: 
220:             // Drain all remaining audio from SilenceFiller
221:             const now = Date.now();
222: 
223:             // Keep reading until no more audio is available
224:             while (this.destination) {
225:                 const remainingChunk = this.unclockedSilenceFiller.readAudio(now);
226: 
227:                 if (!remainingChunk || remainingChunk.length === 0) {
228:                     break;
229:                 }
230: 
231:                 const alignedChunkSize = Math.floor(remainingChunk.length / this.bytesPerSample) * this.bytesPerSample;
232:                 if (alignedChunkSize > 0) {
233:                     const chunk = remainingChunk.subarray(0, alignedChunkSize);
234:                     this.destination.write(chunk);
235:                 }
236:             }
237: 
238:             this.emit("end");
239:             resolve();
240:         });
241:     }
242: }
243: 
244: /**
245:  * Does the actual calculation of how interspersing audio with silence
246:  * is "pure" in the sense that it does not rely on the system clock.
247:  * It's up to the caller to provide timestamps.
248:  *
249:  * @internal
250:  */
251: export class UnclockedSilenceFiller {
252:     private audioQueue: Uint8Array[] = [];
253:     private totalBufferedBytes: number = 0;
254:     private startTimestamp: number | null = null;
255:     private totalBytesSent: number = 0;
256:     public donePrebuffering: boolean = false;
257:     private bufferSize: number;
258:     private sampleRate: number;
259:     private bytesPerSample: number;
260: 
261:     constructor(bufferSize: number, sampleRate: number, bytesPerSample: number) {
262:         this.bufferSize = bufferSize;
263:         this.sampleRate = sampleRate;
264:         this.bytesPerSample = bytesPerSample;
265:     }
266: 
267:     writeAudio(audioBuffer: Uint8Array, timestamp: number): void {
268:         this.audioQueue.push(audioBuffer);
269:         this.totalBufferedBytes += audioBuffer.length;
270: 
271:         if (this.startTimestamp === null) {
272:             this.startTimestamp = timestamp;
273:         }
274: 
275:         if (!this.donePrebuffering && this.totalBufferedBytes >= this.bufferSize) {
276:             this.donePrebuffering = true;
277:         }
278:     }
279: 
280:     readAudio(timestamp: number): Uint8Array | null {
281:         if (this.startTimestamp === null || !this.donePrebuffering) {
282:             return null;
283:         }
284: 
285:         const elapsedMs = timestamp - this.startTimestamp;
286: 
287:         const targetBytesSent = Math.floor(((this.sampleRate * elapsedMs) / 1000) * this.bytesPerSample);
288: 
289:         const bytesNeeded = targetBytesSent - this.totalBytesSent;
290: 
291:         if (bytesNeeded <= 0) {
292:             return null;
293:         }
294: 
295:         // Ensure bytesNeeded is a multiple of bytesPerSample
296:         const alignedBytesNeeded = Math.floor(bytesNeeded / this.bytesPerSample) * this.bytesPerSample;
297: 
298:         if (alignedBytesNeeded <= 0) {
299:             return null;
300:         }
301: 
302:         let chunk = new Uint8Array(0);
303: 
304:         // Drain from queue until we have enough bytes
305:         while (chunk.length < alignedBytesNeeded && this.audioQueue.length > 0) {
306:             const nextBuffer = this.audioQueue.shift()!;
307:             chunk = concatUint8Arrays(chunk, nextBuffer);
308:             this.totalBufferedBytes -= nextBuffer.length;
309:         }
310: 
311:         // If we have more than needed, put the excess back
312:         if (chunk.length > alignedBytesNeeded) {
313:             const excess = chunk.subarray(alignedBytesNeeded);
314:             this.audioQueue.unshift(excess);
315:             this.totalBufferedBytes += excess.length;
316:             chunk = chunk.subarray(0, alignedBytesNeeded);
317:         }
318: 
319:         // Fill remaining with silence if needed
320:         if (chunk.length < alignedBytesNeeded) {
321:             const silenceNeeded = new Uint8Array(alignedBytesNeeded - chunk.length); // Uint8Array is zero-filled by default
322:             chunk = concatUint8Arrays(chunk, silenceNeeded);
323:         }
324: 
325:         // Update total bytes sent
326:         this.totalBytesSent += chunk.length;
327: 
328:         return chunk;
329:     }
330: }
331: 
332: /**
333:  * Concatenates two Uint8Arrays into a new Uint8Array.
334:  */
335: function concatUint8Arrays(a: Uint8Array, b: Uint8Array): Uint8Array {
336:     const result = new Uint8Array(a.length + b.length);
337:     result.set(a, 0);
338:     result.set(b, a.length);
339:     return result;
340: }
````

## File: src/BaseClient.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import { HeaderAuthProvider } from "./auth/HeaderAuthProvider.js";
 4: import { mergeHeaders } from "./core/headers.js";
 5: import * as core from "./core/index.js";
 6: import type * as environments from "./environments.js";
 7: 
 8: export type BaseClientOptions = {
 9:     environment?: core.Supplier<environments.HumeEnvironment | environments.HumeEnvironmentUrls>;
10:     /** Specify a custom URL to connect the client to. */
11:     baseUrl?: core.Supplier<string>;
12:     /** Additional headers to include in requests. */
13:     headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
14:     /** The default maximum time to wait for a response in seconds. */
15:     timeoutInSeconds?: number;
16:     /** The default number of times to retry the request. Defaults to 2. */
17:     maxRetries?: number;
18:     /** Provide a custom fetch implementation. Useful for platforms that don't have a built-in fetch or need a custom implementation. */
19:     fetch?: typeof fetch;
20:     fetcher?: core.FetchFunction;
21:     /** Configure logging for the client. */
22:     logging?: core.logging.LogConfig | core.logging.Logger;
23: } & HeaderAuthProvider.AuthOptions;
24: 
25: export interface BaseRequestOptions {
26:     /** The maximum time to wait for a response in seconds. */
27:     timeoutInSeconds?: number;
28:     /** The number of times to retry the request. Defaults to 2. */
29:     maxRetries?: number;
30:     /** A hook to abort the request. */
31:     abortSignal?: AbortSignal;
32:     /** Additional query string parameters to include in the request. */
33:     queryParams?: Record<string, unknown>;
34:     /** Additional headers to include in the request. */
35:     headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
36: }
37: 
38: export type NormalizedClientOptions<T extends BaseClientOptions = BaseClientOptions> = T & {
39:     logging: core.logging.Logger;
40:     authProvider?: core.AuthProvider;
41: };
42: 
43: export type NormalizedClientOptionsWithAuth<T extends BaseClientOptions = BaseClientOptions> =
44:     NormalizedClientOptions<T> & {
45:         authProvider: core.AuthProvider;
46:     };
47: 
48: export function normalizeClientOptions<T extends BaseClientOptions = BaseClientOptions>(
49:     options: T,
50: ): NormalizedClientOptions<T> {
51:     const headers = mergeHeaders(
52:         {
53:             "X-Fern-Language": "JavaScript",
54:             "X-Fern-SDK-Name": "hume",
55:             "X-Fern-SDK-Version": "0.15.11",
56:             "User-Agent": "hume/0.15.11",
57:             "X-Fern-Runtime": core.RUNTIME.type,
58:             "X-Fern-Runtime-Version": core.RUNTIME.version,
59:         },
60:         options?.headers,
61:     );
62: 
63:     return {
64:         ...options,
65:         logging: core.logging.createLogger(options?.logging),
66:         headers,
67:     } as NormalizedClientOptions<T>;
68: }
69: 
70: export function normalizeClientOptionsWithAuth<T extends BaseClientOptions = BaseClientOptions>(
71:     options: T,
72: ): NormalizedClientOptionsWithAuth<T> {
73:     const normalized = normalizeClientOptions(options) as NormalizedClientOptionsWithAuth<T>;
74:     const normalizedWithNoOpAuthProvider = withNoOpAuthProvider(normalized);
75:     normalized.authProvider ??= new HeaderAuthProvider(normalizedWithNoOpAuthProvider);
76:     return normalized;
77: }
78: 
79: function withNoOpAuthProvider<T extends BaseClientOptions = BaseClientOptions>(
80:     options: NormalizedClientOptions<T>,
81: ): NormalizedClientOptionsWithAuth<T> {
82:     return {
83:         ...options,
84:         authProvider: new core.NoOpAuthProvider(),
85:     };
86: }
````

## File: src/Client.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import { EmpathicVoiceClient } from "./api/resources/empathicVoice/client/Client.js";
 4: import { ExpressionMeasurementClient } from "./api/resources/expressionMeasurement/client/Client.js";
 5: import { TtsClient } from "./api/resources/tts/client/Client.js";
 6: import type { BaseClientOptions, BaseRequestOptions } from "./BaseClient.js";
 7: import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "./BaseClient.js";
 8: 
 9: export declare namespace HumeClient {
10:     export type Options = BaseClientOptions;
11: 
12:     export interface RequestOptions extends BaseRequestOptions {}
13: }
14: 
15: export class HumeClient {
16:     protected readonly _options: NormalizedClientOptionsWithAuth<HumeClient.Options>;
17:     protected _tts: TtsClient | undefined;
18:     protected _empathicVoice: EmpathicVoiceClient | undefined;
19:     protected _expressionMeasurement: ExpressionMeasurementClient | undefined;
20: 
21:     constructor(options: HumeClient.Options = {}) {
22:         this._options = normalizeClientOptionsWithAuth(options);
23:     }
24: 
25:     public get tts(): TtsClient {
26:         return (this._tts ??= new TtsClient(this._options));
27:     }
28: 
29:     public get empathicVoice(): EmpathicVoiceClient {
30:         return (this._empathicVoice ??= new EmpathicVoiceClient(this._options));
31:     }
32: 
33:     public get expressionMeasurement(): ExpressionMeasurementClient {
34:         return (this._expressionMeasurement ??= new ExpressionMeasurementClient(this._options));
35:     }
36: }
````

## File: src/environments.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: export interface HumeEnvironmentUrls {
 4:     base: string;
 5:     evi: string;
 6:     tts: string;
 7:     stream: string;
 8: }
 9: 
10: export const HumeEnvironment = {
11:     Prod: {
12:         base: "https://api.hume.ai",
13:         evi: "wss://api.hume.ai/v0/evi",
14:         tts: "wss://api.hume.ai/v0/tts",
15:         stream: "wss://api.hume.ai/v0/stream",
16:     },
17: } as const;
18: 
19: export type HumeEnvironment = typeof HumeEnvironment.Prod;
````

## File: src/exports.ts
````typescript
1: export * from "./core/exports.js";
````

## File: src/index.ts
````typescript
1: export * as Hume from "./api/index.js";
2: export * as serialization from "./serialization/index.js";
3: export { HumeError, HumeTimeoutError } from "./errors/index.js";
4: export { HumeEnvironment } from "./environments.js";
5: export type { HumeEnvironmentUrls } from "./environments.js";
6: export * from "./exports.js";
7: 
8: export * from "./wrapper/index.js";
````

## File: src/index.ts.diff
````diff
 1: diff --git a/src/index.ts b/src/index.ts
 2: index 4d19902..c814670 100644
 3: --- a/src/index.ts
 4: +++ b/src/index.ts
 5: @@ -1,8 +1,7 @@
 6:  export * as Hume from "./api/index.js";
 7: -export * as serialization from "./serialization/index.js";
 8: +export type { BaseClientOptions, BaseRequestOptions } from "./BaseClient.js";
 9: +export { HumeClient } from "./Client.js";
10: +export { HumeEnvironment, type HumeEnvironmentUrls } from "./environments.js";
11:  export { HumeError, HumeTimeoutError } from "./errors/index.js";
12: -export { HumeEnvironment } from "./environments.js";
13: -export type { HumeEnvironmentUrls } from "./environments.js";
14:  export * from "./exports.js";
15: -
16: -export * from "./wrapper/index.js";
17: +export * as serialization from "./serialization/index.js";
````

## File: src/version.ts
````typescript
1: export const SDK_VERSION = "0.15.11";
````

## File: tests/mock-server/mockEndpointBuilder.ts
````typescript
  1: import { type DefaultBodyType, type HttpHandler, HttpResponse, type HttpResponseResolver, http } from "msw";
  2: 
  3: import { url } from "../../src/core";
  4: import { toJson } from "../../src/core/json";
  5: import { withFormUrlEncoded } from "./withFormUrlEncoded";
  6: import { withHeaders } from "./withHeaders";
  7: import { withJson } from "./withJson";
  8: 
  9: type HttpMethod = "all" | "get" | "post" | "put" | "delete" | "patch" | "options" | "head";
 10: 
 11: interface MethodStage {
 12:     baseUrl(baseUrl: string): MethodStage;
 13:     all(path: string): RequestHeadersStage;
 14:     get(path: string): RequestHeadersStage;
 15:     post(path: string): RequestHeadersStage;
 16:     put(path: string): RequestHeadersStage;
 17:     delete(path: string): RequestHeadersStage;
 18:     patch(path: string): RequestHeadersStage;
 19:     options(path: string): RequestHeadersStage;
 20:     head(path: string): RequestHeadersStage;
 21: }
 22: 
 23: interface RequestHeadersStage extends RequestBodyStage, ResponseStage {
 24:     header(name: string, value: string): RequestHeadersStage;
 25:     headers(headers: Record<string, string>): RequestBodyStage;
 26: }
 27: 
 28: interface RequestBodyStage extends ResponseStage {
 29:     jsonBody(body: unknown): ResponseStage;
 30:     formUrlEncodedBody(body: unknown): ResponseStage;
 31: }
 32: 
 33: interface ResponseStage {
 34:     respondWith(): ResponseStatusStage;
 35: }
 36: interface ResponseStatusStage {
 37:     statusCode(statusCode: number): ResponseHeaderStage;
 38: }
 39: 
 40: interface ResponseHeaderStage extends ResponseBodyStage, BuildStage {
 41:     header(name: string, value: string): ResponseHeaderStage;
 42:     headers(headers: Record<string, string>): ResponseHeaderStage;
 43: }
 44: 
 45: interface ResponseBodyStage {
 46:     jsonBody(body: unknown): BuildStage;
 47: }
 48: 
 49: interface BuildStage {
 50:     build(): HttpHandler;
 51: }
 52: 
 53: export interface HttpHandlerBuilderOptions {
 54:     onBuild?: (handler: HttpHandler) => void;
 55:     once?: boolean;
 56: }
 57: 
 58: class RequestBuilder implements MethodStage, RequestHeadersStage, RequestBodyStage, ResponseStage {
 59:     private method: HttpMethod = "get";
 60:     private _baseUrl: string = "";
 61:     private path: string = "/";
 62:     private readonly predicates: ((resolver: HttpResponseResolver) => HttpResponseResolver)[] = [];
 63:     private readonly handlerOptions?: HttpHandlerBuilderOptions;
 64: 
 65:     constructor(options?: HttpHandlerBuilderOptions) {
 66:         this.handlerOptions = options;
 67:     }
 68: 
 69:     baseUrl(baseUrl: string): MethodStage {
 70:         this._baseUrl = baseUrl;
 71:         return this;
 72:     }
 73: 
 74:     all(path: string): RequestHeadersStage {
 75:         this.method = "all";
 76:         this.path = path;
 77:         return this;
 78:     }
 79: 
 80:     get(path: string): RequestHeadersStage {
 81:         this.method = "get";
 82:         this.path = path;
 83:         return this;
 84:     }
 85: 
 86:     post(path: string): RequestHeadersStage {
 87:         this.method = "post";
 88:         this.path = path;
 89:         return this;
 90:     }
 91: 
 92:     put(path: string): RequestHeadersStage {
 93:         this.method = "put";
 94:         this.path = path;
 95:         return this;
 96:     }
 97: 
 98:     delete(path: string): RequestHeadersStage {
 99:         this.method = "delete";
100:         this.path = path;
101:         return this;
102:     }
103: 
104:     patch(path: string): RequestHeadersStage {
105:         this.method = "patch";
106:         this.path = path;
107:         return this;
108:     }
109: 
110:     options(path: string): RequestHeadersStage {
111:         this.method = "options";
112:         this.path = path;
113:         return this;
114:     }
115: 
116:     head(path: string): RequestHeadersStage {
117:         this.method = "head";
118:         this.path = path;
119:         return this;
120:     }
121: 
122:     header(name: string, value: string): RequestHeadersStage {
123:         this.predicates.push((resolver) => withHeaders({ [name]: value }, resolver));
124:         return this;
125:     }
126: 
127:     headers(headers: Record<string, string>): RequestBodyStage {
128:         this.predicates.push((resolver) => withHeaders(headers, resolver));
129:         return this;
130:     }
131: 
132:     jsonBody(body: unknown): ResponseStage {
133:         if (body === undefined) {
134:             throw new Error("Undefined is not valid JSON. Do not call jsonBody if you want an empty body.");
135:         }
136:         this.predicates.push((resolver) => withJson(body, resolver));
137:         return this;
138:     }
139: 
140:     formUrlEncodedBody(body: unknown): ResponseStage {
141:         if (body === undefined) {
142:             throw new Error(
143:                 "Undefined is not valid for form-urlencoded. Do not call formUrlEncodedBody if you want an empty body.",
144:             );
145:         }
146:         this.predicates.push((resolver) => withFormUrlEncoded(body, resolver));
147:         return this;
148:     }
149: 
150:     respondWith(): ResponseStatusStage {
151:         return new ResponseBuilder(this.method, this.buildUrl(), this.predicates, this.handlerOptions);
152:     }
153: 
154:     private buildUrl(): string {
155:         return url.join(this._baseUrl, this.path);
156:     }
157: }
158: 
159: class ResponseBuilder implements ResponseStatusStage, ResponseHeaderStage, ResponseBodyStage, BuildStage {
160:     private readonly method: HttpMethod;
161:     private readonly url: string;
162:     private readonly requestPredicates: ((resolver: HttpResponseResolver) => HttpResponseResolver)[];
163:     private readonly handlerOptions?: HttpHandlerBuilderOptions;
164: 
165:     private responseStatusCode: number = 200;
166:     private responseHeaders: Record<string, string> = {};
167:     private responseBody: DefaultBodyType = undefined;
168: 
169:     constructor(
170:         method: HttpMethod,
171:         url: string,
172:         requestPredicates: ((resolver: HttpResponseResolver) => HttpResponseResolver)[],
173:         options?: HttpHandlerBuilderOptions,
174:     ) {
175:         this.method = method;
176:         this.url = url;
177:         this.requestPredicates = requestPredicates;
178:         this.handlerOptions = options;
179:     }
180: 
181:     public statusCode(code: number): ResponseHeaderStage {
182:         this.responseStatusCode = code;
183:         return this;
184:     }
185: 
186:     public header(name: string, value: string): ResponseHeaderStage {
187:         this.responseHeaders[name] = value;
188:         return this;
189:     }
190: 
191:     public headers(headers: Record<string, string>): ResponseHeaderStage {
192:         this.responseHeaders = { ...this.responseHeaders, ...headers };
193:         return this;
194:     }
195: 
196:     public jsonBody(body: unknown): BuildStage {
197:         if (body === undefined) {
198:             throw new Error("Undefined is not valid JSON. Do not call jsonBody if you expect an empty body.");
199:         }
200:         this.responseBody = toJson(body);
201:         return this;
202:     }
203: 
204:     public build(): HttpHandler {
205:         const responseResolver: HttpResponseResolver = () => {
206:             const response = new HttpResponse(this.responseBody, {
207:                 status: this.responseStatusCode,
208:                 headers: this.responseHeaders,
209:             });
210:             // if no Content-Type header is set, delete the default text content type that is set
211:             if (Object.keys(this.responseHeaders).some((key) => key.toLowerCase() === "content-type") === false) {
212:                 response.headers.delete("Content-Type");
213:             }
214:             return response;
215:         };
216: 
217:         const finalResolver = this.requestPredicates.reduceRight((acc, predicate) => predicate(acc), responseResolver);
218: 
219:         const handler = http[this.method](this.url, finalResolver, this.handlerOptions);
220:         this.handlerOptions?.onBuild?.(handler);
221:         return handler;
222:     }
223: }
224: 
225: export function mockEndpointBuilder(options?: HttpHandlerBuilderOptions): MethodStage {
226:     return new RequestBuilder(options);
227: }
````

## File: tests/mock-server/MockServer.ts
````typescript
 1: import type { RequestHandlerOptions } from "msw";
 2: import type { SetupServer } from "msw/node";
 3: 
 4: import { mockEndpointBuilder } from "./mockEndpointBuilder";
 5: 
 6: export interface MockServerOptions {
 7:     baseUrl: string;
 8:     server: SetupServer;
 9: }
10: 
11: export class MockServer {
12:     private readonly server: SetupServer;
13:     public readonly baseUrl: string;
14: 
15:     constructor({ baseUrl, server }: MockServerOptions) {
16:         this.baseUrl = baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
17:         this.server = server;
18:     }
19: 
20:     public mockEndpoint(options?: RequestHandlerOptions): ReturnType<typeof mockEndpointBuilder> {
21:         const builder = mockEndpointBuilder({
22:             once: options?.once ?? true,
23:             onBuild: (handler) => {
24:                 this.server.use(handler);
25:             },
26:         }).baseUrl(this.baseUrl);
27:         return builder;
28:     }
29: }
````

## File: tests/mock-server/MockServerPool.ts
````typescript
  1: import { setupServer } from "msw/node";
  2: 
  3: import { fromJson, toJson } from "../../src/core/json";
  4: import { MockServer } from "./MockServer";
  5: import { randomBaseUrl } from "./randomBaseUrl";
  6: 
  7: const mswServer = setupServer();
  8: interface MockServerOptions {
  9:     baseUrl?: string;
 10: }
 11: 
 12: async function formatHttpRequest(request: Request, id?: string): Promise<string> {
 13:     try {
 14:         const clone = request.clone();
 15:         const headers = [...clone.headers.entries()].map(([k, v]) => `${k}: ${v}`).join("\n");
 16: 
 17:         let body = "";
 18:         try {
 19:             const contentType = clone.headers.get("content-type");
 20:             if (contentType?.includes("application/json")) {
 21:                 body = toJson(fromJson(await clone.text()), undefined, 2);
 22:             } else if (clone.body) {
 23:                 body = await clone.text();
 24:             }
 25:         } catch (_e) {
 26:             body = "(unable to parse body)";
 27:         }
 28: 
 29:         const title = id ? `### Request ${id} ###\n` : "";
 30:         const firstLine = `${title}${request.method} ${request.url.toString()} HTTP/1.1`;
 31: 
 32:         return `\n${firstLine}\n${headers}\n\n${body || "(no body)"}\n`;
 33:     } catch (e) {
 34:         return `Error formatting request: ${e}`;
 35:     }
 36: }
 37: 
 38: async function formatHttpResponse(response: Response, id?: string): Promise<string> {
 39:     try {
 40:         const clone = response.clone();
 41:         const headers = [...clone.headers.entries()].map(([k, v]) => `${k}: ${v}`).join("\n");
 42: 
 43:         let body = "";
 44:         try {
 45:             const contentType = clone.headers.get("content-type");
 46:             if (contentType?.includes("application/json")) {
 47:                 body = toJson(fromJson(await clone.text()), undefined, 2);
 48:             } else if (clone.body) {
 49:                 body = await clone.text();
 50:             }
 51:         } catch (_e) {
 52:             body = "(unable to parse body)";
 53:         }
 54: 
 55:         const title = id ? `### Response for ${id} ###\n` : "";
 56:         const firstLine = `${title}HTTP/1.1 ${response.status} ${response.statusText}`;
 57: 
 58:         return `\n${firstLine}\n${headers}\n\n${body || "(no body)"}\n`;
 59:     } catch (e) {
 60:         return `Error formatting response: ${e}`;
 61:     }
 62: }
 63: 
 64: class MockServerPool {
 65:     private servers: MockServer[] = [];
 66: 
 67:     public createServer(options?: Partial<MockServerOptions>): MockServer {
 68:         const baseUrl = options?.baseUrl || randomBaseUrl();
 69:         const server = new MockServer({ baseUrl, server: mswServer });
 70:         this.servers.push(server);
 71:         return server;
 72:     }
 73: 
 74:     public getServers(): MockServer[] {
 75:         return [...this.servers];
 76:     }
 77: 
 78:     public listen(): void {
 79:         const onUnhandledRequest = process.env.LOG_LEVEL === "debug" ? "warn" : "bypass";
 80:         mswServer.listen({ onUnhandledRequest });
 81: 
 82:         if (process.env.LOG_LEVEL === "debug") {
 83:             mswServer.events.on("request:start", async ({ request, requestId }) => {
 84:                 const formattedRequest = await formatHttpRequest(request, requestId);
 85:                 console.debug(`request:start\n${formattedRequest}`);
 86:             });
 87: 
 88:             mswServer.events.on("request:unhandled", async ({ request, requestId }) => {
 89:                 const formattedRequest = await formatHttpRequest(request, requestId);
 90:                 console.debug(`request:unhandled\n${formattedRequest}`);
 91:             });
 92: 
 93:             mswServer.events.on("response:mocked", async ({ request, response, requestId }) => {
 94:                 const formattedResponse = await formatHttpResponse(response, requestId);
 95:                 console.debug(`response:mocked\n${formattedResponse}`);
 96:             });
 97:         }
 98:     }
 99: 
100:     public close(): void {
101:         this.servers = [];
102:         mswServer.close();
103:     }
104: }
105: 
106: export const mockServerPool = new MockServerPool();
````

## File: tests/mock-server/randomBaseUrl.ts
````typescript
1: export function randomBaseUrl(): string {
2:     const randomString = Math.random().toString(36).substring(2, 15);
3:     return `http://${randomString}.localhost`;
4: }
````

## File: tests/mock-server/setup.ts
````typescript
 1: import { afterAll, beforeAll } from "vitest";
 2: 
 3: import { mockServerPool } from "./MockServerPool";
 4: 
 5: beforeAll(() => {
 6:     mockServerPool.listen();
 7: });
 8: afterAll(() => {
 9:     mockServerPool.close();
10: });
````

## File: tests/mock-server/withFormUrlEncoded.ts
````typescript
 1: import { type HttpResponseResolver, passthrough } from "msw";
 2: 
 3: import { toJson } from "../../src/core/json";
 4: 
 5: /**
 6:  * Creates a request matcher that validates if the request form-urlencoded body exactly matches the expected object
 7:  * @param expectedBody - The exact body object to match against
 8:  * @param resolver - Response resolver to execute if body matches
 9:  */
10: export function withFormUrlEncoded(expectedBody: unknown, resolver: HttpResponseResolver): HttpResponseResolver {
11:     return async (args) => {
12:         const { request } = args;
13: 
14:         let clonedRequest: Request;
15:         let bodyText: string | undefined;
16:         let actualBody: Record<string, string>;
17:         try {
18:             clonedRequest = request.clone();
19:             bodyText = await clonedRequest.text();
20:             if (bodyText === "") {
21:                 // Empty body is valid if expected body is also empty
22:                 const isExpectedEmpty =
23:                     expectedBody != null &&
24:                     typeof expectedBody === "object" &&
25:                     Object.keys(expectedBody as Record<string, unknown>).length === 0;
26:                 if (!isExpectedEmpty) {
27:                     console.error("Request body is empty, expected a form-urlencoded body.");
28:                     return passthrough();
29:                 }
30:                 actualBody = {};
31:             } else {
32:                 const params = new URLSearchParams(bodyText);
33:                 actualBody = {};
34:                 for (const [key, value] of params.entries()) {
35:                     actualBody[key] = value;
36:                 }
37:             }
38:         } catch (error) {
39:             console.error(`Error processing form-urlencoded request body:\n\tError: ${error}\n\tBody: ${bodyText}`);
40:             return passthrough();
41:         }
42: 
43:         const mismatches = findMismatches(actualBody, expectedBody);
44:         if (Object.keys(mismatches).length > 0) {
45:             console.error("Form-urlencoded body mismatch:", toJson(mismatches, undefined, 2));
46:             return passthrough();
47:         }
48: 
49:         return resolver(args);
50:     };
51: }
52: 
53: function findMismatches(actual: any, expected: any): Record<string, { actual: any; expected: any }> {
54:     const mismatches: Record<string, { actual: any; expected: any }> = {};
55: 
56:     if (typeof actual !== typeof expected) {
57:         return { value: { actual, expected } };
58:     }
59: 
60:     if (typeof actual !== "object" || actual === null || expected === null) {
61:         if (actual !== expected) {
62:             return { value: { actual, expected } };
63:         }
64:         return {};
65:     }
66: 
67:     const actualKeys = Object.keys(actual);
68:     const expectedKeys = Object.keys(expected);
69: 
70:     const allKeys = new Set([...actualKeys, ...expectedKeys]);
71: 
72:     for (const key of allKeys) {
73:         if (!expectedKeys.includes(key)) {
74:             if (actual[key] === undefined) {
75:                 continue;
76:             }
77:             mismatches[key] = { actual: actual[key], expected: undefined };
78:         } else if (!actualKeys.includes(key)) {
79:             if (expected[key] === undefined) {
80:                 continue;
81:             }
82:             mismatches[key] = { actual: undefined, expected: expected[key] };
83:         } else if (actual[key] !== expected[key]) {
84:             mismatches[key] = { actual: actual[key], expected: expected[key] };
85:         }
86:     }
87: 
88:     return mismatches;
89: }
````

## File: tests/mock-server/withHeaders.ts
````typescript
 1: import { type HttpResponseResolver, passthrough } from "msw";
 2: 
 3: /**
 4:  * Creates a request matcher that validates if request headers match specified criteria
 5:  * @param expectedHeaders - Headers to match against
 6:  * @param resolver - Response resolver to execute if headers match
 7:  */
 8: export function withHeaders(
 9:     expectedHeaders: Record<string, string | RegExp | ((value: string) => boolean)>,
10:     resolver: HttpResponseResolver,
11: ): HttpResponseResolver {
12:     return (args) => {
13:         const { request } = args;
14:         const { headers } = request;
15: 
16:         const mismatches: Record<
17:             string,
18:             { actual: string | null; expected: string | RegExp | ((value: string) => boolean) }
19:         > = {};
20: 
21:         for (const [key, expectedValue] of Object.entries(expectedHeaders)) {
22:             const actualValue = headers.get(key);
23: 
24:             if (actualValue === null) {
25:                 mismatches[key] = { actual: null, expected: expectedValue };
26:                 continue;
27:             }
28: 
29:             if (typeof expectedValue === "function") {
30:                 if (!expectedValue(actualValue)) {
31:                     mismatches[key] = { actual: actualValue, expected: expectedValue };
32:                 }
33:             } else if (expectedValue instanceof RegExp) {
34:                 if (!expectedValue.test(actualValue)) {
35:                     mismatches[key] = { actual: actualValue, expected: expectedValue };
36:                 }
37:             } else if (expectedValue !== actualValue) {
38:                 mismatches[key] = { actual: actualValue, expected: expectedValue };
39:             }
40:         }
41: 
42:         if (Object.keys(mismatches).length > 0) {
43:             const formattedMismatches = formatHeaderMismatches(mismatches);
44:             console.error("Header mismatch:", formattedMismatches);
45:             return passthrough();
46:         }
47: 
48:         return resolver(args);
49:     };
50: }
51: 
52: function formatHeaderMismatches(
53:     mismatches: Record<string, { actual: string | null; expected: string | RegExp | ((value: string) => boolean) }>,
54: ): Record<string, { actual: string | null; expected: string }> {
55:     const formatted: Record<string, { actual: string | null; expected: string }> = {};
56: 
57:     for (const [key, { actual, expected }] of Object.entries(mismatches)) {
58:         formatted[key] = {
59:             actual,
60:             expected:
61:                 expected instanceof RegExp
62:                     ? expected.toString()
63:                     : typeof expected === "function"
64:                       ? "[Function]"
65:                       : expected,
66:         };
67:     }
68: 
69:     return formatted;
70: }
````

## File: tests/mock-server/withJson.ts
````typescript
  1: import { type HttpResponseResolver, passthrough } from "msw";
  2: 
  3: import { fromJson, toJson } from "../../src/core/json";
  4: 
  5: /**
  6:  * Creates a request matcher that validates if the request JSON body exactly matches the expected object
  7:  * @param expectedBody - The exact body object to match against
  8:  * @param resolver - Response resolver to execute if body matches
  9:  */
 10: export function withJson(expectedBody: unknown, resolver: HttpResponseResolver): HttpResponseResolver {
 11:     return async (args) => {
 12:         const { request } = args;
 13: 
 14:         let clonedRequest: Request;
 15:         let bodyText: string | undefined;
 16:         let actualBody: unknown;
 17:         try {
 18:             clonedRequest = request.clone();
 19:             bodyText = await clonedRequest.text();
 20:             if (bodyText === "") {
 21:                 console.error("Request body is empty, expected a JSON object.");
 22:                 return passthrough();
 23:             }
 24:             actualBody = fromJson(bodyText);
 25:         } catch (error) {
 26:             console.error(`Error processing request body:\n\tError: ${error}\n\tBody: ${bodyText}`);
 27:             return passthrough();
 28:         }
 29: 
 30:         const mismatches = findMismatches(actualBody, expectedBody);
 31:         if (Object.keys(mismatches).filter((key) => !key.startsWith("pagination.")).length > 0) {
 32:             console.error("JSON body mismatch:", toJson(mismatches, undefined, 2));
 33:             return passthrough();
 34:         }
 35: 
 36:         return resolver(args);
 37:     };
 38: }
 39: 
 40: function findMismatches(actual: any, expected: any): Record<string, { actual: any; expected: any }> {
 41:     const mismatches: Record<string, { actual: any; expected: any }> = {};
 42: 
 43:     if (typeof actual !== typeof expected) {
 44:         if (areEquivalent(actual, expected)) {
 45:             return {};
 46:         }
 47:         return { value: { actual, expected } };
 48:     }
 49: 
 50:     if (typeof actual !== "object" || actual === null || expected === null) {
 51:         if (actual !== expected) {
 52:             if (areEquivalent(actual, expected)) {
 53:                 return {};
 54:             }
 55:             return { value: { actual, expected } };
 56:         }
 57:         return {};
 58:     }
 59: 
 60:     if (Array.isArray(actual) && Array.isArray(expected)) {
 61:         if (actual.length !== expected.length) {
 62:             return { length: { actual: actual.length, expected: expected.length } };
 63:         }
 64: 
 65:         const arrayMismatches: Record<string, { actual: any; expected: any }> = {};
 66:         for (let i = 0; i < actual.length; i++) {
 67:             const itemMismatches = findMismatches(actual[i], expected[i]);
 68:             if (Object.keys(itemMismatches).length > 0) {
 69:                 for (const [mismatchKey, mismatchValue] of Object.entries(itemMismatches)) {
 70:                     arrayMismatches[`[${i}]${mismatchKey === "value" ? "" : `.${mismatchKey}`}`] = mismatchValue;
 71:                 }
 72:             }
 73:         }
 74:         return arrayMismatches;
 75:     }
 76: 
 77:     const actualKeys = Object.keys(actual);
 78:     const expectedKeys = Object.keys(expected);
 79: 
 80:     const allKeys = new Set([...actualKeys, ...expectedKeys]);
 81: 
 82:     for (const key of allKeys) {
 83:         if (!expectedKeys.includes(key)) {
 84:             if (actual[key] === undefined) {
 85:                 continue; // Skip undefined values in actual
 86:             }
 87:             mismatches[key] = { actual: actual[key], expected: undefined };
 88:         } else if (!actualKeys.includes(key)) {
 89:             if (expected[key] === undefined) {
 90:                 continue; // Skip undefined values in expected
 91:             }
 92:             mismatches[key] = { actual: undefined, expected: expected[key] };
 93:         } else if (
 94:             typeof actual[key] === "object" &&
 95:             actual[key] !== null &&
 96:             typeof expected[key] === "object" &&
 97:             expected[key] !== null
 98:         ) {
 99:             const nestedMismatches = findMismatches(actual[key], expected[key]);
100:             if (Object.keys(nestedMismatches).length > 0) {
101:                 for (const [nestedKey, nestedValue] of Object.entries(nestedMismatches)) {
102:                     mismatches[`${key}${nestedKey === "value" ? "" : `.${nestedKey}`}`] = nestedValue;
103:                 }
104:             }
105:         } else if (actual[key] !== expected[key]) {
106:             if (areEquivalent(actual[key], expected[key])) {
107:                 continue;
108:             }
109:             mismatches[key] = { actual: actual[key], expected: expected[key] };
110:         }
111:     }
112: 
113:     return mismatches;
114: }
115: 
116: function areEquivalent(actual: unknown, expected: unknown): boolean {
117:     if (actual === expected) {
118:         return true;
119:     }
120:     if (isEquivalentBigInt(actual, expected)) {
121:         return true;
122:     }
123:     if (isEquivalentDatetime(actual, expected)) {
124:         return true;
125:     }
126:     return false;
127: }
128: 
129: function isEquivalentBigInt(actual: unknown, expected: unknown) {
130:     if (typeof actual === "number") {
131:         actual = BigInt(actual);
132:     }
133:     if (typeof expected === "number") {
134:         expected = BigInt(expected);
135:     }
136:     if (typeof actual === "bigint" && typeof expected === "bigint") {
137:         return actual === expected;
138:     }
139:     return false;
140: }
141: 
142: function isEquivalentDatetime(str1: unknown, str2: unknown): boolean {
143:     if (typeof str1 !== "string" || typeof str2 !== "string") {
144:         return false;
145:     }
146:     const isoDatePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d{3})?Z$/;
147:     if (!isoDatePattern.test(str1) || !isoDatePattern.test(str2)) {
148:         return false;
149:     }
150: 
151:     try {
152:         const date1 = new Date(str1).getTime();
153:         const date2 = new Date(str2).getTime();
154:         return date1 === date2;
155:     } catch {
156:         return false;
157:     }
158: }
````

## File: tests/unit/auth/auth.test.ts
````typescript
  1: /**
  2:  * Tests for authentication support - both apiKey and accessToken methods.
  3:  */
  4: 
  5: import { describe, expect, it } from "vitest";
  6: 
  7: import { HeaderAuthProvider } from "../../../src/auth/HeaderAuthProvider";
  8: import { HumeClient } from "../../../src/wrapper/HumeClient";
  9: 
 10: describe("Authentication", () => {
 11:     describe("HeaderAuthProvider", () => {
 12:         it("returns X-Hume-Api-Key header when apiKey is provided", async () => {
 13:             const provider = new HeaderAuthProvider({ apiKey: "test-api-key" });
 14:             const result = await provider.getAuthRequest();
 15:             expect(result.headers).toEqual({ "X-Hume-Api-Key": "test-api-key" });
 16:         });
 17: 
 18:         it("returns Authorization header when accessToken is provided via headers", async () => {
 19:             const provider = new HeaderAuthProvider({
 20:                 headers: { Authorization: "Bearer test-token" },
 21:             });
 22:             const result = await provider.getAuthRequest();
 23:             expect(result.headers).toEqual({ Authorization: "Bearer test-token" });
 24:         });
 25: 
 26:         it("handles case-insensitive Authorization header", async () => {
 27:             const provider = new HeaderAuthProvider({
 28:                 headers: { authorization: "Bearer test-token" },
 29:             });
 30:             const result = await provider.getAuthRequest();
 31:             expect(result.headers).toEqual({ Authorization: "Bearer test-token" });
 32:         });
 33: 
 34:         it("prefers apiKey over Authorization header when both are provided", async () => {
 35:             const provider = new HeaderAuthProvider({
 36:                 apiKey: "test-api-key",
 37:                 headers: { Authorization: "Bearer test-token" },
 38:             });
 39:             const result = await provider.getAuthRequest();
 40:             expect(result.headers).toEqual({ "X-Hume-Api-Key": "test-api-key" });
 41:         });
 42: 
 43:         it("throws when neither apiKey nor Authorization header is provided", async () => {
 44:             const provider = new HeaderAuthProvider({});
 45:             await expect(provider.getAuthRequest()).rejects.toThrow(
 46:                 "Please provide either 'apiKey' or 'accessToken' when initializing the client",
 47:             );
 48:         });
 49: 
 50:         it("throws when apiKey is undefined and no Authorization header", async () => {
 51:             const provider = new HeaderAuthProvider({ apiKey: undefined });
 52:             await expect(provider.getAuthRequest()).rejects.toThrow("Please provide either 'apiKey' or 'accessToken'");
 53:         });
 54: 
 55:         it("supports Supplier function for apiKey", async () => {
 56:             const provider = new HeaderAuthProvider({
 57:                 apiKey: () => "dynamic-api-key",
 58:             });
 59:             const result = await provider.getAuthRequest();
 60:             expect(result.headers).toEqual({ "X-Hume-Api-Key": "dynamic-api-key" });
 61:         });
 62: 
 63:         // Note: The local Supplier type is synchronous, so async functions are not directly supported.
 64:         // However, the await in getAuthRequest() handles values that happen to be Promises.
 65: 
 66:         it("supports Supplier function for Authorization header", async () => {
 67:             const provider = new HeaderAuthProvider({
 68:                 headers: { Authorization: () => "Bearer dynamic-token" },
 69:             });
 70:             const result = await provider.getAuthRequest();
 71:             expect(result.headers).toEqual({ Authorization: "Bearer dynamic-token" });
 72:         });
 73: 
 74:         describe("canCreate", () => {
 75:             it("returns true when apiKey is provided", () => {
 76:                 expect(HeaderAuthProvider.canCreate({ apiKey: "test" })).toBe(true);
 77:             });
 78: 
 79:             it("returns true when Authorization header is provided", () => {
 80:                 expect(
 81:                     HeaderAuthProvider.canCreate({
 82:                         headers: { Authorization: "Bearer token" },
 83:                     }),
 84:                 ).toBe(true);
 85:             });
 86: 
 87:             it("returns true when authorization header is provided (case-insensitive)", () => {
 88:                 expect(
 89:                     HeaderAuthProvider.canCreate({
 90:                         headers: { authorization: "Bearer token" },
 91:                     }),
 92:                 ).toBe(true);
 93:             });
 94: 
 95:             it("returns false when neither is provided", () => {
 96:                 expect(HeaderAuthProvider.canCreate({})).toBe(false);
 97:             });
 98: 
 99:             it("returns false when headers exist but no Authorization", () => {
100:                 expect(
101:                     HeaderAuthProvider.canCreate({
102:                         headers: { "X-Custom-Header": "value" },
103:                     }),
104:                 ).toBe(false);
105:             });
106:         });
107:     });
108: 
109:     describe("HumeClient wrapper", () => {
110:         it("accepts apiKey authentication", () => {
111:             const client = new HumeClient({ apiKey: "test-api-key" });
112:             expect(client).toBeDefined();
113:         });
114: 
115:         it("accepts accessToken authentication", () => {
116:             const client = new HumeClient({ accessToken: "test-token" });
117:             expect(client).toBeDefined();
118:         });
119: 
120:         it("converts accessToken to Authorization header internally", () => {
121:             const client = new HumeClient({ accessToken: "test-token" });
122:             // Access the internal options to verify the Authorization header is set
123:             const options = (client as any)._options;
124:             expect(options.headers).toBeDefined();
125:             // The Authorization header is set as a Supplier, so we can't easily check the value directly
126:             // but we can verify the header key exists
127:             const hasAuthHeader = Object.keys(options.headers).some((key) => key.toLowerCase() === "authorization");
128:             expect(hasAuthHeader).toBe(true);
129:         });
130: 
131:         it("throws when both accessToken and Authorization header are provided", () => {
132:             expect(
133:                 () =>
134:                     new HumeClient({
135:                         accessToken: "token",
136:                         headers: { Authorization: "Bearer another" },
137:                     }),
138:             ).toThrow("Cannot provide both 'accessToken' and 'headers.Authorization'");
139:         });
140: 
141:         it("allows custom headers alongside apiKey", () => {
142:             const client = new HumeClient({
143:                 apiKey: "test-api-key",
144:                 headers: { "X-Custom-Header": "value" },
145:             });
146:             expect(client).toBeDefined();
147:         });
148: 
149:         it("allows custom headers alongside accessToken", () => {
150:             const client = new HumeClient({
151:                 accessToken: "test-token",
152:                 headers: { "X-Custom-Header": "value" },
153:             });
154:             expect(client).toBeDefined();
155:         });
156:     });
157: });
````

## File: tests/unit/auth/BasicAuth.test.ts
````typescript
 1: import { BasicAuth } from "../../../src/core/auth/BasicAuth";
 2: 
 3: describe("BasicAuth", () => {
 4:     interface ToHeaderTestCase {
 5:         description: string;
 6:         input: { username: string; password: string };
 7:         expected: string;
 8:     }
 9: 
10:     interface FromHeaderTestCase {
11:         description: string;
12:         input: string;
13:         expected: { username: string; password: string };
14:     }
15: 
16:     interface ErrorTestCase {
17:         description: string;
18:         input: string;
19:         expectedError: string;
20:     }
21: 
22:     describe("toAuthorizationHeader", () => {
23:         const toHeaderTests: ToHeaderTestCase[] = [
24:             {
25:                 description: "correctly converts to header",
26:                 input: { username: "username", password: "password" },
27:                 expected: "Basic dXNlcm5hbWU6cGFzc3dvcmQ=",
28:             },
29:         ];
30: 
31:         toHeaderTests.forEach(({ description, input, expected }) => {
32:             it(description, () => {
33:                 expect(BasicAuth.toAuthorizationHeader(input)).toBe(expected);
34:             });
35:         });
36:     });
37: 
38:     describe("fromAuthorizationHeader", () => {
39:         const fromHeaderTests: FromHeaderTestCase[] = [
40:             {
41:                 description: "correctly parses header",
42:                 input: "Basic dXNlcm5hbWU6cGFzc3dvcmQ=",
43:                 expected: { username: "username", password: "password" },
44:             },
45:             {
46:                 description: "handles password with colons",
47:                 input: "Basic dXNlcjpwYXNzOndvcmQ=",
48:                 expected: { username: "user", password: "pass:word" },
49:             },
50:             {
51:                 description: "handles empty username and password (just colon)",
52:                 input: "Basic Og==",
53:                 expected: { username: "", password: "" },
54:             },
55:             {
56:                 description: "handles empty username",
57:                 input: "Basic OnBhc3N3b3Jk",
58:                 expected: { username: "", password: "password" },
59:             },
60:             {
61:                 description: "handles empty password",
62:                 input: "Basic dXNlcm5hbWU6",
63:                 expected: { username: "username", password: "" },
64:             },
65:         ];
66: 
67:         fromHeaderTests.forEach(({ description, input, expected }) => {
68:             it(description, () => {
69:                 expect(BasicAuth.fromAuthorizationHeader(input)).toEqual(expected);
70:             });
71:         });
72: 
73:         const errorTests: ErrorTestCase[] = [
74:             {
75:                 description: "throws error for completely empty credentials",
76:                 input: "Basic ",
77:                 expectedError: "Invalid basic auth",
78:             },
79:             {
80:                 description: "throws error for credentials without colon",
81:                 input: "Basic dXNlcm5hbWU=",
82:                 expectedError: "Invalid basic auth",
83:             },
84:         ];
85: 
86:         errorTests.forEach(({ description, input, expectedError }) => {
87:             it(description, () => {
88:                 expect(() => BasicAuth.fromAuthorizationHeader(input)).toThrow(expectedError);
89:             });
90:         });
91:     });
92: });
````

## File: tests/unit/auth/BearerToken.test.ts
````typescript
 1: import { BearerToken } from "../../../src/core/auth/BearerToken";
 2: 
 3: describe("BearerToken", () => {
 4:     describe("toAuthorizationHeader", () => {
 5:         it("correctly converts to header", () => {
 6:             expect(BearerToken.toAuthorizationHeader("my-token")).toBe("Bearer my-token");
 7:         });
 8:     });
 9:     describe("fromAuthorizationHeader", () => {
10:         it("correctly parses header", () => {
11:             expect(BearerToken.fromAuthorizationHeader("Bearer my-token")).toBe("my-token");
12:         });
13:     });
14: });
````

## File: tests/unit/fetcher/createRequestUrl.test.ts
````typescript
  1: import { createRequestUrl } from "../../../src/core/fetcher/createRequestUrl";
  2: 
  3: describe("Test createRequestUrl", () => {
  4:     const BASE_URL = "https://api.example.com";
  5: 
  6:     interface TestCase {
  7:         description: string;
  8:         baseUrl: string;
  9:         queryParams?: Record<string, any>;
 10:         expected: string;
 11:     }
 12: 
 13:     const testCases: TestCase[] = [
 14:         {
 15:             description: "should return the base URL when no query parameters are provided",
 16:             baseUrl: BASE_URL,
 17:             expected: BASE_URL,
 18:         },
 19:         {
 20:             description: "should append simple query parameters",
 21:             baseUrl: BASE_URL,
 22:             queryParams: { key: "value", another: "param" },
 23:             expected: "https://api.example.com?key=value&another=param",
 24:         },
 25:         {
 26:             description: "should handle array query parameters",
 27:             baseUrl: BASE_URL,
 28:             queryParams: { items: ["a", "b", "c"] },
 29:             expected: "https://api.example.com?items=a&items=b&items=c",
 30:         },
 31:         {
 32:             description: "should handle object query parameters",
 33:             baseUrl: BASE_URL,
 34:             queryParams: { filter: { name: "John", age: 30 } },
 35:             expected: "https://api.example.com?filter%5Bname%5D=John&filter%5Bage%5D=30",
 36:         },
 37:         {
 38:             description: "should handle mixed types of query parameters",
 39:             baseUrl: BASE_URL,
 40:             queryParams: {
 41:                 simple: "value",
 42:                 array: ["x", "y"],
 43:                 object: { key: "value" },
 44:             },
 45:             expected: "https://api.example.com?simple=value&array=x&array=y&object%5Bkey%5D=value",
 46:         },
 47:         {
 48:             description: "should handle empty query parameters object",
 49:             baseUrl: BASE_URL,
 50:             queryParams: {},
 51:             expected: BASE_URL,
 52:         },
 53:         {
 54:             description: "should encode special characters in query parameters",
 55:             baseUrl: BASE_URL,
 56:             queryParams: { special: "a&b=c d" },
 57:             expected: "https://api.example.com?special=a%26b%3Dc%20d",
 58:         },
 59:         {
 60:             description: "should handle numeric values",
 61:             baseUrl: BASE_URL,
 62:             queryParams: { count: 42, price: 19.99, active: 1, inactive: 0 },
 63:             expected: "https://api.example.com?count=42&price=19.99&active=1&inactive=0",
 64:         },
 65:         {
 66:             description: "should handle boolean values",
 67:             baseUrl: BASE_URL,
 68:             queryParams: { enabled: true, disabled: false },
 69:             expected: "https://api.example.com?enabled=true&disabled=false",
 70:         },
 71:         {
 72:             description: "should handle null and undefined values",
 73:             baseUrl: BASE_URL,
 74:             queryParams: {
 75:                 valid: "value",
 76:                 nullValue: null,
 77:                 undefinedValue: undefined,
 78:                 emptyString: "",
 79:             },
 80:             expected: "https://api.example.com?valid=value&nullValue=&emptyString=",
 81:         },
 82:         {
 83:             description: "should handle deeply nested objects",
 84:             baseUrl: BASE_URL,
 85:             queryParams: {
 86:                 user: {
 87:                     profile: {
 88:                         name: "John",
 89:                         settings: { theme: "dark" },
 90:                     },
 91:                 },
 92:             },
 93:             expected:
 94:                 "https://api.example.com?user%5Bprofile%5D%5Bname%5D=John&user%5Bprofile%5D%5Bsettings%5D%5Btheme%5D=dark",
 95:         },
 96:         {
 97:             description: "should handle arrays of objects",
 98:             baseUrl: BASE_URL,
 99:             queryParams: {
100:                 users: [
101:                     { name: "John", age: 30 },
102:                     { name: "Jane", age: 25 },
103:                 ],
104:             },
105:             expected:
106:                 "https://api.example.com?users%5Bname%5D=John&users%5Bage%5D=30&users%5Bname%5D=Jane&users%5Bage%5D=25",
107:         },
108:         {
109:             description: "should handle mixed arrays",
110:             baseUrl: BASE_URL,
111:             queryParams: {
112:                 mixed: ["string", 42, true, { key: "value" }],
113:             },
114:             expected: "https://api.example.com?mixed=string&mixed=42&mixed=true&mixed%5Bkey%5D=value",
115:         },
116:         {
117:             description: "should handle empty arrays",
118:             baseUrl: BASE_URL,
119:             queryParams: { emptyArray: [] },
120:             expected: BASE_URL,
121:         },
122:         {
123:             description: "should handle empty objects",
124:             baseUrl: BASE_URL,
125:             queryParams: { emptyObject: {} },
126:             expected: BASE_URL,
127:         },
128:         {
129:             description: "should handle special characters in keys",
130:             baseUrl: BASE_URL,
131:             queryParams: { "key with spaces": "value", "key[with]brackets": "value" },
132:             expected: "https://api.example.com?key%20with%20spaces=value&key%5Bwith%5Dbrackets=value",
133:         },
134:         {
135:             description: "should handle URL with existing query parameters",
136:             baseUrl: "https://api.example.com?existing=param",
137:             queryParams: { new: "value" },
138:             expected: "https://api.example.com?existing=param?new=value",
139:         },
140:         {
141:             description: "should handle complex nested structures",
142:             baseUrl: BASE_URL,
143:             queryParams: {
144:                 filters: {
145:                     status: ["active", "pending"],
146:                     category: {
147:                         type: "electronics",
148:                         subcategories: ["phones", "laptops"],
149:                     },
150:                 },
151:                 sort: { field: "name", direction: "asc" },
152:             },
153:             expected:
154:                 "https://api.example.com?filters%5Bstatus%5D=active&filters%5Bstatus%5D=pending&filters%5Bcategory%5D%5Btype%5D=electronics&filters%5Bcategory%5D%5Bsubcategories%5D=phones&filters%5Bcategory%5D%5Bsubcategories%5D=laptops&sort%5Bfield%5D=name&sort%5Bdirection%5D=asc",
155:         },
156:     ];
157: 
158:     testCases.forEach(({ description, baseUrl, queryParams, expected }) => {
159:         it(description, () => {
160:             expect(createRequestUrl(baseUrl, queryParams)).toBe(expected);
161:         });
162:     });
163: });
````

## File: tests/unit/fetcher/Fetcher.test.ts
````typescript
  1: import fs from "fs";
  2: import stream from "stream";
  3: import { join } from "path";
  4: 
  5: import { Fetcher, fetcherImpl } from "../../../src/core/fetcher/Fetcher";
  6: import type { BinaryResponse } from "../../../src/core";
  7: 
  8: function expectHeadersToContain(headers: Headers, expected: Record<string, string>) {
  9:     for (const [key, value] of Object.entries(expected)) {
 10:         expect(headers.get(key)).toBe(value);
 11:     }
 12: }
 13: 
 14: describe("Test fetcherImpl", () => {
 15:     it("should handle successful request", async () => {
 16:         const mockArgs: Fetcher.Args = {
 17:             url: "https://httpbin.org/post",
 18:             method: "POST",
 19:             headers: { "X-Test": "x-test-header" },
 20:             body: { data: "test" },
 21:             contentType: "application/json",
 22:             requestType: "json",
 23:             responseType: "json",
 24:         };
 25: 
 26:         global.fetch = vi.fn().mockResolvedValue(
 27:             new Response(JSON.stringify({ data: "test" }), {
 28:                 status: 200,
 29:                 statusText: "OK",
 30:             }),
 31:         );
 32: 
 33:         const result = await fetcherImpl(mockArgs);
 34:         expect(result.ok).toBe(true);
 35:         if (result.ok) {
 36:             expect(result.body).toEqual({ data: "test" });
 37:         }
 38: 
 39:         expect(global.fetch).toHaveBeenCalledWith(
 40:             "https://httpbin.org/post",
 41:             expect.objectContaining({
 42:                 method: "POST",
 43:                 body: JSON.stringify({ data: "test" }),
 44:             }),
 45:         );
 46:         const callArgs = vi.mocked(global.fetch).mock.calls[0]![1]!;
 47:         expectHeadersToContain(callArgs.headers as Headers, { "X-Test": "x-test-header" });
 48:     });
 49: 
 50:     it("should send octet stream", async () => {
 51:         const url = "https://httpbin.org/post/file";
 52:         const mockArgs: Fetcher.Args = {
 53:             url,
 54:             method: "POST",
 55:             headers: { "X-Test": "x-test-header" },
 56:             contentType: "application/octet-stream",
 57:             requestType: "bytes",
 58:             responseType: "json",
 59:             body: fs.createReadStream(join(__dirname, "test-file.txt")),
 60:         };
 61: 
 62:         global.fetch = vi.fn().mockResolvedValue(
 63:             new Response(JSON.stringify({ data: "test" }), {
 64:                 status: 200,
 65:                 statusText: "OK",
 66:             }),
 67:         );
 68: 
 69:         const result = await fetcherImpl(mockArgs);
 70: 
 71:         expect(global.fetch).toHaveBeenCalledWith(
 72:             url,
 73:             expect.objectContaining({
 74:                 method: "POST",
 75:                 body: expect.any(fs.ReadStream),
 76:             }),
 77:         );
 78:         const callArgs = vi.mocked(global.fetch).mock.calls[0]![1]!;
 79:         expectHeadersToContain(callArgs.headers as Headers, { "X-Test": "x-test-header" });
 80:         expect(result.ok).toBe(true);
 81:         if (result.ok) {
 82:             expect(result.body).toEqual({ data: "test" });
 83:         }
 84:     });
 85: 
 86:     it("should receive file as stream", async () => {
 87:         const url = "https://httpbin.org/post/file";
 88:         const mockArgs: Fetcher.Args = {
 89:             url,
 90:             method: "GET",
 91:             headers: { "X-Test": "x-test-header" },
 92:             responseType: "binary-response",
 93:         };
 94: 
 95:         global.fetch = vi.fn().mockResolvedValue(
 96:             new Response(
 97:                 stream.Readable.toWeb(fs.createReadStream(join(__dirname, "test-file.txt"))) as ReadableStream,
 98:                 {
 99:                     status: 200,
100:                     statusText: "OK",
101:                 },
102:             ),
103:         );
104: 
105:         const result = await fetcherImpl(mockArgs);
106: 
107:         expect(global.fetch).toHaveBeenCalledWith(
108:             url,
109:             expect.objectContaining({
110:                 method: "GET",
111:             }),
112:         );
113:         const callArgs = vi.mocked(global.fetch).mock.calls[0]![1]!;
114:         expectHeadersToContain(callArgs.headers as Headers, { "X-Test": "x-test-header" });
115:         expect(result.ok).toBe(true);
116:         if (result.ok) {
117:             const body = result.body as BinaryResponse;
118:             expect(body).toBeDefined();
119:             expect(body.bodyUsed).toBe(false);
120:             expect(typeof body.stream).toBe("function");
121:             const stream = body.stream();
122:             expect(stream).toBeInstanceOf(ReadableStream);
123:             const reader = stream.getReader();
124:             const { value } = await reader.read();
125:             const decoder = new TextDecoder();
126:             const streamContent = decoder.decode(value);
127:             expect(streamContent).toBe("This is a test file!\n");
128:             expect(body.bodyUsed).toBe(true);
129:         }
130:     });
131: 
132:     it("should receive file as blob", async () => {
133:         const url = "https://httpbin.org/post/file";
134:         const mockArgs: Fetcher.Args = {
135:             url,
136:             method: "GET",
137:             headers: { "X-Test": "x-test-header" },
138:             responseType: "binary-response",
139:         };
140: 
141:         global.fetch = vi.fn().mockResolvedValue(
142:             new Response(
143:                 stream.Readable.toWeb(fs.createReadStream(join(__dirname, "test-file.txt"))) as ReadableStream,
144:                 {
145:                     status: 200,
146:                     statusText: "OK",
147:                 },
148:             ),
149:         );
150: 
151:         const result = await fetcherImpl(mockArgs);
152: 
153:         expect(global.fetch).toHaveBeenCalledWith(
154:             url,
155:             expect.objectContaining({
156:                 method: "GET",
157:             }),
158:         );
159:         const callArgs = vi.mocked(global.fetch).mock.calls[0]![1]!;
160:         expectHeadersToContain(callArgs.headers as Headers, { "X-Test": "x-test-header" });
161:         expect(result.ok).toBe(true);
162:         if (result.ok) {
163:             const body = result.body as BinaryResponse;
164:             expect(body).toBeDefined();
165:             expect(body.bodyUsed).toBe(false);
166:             expect(typeof body.blob).toBe("function");
167:             const blob = await body.blob();
168:             expect(blob).toBeInstanceOf(Blob);
169:             const reader = blob.stream().getReader();
170:             const { value } = await reader.read();
171:             const decoder = new TextDecoder();
172:             const streamContent = decoder.decode(value);
173:             expect(streamContent).toBe("This is a test file!\n");
174:             expect(body.bodyUsed).toBe(true);
175:         }
176:     });
177: 
178:     it("should receive file as arraybuffer", async () => {
179:         const url = "https://httpbin.org/post/file";
180:         const mockArgs: Fetcher.Args = {
181:             url,
182:             method: "GET",
183:             headers: { "X-Test": "x-test-header" },
184:             responseType: "binary-response",
185:         };
186: 
187:         global.fetch = vi.fn().mockResolvedValue(
188:             new Response(
189:                 stream.Readable.toWeb(fs.createReadStream(join(__dirname, "test-file.txt"))) as ReadableStream,
190:                 {
191:                     status: 200,
192:                     statusText: "OK",
193:                 },
194:             ),
195:         );
196: 
197:         const result = await fetcherImpl(mockArgs);
198: 
199:         expect(global.fetch).toHaveBeenCalledWith(
200:             url,
201:             expect.objectContaining({
202:                 method: "GET",
203:             }),
204:         );
205:         const callArgs = vi.mocked(global.fetch).mock.calls[0]![1]!;
206:         expectHeadersToContain(callArgs.headers as Headers, { "X-Test": "x-test-header" });
207:         expect(result.ok).toBe(true);
208:         if (result.ok) {
209:             const body = result.body as BinaryResponse;
210:             expect(body).toBeDefined();
211:             expect(body.bodyUsed).toBe(false);
212:             expect(typeof body.arrayBuffer).toBe("function");
213:             const arrayBuffer = await body.arrayBuffer();
214:             expect(arrayBuffer).toBeInstanceOf(ArrayBuffer);
215:             const decoder = new TextDecoder();
216:             const streamContent = decoder.decode(new Uint8Array(arrayBuffer));
217:             expect(streamContent).toBe("This is a test file!\n");
218:             expect(body.bodyUsed).toBe(true);
219:         }
220:     });
221: 
222:     it("should receive file as bytes", async () => {
223:         const url = "https://httpbin.org/post/file";
224:         const mockArgs: Fetcher.Args = {
225:             url,
226:             method: "GET",
227:             headers: { "X-Test": "x-test-header" },
228:             responseType: "binary-response",
229:         };
230: 
231:         global.fetch = vi.fn().mockResolvedValue(
232:             new Response(
233:                 stream.Readable.toWeb(fs.createReadStream(join(__dirname, "test-file.txt"))) as ReadableStream,
234:                 {
235:                     status: 200,
236:                     statusText: "OK",
237:                 },
238:             ),
239:         );
240: 
241:         const result = await fetcherImpl(mockArgs);
242: 
243:         expect(global.fetch).toHaveBeenCalledWith(
244:             url,
245:             expect.objectContaining({
246:                 method: "GET",
247:             }),
248:         );
249:         const callArgs = vi.mocked(global.fetch).mock.calls[0]![1]!;
250:         expectHeadersToContain(callArgs.headers as Headers, { "X-Test": "x-test-header" });
251:         expect(result.ok).toBe(true);
252:         if (result.ok) {
253:             const body = result.body as BinaryResponse;
254:             expect(body).toBeDefined();
255:             expect(body.bodyUsed).toBe(false);
256:             if (!body.bytes) {
257:                 return;
258:             }
259:             expect(typeof body.bytes).toBe("function");
260:             const bytes = await body.bytes();
261:             expect(bytes).toBeInstanceOf(Uint8Array);
262:             const decoder = new TextDecoder();
263:             const streamContent = decoder.decode(bytes);
264:             expect(streamContent).toBe("This is a test file!\n");
265:             expect(body.bodyUsed).toBe(true);
266:         }
267:     });
268: });
````

## File: tests/unit/fetcher/getRequestBody.test.ts
````typescript
  1: import { getRequestBody } from "../../../src/core/fetcher/getRequestBody";
  2: import { RUNTIME } from "../../../src/core/runtime";
  3: 
  4: describe("Test getRequestBody", () => {
  5:     interface TestCase {
  6:         description: string;
  7:         input: any;
  8:         type: "json" | "form" | "file" | "bytes" | "other";
  9:         expected: any;
 10:         skipCondition?: () => boolean;
 11:     }
 12: 
 13:     const testCases: TestCase[] = [
 14:         {
 15:             description: "should stringify body if not FormData in Node environment",
 16:             input: { key: "value" },
 17:             type: "json",
 18:             expected: '{"key":"value"}',
 19:             skipCondition: () => RUNTIME.type !== "node",
 20:         },
 21:         {
 22:             description: "should stringify body if not FormData in browser environment",
 23:             input: { key: "value" },
 24:             type: "json",
 25:             expected: '{"key":"value"}',
 26:             skipCondition: () => RUNTIME.type !== "browser",
 27:         },
 28:         {
 29:             description: "should return the Uint8Array",
 30:             input: new Uint8Array([1, 2, 3]),
 31:             type: "bytes",
 32:             expected: new Uint8Array([1, 2, 3]),
 33:         },
 34:         {
 35:             description: "should serialize objects for form-urlencoded content type",
 36:             input: { username: "johndoe", email: "john@example.com" },
 37:             type: "form",
 38:             expected: "username=johndoe&email=john%40example.com",
 39:         },
 40:         {
 41:             description: "should serialize complex nested objects and arrays for form-urlencoded content type",
 42:             input: {
 43:                 user: {
 44:                     profile: {
 45:                         name: "John Doe",
 46:                         settings: {
 47:                             theme: "dark",
 48:                             notifications: true,
 49:                         },
 50:                     },
 51:                     tags: ["admin", "user"],
 52:                     contacts: [
 53:                         { type: "email", value: "john@example.com" },
 54:                         { type: "phone", value: "+1234567890" },
 55:                     ],
 56:                 },
 57:                 filters: {
 58:                     status: ["active", "pending"],
 59:                     metadata: {
 60:                         created: "2024-01-01",
 61:                         categories: ["electronics", "books"],
 62:                     },
 63:                 },
 64:                 preferences: ["notifications", "updates"],
 65:             },
 66:             type: "form",
 67:             expected:
 68:                 "user%5Bprofile%5D%5Bname%5D=John%20Doe&" +
 69:                 "user%5Bprofile%5D%5Bsettings%5D%5Btheme%5D=dark&" +
 70:                 "user%5Bprofile%5D%5Bsettings%5D%5Bnotifications%5D=true&" +
 71:                 "user%5Btags%5D=admin&" +
 72:                 "user%5Btags%5D=user&" +
 73:                 "user%5Bcontacts%5D%5Btype%5D=email&" +
 74:                 "user%5Bcontacts%5D%5Bvalue%5D=john%40example.com&" +
 75:                 "user%5Bcontacts%5D%5Btype%5D=phone&" +
 76:                 "user%5Bcontacts%5D%5Bvalue%5D=%2B1234567890&" +
 77:                 "filters%5Bstatus%5D=active&" +
 78:                 "filters%5Bstatus%5D=pending&" +
 79:                 "filters%5Bmetadata%5D%5Bcreated%5D=2024-01-01&" +
 80:                 "filters%5Bmetadata%5D%5Bcategories%5D=electronics&" +
 81:                 "filters%5Bmetadata%5D%5Bcategories%5D=books&" +
 82:                 "preferences=notifications&" +
 83:                 "preferences=updates",
 84:         },
 85:         {
 86:             description: "should return the input for pre-serialized form-urlencoded strings",
 87:             input: "key=value&another=param",
 88:             type: "other",
 89:             expected: "key=value&another=param",
 90:         },
 91:         {
 92:             description: "should JSON stringify objects",
 93:             input: { key: "value" },
 94:             type: "json",
 95:             expected: '{"key":"value"}',
 96:         },
 97:     ];
 98: 
 99:     testCases.forEach(({ description, input, type, expected, skipCondition }) => {
100:         it(description, async () => {
101:             if (skipCondition?.()) {
102:                 return;
103:             }
104: 
105:             const result = await getRequestBody({
106:                 body: input,
107:                 type,
108:             });
109: 
110:             if (input instanceof Uint8Array) {
111:                 expect(result).toBe(input);
112:             } else {
113:                 expect(result).toBe(expected);
114:             }
115:         });
116:     });
117: 
118:     it("should return FormData in browser environment", async () => {
119:         if (RUNTIME.type === "browser") {
120:             const formData = new FormData();
121:             formData.append("key", "value");
122:             const result = await getRequestBody({
123:                 body: formData,
124:                 type: "file",
125:             });
126:             expect(result).toBe(formData);
127:         }
128:     });
129: });
````

## File: tests/unit/fetcher/getResponseBody.test.ts
````typescript
 1: import { getResponseBody } from "../../../src/core/fetcher/getResponseBody";
 2: 
 3: import { RUNTIME } from "../../../src/core/runtime";
 4: 
 5: describe("Test getResponseBody", () => {
 6:     interface SimpleTestCase {
 7:         description: string;
 8:         responseData: string | Record<string, any>;
 9:         responseType?: "blob" | "sse" | "streaming" | "text";
10:         expected: any;
11:         skipCondition?: () => boolean;
12:     }
13: 
14:     const simpleTestCases: SimpleTestCase[] = [
15:         {
16:             description: "should handle text response type",
17:             responseData: "test text",
18:             responseType: "text",
19:             expected: "test text",
20:         },
21:         {
22:             description: "should handle JSON response",
23:             responseData: { key: "value" },
24:             expected: { key: "value" },
25:         },
26:         {
27:             description: "should handle empty response",
28:             responseData: "",
29:             expected: undefined,
30:         },
31:         {
32:             description: "should handle non-JSON response",
33:             responseData: "invalid json",
34:             expected: {
35:                 ok: false,
36:                 error: {
37:                     reason: "non-json",
38:                     statusCode: 200,
39:                     rawBody: "invalid json",
40:                 },
41:             },
42:         },
43:     ];
44: 
45:     simpleTestCases.forEach(({ description, responseData, responseType, expected, skipCondition }) => {
46:         it(description, async () => {
47:             if (skipCondition?.()) {
48:                 return;
49:             }
50: 
51:             const mockResponse = new Response(
52:                 typeof responseData === "string" ? responseData : JSON.stringify(responseData),
53:             );
54:             const result = await getResponseBody(mockResponse, responseType);
55:             expect(result).toEqual(expected);
56:         });
57:     });
58: 
59:     it("should handle blob response type", async () => {
60:         const mockBlob = new Blob(["test"], { type: "text/plain" });
61:         const mockResponse = new Response(mockBlob);
62:         const result = await getResponseBody(mockResponse, "blob");
63:         // @ts-expect-error
64:         expect(result.constructor.name).toBe("Blob");
65:     });
66: 
67:     it("should handle sse response type", async () => {
68:         if (RUNTIME.type === "node") {
69:             const mockStream = new ReadableStream();
70:             const mockResponse = new Response(mockStream);
71:             const result = await getResponseBody(mockResponse, "sse");
72:             expect(result).toBe(mockStream);
73:         }
74:     });
75: 
76:     it("should handle streaming response type", async () => {
77:         const encoder = new TextEncoder();
78:         const testData = "test stream data";
79:         const mockStream = new ReadableStream({
80:             start(controller) {
81:                 controller.enqueue(encoder.encode(testData));
82:                 controller.close();
83:             },
84:         });
85: 
86:         const mockResponse = new Response(mockStream);
87:         const result = (await getResponseBody(mockResponse, "streaming")) as ReadableStream;
88: 
89:         expect(result).toBeInstanceOf(ReadableStream);
90: 
91:         const reader = result.getReader();
92:         const decoder = new TextDecoder();
93:         const { value } = await reader.read();
94:         const streamContent = decoder.decode(value);
95:         expect(streamContent).toBe(testData);
96:     });
97: });
````

## File: tests/unit/fetcher/HttpResponsePromise.test.ts
````typescript
  1: import { beforeEach, describe, expect, it, vi } from "vitest";
  2: 
  3: import { HttpResponsePromise } from "../../../src/core/fetcher/HttpResponsePromise";
  4: import type { RawResponse, WithRawResponse } from "../../../src/core/fetcher/RawResponse";
  5: 
  6: describe("HttpResponsePromise", () => {
  7:     const mockRawResponse: RawResponse = {
  8:         headers: new Headers(),
  9:         redirected: false,
 10:         status: 200,
 11:         statusText: "OK",
 12:         type: "basic" as ResponseType,
 13:         url: "https://example.com",
 14:     };
 15:     const mockData = { id: "123", name: "test" };
 16:     const mockWithRawResponse: WithRawResponse<typeof mockData> = {
 17:         data: mockData,
 18:         rawResponse: mockRawResponse,
 19:     };
 20: 
 21:     describe("fromFunction", () => {
 22:         it("should create an HttpResponsePromise from a function", async () => {
 23:             const mockFn = vi
 24:                 .fn<(arg1: string, arg2: string) => Promise<WithRawResponse<typeof mockData>>>()
 25:                 .mockResolvedValue(mockWithRawResponse);
 26: 
 27:             const responsePromise = HttpResponsePromise.fromFunction(mockFn, "arg1", "arg2");
 28: 
 29:             const result = await responsePromise;
 30:             expect(result).toEqual(mockData);
 31:             expect(mockFn).toHaveBeenCalledWith("arg1", "arg2");
 32: 
 33:             const resultWithRawResponse = await responsePromise.withRawResponse();
 34:             expect(resultWithRawResponse).toEqual({
 35:                 data: mockData,
 36:                 rawResponse: mockRawResponse,
 37:             });
 38:         });
 39:     });
 40: 
 41:     describe("fromPromise", () => {
 42:         it("should create an HttpResponsePromise from a promise", async () => {
 43:             const promise = Promise.resolve(mockWithRawResponse);
 44: 
 45:             const responsePromise = HttpResponsePromise.fromPromise(promise);
 46: 
 47:             const result = await responsePromise;
 48:             expect(result).toEqual(mockData);
 49: 
 50:             const resultWithRawResponse = await responsePromise.withRawResponse();
 51:             expect(resultWithRawResponse).toEqual({
 52:                 data: mockData,
 53:                 rawResponse: mockRawResponse,
 54:             });
 55:         });
 56:     });
 57: 
 58:     describe("fromExecutor", () => {
 59:         it("should create an HttpResponsePromise from an executor function", async () => {
 60:             const responsePromise = HttpResponsePromise.fromExecutor((resolve) => {
 61:                 resolve(mockWithRawResponse);
 62:             });
 63: 
 64:             const result = await responsePromise;
 65:             expect(result).toEqual(mockData);
 66: 
 67:             const resultWithRawResponse = await responsePromise.withRawResponse();
 68:             expect(resultWithRawResponse).toEqual({
 69:                 data: mockData,
 70:                 rawResponse: mockRawResponse,
 71:             });
 72:         });
 73:     });
 74: 
 75:     describe("fromResult", () => {
 76:         it("should create an HttpResponsePromise from a result", async () => {
 77:             const responsePromise = HttpResponsePromise.fromResult(mockWithRawResponse);
 78: 
 79:             const result = await responsePromise;
 80:             expect(result).toEqual(mockData);
 81: 
 82:             const resultWithRawResponse = await responsePromise.withRawResponse();
 83:             expect(resultWithRawResponse).toEqual({
 84:                 data: mockData,
 85:                 rawResponse: mockRawResponse,
 86:             });
 87:         });
 88:     });
 89: 
 90:     describe("Promise methods", () => {
 91:         let responsePromise: HttpResponsePromise<typeof mockData>;
 92: 
 93:         beforeEach(() => {
 94:             responsePromise = HttpResponsePromise.fromResult(mockWithRawResponse);
 95:         });
 96: 
 97:         it("should support then() method", async () => {
 98:             const result = await responsePromise.then((data) => ({
 99:                 ...data,
100:                 modified: true,
101:             }));
102: 
103:             expect(result).toEqual({
104:                 ...mockData,
105:                 modified: true,
106:             });
107:         });
108: 
109:         it("should support catch() method", async () => {
110:             const errorResponsePromise = HttpResponsePromise.fromExecutor((_, reject) => {
111:                 reject(new Error("Test error"));
112:             });
113: 
114:             const catchSpy = vi.fn();
115:             await errorResponsePromise.catch(catchSpy);
116: 
117:             expect(catchSpy).toHaveBeenCalled();
118:             const error = catchSpy.mock.calls[0]?.[0];
119:             expect(error).toBeInstanceOf(Error);
120:             expect((error as Error).message).toBe("Test error");
121:         });
122: 
123:         it("should support finally() method", async () => {
124:             const finallySpy = vi.fn();
125:             await responsePromise.finally(finallySpy);
126: 
127:             expect(finallySpy).toHaveBeenCalled();
128:         });
129:     });
130: 
131:     describe("withRawResponse", () => {
132:         it("should return both data and raw response", async () => {
133:             const responsePromise = HttpResponsePromise.fromResult(mockWithRawResponse);
134: 
135:             const result = await responsePromise.withRawResponse();
136: 
137:             expect(result).toEqual({
138:                 data: mockData,
139:                 rawResponse: mockRawResponse,
140:             });
141:         });
142:     });
143: });
````

## File: tests/unit/fetcher/logging.test.ts
````typescript
  1: import { fetcherImpl } from "../../../src/core/fetcher/Fetcher";
  2: 
  3: function createMockLogger() {
  4:     return {
  5:         debug: vi.fn(),
  6:         info: vi.fn(),
  7:         warn: vi.fn(),
  8:         error: vi.fn(),
  9:     };
 10: }
 11: 
 12: function mockSuccessResponse(data: unknown = { data: "test" }, status = 200, statusText = "OK") {
 13:     global.fetch = vi.fn().mockResolvedValue(
 14:         new Response(JSON.stringify(data), {
 15:             status,
 16:             statusText,
 17:         }),
 18:     );
 19: }
 20: 
 21: function mockErrorResponse(data: unknown = { error: "Error" }, status = 404, statusText = "Not Found") {
 22:     global.fetch = vi.fn().mockResolvedValue(
 23:         new Response(JSON.stringify(data), {
 24:             status,
 25:             statusText,
 26:         }),
 27:     );
 28: }
 29: 
 30: describe("Fetcher Logging Integration", () => {
 31:     describe("Request Logging", () => {
 32:         it("should log successful request at debug level", async () => {
 33:             const mockLogger = createMockLogger();
 34:             mockSuccessResponse();
 35: 
 36:             await fetcherImpl({
 37:                 url: "https://example.com/api",
 38:                 method: "POST",
 39:                 headers: { "Content-Type": "application/json" },
 40:                 body: { test: "data" },
 41:                 contentType: "application/json",
 42:                 requestType: "json",
 43:                 responseType: "json",
 44:                 maxRetries: 0,
 45:                 logging: {
 46:                     level: "debug",
 47:                     logger: mockLogger,
 48:                     silent: false,
 49:                 },
 50:             });
 51: 
 52:             expect(mockLogger.debug).toHaveBeenCalledWith(
 53:                 "Making HTTP request",
 54:                 expect.objectContaining({
 55:                     method: "POST",
 56:                     url: "https://example.com/api",
 57:                     headers: expect.toContainHeaders({
 58:                         "Content-Type": "application/json",
 59:                     }),
 60:                     hasBody: true,
 61:                 }),
 62:             );
 63: 
 64:             expect(mockLogger.debug).toHaveBeenCalledWith(
 65:                 "HTTP request succeeded",
 66:                 expect.objectContaining({
 67:                     method: "POST",
 68:                     url: "https://example.com/api",
 69:                     statusCode: 200,
 70:                 }),
 71:             );
 72:         });
 73: 
 74:         it("should not log debug messages at info level for successful requests", async () => {
 75:             const mockLogger = createMockLogger();
 76:             mockSuccessResponse();
 77: 
 78:             await fetcherImpl({
 79:                 url: "https://example.com/api",
 80:                 method: "GET",
 81:                 responseType: "json",
 82:                 maxRetries: 0,
 83:                 logging: {
 84:                     level: "info",
 85:                     logger: mockLogger,
 86:                     silent: false,
 87:                 },
 88:             });
 89: 
 90:             expect(mockLogger.debug).not.toHaveBeenCalled();
 91:             expect(mockLogger.info).not.toHaveBeenCalled();
 92:         });
 93: 
 94:         it("should log request with body flag", async () => {
 95:             const mockLogger = createMockLogger();
 96:             mockSuccessResponse();
 97: 
 98:             await fetcherImpl({
 99:                 url: "https://example.com/api",
100:                 method: "POST",
101:                 body: { data: "test" },
102:                 contentType: "application/json",
103:                 requestType: "json",
104:                 responseType: "json",
105:                 maxRetries: 0,
106:                 logging: {
107:                     level: "debug",
108:                     logger: mockLogger,
109:                     silent: false,
110:                 },
111:             });
112: 
113:             expect(mockLogger.debug).toHaveBeenCalledWith(
114:                 "Making HTTP request",
115:                 expect.objectContaining({
116:                     hasBody: true,
117:                 }),
118:             );
119:         });
120: 
121:         it("should log request without body flag", async () => {
122:             const mockLogger = createMockLogger();
123:             mockSuccessResponse();
124: 
125:             await fetcherImpl({
126:                 url: "https://example.com/api",
127:                 method: "GET",
128:                 responseType: "json",
129:                 maxRetries: 0,
130:                 logging: {
131:                     level: "debug",
132:                     logger: mockLogger,
133:                     silent: false,
134:                 },
135:             });
136: 
137:             expect(mockLogger.debug).toHaveBeenCalledWith(
138:                 "Making HTTP request",
139:                 expect.objectContaining({
140:                     hasBody: false,
141:                 }),
142:             );
143:         });
144: 
145:         it("should not log when silent mode is enabled", async () => {
146:             const mockLogger = createMockLogger();
147:             mockSuccessResponse();
148: 
149:             await fetcherImpl({
150:                 url: "https://example.com/api",
151:                 method: "GET",
152:                 responseType: "json",
153:                 maxRetries: 0,
154:                 logging: {
155:                     level: "debug",
156:                     logger: mockLogger,
157:                     silent: true,
158:                 },
159:             });
160: 
161:             expect(mockLogger.debug).not.toHaveBeenCalled();
162:             expect(mockLogger.info).not.toHaveBeenCalled();
163:             expect(mockLogger.warn).not.toHaveBeenCalled();
164:             expect(mockLogger.error).not.toHaveBeenCalled();
165:         });
166: 
167:         it("should not log when no logging config is provided", async () => {
168:             const mockLogger = createMockLogger();
169:             mockSuccessResponse();
170: 
171:             await fetcherImpl({
172:                 url: "https://example.com/api",
173:                 method: "GET",
174:                 responseType: "json",
175:                 maxRetries: 0,
176:             });
177: 
178:             expect(mockLogger.debug).not.toHaveBeenCalled();
179:         });
180:     });
181: 
182:     describe("Error Logging", () => {
183:         it("should log 4xx errors at error level", async () => {
184:             const mockLogger = createMockLogger();
185:             mockErrorResponse({ error: "Not found" }, 404, "Not Found");
186: 
187:             const result = await fetcherImpl({
188:                 url: "https://example.com/api",
189:                 method: "GET",
190:                 responseType: "json",
191:                 maxRetries: 0,
192:                 logging: {
193:                     level: "error",
194:                     logger: mockLogger,
195:                     silent: false,
196:                 },
197:             });
198: 
199:             expect(result.ok).toBe(false);
200:             expect(mockLogger.error).toHaveBeenCalledWith(
201:                 "HTTP request failed with error status",
202:                 expect.objectContaining({
203:                     method: "GET",
204:                     url: "https://example.com/api",
205:                     statusCode: 404,
206:                 }),
207:             );
208:         });
209: 
210:         it("should log 5xx errors at error level", async () => {
211:             const mockLogger = createMockLogger();
212:             mockErrorResponse({ error: "Internal error" }, 500, "Internal Server Error");
213: 
214:             const result = await fetcherImpl({
215:                 url: "https://example.com/api",
216:                 method: "GET",
217:                 responseType: "json",
218:                 maxRetries: 0,
219:                 logging: {
220:                     level: "error",
221:                     logger: mockLogger,
222:                     silent: false,
223:                 },
224:             });
225: 
226:             expect(result.ok).toBe(false);
227:             expect(mockLogger.error).toHaveBeenCalledWith(
228:                 "HTTP request failed with error status",
229:                 expect.objectContaining({
230:                     method: "GET",
231:                     url: "https://example.com/api",
232:                     statusCode: 500,
233:                 }),
234:             );
235:         });
236: 
237:         it("should log aborted request errors", async () => {
238:             const mockLogger = createMockLogger();
239: 
240:             const abortController = new AbortController();
241:             abortController.abort();
242: 
243:             global.fetch = vi.fn().mockRejectedValue(new Error("Aborted"));
244: 
245:             const result = await fetcherImpl({
246:                 url: "https://example.com/api",
247:                 method: "GET",
248:                 responseType: "json",
249:                 abortSignal: abortController.signal,
250:                 maxRetries: 0,
251:                 logging: {
252:                     level: "error",
253:                     logger: mockLogger,
254:                     silent: false,
255:                 },
256:             });
257: 
258:             expect(result.ok).toBe(false);
259:             expect(mockLogger.error).toHaveBeenCalledWith(
260:                 "HTTP request was aborted",
261:                 expect.objectContaining({
262:                     method: "GET",
263:                     url: "https://example.com/api",
264:                 }),
265:             );
266:         });
267: 
268:         it("should log timeout errors", async () => {
269:             const mockLogger = createMockLogger();
270: 
271:             const timeoutError = new Error("Request timeout");
272:             timeoutError.name = "AbortError";
273: 
274:             global.fetch = vi.fn().mockRejectedValue(timeoutError);
275: 
276:             const result = await fetcherImpl({
277:                 url: "https://example.com/api",
278:                 method: "GET",
279:                 responseType: "json",
280:                 maxRetries: 0,
281:                 logging: {
282:                     level: "error",
283:                     logger: mockLogger,
284:                     silent: false,
285:                 },
286:             });
287: 
288:             expect(result.ok).toBe(false);
289:             expect(mockLogger.error).toHaveBeenCalledWith(
290:                 "HTTP request timed out",
291:                 expect.objectContaining({
292:                     method: "GET",
293:                     url: "https://example.com/api",
294:                     timeoutMs: undefined,
295:                 }),
296:             );
297:         });
298: 
299:         it("should log unknown errors", async () => {
300:             const mockLogger = createMockLogger();
301: 
302:             const unknownError = new Error("Unknown error");
303: 
304:             global.fetch = vi.fn().mockRejectedValue(unknownError);
305: 
306:             const result = await fetcherImpl({
307:                 url: "https://example.com/api",
308:                 method: "GET",
309:                 responseType: "json",
310:                 maxRetries: 0,
311:                 logging: {
312:                     level: "error",
313:                     logger: mockLogger,
314:                     silent: false,
315:                 },
316:             });
317: 
318:             expect(result.ok).toBe(false);
319:             expect(mockLogger.error).toHaveBeenCalledWith(
320:                 "HTTP request failed with error",
321:                 expect.objectContaining({
322:                     method: "GET",
323:                     url: "https://example.com/api",
324:                     errorMessage: "Unknown error",
325:                 }),
326:             );
327:         });
328:     });
329: 
330:     describe("Logging with Redaction", () => {
331:         it("should redact sensitive data in error logs", async () => {
332:             const mockLogger = createMockLogger();
333:             mockErrorResponse({ error: "Unauthorized" }, 401, "Unauthorized");
334: 
335:             await fetcherImpl({
336:                 url: "https://example.com/api?api_key=secret",
337:                 method: "GET",
338:                 responseType: "json",
339:                 maxRetries: 0,
340:                 logging: {
341:                     level: "error",
342:                     logger: mockLogger,
343:                     silent: false,
344:                 },
345:             });
346: 
347:             expect(mockLogger.error).toHaveBeenCalledWith(
348:                 "HTTP request failed with error status",
349:                 expect.objectContaining({
350:                     url: "https://example.com/api?api_key=[REDACTED]",
351:                 }),
352:             );
353:         });
354:     });
355: 
356:     describe("Different HTTP Methods", () => {
357:         it("should log GET requests", async () => {
358:             const mockLogger = createMockLogger();
359:             mockSuccessResponse();
360: 
361:             await fetcherImpl({
362:                 url: "https://example.com/api",
363:                 method: "GET",
364:                 responseType: "json",
365:                 maxRetries: 0,
366:                 logging: {
367:                     level: "debug",
368:                     logger: mockLogger,
369:                     silent: false,
370:                 },
371:             });
372: 
373:             expect(mockLogger.debug).toHaveBeenCalledWith(
374:                 "Making HTTP request",
375:                 expect.objectContaining({
376:                     method: "GET",
377:                 }),
378:             );
379:         });
380: 
381:         it("should log POST requests", async () => {
382:             const mockLogger = createMockLogger();
383:             mockSuccessResponse({ data: "test" }, 201, "Created");
384: 
385:             await fetcherImpl({
386:                 url: "https://example.com/api",
387:                 method: "POST",
388:                 body: { data: "test" },
389:                 contentType: "application/json",
390:                 requestType: "json",
391:                 responseType: "json",
392:                 maxRetries: 0,
393:                 logging: {
394:                     level: "debug",
395:                     logger: mockLogger,
396:                     silent: false,
397:                 },
398:             });
399: 
400:             expect(mockLogger.debug).toHaveBeenCalledWith(
401:                 "Making HTTP request",
402:                 expect.objectContaining({
403:                     method: "POST",
404:                 }),
405:             );
406:         });
407: 
408:         it("should log PUT requests", async () => {
409:             const mockLogger = createMockLogger();
410:             mockSuccessResponse();
411: 
412:             await fetcherImpl({
413:                 url: "https://example.com/api",
414:                 method: "PUT",
415:                 body: { data: "test" },
416:                 contentType: "application/json",
417:                 requestType: "json",
418:                 responseType: "json",
419:                 maxRetries: 0,
420:                 logging: {
421:                     level: "debug",
422:                     logger: mockLogger,
423:                     silent: false,
424:                 },
425:             });
426: 
427:             expect(mockLogger.debug).toHaveBeenCalledWith(
428:                 "Making HTTP request",
429:                 expect.objectContaining({
430:                     method: "PUT",
431:                 }),
432:             );
433:         });
434: 
435:         it("should log DELETE requests", async () => {
436:             const mockLogger = createMockLogger();
437:             global.fetch = vi.fn().mockResolvedValue(
438:                 new Response(null, {
439:                     status: 200,
440:                     statusText: "OK",
441:                 }),
442:             );
443: 
444:             await fetcherImpl({
445:                 url: "https://example.com/api",
446:                 method: "DELETE",
447:                 responseType: "json",
448:                 maxRetries: 0,
449:                 logging: {
450:                     level: "debug",
451:                     logger: mockLogger,
452:                     silent: false,
453:                 },
454:             });
455: 
456:             expect(mockLogger.debug).toHaveBeenCalledWith(
457:                 "Making HTTP request",
458:                 expect.objectContaining({
459:                     method: "DELETE",
460:                 }),
461:             );
462:         });
463:     });
464: 
465:     describe("Status Code Logging", () => {
466:         it("should log 2xx success status codes", async () => {
467:             const mockLogger = createMockLogger();
468:             mockSuccessResponse({ data: "test" }, 201, "Created");
469: 
470:             await fetcherImpl({
471:                 url: "https://example.com/api",
472:                 method: "POST",
473:                 body: { data: "test" },
474:                 contentType: "application/json",
475:                 requestType: "json",
476:                 responseType: "json",
477:                 maxRetries: 0,
478:                 logging: {
479:                     level: "debug",
480:                     logger: mockLogger,
481:                     silent: false,
482:                 },
483:             });
484: 
485:             expect(mockLogger.debug).toHaveBeenCalledWith(
486:                 "HTTP request succeeded",
487:                 expect.objectContaining({
488:                     statusCode: 201,
489:                 }),
490:             );
491:         });
492: 
493:         it("should log 3xx redirect status codes as success", async () => {
494:             const mockLogger = createMockLogger();
495:             mockSuccessResponse({ data: "test" }, 301, "Moved Permanently");
496: 
497:             await fetcherImpl({
498:                 url: "https://example.com/api",
499:                 method: "GET",
500:                 responseType: "json",
501:                 maxRetries: 0,
502:                 logging: {
503:                     level: "debug",
504:                     logger: mockLogger,
505:                     silent: false,
506:                 },
507:             });
508: 
509:             expect(mockLogger.debug).toHaveBeenCalledWith(
510:                 "HTTP request succeeded",
511:                 expect.objectContaining({
512:                     statusCode: 301,
513:                 }),
514:             );
515:         });
516:     });
517: });
````

## File: tests/unit/fetcher/makeRequest.test.ts
````typescript
 1: import type { Mock } from "vitest";
 2: import { makeRequest } from "../../../src/core/fetcher/makeRequest";
 3: 
 4: describe("Test makeRequest", () => {
 5:     const mockPostUrl = "https://httpbin.org/post";
 6:     const mockGetUrl = "https://httpbin.org/get";
 7:     const mockHeaders = { "Content-Type": "application/json" };
 8:     const mockBody = JSON.stringify({ key: "value" });
 9: 
10:     let mockFetch: Mock;
11: 
12:     beforeEach(() => {
13:         mockFetch = vi.fn();
14:         mockFetch.mockResolvedValue(new Response(JSON.stringify({ test: "successful" }), { status: 200 }));
15:     });
16: 
17:     it("should handle POST request correctly", async () => {
18:         const response = await makeRequest(mockFetch, mockPostUrl, "POST", mockHeaders, mockBody);
19:         const responseBody = await response.json();
20:         expect(responseBody).toEqual({ test: "successful" });
21:         expect(mockFetch).toHaveBeenCalledTimes(1);
22:         const [calledUrl, calledOptions] = mockFetch.mock.calls[0];
23:         expect(calledUrl).toBe(mockPostUrl);
24:         expect(calledOptions).toEqual(
25:             expect.objectContaining({
26:                 method: "POST",
27:                 headers: mockHeaders,
28:                 body: mockBody,
29:                 credentials: undefined,
30:             }),
31:         );
32:         expect(calledOptions.signal).toBeDefined();
33:         expect(calledOptions.signal).toBeInstanceOf(AbortSignal);
34:     });
35: 
36:     it("should handle GET request correctly", async () => {
37:         const response = await makeRequest(mockFetch, mockGetUrl, "GET", mockHeaders, undefined);
38:         const responseBody = await response.json();
39:         expect(responseBody).toEqual({ test: "successful" });
40:         expect(mockFetch).toHaveBeenCalledTimes(1);
41:         const [calledUrl, calledOptions] = mockFetch.mock.calls[0];
42:         expect(calledUrl).toBe(mockGetUrl);
43:         expect(calledOptions).toEqual(
44:             expect.objectContaining({
45:                 method: "GET",
46:                 headers: mockHeaders,
47:                 body: undefined,
48:                 credentials: undefined,
49:             }),
50:         );
51:         expect(calledOptions.signal).toBeDefined();
52:         expect(calledOptions.signal).toBeInstanceOf(AbortSignal);
53:     });
54: });
````

## File: tests/unit/fetcher/RawResponse.test.ts
````typescript
 1: import { describe, expect, it } from "vitest";
 2: 
 3: import { toRawResponse } from "../../../src/core/fetcher/RawResponse";
 4: 
 5: describe("RawResponse", () => {
 6:     describe("toRawResponse", () => {
 7:         it("should convert Response to RawResponse by removing body, bodyUsed, and ok properties", () => {
 8:             const mockHeaders = new Headers({ "content-type": "application/json" });
 9:             const mockResponse = {
10:                 body: "test body",
11:                 bodyUsed: false,
12:                 ok: true,
13:                 headers: mockHeaders,
14:                 redirected: false,
15:                 status: 200,
16:                 statusText: "OK",
17:                 type: "basic" as ResponseType,
18:                 url: "https://example.com",
19:             };
20: 
21:             const result = toRawResponse(mockResponse as unknown as Response);
22: 
23:             expect("body" in result).toBe(false);
24:             expect("bodyUsed" in result).toBe(false);
25:             expect("ok" in result).toBe(false);
26:             expect(result.headers).toBe(mockHeaders);
27:             expect(result.redirected).toBe(false);
28:             expect(result.status).toBe(200);
29:             expect(result.statusText).toBe("OK");
30:             expect(result.type).toBe("basic");
31:             expect(result.url).toBe("https://example.com");
32:         });
33:     });
34: });
````

## File: tests/unit/fetcher/requestWithRetries.test.ts
````typescript
  1: import type { Mock, MockInstance } from "vitest";
  2: import { requestWithRetries } from "../../../src/core/fetcher/requestWithRetries";
  3: 
  4: describe("requestWithRetries", () => {
  5:     let mockFetch: Mock;
  6:     let originalMathRandom: typeof Math.random;
  7:     let setTimeoutSpy: MockInstance;
  8: 
  9:     beforeEach(() => {
 10:         mockFetch = vi.fn();
 11:         originalMathRandom = Math.random;
 12: 
 13:         Math.random = vi.fn(() => 0.5);
 14: 
 15:         vi.useFakeTimers({
 16:             toFake: [
 17:                 "setTimeout",
 18:                 "clearTimeout",
 19:                 "setInterval",
 20:                 "clearInterval",
 21:                 "setImmediate",
 22:                 "clearImmediate",
 23:                 "Date",
 24:                 "performance",
 25:                 "requestAnimationFrame",
 26:                 "cancelAnimationFrame",
 27:                 "requestIdleCallback",
 28:                 "cancelIdleCallback",
 29:             ],
 30:         });
 31:     });
 32: 
 33:     afterEach(() => {
 34:         Math.random = originalMathRandom;
 35:         vi.clearAllMocks();
 36:         vi.clearAllTimers();
 37:     });
 38: 
 39:     it("should retry on retryable status codes", async () => {
 40:         setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
 41:             process.nextTick(callback);
 42:             return null as any;
 43:         });
 44: 
 45:         const retryableStatuses = [408, 429, 500, 502];
 46:         let callCount = 0;
 47: 
 48:         mockFetch.mockImplementation(async () => {
 49:             if (callCount < retryableStatuses.length) {
 50:                 return new Response("", { status: retryableStatuses[callCount++] });
 51:             }
 52:             return new Response("", { status: 200 });
 53:         });
 54: 
 55:         const responsePromise = requestWithRetries(() => mockFetch(), retryableStatuses.length);
 56:         await vi.runAllTimersAsync();
 57:         const response = await responsePromise;
 58: 
 59:         expect(mockFetch).toHaveBeenCalledTimes(retryableStatuses.length + 1);
 60:         expect(response.status).toBe(200);
 61:     });
 62: 
 63:     it("should respect maxRetries limit", async () => {
 64:         setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
 65:             process.nextTick(callback);
 66:             return null as any;
 67:         });
 68: 
 69:         const maxRetries = 2;
 70:         mockFetch.mockResolvedValue(new Response("", { status: 500 }));
 71: 
 72:         const responsePromise = requestWithRetries(() => mockFetch(), maxRetries);
 73:         await vi.runAllTimersAsync();
 74:         const response = await responsePromise;
 75: 
 76:         expect(mockFetch).toHaveBeenCalledTimes(maxRetries + 1);
 77:         expect(response.status).toBe(500);
 78:     });
 79: 
 80:     it("should not retry on success status codes", async () => {
 81:         setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
 82:             process.nextTick(callback);
 83:             return null as any;
 84:         });
 85: 
 86:         const successStatuses = [200, 201, 202];
 87: 
 88:         for (const status of successStatuses) {
 89:             mockFetch.mockReset();
 90:             setTimeoutSpy.mockClear();
 91:             mockFetch.mockResolvedValueOnce(new Response("", { status }));
 92: 
 93:             const responsePromise = requestWithRetries(() => mockFetch(), 3);
 94:             await vi.runAllTimersAsync();
 95:             await responsePromise;
 96: 
 97:             expect(mockFetch).toHaveBeenCalledTimes(1);
 98:             expect(setTimeoutSpy).not.toHaveBeenCalled();
 99:         }
100:     });
101: 
102:     interface RetryHeaderTestCase {
103:         description: string;
104:         headerName: string;
105:         headerValue: string | (() => string);
106:         expectedDelayMin: number;
107:         expectedDelayMax: number;
108:     }
109: 
110:     const retryHeaderTests: RetryHeaderTestCase[] = [
111:         {
112:             description: "should respect retry-after header with seconds value",
113:             headerName: "retry-after",
114:             headerValue: "5",
115:             expectedDelayMin: 4000,
116:             expectedDelayMax: 6000,
117:         },
118:         {
119:             description: "should respect retry-after header with HTTP date value",
120:             headerName: "retry-after",
121:             headerValue: () => new Date(Date.now() + 3000).toUTCString(),
122:             expectedDelayMin: 2000,
123:             expectedDelayMax: 4000,
124:         },
125:         {
126:             description: "should respect x-ratelimit-reset header",
127:             headerName: "x-ratelimit-reset",
128:             headerValue: () => Math.floor((Date.now() + 4000) / 1000).toString(),
129:             expectedDelayMin: 3000,
130:             expectedDelayMax: 6000,
131:         },
132:     ];
133: 
134:     retryHeaderTests.forEach(({ description, headerName, headerValue, expectedDelayMin, expectedDelayMax }) => {
135:         it(description, async () => {
136:             setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
137:                 process.nextTick(callback);
138:                 return null as any;
139:             });
140: 
141:             const value = typeof headerValue === "function" ? headerValue() : headerValue;
142:             mockFetch
143:                 .mockResolvedValueOnce(
144:                     new Response("", {
145:                         status: 429,
146:                         headers: new Headers({ [headerName]: value }),
147:                     }),
148:                 )
149:                 .mockResolvedValueOnce(new Response("", { status: 200 }));
150: 
151:             const responsePromise = requestWithRetries(() => mockFetch(), 1);
152:             await vi.runAllTimersAsync();
153:             const response = await responsePromise;
154: 
155:             expect(setTimeoutSpy).toHaveBeenCalledWith(expect.any(Function), expect.any(Number));
156:             const actualDelay = setTimeoutSpy.mock.calls[0][1];
157:             expect(actualDelay).toBeGreaterThan(expectedDelayMin);
158:             expect(actualDelay).toBeLessThan(expectedDelayMax);
159:             expect(response.status).toBe(200);
160:         });
161:     });
162: 
163:     it("should apply correct exponential backoff with jitter", async () => {
164:         setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
165:             process.nextTick(callback);
166:             return null as any;
167:         });
168: 
169:         mockFetch.mockResolvedValue(new Response("", { status: 500 }));
170:         const maxRetries = 3;
171:         const expectedDelays = [1000, 2000, 4000];
172: 
173:         const responsePromise = requestWithRetries(() => mockFetch(), maxRetries);
174:         await vi.runAllTimersAsync();
175:         await responsePromise;
176: 
177:         expect(setTimeoutSpy).toHaveBeenCalledTimes(expectedDelays.length);
178: 
179:         expectedDelays.forEach((delay, index) => {
180:             expect(setTimeoutSpy).toHaveBeenNthCalledWith(index + 1, expect.any(Function), delay);
181:         });
182: 
183:         expect(mockFetch).toHaveBeenCalledTimes(maxRetries + 1);
184:     });
185: 
186:     it("should handle concurrent retries independently", async () => {
187:         setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
188:             process.nextTick(callback);
189:             return null as any;
190:         });
191: 
192:         mockFetch
193:             .mockResolvedValueOnce(new Response("", { status: 500 }))
194:             .mockResolvedValueOnce(new Response("", { status: 500 }))
195:             .mockResolvedValueOnce(new Response("", { status: 200 }))
196:             .mockResolvedValueOnce(new Response("", { status: 200 }));
197: 
198:         const promise1 = requestWithRetries(() => mockFetch(), 1);
199:         const promise2 = requestWithRetries(() => mockFetch(), 1);
200: 
201:         await vi.runAllTimersAsync();
202:         const [response1, response2] = await Promise.all([promise1, promise2]);
203: 
204:         expect(response1.status).toBe(200);
205:         expect(response2.status).toBe(200);
206:     });
207: 
208:     it("should cap delay at MAX_RETRY_DELAY for large header values", async () => {
209:         setTimeoutSpy = vi.spyOn(global, "setTimeout").mockImplementation((callback: (args: void) => void) => {
210:             process.nextTick(callback);
211:             return null as any;
212:         });
213: 
214:         mockFetch
215:             .mockResolvedValueOnce(
216:                 new Response("", {
217:                     status: 429,
218:                     headers: new Headers({ "retry-after": "120" }), // 120 seconds = 120000ms > MAX_RETRY_DELAY (60000ms)
219:                 }),
220:             )
221:             .mockResolvedValueOnce(new Response("", { status: 200 }));
222: 
223:         const responsePromise = requestWithRetries(() => mockFetch(), 1);
224:         await vi.runAllTimersAsync();
225:         const response = await responsePromise;
226: 
227:         expect(setTimeoutSpy).toHaveBeenCalledWith(expect.any(Function), 60000);
228:         expect(response.status).toBe(200);
229:     });
230: });
````

## File: tests/unit/fetcher/signals.test.ts
````typescript
 1: import { anySignal, getTimeoutSignal } from "../../../src/core/fetcher/signals";
 2: 
 3: describe("Test getTimeoutSignal", () => {
 4:     beforeEach(() => {
 5:         vi.useFakeTimers();
 6:     });
 7: 
 8:     afterEach(() => {
 9:         vi.useRealTimers();
10:     });
11: 
12:     it("should return an object with signal and abortId", () => {
13:         const { signal, abortId } = getTimeoutSignal(1000);
14: 
15:         expect(signal).toBeDefined();
16:         expect(abortId).toBeDefined();
17:         expect(signal).toBeInstanceOf(AbortSignal);
18:         expect(signal.aborted).toBe(false);
19:     });
20: 
21:     it("should create a signal that aborts after the specified timeout", () => {
22:         const timeoutMs = 5000;
23:         const { signal } = getTimeoutSignal(timeoutMs);
24: 
25:         expect(signal.aborted).toBe(false);
26: 
27:         vi.advanceTimersByTime(timeoutMs - 1);
28:         expect(signal.aborted).toBe(false);
29: 
30:         vi.advanceTimersByTime(1);
31:         expect(signal.aborted).toBe(true);
32:     });
33: });
34: 
35: describe("Test anySignal", () => {
36:     it("should return an AbortSignal", () => {
37:         const signal = anySignal(new AbortController().signal);
38:         expect(signal).toBeInstanceOf(AbortSignal);
39:     });
40: 
41:     it("should abort when any of the input signals is aborted", () => {
42:         const controller1 = new AbortController();
43:         const controller2 = new AbortController();
44:         const signal = anySignal(controller1.signal, controller2.signal);
45: 
46:         expect(signal.aborted).toBe(false);
47:         controller1.abort();
48:         expect(signal.aborted).toBe(true);
49:     });
50: 
51:     it("should handle an array of signals", () => {
52:         const controller1 = new AbortController();
53:         const controller2 = new AbortController();
54:         const signal = anySignal([controller1.signal, controller2.signal]);
55: 
56:         expect(signal.aborted).toBe(false);
57:         controller2.abort();
58:         expect(signal.aborted).toBe(true);
59:     });
60: 
61:     it("should abort immediately if one of the input signals is already aborted", () => {
62:         const controller1 = new AbortController();
63:         const controller2 = new AbortController();
64:         controller1.abort();
65: 
66:         const signal = anySignal(controller1.signal, controller2.signal);
67:         expect(signal.aborted).toBe(true);
68:     });
69: });
````

## File: tests/unit/fetcher/test-file.txt
````
1: This is a test file!
````

## File: tests/unit/file/file.test.ts
````typescript
  1: import fs from "fs";
  2: import { join } from "path";
  3: import { Readable } from "stream";
  4: import { toBinaryUploadRequest, Uploadable } from "../../../src/core/file/index";
  5: 
  6: let File = global.File;
  7: if (typeof File === "undefined") {
  8:     File = require("buffer").File;
  9: }
 10: 
 11: describe("toBinaryUploadRequest", () => {
 12:     const TEST_FILE_PATH = join(__dirname, "test-file.txt");
 13: 
 14:     beforeEach(() => {
 15:         vi.clearAllMocks();
 16:     });
 17: 
 18:     describe("Buffer input", () => {
 19:         it("should handle Buffer with all metadata", async () => {
 20:             const buffer = Buffer.from("test data");
 21:             const input: Uploadable.WithMetadata = {
 22:                 data: buffer,
 23:                 filename: "test.txt",
 24:                 contentType: "text/plain",
 25:                 contentLength: 42,
 26:             };
 27: 
 28:             const result = await toBinaryUploadRequest(input);
 29: 
 30:             expect(result.body).toBe(buffer);
 31:             expect(result.headers).toEqual({
 32:                 "Content-Disposition": 'attachment; filename="test.txt"',
 33:                 "Content-Type": "text/plain",
 34:                 "Content-Length": "42",
 35:             });
 36:         });
 37: 
 38:         it("should handle Buffer without metadata", async () => {
 39:             const buffer = Buffer.from("test data");
 40:             const input: Uploadable.WithMetadata = {
 41:                 data: buffer,
 42:             };
 43: 
 44:             const result = await toBinaryUploadRequest(input);
 45: 
 46:             expect(result.body).toBe(buffer);
 47:             expect(result.headers).toEqual({
 48:                 "Content-Length": "9", // buffer.length
 49:             });
 50:         });
 51: 
 52:         it("should handle Buffer passed directly", async () => {
 53:             const buffer = Buffer.from("test data");
 54: 
 55:             const result = await toBinaryUploadRequest(buffer);
 56: 
 57:             expect(result.body).toBe(buffer);
 58:             expect(result.headers).toEqual({
 59:                 "Content-Length": "9", // buffer.length
 60:             });
 61:         });
 62:     });
 63: 
 64:     describe("ArrayBuffer input", () => {
 65:         it("should handle ArrayBuffer with metadata", async () => {
 66:             const arrayBuffer = new ArrayBuffer(10);
 67:             const input: Uploadable.WithMetadata = {
 68:                 data: arrayBuffer,
 69:                 filename: "data.bin",
 70:                 contentType: "application/octet-stream",
 71:             };
 72: 
 73:             const result = await toBinaryUploadRequest(input);
 74: 
 75:             expect(result.body).toBe(arrayBuffer);
 76:             expect(result.headers).toEqual({
 77:                 "Content-Disposition": 'attachment; filename="data.bin"',
 78:                 "Content-Type": "application/octet-stream",
 79:                 "Content-Length": "10", // arrayBuffer.byteLength
 80:             });
 81:         });
 82: 
 83:         it("should handle ArrayBuffer passed directly", async () => {
 84:             const arrayBuffer = new ArrayBuffer(10);
 85: 
 86:             const result = await toBinaryUploadRequest(arrayBuffer);
 87: 
 88:             expect(result.body).toBe(arrayBuffer);
 89:             expect(result.headers).toEqual({
 90:                 "Content-Length": "10", // arrayBuffer.byteLength
 91:             });
 92:         });
 93:     });
 94: 
 95:     describe("Uint8Array input", () => {
 96:         it("should handle Uint8Array with metadata", async () => {
 97:             const uint8Array = new Uint8Array([1, 2, 3, 4, 5]);
 98:             const input: Uploadable.WithMetadata = {
 99:                 data: uint8Array,
100:                 filename: "bytes.bin",
101:                 contentType: "application/octet-stream",
102:             };
103: 
104:             const result = await toBinaryUploadRequest(input);
105: 
106:             expect(result.body).toBe(uint8Array);
107:             expect(result.headers).toEqual({
108:                 "Content-Disposition": 'attachment; filename="bytes.bin"',
109:                 "Content-Type": "application/octet-stream",
110:                 "Content-Length": "5", // uint8Array.byteLength
111:             });
112:         });
113: 
114:         it("should handle Uint8Array passed directly", async () => {
115:             const uint8Array = new Uint8Array([1, 2, 3, 4, 5]);
116: 
117:             const result = await toBinaryUploadRequest(uint8Array);
118: 
119:             expect(result.body).toBe(uint8Array);
120:             expect(result.headers).toEqual({
121:                 "Content-Length": "5", // uint8Array.byteLength
122:             });
123:         });
124:     });
125: 
126:     describe("Blob input", () => {
127:         it("should handle Blob with metadata", async () => {
128:             const blob = new Blob(["test content"], { type: "text/plain" });
129:             const input: Uploadable.WithMetadata = {
130:                 data: blob,
131:                 filename: "override.txt",
132:                 contentType: "text/html", // Override blob's type
133:             };
134: 
135:             const result = await toBinaryUploadRequest(input);
136: 
137:             expect(result.body).toBe(blob);
138:             expect(result.headers).toEqual({
139:                 "Content-Disposition": 'attachment; filename="override.txt"',
140:                 "Content-Type": "text/html", // Should use provided contentType
141:                 "Content-Length": "12", // blob.size
142:             });
143:         });
144: 
145:         it("should handle Blob with intrinsic type", async () => {
146:             const blob = new Blob(["test content"], { type: "application/json" });
147:             const input: Uploadable.WithMetadata = {
148:                 data: blob,
149:                 filename: "data.json",
150:             };
151: 
152:             const result = await toBinaryUploadRequest(input);
153: 
154:             expect(result.body).toBe(blob);
155:             expect(result.headers).toEqual({
156:                 "Content-Disposition": 'attachment; filename="data.json"',
157:                 "Content-Type": "application/json", // Should use blob's type
158:                 "Content-Length": "12", // blob.size
159:             });
160:         });
161: 
162:         it("should handle Blob passed directly", async () => {
163:             const blob = new Blob(["test content"], { type: "text/plain" });
164: 
165:             const result = await toBinaryUploadRequest(blob);
166: 
167:             expect(result.body).toBe(blob);
168:             expect(result.headers).toEqual({
169:                 "Content-Type": "text/plain", // Should use blob's type
170:                 "Content-Length": "12", // blob.size
171:             });
172:         });
173:     });
174: 
175:     describe("File input", () => {
176:         it("should handle File with metadata", async () => {
177:             const file = new File(["file content"], "original.txt", { type: "text/plain" });
178:             const input: Uploadable.WithMetadata = {
179:                 data: file,
180:                 filename: "renamed.txt",
181:                 contentType: "text/html", // Override file's type
182:             };
183: 
184:             const result = await toBinaryUploadRequest(input);
185: 
186:             expect(result.body).toBe(file);
187:             expect(result.headers).toEqual({
188:                 "Content-Disposition": 'attachment; filename="renamed.txt"',
189:                 "Content-Type": "text/html", // Should use provided contentType
190:                 "Content-Length": "12", // file.size
191:             });
192:         });
193: 
194:         it("should handle File with intrinsic properties", async () => {
195:             const file = new File(["file content"], "test.json", { type: "application/json" });
196:             const input: Uploadable.WithMetadata = {
197:                 data: file,
198:             };
199: 
200:             const result = await toBinaryUploadRequest(input);
201: 
202:             expect(result.body).toBe(file);
203:             expect(result.headers).toEqual({
204:                 "Content-Disposition": 'attachment; filename="test.json"', // Should use file's name
205:                 "Content-Type": "application/json", // Should use file's type
206:                 "Content-Length": "12", // file.size
207:             });
208:         });
209: 
210:         it("should handle File passed directly", async () => {
211:             const file = new File(["file content"], "direct.txt", { type: "text/plain" });
212: 
213:             const result = await toBinaryUploadRequest(file);
214: 
215:             expect(result.body).toBe(file);
216:             expect(result.headers).toEqual({
217:                 "Content-Disposition": 'attachment; filename="direct.txt"',
218:                 "Content-Type": "text/plain",
219:                 "Content-Length": "12", // file.size
220:             });
221:         });
222:     });
223: 
224:     describe("ReadableStream input", () => {
225:         it("should handle ReadableStream with metadata", async () => {
226:             const stream = new ReadableStream({
227:                 start(controller) {
228:                     controller.enqueue(new TextEncoder().encode("stream data"));
229:                     controller.close();
230:                 },
231:             });
232:             const input: Uploadable.WithMetadata = {
233:                 data: stream,
234:                 filename: "stream.txt",
235:                 contentType: "text/plain",
236:                 contentLength: 100,
237:             };
238: 
239:             const result = await toBinaryUploadRequest(input);
240: 
241:             expect(result.body).toBe(stream);
242:             expect(result.headers).toEqual({
243:                 "Content-Disposition": 'attachment; filename="stream.txt"',
244:                 "Content-Type": "text/plain",
245:                 "Content-Length": "100", // Should use provided contentLength
246:             });
247:         });
248: 
249:         it("should handle ReadableStream without size", async () => {
250:             const stream = new ReadableStream({
251:                 start(controller) {
252:                     controller.enqueue(new TextEncoder().encode("stream data"));
253:                     controller.close();
254:                 },
255:             });
256:             const input: Uploadable.WithMetadata = {
257:                 data: stream,
258:                 filename: "stream.txt",
259:                 contentType: "text/plain",
260:             };
261: 
262:             const result = await toBinaryUploadRequest(input);
263: 
264:             expect(result.body).toBe(stream);
265:             expect(result.headers).toEqual({
266:                 "Content-Disposition": 'attachment; filename="stream.txt"',
267:                 "Content-Type": "text/plain",
268:                 // No Content-Length header since it cannot be determined from ReadableStream
269:             });
270:         });
271: 
272:         it("should handle ReadableStream passed directly", async () => {
273:             const stream = new ReadableStream({
274:                 start(controller) {
275:                     controller.enqueue(new TextEncoder().encode("stream data"));
276:                     controller.close();
277:                 },
278:             });
279: 
280:             const result = await toBinaryUploadRequest(stream);
281: 
282:             expect(result.body).toBe(stream);
283:             expect(result.headers).toEqual({
284:                 // No headers since no metadata provided and cannot be determined
285:             });
286:         });
287:     });
288: 
289:     describe("Node.js Readable stream input", () => {
290:         it("should handle Readable stream with metadata", async () => {
291:             const readable = new Readable({
292:                 read() {
293:                     this.push("readable data");
294:                     this.push(null);
295:                 },
296:             });
297:             const input: Uploadable.WithMetadata = {
298:                 data: readable,
299:                 filename: "readable.txt",
300:                 contentType: "text/plain",
301:                 contentLength: 50,
302:             };
303: 
304:             const result = await toBinaryUploadRequest(input);
305: 
306:             expect(result.body).toBe(readable);
307:             expect(result.headers).toEqual({
308:                 "Content-Disposition": 'attachment; filename="readable.txt"',
309:                 "Content-Type": "text/plain",
310:                 "Content-Length": "50", // Should use provided contentLength
311:             });
312:         });
313: 
314:         it("should handle Readable stream without size", async () => {
315:             const readable = new Readable({
316:                 read() {
317:                     this.push("readable data");
318:                     this.push(null);
319:                 },
320:             });
321:             const input: Uploadable.WithMetadata = {
322:                 data: readable,
323:                 filename: "readable.txt",
324:                 contentType: "text/plain",
325:             };
326: 
327:             const result = await toBinaryUploadRequest(input);
328: 
329:             expect(result.body).toBe(readable);
330:             expect(result.headers).toEqual({
331:                 "Content-Disposition": 'attachment; filename="readable.txt"',
332:                 "Content-Type": "text/plain",
333:                 // No Content-Length header since it cannot be determined from Readable
334:             });
335:         });
336: 
337:         it("should handle Readable stream passed directly", async () => {
338:             const readable = new Readable({
339:                 read() {
340:                     this.push("readable data");
341:                     this.push(null);
342:                 },
343:             });
344: 
345:             const result = await toBinaryUploadRequest(readable);
346: 
347:             expect(result.body).toBe(readable);
348:             expect(result.headers).toEqual({
349:                 // No headers since no metadata provided and cannot be determined
350:             });
351:         });
352:     });
353: 
354:     describe("File path input (FromPath type)", () => {
355:         it("should handle file path with all metadata", async () => {
356:             const input: Uploadable.FromPath = {
357:                 path: TEST_FILE_PATH,
358:                 filename: "custom.txt",
359:                 contentType: "text/html",
360:                 contentLength: 42,
361:             };
362: 
363:             const result = await toBinaryUploadRequest(input);
364: 
365:             expect(result.body).toBeInstanceOf(fs.ReadStream);
366:             expect(result.headers).toEqual({
367:                 "Content-Disposition": 'attachment; filename="custom.txt"',
368:                 "Content-Type": "text/html",
369:                 "Content-Length": "42", // Should use provided contentLength
370:             });
371:         });
372: 
373:         it("should handle file path with minimal metadata", async () => {
374:             const input: Uploadable.FromPath = {
375:                 path: TEST_FILE_PATH,
376:                 contentType: "text/plain",
377:             };
378: 
379:             const result = await toBinaryUploadRequest(input);
380: 
381:             expect(result.body).toBeInstanceOf(fs.ReadStream);
382:             expect(result.headers).toEqual({
383:                 "Content-Disposition": 'attachment; filename="test-file.txt"', // Should extract from path
384:                 "Content-Type": "text/plain",
385:                 "Content-Length": "21", // Should determine from file system (test file is 21 bytes)
386:             });
387:         });
388: 
389:         it("should handle file path with no metadata", async () => {
390:             const input: Uploadable.FromPath = {
391:                 path: TEST_FILE_PATH,
392:             };
393: 
394:             const result = await toBinaryUploadRequest(input);
395: 
396:             expect(result.body).toBeInstanceOf(fs.ReadStream);
397:             expect(result.headers).toEqual({
398:                 "Content-Disposition": 'attachment; filename="test-file.txt"', // Should extract from path
399:                 "Content-Length": "21", // Should determine from file system (test file is 21 bytes)
400:             });
401:         });
402: 
403:         it("should handle Windows-style paths", async () => {
404:             const input: Uploadable.FromPath = {
405:                 path: "C:\\Users\\test\\file.txt",
406:             };
407: 
408:             // Mock fs methods to avoid actual file system access
409:             const mockStats = { size: 123 };
410:             const mockReadStream = {} as fs.ReadStream;
411: 
412:             // Mock the dynamic import of fs
413:             vi.doMock("fs", () => ({
414:                 createReadStream: vi.fn().mockReturnValue(mockReadStream),
415:                 promises: {
416:                     stat: vi.fn().mockResolvedValue(mockStats),
417:                 },
418:             }));
419: 
420:             const result = await toBinaryUploadRequest(input);
421: 
422:             expect(result.body).toBe(mockReadStream);
423:             expect(result.headers).toEqual({
424:                 "Content-Disposition": 'attachment; filename="file.txt"', // Should extract from Windows path
425:                 "Content-Length": "123",
426:             });
427: 
428:             // Clear the mock
429:             vi.doUnmock("fs");
430:         });
431: 
432:         it("should handle file path when fs is not available", async () => {
433:             const input: Uploadable.FromPath = {
434:                 path: TEST_FILE_PATH,
435:             };
436: 
437:             // Mock import to simulate environment without fs
438:             vi.doMock("fs", () => ({
439:                 createReadStream: undefined,
440:             }));
441: 
442:             await expect(toBinaryUploadRequest(input)).rejects.toThrow(
443:                 "File path uploads are not supported in this environment.",
444:             );
445: 
446:             // Clear the mock
447:             vi.doUnmock("fs");
448:         });
449:     });
450: 
451:     describe("ArrayBufferView input", () => {
452:         it("should handle ArrayBufferView with metadata", async () => {
453:             const arrayBuffer = new ArrayBuffer(10);
454:             const arrayBufferView = new Int8Array(arrayBuffer);
455:             const input: Uploadable.WithMetadata = {
456:                 data: arrayBufferView,
457:                 filename: "view.bin",
458:                 contentType: "application/octet-stream",
459:             };
460: 
461:             const result = await toBinaryUploadRequest(input);
462: 
463:             expect(result.body).toBe(arrayBufferView);
464:             expect(result.headers).toEqual({
465:                 "Content-Disposition": 'attachment; filename="view.bin"',
466:                 "Content-Type": "application/octet-stream",
467:                 "Content-Length": "10", // arrayBufferView.byteLength
468:             });
469:         });
470: 
471:         it("should handle ArrayBufferView passed directly", async () => {
472:             const arrayBuffer = new ArrayBuffer(10);
473:             const arrayBufferView = new Int8Array(arrayBuffer);
474: 
475:             const result = await toBinaryUploadRequest(arrayBufferView);
476: 
477:             expect(result.body).toBe(arrayBufferView);
478:             expect(result.headers).toEqual({
479:                 "Content-Length": "10", // arrayBufferView.byteLength
480:             });
481:         });
482:     });
483: 
484:     describe("Edge cases", () => {
485:         it("should handle empty headers when no metadata is available", async () => {
486:             const buffer = Buffer.from("");
487:             const input: Uploadable.WithMetadata = {
488:                 data: buffer,
489:             };
490: 
491:             const result = await toBinaryUploadRequest(input);
492: 
493:             expect(result.body).toBe(buffer);
494:             expect(result.headers).toEqual({
495:                 "Content-Length": "0",
496:             });
497:         });
498: 
499:         it("should handle zero contentLength", async () => {
500:             const buffer = Buffer.from("test");
501:             const input: Uploadable.WithMetadata = {
502:                 data: buffer,
503:                 contentLength: 0,
504:             };
505: 
506:             const result = await toBinaryUploadRequest(input);
507: 
508:             expect(result.body).toBe(buffer);
509:             expect(result.headers).toEqual({
510:                 "Content-Length": "0", // Should use provided 0
511:             });
512:         });
513: 
514:         it("should handle null filename", async () => {
515:             const buffer = Buffer.from("test");
516:             const input: Uploadable.WithMetadata = {
517:                 data: buffer,
518:                 filename: undefined,
519:                 contentType: "text/plain",
520:             };
521: 
522:             const result = await toBinaryUploadRequest(input);
523: 
524:             expect(result.body).toBe(buffer);
525:             expect(result.headers).toEqual({
526:                 "Content-Type": "text/plain",
527:                 "Content-Length": "4",
528:                 // No Content-Disposition since filename is undefined
529:             });
530:         });
531: 
532:         it("should handle null contentType", async () => {
533:             const buffer = Buffer.from("test");
534:             const input: Uploadable.WithMetadata = {
535:                 data: buffer,
536:                 filename: "test.txt",
537:                 contentType: undefined,
538:             };
539: 
540:             const result = await toBinaryUploadRequest(input);
541: 
542:             expect(result.body).toBe(buffer);
543:             expect(result.headers).toEqual({
544:                 "Content-Disposition": 'attachment; filename="test.txt"',
545:                 "Content-Length": "4",
546:                 // No Content-Type since contentType is undefined
547:             });
548:         });
549:     });
550: });
````

## File: tests/unit/file/test-file.txt
````
1: This is a test file!
````

## File: tests/unit/form-data-utils/encodeAsFormParameter.test.ts
````typescript
  1: import { encodeAsFormParameter } from "../../../src/core/form-data-utils/encodeAsFormParameter";
  2: 
  3: describe("encodeAsFormParameter", () => {
  4:     describe("Basic functionality", () => {
  5:         it("should return empty object for null/undefined", () => {
  6:             expect(encodeAsFormParameter(null)).toEqual({});
  7:             expect(encodeAsFormParameter(undefined)).toEqual({});
  8:         });
  9: 
 10:         it("should return empty object for primitive values", () => {
 11:             expect(encodeAsFormParameter("hello")).toEqual({});
 12:             expect(encodeAsFormParameter(42)).toEqual({});
 13:             expect(encodeAsFormParameter(true)).toEqual({});
 14:         });
 15: 
 16:         it("should handle simple key-value pairs", () => {
 17:             const obj = { name: "John", age: 30 };
 18:             expect(encodeAsFormParameter(obj)).toEqual({
 19:                 name: "John",
 20:                 age: "30",
 21:             });
 22:         });
 23: 
 24:         it("should handle empty objects", () => {
 25:             expect(encodeAsFormParameter({})).toEqual({});
 26:         });
 27:     });
 28: 
 29:     describe("Array handling", () => {
 30:         it("should handle arrays with indices format (default)", () => {
 31:             const obj = { items: ["a", "b", "c"] };
 32:             expect(encodeAsFormParameter(obj)).toEqual({
 33:                 "items[0]": "a",
 34:                 "items[1]": "b",
 35:                 "items[2]": "c",
 36:             });
 37:         });
 38: 
 39:         it("should handle empty arrays", () => {
 40:             const obj = { items: [] };
 41:             expect(encodeAsFormParameter(obj)).toEqual({});
 42:         });
 43: 
 44:         it("should handle arrays with mixed types", () => {
 45:             const obj = { mixed: ["string", 42, true, false] };
 46:             expect(encodeAsFormParameter(obj)).toEqual({
 47:                 "mixed[0]": "string",
 48:                 "mixed[1]": "42",
 49:                 "mixed[2]": "true",
 50:                 "mixed[3]": "false",
 51:             });
 52:         });
 53: 
 54:         it("should handle arrays with objects", () => {
 55:             const obj = { users: [{ name: "John" }, { name: "Jane" }] };
 56:             expect(encodeAsFormParameter(obj)).toEqual({
 57:                 "users[0][name]": "John",
 58:                 "users[1][name]": "Jane",
 59:             });
 60:         });
 61: 
 62:         it("should handle arrays with null/undefined values", () => {
 63:             const obj = { items: ["a", null, "c", undefined, "e"] };
 64:             expect(encodeAsFormParameter(obj)).toEqual({
 65:                 "items[0]": "a",
 66:                 "items[1]": "",
 67:                 "items[2]": "c",
 68:                 "items[4]": "e",
 69:             });
 70:         });
 71:     });
 72: 
 73:     describe("Nested objects", () => {
 74:         it("should handle nested objects", () => {
 75:             const obj = { user: { name: "John", age: 30 } };
 76:             expect(encodeAsFormParameter(obj)).toEqual({
 77:                 "user[name]": "John",
 78:                 "user[age]": "30",
 79:             });
 80:         });
 81: 
 82:         it("should handle deeply nested objects", () => {
 83:             const obj = { user: { profile: { name: "John", settings: { theme: "dark" } } } };
 84:             expect(encodeAsFormParameter(obj)).toEqual({
 85:                 "user[profile][name]": "John",
 86:                 "user[profile][settings][theme]": "dark",
 87:             });
 88:         });
 89: 
 90:         it("should handle empty nested objects", () => {
 91:             const obj = { user: {} };
 92:             expect(encodeAsFormParameter(obj)).toEqual({});
 93:         });
 94:     });
 95: 
 96:     describe("Special characters and encoding", () => {
 97:         it("should not encode values (encode: false is used)", () => {
 98:             const obj = { name: "John Doe", email: "john@example.com" };
 99:             expect(encodeAsFormParameter(obj)).toEqual({
100:                 name: "John Doe",
101:                 email: "john@example.com",
102:             });
103:         });
104: 
105:         it("should not encode special characters in keys", () => {
106:             const obj = { "user name": "John", "email[primary]": "john@example.com" };
107:             expect(encodeAsFormParameter(obj)).toEqual({
108:                 "user name": "John",
109:                 "email[primary]": "john@example.com",
110:             });
111:         });
112: 
113:         it("should handle values that contain special characters", () => {
114:             const obj = {
115:                 query: "search term with spaces",
116:                 filter: "category:electronics",
117:             };
118:             expect(encodeAsFormParameter(obj)).toEqual({
119:                 query: "search term with spaces",
120:                 filter: "category:electronics",
121:             });
122:         });
123: 
124:         it("should handle ampersand and equals characters (edge case)", () => {
125:             // Note: Values containing & and = may be problematic because
126:             // encodeAsFormParameter splits on these characters when parsing the stringified result
127:             const obj = {
128:                 message: "Hello & welcome",
129:                 equation: "x = y + z",
130:             };
131:             // This demonstrates the limitation - ampersands and equals signs in values
132:             // will cause the parameter to be split incorrectly
133:             const result = encodeAsFormParameter(obj);
134: 
135:             // We expect this to be parsed incorrectly due to the implementation
136:             expect(result.message).toBe("Hello ");
137:             expect(result[" welcome"]).toBeUndefined();
138:             expect(result.equation).toBe("x ");
139:             expect(result[" y + z"]).toBeUndefined();
140:         });
141:     });
142: 
143:     describe("Form data specific scenarios", () => {
144:         it("should handle file upload metadata", () => {
145:             const metadata = {
146:                 file: {
147:                     name: "document.pdf",
148:                     size: 1024,
149:                     type: "application/pdf",
150:                 },
151:                 options: {
152:                     compress: true,
153:                     quality: 0.8,
154:                 },
155:             };
156:             expect(encodeAsFormParameter(metadata)).toEqual({
157:                 "file[name]": "document.pdf",
158:                 "file[size]": "1024",
159:                 "file[type]": "application/pdf",
160:                 "options[compress]": "true",
161:                 "options[quality]": "0.8",
162:             });
163:         });
164: 
165:         it("should handle form validation data", () => {
166:             const formData = {
167:                 fields: ["name", "email", "phone"],
168:                 validation: {
169:                     required: ["name", "email"],
170:                     patterns: {
171:                         email: "^[^@]+@[^@]+\\.[^@]+$",
172:                         phone: "^\\+?[1-9]\\d{1,14}$",
173:                     },
174:                 },
175:             };
176:             expect(encodeAsFormParameter(formData)).toEqual({
177:                 "fields[0]": "name",
178:                 "fields[1]": "email",
179:                 "fields[2]": "phone",
180:                 "validation[required][0]": "name",
181:                 "validation[required][1]": "email",
182:                 "validation[patterns][email]": "^[^@]+@[^@]+\\.[^@]+$",
183:                 "validation[patterns][phone]": "^\\+?[1-9]\\d{1,14}$",
184:             });
185:         });
186: 
187:         it("should handle search/filter parameters", () => {
188:             const searchParams = {
189:                 filters: {
190:                     status: ["active", "pending"],
191:                     category: {
192:                         type: "electronics",
193:                         subcategories: ["phones", "laptops"],
194:                     },
195:                 },
196:                 sort: { field: "name", direction: "asc" },
197:                 pagination: { page: 1, limit: 20 },
198:             };
199:             expect(encodeAsFormParameter(searchParams)).toEqual({
200:                 "filters[status][0]": "active",
201:                 "filters[status][1]": "pending",
202:                 "filters[category][type]": "electronics",
203:                 "filters[category][subcategories][0]": "phones",
204:                 "filters[category][subcategories][1]": "laptops",
205:                 "sort[field]": "name",
206:                 "sort[direction]": "asc",
207:                 "pagination[page]": "1",
208:                 "pagination[limit]": "20",
209:             });
210:         });
211:     });
212: 
213:     describe("Edge cases", () => {
214:         it("should handle boolean values", () => {
215:             const obj = { enabled: true, disabled: false };
216:             expect(encodeAsFormParameter(obj)).toEqual({
217:                 enabled: "true",
218:                 disabled: "false",
219:             });
220:         });
221: 
222:         it("should handle empty strings", () => {
223:             const obj = { name: "", description: "test" };
224:             expect(encodeAsFormParameter(obj)).toEqual({
225:                 name: "",
226:                 description: "test",
227:             });
228:         });
229: 
230:         it("should handle zero values", () => {
231:             const obj = { count: 0, price: 0.0 };
232:             expect(encodeAsFormParameter(obj)).toEqual({
233:                 count: "0",
234:                 price: "0",
235:             });
236:         });
237: 
238:         it("should handle numeric keys", () => {
239:             const obj = { "0": "zero", "1": "one" };
240:             expect(encodeAsFormParameter(obj)).toEqual({
241:                 "0": "zero",
242:                 "1": "one",
243:             });
244:         });
245: 
246:         it("should handle objects with null/undefined values", () => {
247:             const obj = { name: "John", age: null, email: undefined, active: true };
248:             expect(encodeAsFormParameter(obj)).toEqual({
249:                 name: "John",
250:                 age: "",
251:                 active: "true",
252:             });
253:         });
254:     });
255: 
256:     describe("Integration with form submission", () => {
257:         it("should produce form-compatible key-value pairs", () => {
258:             const formObject = {
259:                 username: "john_doe",
260:                 preferences: {
261:                     theme: "dark",
262:                     notifications: ["email", "push"],
263:                     settings: {
264:                         autoSave: true,
265:                         timeout: 300,
266:                     },
267:                 },
268:             };
269: 
270:             const result = encodeAsFormParameter(formObject);
271: 
272:             // Verify all values are strings (as required for form data)
273:             Object.values(result).forEach((value) => {
274:                 expect(typeof value).toBe("string");
275:             });
276: 
277:             // Verify the structure can be reconstructed
278:             expect(result).toEqual({
279:                 username: "john_doe",
280:                 "preferences[theme]": "dark",
281:                 "preferences[notifications][0]": "email",
282:                 "preferences[notifications][1]": "push",
283:                 "preferences[settings][autoSave]": "true",
284:                 "preferences[settings][timeout]": "300",
285:             });
286:         });
287: 
288:         it("should handle complex nested arrays for API parameters", () => {
289:             const apiParams = {
290:                 query: {
291:                     filters: [
292:                         { field: "status", operator: "eq", value: "active" },
293:                         { field: "created", operator: "gte", value: "2023-01-01" },
294:                     ],
295:                     sort: [
296:                         { field: "name", direction: "asc" },
297:                         { field: "created", direction: "desc" },
298:                     ],
299:                 },
300:             };
301: 
302:             const result = encodeAsFormParameter(apiParams);
303:             expect(result).toEqual({
304:                 "query[filters][0][field]": "status",
305:                 "query[filters][0][operator]": "eq",
306:                 "query[filters][0][value]": "active",
307:                 "query[filters][1][field]": "created",
308:                 "query[filters][1][operator]": "gte",
309:                 "query[filters][1][value]": "2023-01-01",
310:                 "query[sort][0][field]": "name",
311:                 "query[sort][0][direction]": "asc",
312:                 "query[sort][1][field]": "created",
313:                 "query[sort][1][direction]": "desc",
314:             });
315:         });
316:     });
317: 
318:     describe("Error cases and malformed input", () => {
319:         it("should handle circular references gracefully", () => {
320:             const obj: any = { name: "test" };
321:             obj.self = obj;
322: 
323:             // This will throw a RangeError due to stack overflow - this is expected behavior
324:             expect(() => encodeAsFormParameter(obj)).toThrow("Maximum call stack size exceeded");
325:         });
326: 
327:         it("should handle very deeply nested objects", () => {
328:             let deepObj: any = { value: "deep" };
329:             for (let i = 0; i < 100; i++) {
330:                 deepObj = { level: deepObj };
331:             }
332: 
333:             expect(() => encodeAsFormParameter(deepObj)).not.toThrow();
334:             const result = encodeAsFormParameter(deepObj);
335:             expect(Object.keys(result).length).toBeGreaterThan(0);
336:         });
337: 
338:         it("should handle empty string splitting edge case", () => {
339:             // Test what happens when qs returns an empty string
340:             const result = encodeAsFormParameter({});
341:             expect(result).toEqual({});
342:         });
343:     });
344: });
````

## File: tests/unit/form-data-utils/formDataWrapper.test.ts
````typescript
  1: import { Blob, File } from "buffer";
  2: import { join } from "path";
  3: /* eslint-disable @typescript-eslint/ban-ts-comment */
  4: import { Readable } from "stream";
  5: import { FormDataWrapper, newFormData } from "../../../src/core/form-data-utils/FormDataWrapper";
  6: 
  7: // Helper function to serialize FormData to string for inspection
  8: async function serializeFormData(formData: FormData): Promise<string> {
  9:     const request = new Request("http://localhost", {
 10:         method: "POST",
 11:         body: formData,
 12:     });
 13: 
 14:     const buffer = await request.arrayBuffer();
 15:     return new TextDecoder().decode(buffer);
 16: }
 17: 
 18: describe("FormDataWrapper", () => {
 19:     let formData: FormDataWrapper;
 20: 
 21:     beforeEach(async () => {
 22:         formData = new FormDataWrapper();
 23:         await formData.setup();
 24:     });
 25: 
 26:     it("Upload file by path", async () => {
 27:         await formData.appendFile("file", {
 28:             path: join(__dirname, "..", "test-file.txt"),
 29:         });
 30: 
 31:         const serialized = await serializeFormData(formData.getRequest().body);
 32: 
 33:         expect(serialized).toContain('Content-Disposition: form-data; name="file"');
 34:         expect(serialized).toContain('filename="test-file.txt"');
 35:         expect(serialized).toContain("This is a test file!");
 36:     });
 37: 
 38:     it("Upload file by path with filename", async () => {
 39:         await formData.appendFile("file", {
 40:             path: join(__dirname, "..", "test-file.txt"),
 41:             filename: "custom-file.txt",
 42:         });
 43: 
 44:         const serialized = await serializeFormData(formData.getRequest().body);
 45: 
 46:         expect(serialized).toContain('Content-Disposition: form-data; name="file"');
 47:         expect(serialized).toContain('filename="custom-file.txt"');
 48:         expect(serialized).toContain("This is a test file!");
 49:     });
 50: 
 51:     describe("Stream handling", () => {
 52:         it("serializes Node.js Readable stream with filename", async () => {
 53:             const stream = Readable.from(["file content"]);
 54:             await formData.appendFile("file", {
 55:                 data: stream,
 56:                 filename: "testfile.txt",
 57:             });
 58: 
 59:             const serialized = await serializeFormData(formData.getRequest().body);
 60: 
 61:             expect(serialized).toContain('Content-Disposition: form-data; name="file"');
 62:             expect(serialized).toContain('filename="testfile.txt"');
 63:             expect(serialized).toContain("file content");
 64:         });
 65: 
 66:         it("auto-detects filename from stream path property", async () => {
 67:             const stream = Readable.from(["file content"]);
 68:             (stream as { path?: string }).path = "/test/path/testfile.txt";
 69: 
 70:             await formData.appendFile("file", stream);
 71: 
 72:             const serialized = await serializeFormData(formData.getRequest().body);
 73:             expect(serialized).toContain('filename="testfile.txt"');
 74:         });
 75: 
 76:         it("handles Windows-style paths", async () => {
 77:             const stream = Readable.from(["file content"]);
 78:             (stream as { path?: string }).path = "C:\\test\\path\\testfile.txt";
 79: 
 80:             await formData.appendFile("file", stream);
 81: 
 82:             const serialized = await serializeFormData(formData.getRequest().body);
 83:             expect(serialized).toContain('filename="testfile.txt"');
 84:         });
 85: 
 86:         it("handles empty streams", async () => {
 87:             const stream = Readable.from([]);
 88:             await formData.appendFile("file", {
 89:                 data: stream,
 90:                 filename: "empty.txt",
 91:             });
 92: 
 93:             const serialized = await serializeFormData(formData.getRequest().body);
 94:             expect(serialized).toContain('filename="empty.txt"');
 95:             expect(serialized).toMatch(/------formdata-undici-\w+|------WebKitFormBoundary\w+/);
 96:         });
 97: 
 98:         it("serializes Web ReadableStream with filename", async () => {
 99:             const stream = new ReadableStream({
100:                 start(controller) {
101:                     controller.enqueue(new TextEncoder().encode("web stream content"));
102:                     controller.close();
103:                 },
104:             });
105: 
106:             await formData.appendFile("file", {
107:                 data: stream,
108:                 filename: "webstream.txt",
109:             });
110: 
111:             const serialized = await serializeFormData(formData.getRequest().body);
112:             expect(serialized).toContain('filename="webstream.txt"');
113:             expect(serialized).toContain("web stream content");
114:         });
115: 
116:         it("handles empty Web ReadableStream", async () => {
117:             const stream = new ReadableStream({
118:                 start(controller) {
119:                     controller.close();
120:                 },
121:             });
122: 
123:             await formData.appendFile("file", {
124:                 data: stream,
125:                 filename: "empty.txt",
126:             });
127: 
128:             const serialized = await serializeFormData(formData.getRequest().body);
129:             expect(serialized).toContain('filename="empty.txt"');
130:             expect(serialized).toMatch(/------formdata-undici-\w+|------WebKitFormBoundary\w+/);
131:         });
132:     });
133: 
134:     describe("Blob and File types", () => {
135:         it("serializes Blob with specified filename", async () => {
136:             const blob = new Blob(["file content"], { type: "text/plain" });
137:             await formData.appendFile("file", {
138:                 data: blob,
139:                 filename: "testfile.txt",
140:             });
141: 
142:             const serialized = await serializeFormData(formData.getRequest().body);
143:             expect(serialized).toContain('filename="testfile.txt"');
144:             expect(serialized).toContain("Content-Type: text/plain");
145:             expect(serialized).toContain("file content");
146:         });
147: 
148:         it("uses default filename for Blob without explicit filename", async () => {
149:             const blob = new Blob(["file content"], { type: "text/plain" });
150:             await formData.appendFile("file", blob);
151: 
152:             const serialized = await serializeFormData(formData.getRequest().body);
153:             expect(serialized).toContain('filename="blob"');
154:         });
155: 
156:         it("preserves File object filename", async () => {
157:             if (typeof File !== "undefined") {
158:                 const file = new File(["file content"], "original.txt", { type: "text/plain" });
159:                 await formData.appendFile("file", file);
160: 
161:                 const serialized = await serializeFormData(formData.getRequest().body);
162:                 expect(serialized).toContain('filename="original.txt"');
163:                 expect(serialized).toContain("file content");
164:             }
165:         });
166: 
167:         it("allows filename override for File objects", async () => {
168:             if (typeof File !== "undefined") {
169:                 const file = new File(["file content"], "original.txt", { type: "text/plain" });
170:                 await formData.appendFile("file", {
171:                     data: file,
172:                     filename: "override.txt",
173:                 });
174: 
175:                 const serialized = await serializeFormData(formData.getRequest().body);
176:                 expect(serialized).toContain('filename="override.txt"');
177:                 expect(serialized).not.toContain('filename="original.txt"');
178:             }
179:         });
180:     });
181: 
182:     describe("Binary data types", () => {
183:         it("serializes ArrayBuffer with filename", async () => {
184:             const arrayBuffer = new ArrayBuffer(8);
185:             new Uint8Array(arrayBuffer).set([1, 2, 3, 4, 5, 6, 7, 8]);
186: 
187:             await formData.appendFile("file", {
188:                 data: arrayBuffer,
189:                 filename: "binary.bin",
190:             });
191: 
192:             const serialized = await serializeFormData(formData.getRequest().body);
193:             expect(serialized).toContain('filename="binary.bin"');
194:             expect(serialized).toMatch(/------formdata-undici-\w+|------WebKitFormBoundary\w+/);
195:         });
196: 
197:         it("serializes Uint8Array with filename", async () => {
198:             const uint8Array = new Uint8Array([72, 101, 108, 108, 111]); // "Hello"
199:             await formData.appendFile("file", {
200:                 data: uint8Array,
201:                 filename: "binary.bin",
202:             });
203: 
204:             const serialized = await serializeFormData(formData.getRequest().body);
205:             expect(serialized).toContain('filename="binary.bin"');
206:             expect(serialized).toContain("Hello");
207:         });
208: 
209:         it("serializes other typed arrays", async () => {
210:             const int16Array = new Int16Array([1000, 2000, 3000]);
211:             await formData.appendFile("file", {
212:                 data: int16Array,
213:                 filename: "numbers.bin",
214:             });
215: 
216:             const serialized = await serializeFormData(formData.getRequest().body);
217:             expect(serialized).toContain('filename="numbers.bin"');
218:         });
219: 
220:         it("serializes Buffer data with filename", async () => {
221:             if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer === "function") {
222:                 const buffer = Buffer.from("test content");
223:                 await formData.appendFile("file", {
224:                     data: buffer,
225:                     filename: "test.txt",
226:                 });
227: 
228:                 const serialized = await serializeFormData(formData.getRequest().body);
229:                 expect(serialized).toContain('filename="test.txt"');
230:                 expect(serialized).toContain("test content");
231:             }
232:         });
233:     });
234: 
235:     describe("Text and primitive types", () => {
236:         it("serializes string as regular form field", async () => {
237:             formData.append("text", "test string");
238: 
239:             const serialized = await serializeFormData(formData.getRequest().body);
240:             expect(serialized).toContain('name="text"');
241:             expect(serialized).not.toContain("filename=");
242:             expect(serialized).toContain("test string");
243:         });
244: 
245:         it("serializes numbers and booleans as strings", async () => {
246:             formData.append("number", 12345);
247:             formData.append("flag", true);
248: 
249:             const serialized = await serializeFormData(formData.getRequest().body);
250:             expect(serialized).toContain("12345");
251:             expect(serialized).toContain("true");
252:         });
253:     });
254: 
255:     describe("Edge cases and error handling", () => {
256:         it("handles empty filename gracefully", async () => {
257:             await formData.appendFile("file", {
258:                 data: new Blob(["content"], { type: "text/plain" }),
259:                 filename: "",
260:             });
261: 
262:             const serialized = await serializeFormData(formData.getRequest().body);
263:             expect(serialized).toContain('filename="blob"'); // Default fallback
264:         });
265: 
266:         it("handles multiple files in single form", async () => {
267:             await formData.appendFile("file1", {
268:                 data: new Blob(["content1"], { type: "text/plain" }),
269:                 filename: "file1.txt",
270:             });
271:             await formData.appendFile("file2", {
272:                 data: new Blob(["content2"], { type: "text/plain" }),
273:                 filename: "file2.txt",
274:             });
275:             formData.append("text", "regular field");
276: 
277:             const serialized = await serializeFormData(formData.getRequest().body);
278: 
279:             expect(serialized).toContain('filename="file1.txt"');
280:             expect(serialized).toContain('filename="file2.txt"');
281:             expect(serialized).toContain('name="text"');
282:             expect(serialized).not.toContain('filename="text"');
283:         });
284:     });
285: 
286:     describe("Request structure", () => {
287:         it("returns correct request structure", async () => {
288:             await formData.appendFile("file", {
289:                 data: new Blob(["content"], { type: "text/plain" }),
290:                 filename: "test.txt",
291:             });
292: 
293:             const request = formData.getRequest();
294: 
295:             expect(request).toHaveProperty("body");
296:             expect(request).toHaveProperty("headers");
297:             expect(request).toHaveProperty("duplex");
298:             expect(request.body).toBeInstanceOf(FormData);
299:             expect(request.headers).toEqual({});
300:             expect(request.duplex).toBe("half");
301:         });
302: 
303:         it("generates proper multipart boundary structure", async () => {
304:             await formData.appendFile("file", {
305:                 data: new Blob(["test content"], { type: "text/plain" }),
306:                 filename: "test.txt",
307:             });
308:             formData.append("field", "value");
309: 
310:             const serialized = await serializeFormData(formData.getRequest().body);
311: 
312:             expect(serialized).toMatch(/------formdata-undici-\w+|------WebKitFormBoundary\w+/);
313:             expect(serialized).toContain("Content-Disposition: form-data;");
314:             expect(serialized).toMatch(/------formdata-undici-\w+--|------WebKitFormBoundary\w+--/);
315:         });
316:     });
317: 
318:     describe("Factory function", () => {
319:         it("returns FormDataWrapper instance", async () => {
320:             const formData = await newFormData();
321:             expect(formData).toBeInstanceOf(FormDataWrapper);
322:         });
323: 
324:         it("creates independent instances", async () => {
325:             const formData1 = await newFormData();
326:             const formData2 = await newFormData();
327: 
328:             await formData1.setup();
329:             await formData2.setup();
330: 
331:             formData1.append("test1", "value1");
332:             formData2.append("test2", "value2");
333: 
334:             const request1 = formData1.getRequest() as { body: FormData };
335:             const request2 = formData2.getRequest() as { body: FormData };
336: 
337:             const entries1 = Array.from(request1.body.entries());
338:             const entries2 = Array.from(request2.body.entries());
339: 
340:             expect(entries1).toHaveLength(1);
341:             expect(entries2).toHaveLength(1);
342:             expect(entries1[0][0]).toBe("test1");
343:             expect(entries2[0][0]).toBe("test2");
344:         });
345:     });
346: });
````

## File: tests/unit/logging/logger.test.ts
````typescript
  1: import { ConsoleLogger, createLogger, Logger, LogLevel } from "../../../src/core/logging/logger";
  2: 
  3: function createMockLogger() {
  4:     return {
  5:         debug: vi.fn(),
  6:         info: vi.fn(),
  7:         warn: vi.fn(),
  8:         error: vi.fn(),
  9:     };
 10: }
 11: 
 12: describe("Logger", () => {
 13:     describe("LogLevel", () => {
 14:         it("should have correct log levels", () => {
 15:             expect(LogLevel.Debug).toBe("debug");
 16:             expect(LogLevel.Info).toBe("info");
 17:             expect(LogLevel.Warn).toBe("warn");
 18:             expect(LogLevel.Error).toBe("error");
 19:         });
 20:     });
 21: 
 22:     describe("ConsoleLogger", () => {
 23:         let consoleLogger: ConsoleLogger;
 24:         let consoleSpy: {
 25:             debug: ReturnType<typeof vi.spyOn>;
 26:             info: ReturnType<typeof vi.spyOn>;
 27:             warn: ReturnType<typeof vi.spyOn>;
 28:             error: ReturnType<typeof vi.spyOn>;
 29:         };
 30: 
 31:         beforeEach(() => {
 32:             consoleLogger = new ConsoleLogger();
 33:             consoleSpy = {
 34:                 debug: vi.spyOn(console, "debug").mockImplementation(() => {}),
 35:                 info: vi.spyOn(console, "info").mockImplementation(() => {}),
 36:                 warn: vi.spyOn(console, "warn").mockImplementation(() => {}),
 37:                 error: vi.spyOn(console, "error").mockImplementation(() => {}),
 38:             };
 39:         });
 40: 
 41:         afterEach(() => {
 42:             consoleSpy.debug.mockRestore();
 43:             consoleSpy.info.mockRestore();
 44:             consoleSpy.warn.mockRestore();
 45:             consoleSpy.error.mockRestore();
 46:         });
 47: 
 48:         it("should log debug messages", () => {
 49:             consoleLogger.debug("debug message", { data: "test" });
 50:             expect(consoleSpy.debug).toHaveBeenCalledWith("debug message", { data: "test" });
 51:         });
 52: 
 53:         it("should log info messages", () => {
 54:             consoleLogger.info("info message", { data: "test" });
 55:             expect(consoleSpy.info).toHaveBeenCalledWith("info message", { data: "test" });
 56:         });
 57: 
 58:         it("should log warn messages", () => {
 59:             consoleLogger.warn("warn message", { data: "test" });
 60:             expect(consoleSpy.warn).toHaveBeenCalledWith("warn message", { data: "test" });
 61:         });
 62: 
 63:         it("should log error messages", () => {
 64:             consoleLogger.error("error message", { data: "test" });
 65:             expect(consoleSpy.error).toHaveBeenCalledWith("error message", { data: "test" });
 66:         });
 67: 
 68:         it("should handle multiple arguments", () => {
 69:             consoleLogger.debug("message", "arg1", "arg2", { key: "value" });
 70:             expect(consoleSpy.debug).toHaveBeenCalledWith("message", "arg1", "arg2", { key: "value" });
 71:         });
 72:     });
 73: 
 74:     describe("Logger with level filtering", () => {
 75:         let mockLogger: {
 76:             debug: ReturnType<typeof vi.fn>;
 77:             info: ReturnType<typeof vi.fn>;
 78:             warn: ReturnType<typeof vi.fn>;
 79:             error: ReturnType<typeof vi.fn>;
 80:         };
 81: 
 82:         beforeEach(() => {
 83:             mockLogger = createMockLogger();
 84:         });
 85: 
 86:         describe("Debug level", () => {
 87:             it("should log all levels when set to debug", () => {
 88:                 const logger = new Logger({
 89:                     level: LogLevel.Debug,
 90:                     logger: mockLogger,
 91:                     silent: false,
 92:                 });
 93: 
 94:                 logger.debug("debug");
 95:                 logger.info("info");
 96:                 logger.warn("warn");
 97:                 logger.error("error");
 98: 
 99:                 expect(mockLogger.debug).toHaveBeenCalledWith("debug");
100:                 expect(mockLogger.info).toHaveBeenCalledWith("info");
101:                 expect(mockLogger.warn).toHaveBeenCalledWith("warn");
102:                 expect(mockLogger.error).toHaveBeenCalledWith("error");
103:             });
104: 
105:             it("should report correct level checks", () => {
106:                 const logger = new Logger({
107:                     level: LogLevel.Debug,
108:                     logger: mockLogger,
109:                     silent: false,
110:                 });
111: 
112:                 expect(logger.isDebug()).toBe(true);
113:                 expect(logger.isInfo()).toBe(true);
114:                 expect(logger.isWarn()).toBe(true);
115:                 expect(logger.isError()).toBe(true);
116:             });
117:         });
118: 
119:         describe("Info level", () => {
120:             it("should log info, warn, and error when set to info", () => {
121:                 const logger = new Logger({
122:                     level: LogLevel.Info,
123:                     logger: mockLogger,
124:                     silent: false,
125:                 });
126: 
127:                 logger.debug("debug");
128:                 logger.info("info");
129:                 logger.warn("warn");
130:                 logger.error("error");
131: 
132:                 expect(mockLogger.debug).not.toHaveBeenCalled();
133:                 expect(mockLogger.info).toHaveBeenCalledWith("info");
134:                 expect(mockLogger.warn).toHaveBeenCalledWith("warn");
135:                 expect(mockLogger.error).toHaveBeenCalledWith("error");
136:             });
137: 
138:             it("should report correct level checks", () => {
139:                 const logger = new Logger({
140:                     level: LogLevel.Info,
141:                     logger: mockLogger,
142:                     silent: false,
143:                 });
144: 
145:                 expect(logger.isDebug()).toBe(false);
146:                 expect(logger.isInfo()).toBe(true);
147:                 expect(logger.isWarn()).toBe(true);
148:                 expect(logger.isError()).toBe(true);
149:             });
150:         });
151: 
152:         describe("Warn level", () => {
153:             it("should log warn and error when set to warn", () => {
154:                 const logger = new Logger({
155:                     level: LogLevel.Warn,
156:                     logger: mockLogger,
157:                     silent: false,
158:                 });
159: 
160:                 logger.debug("debug");
161:                 logger.info("info");
162:                 logger.warn("warn");
163:                 logger.error("error");
164: 
165:                 expect(mockLogger.debug).not.toHaveBeenCalled();
166:                 expect(mockLogger.info).not.toHaveBeenCalled();
167:                 expect(mockLogger.warn).toHaveBeenCalledWith("warn");
168:                 expect(mockLogger.error).toHaveBeenCalledWith("error");
169:             });
170: 
171:             it("should report correct level checks", () => {
172:                 const logger = new Logger({
173:                     level: LogLevel.Warn,
174:                     logger: mockLogger,
175:                     silent: false,
176:                 });
177: 
178:                 expect(logger.isDebug()).toBe(false);
179:                 expect(logger.isInfo()).toBe(false);
180:                 expect(logger.isWarn()).toBe(true);
181:                 expect(logger.isError()).toBe(true);
182:             });
183:         });
184: 
185:         describe("Error level", () => {
186:             it("should only log error when set to error", () => {
187:                 const logger = new Logger({
188:                     level: LogLevel.Error,
189:                     logger: mockLogger,
190:                     silent: false,
191:                 });
192: 
193:                 logger.debug("debug");
194:                 logger.info("info");
195:                 logger.warn("warn");
196:                 logger.error("error");
197: 
198:                 expect(mockLogger.debug).not.toHaveBeenCalled();
199:                 expect(mockLogger.info).not.toHaveBeenCalled();
200:                 expect(mockLogger.warn).not.toHaveBeenCalled();
201:                 expect(mockLogger.error).toHaveBeenCalledWith("error");
202:             });
203: 
204:             it("should report correct level checks", () => {
205:                 const logger = new Logger({
206:                     level: LogLevel.Error,
207:                     logger: mockLogger,
208:                     silent: false,
209:                 });
210: 
211:                 expect(logger.isDebug()).toBe(false);
212:                 expect(logger.isInfo()).toBe(false);
213:                 expect(logger.isWarn()).toBe(false);
214:                 expect(logger.isError()).toBe(true);
215:             });
216:         });
217: 
218:         describe("Silent mode", () => {
219:             it("should not log anything when silent is true", () => {
220:                 const logger = new Logger({
221:                     level: LogLevel.Debug,
222:                     logger: mockLogger,
223:                     silent: true,
224:                 });
225: 
226:                 logger.debug("debug");
227:                 logger.info("info");
228:                 logger.warn("warn");
229:                 logger.error("error");
230: 
231:                 expect(mockLogger.debug).not.toHaveBeenCalled();
232:                 expect(mockLogger.info).not.toHaveBeenCalled();
233:                 expect(mockLogger.warn).not.toHaveBeenCalled();
234:                 expect(mockLogger.error).not.toHaveBeenCalled();
235:             });
236: 
237:             it("should report all level checks as false when silent", () => {
238:                 const logger = new Logger({
239:                     level: LogLevel.Debug,
240:                     logger: mockLogger,
241:                     silent: true,
242:                 });
243: 
244:                 expect(logger.isDebug()).toBe(false);
245:                 expect(logger.isInfo()).toBe(false);
246:                 expect(logger.isWarn()).toBe(false);
247:                 expect(logger.isError()).toBe(false);
248:             });
249:         });
250: 
251:         describe("shouldLog", () => {
252:             it("should correctly determine if level should be logged", () => {
253:                 const logger = new Logger({
254:                     level: LogLevel.Info,
255:                     logger: mockLogger,
256:                     silent: false,
257:                 });
258: 
259:                 expect(logger.shouldLog(LogLevel.Debug)).toBe(false);
260:                 expect(logger.shouldLog(LogLevel.Info)).toBe(true);
261:                 expect(logger.shouldLog(LogLevel.Warn)).toBe(true);
262:                 expect(logger.shouldLog(LogLevel.Error)).toBe(true);
263:             });
264: 
265:             it("should return false for all levels when silent", () => {
266:                 const logger = new Logger({
267:                     level: LogLevel.Debug,
268:                     logger: mockLogger,
269:                     silent: true,
270:                 });
271: 
272:                 expect(logger.shouldLog(LogLevel.Debug)).toBe(false);
273:                 expect(logger.shouldLog(LogLevel.Info)).toBe(false);
274:                 expect(logger.shouldLog(LogLevel.Warn)).toBe(false);
275:                 expect(logger.shouldLog(LogLevel.Error)).toBe(false);
276:             });
277:         });
278: 
279:         describe("Multiple arguments", () => {
280:             it("should pass multiple arguments to logger", () => {
281:                 const logger = new Logger({
282:                     level: LogLevel.Debug,
283:                     logger: mockLogger,
284:                     silent: false,
285:                 });
286: 
287:                 logger.debug("message", "arg1", { key: "value" }, 123);
288:                 expect(mockLogger.debug).toHaveBeenCalledWith("message", "arg1", { key: "value" }, 123);
289:             });
290:         });
291:     });
292: 
293:     describe("createLogger", () => {
294:         it("should return default logger when no config provided", () => {
295:             const logger = createLogger();
296:             expect(logger).toBeInstanceOf(Logger);
297:         });
298: 
299:         it("should return same logger instance when Logger is passed", () => {
300:             const customLogger = new Logger({
301:                 level: LogLevel.Debug,
302:                 logger: new ConsoleLogger(),
303:                 silent: false,
304:             });
305: 
306:             const result = createLogger(customLogger);
307:             expect(result).toBe(customLogger);
308:         });
309: 
310:         it("should create logger with custom config", () => {
311:             const mockLogger = createMockLogger();
312: 
313:             const logger = createLogger({
314:                 level: LogLevel.Warn,
315:                 logger: mockLogger,
316:                 silent: false,
317:             });
318: 
319:             expect(logger).toBeInstanceOf(Logger);
320:             logger.warn("test");
321:             expect(mockLogger.warn).toHaveBeenCalledWith("test");
322:         });
323: 
324:         it("should use default values for missing config", () => {
325:             const logger = createLogger({});
326:             expect(logger).toBeInstanceOf(Logger);
327:         });
328: 
329:         it("should override default level", () => {
330:             const mockLogger = createMockLogger();
331: 
332:             const logger = createLogger({
333:                 level: LogLevel.Debug,
334:                 logger: mockLogger,
335:                 silent: false,
336:             });
337: 
338:             logger.debug("test");
339:             expect(mockLogger.debug).toHaveBeenCalledWith("test");
340:         });
341: 
342:         it("should override default silent mode", () => {
343:             const mockLogger = createMockLogger();
344: 
345:             const logger = createLogger({
346:                 logger: mockLogger,
347:                 silent: false,
348:             });
349: 
350:             logger.info("test");
351:             expect(mockLogger.info).toHaveBeenCalledWith("test");
352:         });
353: 
354:         it("should use provided logger implementation", () => {
355:             const customLogger = createMockLogger();
356: 
357:             const logger = createLogger({
358:                 logger: customLogger,
359:                 level: LogLevel.Debug,
360:                 silent: false,
361:             });
362: 
363:             logger.debug("test");
364:             expect(customLogger.debug).toHaveBeenCalledWith("test");
365:         });
366: 
367:         it("should default to silent: true", () => {
368:             const mockLogger = createMockLogger();
369: 
370:             const logger = createLogger({
371:                 logger: mockLogger,
372:                 level: LogLevel.Debug,
373:             });
374: 
375:             logger.debug("test");
376:             expect(mockLogger.debug).not.toHaveBeenCalled();
377:         });
378:     });
379: 
380:     describe("Default logger", () => {
381:         it("should have silent: true by default", () => {
382:             const logger = createLogger();
383:             expect(logger.shouldLog(LogLevel.Info)).toBe(false);
384:         });
385: 
386:         it("should not log when using default logger", () => {
387:             const logger = createLogger();
388: 
389:             logger.info("test");
390:             expect(logger.isInfo()).toBe(false);
391:         });
392:     });
393: 
394:     describe("Edge cases", () => {
395:         it("should handle empty message", () => {
396:             const mockLogger = createMockLogger();
397: 
398:             const logger = new Logger({
399:                 level: LogLevel.Debug,
400:                 logger: mockLogger,
401:                 silent: false,
402:             });
403: 
404:             logger.debug("");
405:             expect(mockLogger.debug).toHaveBeenCalledWith("");
406:         });
407: 
408:         it("should handle no arguments", () => {
409:             const mockLogger = createMockLogger();
410: 
411:             const logger = new Logger({
412:                 level: LogLevel.Debug,
413:                 logger: mockLogger,
414:                 silent: false,
415:             });
416: 
417:             logger.debug("message");
418:             expect(mockLogger.debug).toHaveBeenCalledWith("message");
419:         });
420: 
421:         it("should handle complex objects", () => {
422:             const mockLogger = createMockLogger();
423: 
424:             const logger = new Logger({
425:                 level: LogLevel.Debug,
426:                 logger: mockLogger,
427:                 silent: false,
428:             });
429: 
430:             const complexObject = {
431:                 nested: { key: "value" },
432:                 array: [1, 2, 3],
433:                 fn: () => "test",
434:             };
435: 
436:             logger.debug("message", complexObject);
437:             expect(mockLogger.debug).toHaveBeenCalledWith("message", complexObject);
438:         });
439: 
440:         it("should handle errors as arguments", () => {
441:             const mockLogger = createMockLogger();
442: 
443:             const logger = new Logger({
444:                 level: LogLevel.Error,
445:                 logger: mockLogger,
446:                 silent: false,
447:             });
448: 
449:             const error = new Error("Test error");
450:             logger.error("Error occurred", error);
451:             expect(mockLogger.error).toHaveBeenCalledWith("Error occurred", error);
452:         });
453:     });
454: });
````

## File: tests/unit/schemas/bigint/bigint.test.ts
````typescript
 1: import { bigint } from "../../../../src/core/schemas/builders/bigint";
 2: import { itJson, itParse, itSchema } from "../utils/itSchema";
 3: import { itValidateJson, itValidateParse } from "../utils/itValidate";
 4: 
 5: describe("bigint", () => {
 6:     itSchema("converts between raw bigint and parsed bigint", bigint(), {
 7:         raw: BigInt("9007199254740992"),
 8:         parsed: BigInt("9007199254740992"),
 9:     });
10: 
11:     itParse("converts between raw number and parsed bigint", bigint(), {
12:         raw: 10,
13:         parsed: BigInt("10"),
14:     });
15: 
16:     itParse("converts between raw number and parsed bigint", bigint(), {
17:         raw: BigInt("10"),
18:         parsed: BigInt("10"),
19:     });
20: 
21:     itJson("converts raw bigint to parsed bigint", bigint(), {
22:         parsed: BigInt("10"),
23:         raw: BigInt("10"),
24:     });
25: 
26:     itValidateParse("string", bigint(), "42", [
27:         {
28:             message: 'Expected bigint | number. Received "42".',
29:             path: [],
30:         },
31:     ]);
32: 
33:     itValidateJson("number", bigint(), 42, [
34:         {
35:             message: "Expected bigint. Received 42.",
36:             path: [],
37:         },
38:     ]);
39: 
40:     itValidateJson("string", bigint(), "42", [
41:         {
42:             message: 'Expected bigint. Received "42".',
43:             path: [],
44:         },
45:     ]);
46: });
````

## File: tests/unit/schemas/date/date.test.ts
````typescript
 1: import { date } from "../../../../src/core/schemas/builders/date";
 2: import { itSchema } from "../utils/itSchema";
 3: import { itValidateJson, itValidateParse } from "../utils/itValidate";
 4: 
 5: describe("date", () => {
 6:     itSchema("converts between raw ISO string and parsed Date", date(), {
 7:         raw: "2022-09-29T05:41:21.939Z",
 8:         parsed: new Date("2022-09-29T05:41:21.939Z"),
 9:     });
10: 
11:     itValidateParse("non-string", date(), 42, [
12:         {
13:             message: "Expected string. Received 42.",
14:             path: [],
15:         },
16:     ]);
17: 
18:     itValidateParse("non-ISO", date(), "hello world", [
19:         {
20:             message: 'Expected ISO 8601 date string. Received "hello world".',
21:             path: [],
22:         },
23:     ]);
24: 
25:     itValidateJson("non-Date", date(), "hello", [
26:         {
27:             message: 'Expected Date object. Received "hello".',
28:             path: [],
29:         },
30:     ]);
31: });
````

## File: tests/unit/schemas/enum/enum.test.ts
````typescript
 1: import { enum_ } from "../../../../src/core/schemas/builders/enum";
 2: import { itSchemaIdentity } from "../utils/itSchema";
 3: import { itValidate } from "../utils/itValidate";
 4: 
 5: describe("enum", () => {
 6:     itSchemaIdentity(enum_(["A", "B", "C"]), "A");
 7: 
 8:     itSchemaIdentity(enum_(["A", "B", "C"]), "D" as any, {
 9:         opts: { allowUnrecognizedEnumValues: true },
10:     });
11: 
12:     itValidate("invalid enum", enum_(["A", "B", "C"]), "D", [
13:         {
14:             message: 'Expected enum. Received "D".',
15:             path: [],
16:         },
17:     ]);
18: 
19:     itValidate(
20:         "non-string",
21:         enum_(["A", "B", "C"]),
22:         [],
23:         [
24:             {
25:                 message: "Expected string. Received list.",
26:                 path: [],
27:             },
28:         ],
29:     );
30: });
````

## File: tests/unit/schemas/lazy/recursive/a.ts
````typescript
1: import { object } from "../../../../../src/core/schemas/builders/object";
2: import { schemaB } from "./b";
3: 
4: // @ts-expect-error
5: export const schemaA = object({
6:     b: schemaB,
7: });
````

## File: tests/unit/schemas/lazy/recursive/b.ts
````typescript
1: import { object } from "../../../../../src/core/schemas/builders/object";
2: import { optional } from "../../../../../src/core/schemas/builders/schema-utils";
3: import { schemaA } from "./a";
4: 
5: // @ts-expect-error
6: export const schemaB = object({
7:     a: optional(schemaA),
8: });
````

## File: tests/unit/schemas/lazy/lazy.test.ts
````typescript
 1: import { lazy, list, object, string } from "../../../../src/core/schemas/builders";
 2: import type { Schema } from "../../../../src/core/schemas/Schema";
 3: import { itSchemaIdentity } from "../utils/itSchema";
 4: 
 5: describe("lazy", () => {
 6:     it("doesn't run immediately", () => {
 7:         let wasRun = false;
 8:         lazy(() => {
 9:             wasRun = true;
10:             return string();
11:         });
12:         expect(wasRun).toBe(false);
13:     });
14: 
15:     it("only runs first time", async () => {
16:         let count = 0;
17:         const schema = lazy(() => {
18:             count++;
19:             return string();
20:         });
21:         await schema.parse("hello");
22:         await schema.json("world");
23:         expect(count).toBe(1);
24:     });
25: 
26:     itSchemaIdentity(
27:         lazy(() => object({})),
28:         { foo: "hello" },
29:         {
30:             title: "passes opts through",
31:             opts: { unrecognizedObjectKeys: "passthrough" },
32:         },
33:     );
34: 
35:     itSchemaIdentity(
36:         lazy(() => object({ foo: string() })),
37:         { foo: "hello" },
38:     );
39: 
40:     // eslint-disable-next-line vi/expect-expect
41:     it("self-referencial schema doesn't compile", () => {
42:         () => {
43:             // @ts-expect-error
44:             const a = lazy(() => object({ foo: a }));
45:         };
46:     });
47: 
48:     // eslint-disable-next-line vi/expect-expect
49:     it("self-referencial compiles with explicit type", () => {
50:         () => {
51:             interface TreeNode {
52:                 children: TreeNode[];
53:             }
54:             const TreeNode: Schema<TreeNode, TreeNode> = lazy(() => object({ children: list(TreeNode) }));
55:         };
56:     });
57: });
````

## File: tests/unit/schemas/lazy/lazyObject.test.ts
````typescript
 1: import { lazyObject, number, object, string } from "../../../../src/core/schemas/builders";
 2: import { itSchemaIdentity } from "../utils/itSchema";
 3: 
 4: describe("lazy", () => {
 5:     itSchemaIdentity(
 6:         lazyObject(() => object({ foo: string() })),
 7:         { foo: "hello" },
 8:     );
 9: 
10:     itSchemaIdentity(
11:         lazyObject(() => object({ foo: string() })).extend(object({ bar: number() })),
12:         {
13:             foo: "hello",
14:             bar: 42,
15:         },
16:         { title: "returned schema has object utils" },
17:     );
18: });
````

## File: tests/unit/schemas/list/list.test.ts
````typescript
 1: import { list, object, property, string } from "../../../../src/core/schemas/builders";
 2: import { itSchema, itSchemaIdentity } from "../utils/itSchema";
 3: import { itValidate } from "../utils/itValidate";
 4: 
 5: describe("list", () => {
 6:     itSchemaIdentity(list(string()), ["hello", "world"], {
 7:         title: "functions as identity when item type is primitive",
 8:     });
 9: 
10:     itSchema(
11:         "converts objects correctly",
12:         list(
13:             object({
14:                 helloWorld: property("hello_world", string()),
15:             }),
16:         ),
17:         {
18:             raw: [{ hello_world: "123" }],
19:             parsed: [{ helloWorld: "123" }],
20:         },
21:     );
22: 
23:     itValidate("not a list", list(string()), 42, [
24:         {
25:             path: [],
26:             message: "Expected list. Received 42.",
27:         },
28:     ]);
29: 
30:     itValidate(
31:         "invalid item type",
32:         list(string()),
33:         [42],
34:         [
35:             {
36:                 path: ["[0]"],
37:                 message: "Expected string. Received 42.",
38:             },
39:         ],
40:     );
41: });
````

## File: tests/unit/schemas/literals/stringLiteral.test.ts
````typescript
 1: import { stringLiteral } from "../../../../src/core/schemas/builders";
 2: import { itSchemaIdentity } from "../utils/itSchema";
 3: import { itValidate } from "../utils/itValidate";
 4: 
 5: describe("stringLiteral", () => {
 6:     itSchemaIdentity(stringLiteral("A"), "A");
 7: 
 8:     itValidate("incorrect string", stringLiteral("A"), "B", [
 9:         {
10:             path: [],
11:             message: 'Expected "A". Received "B".',
12:         },
13:     ]);
14: 
15:     itValidate("non-string", stringLiteral("A"), 42, [
16:         {
17:             path: [],
18:             message: 'Expected "A". Received 42.',
19:         },
20:     ]);
21: });
````

## File: tests/unit/schemas/object/extend.test.ts
````typescript
 1: import { boolean, object, property, string, stringLiteral } from "../../../../src/core/schemas/builders";
 2: import { itSchema, itSchemaIdentity } from "../utils/itSchema";
 3: 
 4: describe("extend", () => {
 5:     itSchemaIdentity(
 6:         object({
 7:             foo: string(),
 8:         }).extend(
 9:             object({
10:                 bar: stringLiteral("bar"),
11:             }),
12:         ),
13:         {
14:             foo: "",
15:             bar: "bar",
16:         } as const,
17:         {
18:             title: "extended properties are included in schema",
19:         },
20:     );
21: 
22:     itSchemaIdentity(
23:         object({
24:             foo: string(),
25:         })
26:             .extend(
27:                 object({
28:                     bar: stringLiteral("bar"),
29:                 }),
30:             )
31:             .extend(
32:                 object({
33:                     baz: boolean(),
34:                 }),
35:             ),
36:         {
37:             foo: "",
38:             bar: "bar",
39:             baz: true,
40:         } as const,
41:         {
42:             title: "extensions can be extended",
43:         },
44:     );
45: 
46:     itSchema(
47:         "converts nested object",
48:         object({
49:             item: object({
50:                 helloWorld: property("hello_world", string()),
51:             }),
52:         }).extend(
53:             object({
54:                 goodbye: property("goodbye_raw", string()),
55:             }),
56:         ),
57:         {
58:             raw: { item: { hello_world: "yo" }, goodbye_raw: "peace" },
59:             parsed: { item: { helloWorld: "yo" }, goodbye: "peace" },
60:         },
61:     );
62: 
63:     itSchema(
64:         "extensions work with raw/parsed property name conversions",
65:         object({
66:             item: property("item_raw", string()),
67:         }).extend(
68:             object({
69:                 goodbye: property("goodbye_raw", string()),
70:             }),
71:         ),
72:         {
73:             raw: { item_raw: "hi", goodbye_raw: "peace" },
74:             parsed: { item: "hi", goodbye: "peace" },
75:         },
76:     );
77: 
78:     describe("compile", () => {
79:         // eslint-disable-next-line vi/expect-expect
80:         it("doesn't compile with non-object schema", () => {
81:             () =>
82:                 object({
83:                     foo: string(),
84:                 })
85:                     // @ts-expect-error
86:                     .extend([]);
87:         });
88:     });
89: });
````

## File: tests/unit/schemas/object/object.test.ts
````typescript
  1: import { any, number, object, property, string, stringLiteral, unknown } from "../../../../src/core/schemas/builders";
  2: import { itJson, itParse, itSchema, itSchemaIdentity } from "../utils/itSchema";
  3: import { itValidate } from "../utils/itValidate";
  4: 
  5: describe("object", () => {
  6:     itSchemaIdentity(
  7:         object({
  8:             foo: string(),
  9:             bar: stringLiteral("bar"),
 10:         }),
 11:         {
 12:             foo: "",
 13:             bar: "bar",
 14:         },
 15:         {
 16:             title: "functions as identity when values are primitives and property() isn't used",
 17:         },
 18:     );
 19: 
 20:     itSchema(
 21:         "uses raw key from property()",
 22:         object({
 23:             foo: property("raw_foo", string()),
 24:             bar: stringLiteral("bar"),
 25:         }),
 26:         {
 27:             raw: { raw_foo: "foo", bar: "bar" },
 28:             parsed: { foo: "foo", bar: "bar" },
 29:         },
 30:     );
 31: 
 32:     itSchema(
 33:         "keys with unknown type can be omitted",
 34:         object({
 35:             foo: unknown(),
 36:         }),
 37:         {
 38:             raw: {},
 39:             parsed: {},
 40:         },
 41:     );
 42: 
 43:     itSchema(
 44:         "keys with any type can be omitted",
 45:         object({
 46:             foo: any(),
 47:         }),
 48:         {
 49:             raw: {},
 50:             parsed: {},
 51:         },
 52:     );
 53: 
 54:     describe("unrecognizedObjectKeys", () => {
 55:         describe("parse", () => {
 56:             itParse(
 57:                 'includes unknown values when unrecognizedObjectKeys === "passthrough"',
 58:                 object({
 59:                     foo: property("raw_foo", string()),
 60:                     bar: stringLiteral("bar"),
 61:                 }),
 62:                 {
 63:                     raw: {
 64:                         raw_foo: "foo",
 65:                         bar: "bar",
 66:                         // @ts-expect-error
 67:                         baz: "yoyo",
 68:                     },
 69:                     parsed: {
 70:                         foo: "foo",
 71:                         bar: "bar",
 72:                         // @ts-expect-error
 73:                         baz: "yoyo",
 74:                     },
 75:                     opts: {
 76:                         unrecognizedObjectKeys: "passthrough",
 77:                     },
 78:                 },
 79:             );
 80: 
 81:             itParse(
 82:                 'strips unknown values when unrecognizedObjectKeys === "strip"',
 83:                 object({
 84:                     foo: property("raw_foo", string()),
 85:                     bar: stringLiteral("bar"),
 86:                 }),
 87:                 {
 88:                     raw: {
 89:                         raw_foo: "foo",
 90:                         bar: "bar",
 91:                         // @ts-expect-error
 92:                         baz: "yoyo",
 93:                     },
 94:                     parsed: {
 95:                         foo: "foo",
 96:                         bar: "bar",
 97:                     },
 98:                     opts: {
 99:                         unrecognizedObjectKeys: "strip",
100:                     },
101:                 },
102:             );
103:         });
104: 
105:         describe("json", () => {
106:             itJson(
107:                 'includes unknown values when unrecognizedObjectKeys === "passthrough"',
108:                 object({
109:                     foo: property("raw_foo", string()),
110:                     bar: stringLiteral("bar"),
111:                 }),
112:                 {
113:                     raw: {
114:                         raw_foo: "foo",
115:                         bar: "bar",
116:                         // @ts-expect-error
117:                         baz: "yoyo",
118:                     },
119:                     parsed: {
120:                         foo: "foo",
121:                         bar: "bar",
122:                         // @ts-expect-error
123:                         baz: "yoyo",
124:                     },
125:                     opts: {
126:                         unrecognizedObjectKeys: "passthrough",
127:                     },
128:                 },
129:             );
130: 
131:             itJson(
132:                 'strips unknown values when unrecognizedObjectKeys === "strip"',
133:                 object({
134:                     foo: property("raw_foo", string()),
135:                     bar: stringLiteral("bar"),
136:                 }),
137:                 {
138:                     raw: {
139:                         raw_foo: "foo",
140:                         bar: "bar",
141:                     },
142:                     parsed: {
143:                         foo: "foo",
144:                         bar: "bar",
145:                         // @ts-expect-error
146:                         baz: "yoyo",
147:                     },
148:                     opts: {
149:                         unrecognizedObjectKeys: "strip",
150:                     },
151:                 },
152:             );
153:         });
154:     });
155: 
156:     describe("nullish properties", () => {
157:         itSchema("missing properties are not added", object({ foo: property("raw_foo", string().optional()) }), {
158:             raw: {},
159:             parsed: {},
160:         });
161: 
162:         itSchema("undefined properties are not dropped", object({ foo: property("raw_foo", string().optional()) }), {
163:             raw: { raw_foo: null },
164:             parsed: { foo: undefined },
165:         });
166: 
167:         itSchema("null properties are not dropped", object({ foo: property("raw_foo", string().optional()) }), {
168:             raw: { raw_foo: null },
169:             parsed: { foo: undefined },
170:         });
171: 
172:         describe("extensions", () => {
173:             itSchema(
174:                 "undefined properties are not dropped",
175:                 object({}).extend(object({ foo: property("raw_foo", string().optional()) })),
176:                 {
177:                     raw: { raw_foo: null },
178:                     parsed: { foo: undefined },
179:                 },
180:             );
181: 
182:             describe("parse()", () => {
183:                 itParse(
184:                     "null properties are not dropped",
185:                     object({}).extend(object({ foo: property("raw_foo", string().optional()) })),
186:                     {
187:                         raw: { raw_foo: null },
188:                         parsed: { foo: undefined },
189:                     },
190:                 );
191:             });
192:         });
193:     });
194: 
195:     itValidate(
196:         "missing property",
197:         object({
198:             foo: string(),
199:             bar: stringLiteral("bar"),
200:         }),
201:         { foo: "hello" },
202:         [
203:             {
204:                 path: [],
205:                 message: 'Missing required key "bar"',
206:             },
207:         ],
208:     );
209: 
210:     itValidate(
211:         "extra property",
212:         object({
213:             foo: string(),
214:             bar: stringLiteral("bar"),
215:         }),
216:         { foo: "hello", bar: "bar", baz: 42 },
217:         [
218:             {
219:                 path: ["baz"],
220:                 message: 'Unexpected key "baz"',
221:             },
222:         ],
223:     );
224: 
225:     itValidate(
226:         "not an object",
227:         object({
228:             foo: string(),
229:             bar: stringLiteral("bar"),
230:         }),
231:         [],
232:         [
233:             {
234:                 path: [],
235:                 message: "Expected object. Received list.",
236:             },
237:         ],
238:     );
239: 
240:     itValidate(
241:         "nested validation error",
242:         object({
243:             foo: object({
244:                 bar: number(),
245:             }),
246:         }),
247:         { foo: { bar: "hello" } },
248:         [
249:             {
250:                 path: ["foo", "bar"],
251:                 message: 'Expected number. Received "hello".',
252:             },
253:         ],
254:     );
255: });
````

## File: tests/unit/schemas/object/objectWithoutOptionalProperties.test.ts
````typescript
 1: import { objectWithoutOptionalProperties, string, stringLiteral } from "../../../../src/core/schemas/builders";
 2: import { itSchema } from "../utils/itSchema";
 3: 
 4: describe("objectWithoutOptionalProperties", () => {
 5:     itSchema(
 6:         "all properties are required",
 7:         objectWithoutOptionalProperties({
 8:             foo: string(),
 9:             bar: stringLiteral("bar").optional(),
10:         }),
11:         {
12:             raw: {
13:                 foo: "hello",
14:             },
15:             // @ts-expect-error
16:             parsed: {
17:                 foo: "hello",
18:             },
19:         },
20:     );
21: });
````

## File: tests/unit/schemas/object/passthrough.test.ts
````typescript
 1: import { object, string, stringLiteral } from "../../../../src/core/schemas/builders";
 2: import { itJson, itParse, itSchema } from "../utils/itSchema";
 3: import { itValidate } from "../utils/itValidate";
 4: 
 5: describe("passthrough", () => {
 6:     const baseSchema = object({
 7:         foo: string(),
 8:         bar: stringLiteral("bar"),
 9:     });
10: 
11:     describe("parse", () => {
12:         itParse("includes unknown values", baseSchema.passthrough(), {
13:             raw: {
14:                 foo: "hello",
15:                 bar: "bar",
16:                 baz: "extra",
17:             },
18:             parsed: {
19:                 foo: "hello",
20:                 bar: "bar",
21:                 baz: "extra",
22:             },
23:         });
24: 
25:         itValidate(
26:             "preserves schema validation",
27:             baseSchema.passthrough(),
28:             {
29:                 foo: 123,
30:                 bar: "bar",
31:                 baz: "extra",
32:             },
33:             [
34:                 {
35:                     path: ["foo"],
36:                     message: "Expected string. Received 123.",
37:                 },
38:             ],
39:         );
40:     });
41: 
42:     describe("json", () => {
43:         itJson("includes unknown values", baseSchema.passthrough(), {
44:             raw: {
45:                 foo: "hello",
46:                 bar: "bar",
47: 
48:                 baz: "extra",
49:             },
50:             parsed: {
51:                 foo: "hello",
52:                 bar: "bar",
53: 
54:                 baz: "extra",
55:             },
56:         });
57: 
58:         itValidate(
59:             "preserves schema validation",
60:             baseSchema.passthrough(),
61:             {
62:                 foo: "hello",
63:                 bar: "wrong",
64:                 baz: "extra",
65:             },
66:             [
67:                 {
68:                     path: ["bar"],
69:                     message: 'Expected "bar". Received "wrong".',
70:                 },
71:             ],
72:         );
73:     });
74: 
75:     itSchema("preserves schema validation in both directions", baseSchema.passthrough(), {
76:         raw: {
77:             foo: "hello",
78:             bar: "bar",
79:             extra: 42,
80:         },
81:         parsed: {
82:             foo: "hello",
83:             bar: "bar",
84:             extra: 42,
85:         },
86:     });
87: });
````

## File: tests/unit/schemas/object-like/withParsedProperties.test.ts
````typescript
 1: import { object, property, string, stringLiteral } from "../../../../src/core/schemas/builders";
 2: 
 3: describe("withParsedProperties", () => {
 4:     it("Added properties included on parsed object", async () => {
 5:         const schema = object({
 6:             foo: property("raw_foo", string()),
 7:             bar: stringLiteral("bar"),
 8:         }).withParsedProperties({
 9:             printFoo: (parsed) => () => parsed.foo,
10:             printHelloWorld: () => () => "Hello world",
11:             helloWorld: "Hello world",
12:         });
13: 
14:         const parsed = await schema.parse({ raw_foo: "value of foo", bar: "bar" });
15:         if (!parsed.ok) {
16:             throw new Error("Failed to parse");
17:         }
18:         expect(parsed.value.printFoo()).toBe("value of foo");
19:         expect(parsed.value.printHelloWorld()).toBe("Hello world");
20:         expect(parsed.value.helloWorld).toBe("Hello world");
21:     });
22: 
23:     it("Added property is removed on raw object", async () => {
24:         const schema = object({
25:             foo: property("raw_foo", string()),
26:             bar: stringLiteral("bar"),
27:         }).withParsedProperties({
28:             printFoo: (parsed) => () => parsed.foo,
29:         });
30: 
31:         const original = { raw_foo: "value of foo", bar: "bar" } as const;
32:         const parsed = await schema.parse(original);
33:         if (!parsed.ok) {
34:             throw new Error("Failed to parse()");
35:         }
36: 
37:         const raw = await schema.json(parsed.value);
38: 
39:         if (!raw.ok) {
40:             throw new Error("Failed to json()");
41:         }
42: 
43:         expect(raw.value).toEqual(original);
44:     });
45: 
46:     describe("compile", () => {
47:         // eslint-disable-next-line vi/expect-expect
48:         it("doesn't compile with non-object schema", () => {
49:             () =>
50:                 object({
51:                     foo: string(),
52:                 })
53:                     // @ts-expect-error
54:                     .withParsedProperties(42);
55:         });
56:     });
57: });
````

## File: tests/unit/schemas/primitives/any.test.ts
````typescript
1: import { any } from "../../../../src/core/schemas/builders";
2: import { itSchemaIdentity } from "../utils/itSchema";
3: 
4: describe("any", () => {
5:     itSchemaIdentity(any(), true);
6: });
````

## File: tests/unit/schemas/primitives/boolean.test.ts
````typescript
 1: import { boolean } from "../../../../src/core/schemas/builders";
 2: import { itSchemaIdentity } from "../utils/itSchema";
 3: import { itValidate } from "../utils/itValidate";
 4: 
 5: describe("boolean", () => {
 6:     itSchemaIdentity(boolean(), true);
 7: 
 8:     itValidate("non-boolean", boolean(), {}, [
 9:         {
10:             path: [],
11:             message: "Expected boolean. Received object.",
12:         },
13:     ]);
14: });
````

## File: tests/unit/schemas/primitives/never.test.ts
````typescript
 1: import { never } from "../../../../src/core/schemas/builders";
 2: 
 3: describe("never", () => {
 4:     it("always fails to parse", () => {
 5:         const schema = never();
 6:         const result = schema.parse("test");
 7:         expect(result.ok).toBe(false);
 8:         if (!result.ok) {
 9:             expect(result.errors).toHaveLength(1);
10:             expect(result.errors[0]?.message).toBe("Expected never");
11:         }
12:     });
13: 
14:     it("always fails to json", () => {
15:         const schema = never();
16:         const result = schema.json("test");
17:         expect(result.ok).toBe(false);
18:         if (!result.ok) {
19:             expect(result.errors).toHaveLength(1);
20:             expect(result.errors[0]?.message).toBe("Expected never");
21:         }
22:     });
23: 
24:     it("fails with any value including undefined", () => {
25:         const schema = never();
26:         expect(schema.parse(undefined).ok).toBe(false);
27:         expect(schema.parse(null).ok).toBe(false);
28:         expect(schema.parse(0).ok).toBe(false);
29:         expect(schema.parse("").ok).toBe(false);
30:         expect(schema.parse({}).ok).toBe(false);
31:         expect(schema.parse([]).ok).toBe(false);
32:     });
33: 
34:     it("works when called without options parameter", () => {
35:         const schema = never();
36:         // This tests that the default = {} parameter works correctly
37:         const result = schema.parse("test");
38:         expect(result.ok).toBe(false);
39:         if (!result.ok) {
40:             expect(result.errors).toHaveLength(1);
41:             expect(result.errors[0]?.message).toBe("Expected never");
42:             expect(result.errors[0]?.path).toEqual([]);
43:         }
44:     });
45: 
46:     it("succeeds with skipValidation", () => {
47:         const schema = never();
48:         const result = schema.parse("test", { skipValidation: true });
49:         expect(result.ok).toBe(true);
50:         if (result.ok) {
51:             expect(result.value).toBe("test");
52:         }
53:     });
54: });
````

## File: tests/unit/schemas/primitives/number.test.ts
````typescript
 1: import { number } from "../../../../src/core/schemas/builders";
 2: import { itSchemaIdentity } from "../utils/itSchema";
 3: import { itValidate } from "../utils/itValidate";
 4: 
 5: describe("number", () => {
 6:     itSchemaIdentity(number(), 42);
 7: 
 8:     itValidate("non-number", number(), "hello", [
 9:         {
10:             path: [],
11:             message: 'Expected number. Received "hello".',
12:         },
13:     ]);
14: });
````

## File: tests/unit/schemas/primitives/string.test.ts
````typescript
 1: import { string } from "../../../../src/core/schemas/builders";
 2: import { itSchemaIdentity } from "../utils/itSchema";
 3: import { itValidate } from "../utils/itValidate";
 4: 
 5: describe("string", () => {
 6:     itSchemaIdentity(string(), "hello");
 7: 
 8:     itValidate("non-string", string(), 42, [
 9:         {
10:             path: [],
11:             message: "Expected string. Received 42.",
12:         },
13:     ]);
14: });
````

## File: tests/unit/schemas/primitives/unknown.test.ts
````typescript
1: import { unknown } from "../../../../src/core/schemas/builders";
2: import { itSchemaIdentity } from "../utils/itSchema";
3: 
4: describe("unknown", () => {
5:     itSchemaIdentity(unknown(), true);
6: });
````

## File: tests/unit/schemas/record/record.test.ts
````typescript
 1: import { number, record, string } from "../../../../src/core/schemas/builders";
 2: import { itSchemaIdentity } from "../utils/itSchema";
 3: import { itValidate } from "../utils/itValidate";
 4: 
 5: describe("record", () => {
 6:     itSchemaIdentity(record(string(), string()), { hello: "world" });
 7:     itSchemaIdentity(record(number(), string()), { 42: "world" });
 8: 
 9:     itValidate(
10:         "non-record",
11:         record(number(), string()),
12:         [],
13:         [
14:             {
15:                 path: [],
16:                 message: "Expected object. Received list.",
17:             },
18:         ],
19:     );
20: 
21:     itValidate("invalid key type", record(number(), string()), { hello: "world" }, [
22:         {
23:             path: ["hello (key)"],
24:             message: 'Expected number. Received "hello".',
25:         },
26:     ]);
27: 
28:     itValidate("invalid value type", record(string(), number()), { hello: "world" }, [
29:         {
30:             path: ["hello"],
31:             message: 'Expected number. Received "world".',
32:         },
33:     ]);
34: });
````

## File: tests/unit/schemas/schema-utils/getSchemaUtils.test.ts
````typescript
 1: import { object, string } from "../../../../src/core/schemas/builders";
 2: import { itSchema } from "../utils/itSchema";
 3: 
 4: describe("getSchemaUtils", () => {
 5:     describe("optional()", () => {
 6:         itSchema("optional fields allow original schema", string().optional(), {
 7:             raw: "hello",
 8:             parsed: "hello",
 9:         });
10: 
11:         itSchema("optional fields are not required", string().optional(), {
12:             raw: null,
13:             parsed: undefined,
14:         });
15:     });
16: 
17:     describe("transform()", () => {
18:         itSchema(
19:             "transform and untransform run correctly",
20:             string().transform({
21:                 transform: (x) => `${x}X`,
22:                 untransform: (x) => (x as string).slice(0, -1),
23:             }),
24:             {
25:                 raw: "hello",
26:                 parsed: "helloX",
27:             },
28:         );
29:     });
30: 
31:     describe("parseOrThrow()", () => {
32:         it("parses valid value", async () => {
33:             const value = string().parseOrThrow("hello");
34:             expect(value).toBe("hello");
35:         });
36: 
37:         it("throws on invalid value", async () => {
38:             const value = () => object({ a: string(), b: string() }).parseOrThrow({ a: 24 });
39:             expect(value).toThrowError('a: Expected string. Received 24.; Missing required key "b"');
40:         });
41:     });
42: 
43:     describe("jsonOrThrow()", () => {
44:         it("serializes valid value", async () => {
45:             const value = string().jsonOrThrow("hello");
46:             expect(value).toBe("hello");
47:         });
48: 
49:         it("throws on invalid value", async () => {
50:             const value = () => object({ a: string(), b: string() }).jsonOrThrow({ a: 24 });
51:             expect(value).toThrowError('a: Expected string. Received 24.; Missing required key "b"');
52:         });
53:     });
54: 
55:     describe("omitUndefined", () => {
56:         it("serializes undefined as null", async () => {
57:             const value = object({
58:                 a: string().optional(),
59:                 b: string().optional(),
60:             }).jsonOrThrow({
61:                 a: "hello",
62:                 b: undefined,
63:             });
64:             expect(value).toEqual({ a: "hello", b: null });
65:         });
66: 
67:         it("omits undefined values", async () => {
68:             const value = object({
69:                 a: string().optional(),
70:                 b: string().optional(),
71:             }).jsonOrThrow(
72:                 {
73:                     a: "hello",
74:                     b: undefined,
75:                 },
76:                 {
77:                     omitUndefined: true,
78:                 },
79:             );
80:             expect(value).toEqual({ a: "hello" });
81:         });
82:     });
83: });
````

## File: tests/unit/schemas/set/set.test.ts
````typescript
 1: import { set, string } from "../../../../src/core/schemas/builders";
 2: import { itSchema } from "../utils/itSchema";
 3: import { itValidateJson, itValidateParse } from "../utils/itValidate";
 4: 
 5: describe("set", () => {
 6:     itSchema("converts between raw list and parsed Set", set(string()), {
 7:         raw: ["A", "B"],
 8:         parsed: new Set(["A", "B"]),
 9:     });
10: 
11:     itValidateParse("not a list", set(string()), 42, [
12:         {
13:             path: [],
14:             message: "Expected list. Received 42.",
15:         },
16:     ]);
17: 
18:     itValidateJson(
19:         "not a Set",
20:         set(string()),
21:         [],
22:         [
23:             {
24:                 path: [],
25:                 message: "Expected Set. Received list.",
26:             },
27:         ],
28:     );
29: 
30:     itValidateParse(
31:         "invalid item type",
32:         set(string()),
33:         [42],
34:         [
35:             {
36:                 path: ["[0]"],
37:                 message: "Expected string. Received 42.",
38:             },
39:         ],
40:     );
41: 
42:     itValidateJson("invalid item type", set(string()), new Set([42]), [
43:         {
44:             path: ["[0]"],
45:             message: "Expected string. Received 42.",
46:         },
47:     ]);
48: });
````

## File: tests/unit/schemas/undiscriminated-union/undiscriminatedUnion.test.ts
````typescript
 1: import { number, object, property, string, undiscriminatedUnion } from "../../../../src/core/schemas/builders";
 2: import { itSchema, itSchemaIdentity } from "../utils/itSchema";
 3: 
 4: describe("undiscriminatedUnion", () => {
 5:     itSchemaIdentity(undiscriminatedUnion([string(), number()]), "hello world");
 6: 
 7:     itSchemaIdentity(undiscriminatedUnion([object({ hello: string() }), object({ goodbye: string() })]), {
 8:         goodbye: "foo",
 9:     });
10: 
11:     itSchema(
12:         "Correctly transforms",
13:         undiscriminatedUnion([object({ hello: string() }), object({ helloWorld: property("hello_world", string()) })]),
14:         {
15:             raw: { hello_world: "foo " },
16:             parsed: { helloWorld: "foo " },
17:         },
18:     );
19: 
20:     it("Returns errors for all variants", async () => {
21:         const result = await undiscriminatedUnion([string(), number()]).parse(true);
22:         if (result.ok) {
23:             throw new Error("Unexpectedly passed validation");
24:         }
25:         expect(result.errors).toEqual([
26:             {
27:                 message: "[Variant 0] Expected string. Received true.",
28:                 path: [],
29:             },
30:             {
31:                 message: "[Variant 1] Expected number. Received true.",
32:                 path: [],
33:             },
34:         ]);
35:     });
36: 
37:     describe("compile", () => {
38:         // eslint-disable-next-line vi/expect-expect
39:         it("doesn't compile with zero members", () => {
40:             // @ts-expect-error
41:             () => undiscriminatedUnion([]);
42:         });
43:     });
44: });
````

## File: tests/unit/schemas/union/union.test.ts
````typescript
  1: import { boolean, discriminant, number, object, string, union } from "../../../../src/core/schemas/builders";
  2: import { itSchema, itSchemaIdentity } from "../utils/itSchema";
  3: import { itValidate } from "../utils/itValidate";
  4: 
  5: describe("union", () => {
  6:     itSchemaIdentity(
  7:         union("type", {
  8:             lion: object({
  9:                 meows: boolean(),
 10:             }),
 11:             giraffe: object({
 12:                 heightInInches: number(),
 13:             }),
 14:         }),
 15:         { type: "lion", meows: true },
 16:         { title: "doesn't transform discriminant when it's a string" },
 17:     );
 18: 
 19:     itSchema(
 20:         "transforms discriminant when it's a discriminant()",
 21:         union(discriminant("type", "_type"), {
 22:             lion: object({ meows: boolean() }),
 23:             giraffe: object({ heightInInches: number() }),
 24:         }),
 25:         {
 26:             raw: { _type: "lion", meows: true },
 27:             parsed: { type: "lion", meows: true },
 28:         },
 29:     );
 30: 
 31:     describe("allowUnrecognizedUnionMembers", () => {
 32:         itSchema(
 33:             "transforms discriminant & passes through values when discriminant value is unrecognized",
 34:             union(discriminant("type", "_type"), {
 35:                 lion: object({ meows: boolean() }),
 36:                 giraffe: object({ heightInInches: number() }),
 37:             }),
 38:             {
 39:                 // @ts-expect-error
 40:                 raw: { _type: "moose", isAMoose: true },
 41:                 // @ts-expect-error
 42:                 parsed: { type: "moose", isAMoose: true },
 43:                 opts: {
 44:                     allowUnrecognizedUnionMembers: true,
 45:                 },
 46:             },
 47:         );
 48:     });
 49: 
 50:     describe("withParsedProperties", () => {
 51:         it("Added property is included on parsed object", async () => {
 52:             const schema = union("type", {
 53:                 lion: object({}),
 54:                 tiger: object({ value: string() }),
 55:             }).withParsedProperties({
 56:                 printType: (parsed) => () => parsed.type,
 57:             });
 58: 
 59:             const parsed = await schema.parse({ type: "lion" });
 60:             if (!parsed.ok) {
 61:                 throw new Error("Failed to parse");
 62:             }
 63:             expect(parsed.value.printType()).toBe("lion");
 64:         });
 65:     });
 66: 
 67:     itValidate(
 68:         "non-object",
 69:         union("type", {
 70:             lion: object({}),
 71:             tiger: object({ value: string() }),
 72:         }),
 73:         [],
 74:         [
 75:             {
 76:                 path: [],
 77:                 message: "Expected object. Received list.",
 78:             },
 79:         ],
 80:     );
 81: 
 82:     itValidate(
 83:         "missing discriminant",
 84:         union("type", {
 85:             lion: object({}),
 86:             tiger: object({ value: string() }),
 87:         }),
 88:         {},
 89:         [
 90:             {
 91:                 path: [],
 92:                 message: 'Missing discriminant ("type")',
 93:             },
 94:         ],
 95:     );
 96: 
 97:     itValidate(
 98:         "unrecognized discriminant value",
 99:         union("type", {
100:             lion: object({}),
101:             tiger: object({ value: string() }),
102:         }),
103:         {
104:             type: "bear",
105:         },
106:         [
107:             {
108:                 path: ["type"],
109:                 message: 'Expected enum. Received "bear".',
110:             },
111:         ],
112:     );
113: });
````

## File: tests/unit/schemas/utils/itSchema.ts
````typescript
 1: /* eslint-disable vi/no-export */
 2: import type { Schema, SchemaOptions } from "../../../../src/core/schemas/Schema";
 3: 
 4: export function itSchemaIdentity<T>(
 5:     schema: Schema<T, T>,
 6:     value: T,
 7:     { title = "functions as identity", opts }: { title?: string; opts?: SchemaOptions } = {},
 8: ): void {
 9:     itSchema(title, schema, { raw: value, parsed: value, opts });
10: }
11: 
12: export function itSchema<Raw, Parsed>(
13:     title: string,
14:     schema: Schema<Raw, Parsed>,
15:     {
16:         raw,
17:         parsed,
18:         opts,
19:         only = false,
20:     }: {
21:         raw: Raw;
22:         parsed: Parsed;
23:         opts?: SchemaOptions;
24:         only?: boolean;
25:     },
26: ): void {
27:     // eslint-disable-next-line vi/valid-title
28:     (only ? describe.only : describe)(title, () => {
29:         itParse("parse()", schema, { raw, parsed, opts });
30:         itJson("json()", schema, { raw, parsed, opts });
31:     });
32: }
33: 
34: export function itParse<Raw, Parsed>(
35:     title: string,
36:     schema: Schema<Raw, Parsed>,
37:     {
38:         raw,
39:         parsed,
40:         opts,
41:     }: {
42:         raw: Raw;
43:         parsed: Parsed;
44:         opts?: SchemaOptions;
45:     },
46: ): void {
47:     // eslint-disable-next-line vi/valid-title
48:     it(title, () => {
49:         const maybeValid = schema.parse(raw, opts);
50:         if (!maybeValid.ok) {
51:             throw new Error(`Failed to parse() ${JSON.stringify(maybeValid.errors, undefined, 4)}`);
52:         }
53:         expect(maybeValid.value).toStrictEqual(parsed);
54:     });
55: }
56: 
57: export function itJson<Raw, Parsed>(
58:     title: string,
59:     schema: Schema<Raw, Parsed>,
60:     {
61:         raw,
62:         parsed,
63:         opts,
64:     }: {
65:         raw: Raw;
66:         parsed: Parsed;
67:         opts?: SchemaOptions;
68:     },
69: ): void {
70:     // eslint-disable-next-line vi/valid-title
71:     it(title, () => {
72:         const maybeValid = schema.json(parsed, opts);
73:         if (!maybeValid.ok) {
74:             throw new Error(`Failed to json() ${JSON.stringify(maybeValid.errors, undefined, 4)}`);
75:         }
76:         expect(maybeValid.value).toStrictEqual(raw);
77:     });
78: }
````

## File: tests/unit/schemas/utils/itValidate.ts
````typescript
 1: /* eslint-disable vi/no-export */
 2: import type { Schema, SchemaOptions, ValidationError } from "../../../../src/core/schemas/Schema";
 3: 
 4: export function itValidate<Raw, Parsed>(
 5:     title: string,
 6:     schema: Schema<Raw, Parsed>,
 7:     input: unknown,
 8:     errors: ValidationError[],
 9:     opts?: SchemaOptions,
10: ): void {
11:     // eslint-disable-next-line vi/valid-title
12:     describe("parse()", () => {
13:         itValidateParse(title, schema, input, errors, opts);
14:     });
15:     describe("json()", () => {
16:         itValidateJson(title, schema, input, errors, opts);
17:     });
18: }
19: 
20: export function itValidateParse<Raw, Parsed>(
21:     title: string,
22:     schema: Schema<Raw, Parsed>,
23:     raw: unknown,
24:     errors: ValidationError[],
25:     opts?: SchemaOptions,
26: ): void {
27:     describe("parse", () => {
28:         // eslint-disable-next-line vi/valid-title
29:         it(title, async () => {
30:             const maybeValid = await schema.parse(raw, opts);
31:             if (maybeValid.ok) {
32:                 throw new Error("Value passed validation");
33:             }
34:             expect(maybeValid.errors).toStrictEqual(errors);
35:         });
36:     });
37: }
38: 
39: export function itValidateJson<Raw, Parsed>(
40:     title: string,
41:     schema: Schema<Raw, Parsed>,
42:     parsed: unknown,
43:     errors: ValidationError[],
44:     opts?: SchemaOptions,
45: ): void {
46:     describe("json", () => {
47:         // eslint-disable-next-line vi/valid-title
48:         it(title, async () => {
49:             const maybeValid = await schema.json(parsed, opts);
50:             if (maybeValid.ok) {
51:                 throw new Error("Value passed validation");
52:             }
53:             expect(maybeValid.errors).toStrictEqual(errors);
54:         });
55:     });
56: }
````

## File: tests/unit/schemas/schema.test.ts
````typescript
 1: import {
 2:     boolean,
 3:     discriminant,
 4:     list,
 5:     number,
 6:     object,
 7:     string,
 8:     stringLiteral,
 9:     union,
10: } from "../../../src/core/schemas/builders";
11: import { booleanLiteral } from "../../../src/core/schemas/builders/literals/booleanLiteral";
12: import { property } from "../../../src/core/schemas/builders/object/property";
13: import { itSchema } from "./utils/itSchema";
14: 
15: describe("Schema", () => {
16:     itSchema(
17:         "large nested object",
18:         object({
19:             a: string(),
20:             b: stringLiteral("b value"),
21:             c: property(
22:                 "raw_c",
23:                 list(
24:                     object({
25:                         animal: union(discriminant("type", "_type"), {
26:                             dog: object({ value: boolean() }),
27:                             cat: object({ value: property("raw_cat", number()) }),
28:                         }),
29:                     }),
30:                 ),
31:             ),
32:             d: property("raw_d", boolean()),
33:             e: booleanLiteral(true),
34:         }),
35:         {
36:             raw: {
37:                 a: "hello",
38:                 b: "b value",
39:                 raw_c: [
40:                     {
41:                         animal: {
42:                             _type: "dog",
43:                             value: true,
44:                         },
45:                     },
46:                     {
47:                         animal: {
48:                             _type: "cat",
49:                             raw_cat: 42,
50:                         },
51:                     },
52:                 ],
53:                 raw_d: false,
54:                 e: true,
55:             },
56:             parsed: {
57:                 a: "hello",
58:                 b: "b value",
59:                 c: [
60:                     {
61:                         animal: {
62:                             type: "dog",
63:                             value: true,
64:                         },
65:                     },
66:                     {
67:                         animal: {
68:                             type: "cat",
69:                             value: 42,
70:                         },
71:                     },
72:                 ],
73:                 d: false,
74:                 e: true,
75:             },
76:         },
77:     );
78: });
````

## File: tests/unit/schemas/skipValidation.test.ts
````typescript
 1: /* eslint-disable no-console */
 2: import { boolean, number, object, property, string, undiscriminatedUnion } from "../../../src/core/schemas/builders";
 3: 
 4: describe("skipValidation", () => {
 5:     it("allows data that doesn't conform to the schema", async () => {
 6:         const warningLogs: string[] = [];
 7:         const originalConsoleWarn = console.warn;
 8:         console.warn = (...args) => warningLogs.push(args.join(" "));
 9: 
10:         const schema = object({
11:             camelCase: property("snake_case", string()),
12:             numberProperty: number(),
13:             requiredProperty: boolean(),
14:             anyPrimitive: undiscriminatedUnion([string(), number(), boolean()]),
15:         });
16: 
17:         const parsed = await schema.parse(
18:             {
19:                 snake_case: "hello",
20:                 numberProperty: "oops",
21:                 anyPrimitive: true,
22:             },
23:             {
24:                 skipValidation: true,
25:             },
26:         );
27: 
28:         expect(parsed).toEqual({
29:             ok: true,
30:             value: {
31:                 camelCase: "hello",
32:                 numberProperty: "oops",
33:                 anyPrimitive: true,
34:             },
35:         });
36: 
37:         expect(warningLogs).toEqual([
38:             `Failed to validate.
39:   - numberProperty: Expected number. Received "oops".`,
40:         ]);
41: 
42:         console.warn = originalConsoleWarn;
43:     });
44: });
````

## File: tests/unit/stream/Stream.test.ts
````typescript
  1: import { Stream } from "../../../src/core/stream/Stream";
  2: 
  3: describe("Stream", () => {
  4:     describe("JSON streaming", () => {
  5:         it("should parse single JSON message", async () => {
  6:             const mockStream = createReadableStream(['{"value": 1}\n']);
  7:             const stream = new Stream({
  8:                 stream: mockStream,
  9:                 parse: async (val: unknown) => val as { value: number },
 10:                 eventShape: { type: "json", messageTerminator: "\n" },
 11:             });
 12: 
 13:             const messages: unknown[] = [];
 14:             for await (const message of stream) {
 15:                 messages.push(message);
 16:             }
 17: 
 18:             expect(messages).toEqual([{ value: 1 }]);
 19:         });
 20: 
 21:         it("should parse multiple JSON messages", async () => {
 22:             const mockStream = createReadableStream(['{"value": 1}\n{"value": 2}\n{"value": 3}\n']);
 23:             const stream = new Stream({
 24:                 stream: mockStream,
 25:                 parse: async (val: unknown) => val as { value: number },
 26:                 eventShape: { type: "json", messageTerminator: "\n" },
 27:             });
 28: 
 29:             const messages: unknown[] = [];
 30:             for await (const message of stream) {
 31:                 messages.push(message);
 32:             }
 33: 
 34:             expect(messages).toEqual([{ value: 1 }, { value: 2 }, { value: 3 }]);
 35:         });
 36: 
 37:         it("should handle messages split across chunks", async () => {
 38:             const mockStream = createReadableStream(['{"val', 'ue": 1}\n{"value":', " 2}\n"]);
 39:             const stream = new Stream({
 40:                 stream: mockStream,
 41:                 parse: async (val: unknown) => val as { value: number },
 42:                 eventShape: { type: "json", messageTerminator: "\n" },
 43:             });
 44: 
 45:             const messages: unknown[] = [];
 46:             for await (const message of stream) {
 47:                 messages.push(message);
 48:             }
 49: 
 50:             expect(messages).toEqual([{ value: 1 }, { value: 2 }]);
 51:         });
 52: 
 53:         it("should skip empty lines", async () => {
 54:             const mockStream = createReadableStream(['{"value": 1}\n\n\n{"value": 2}\n']);
 55:             const stream = new Stream({
 56:                 stream: mockStream,
 57:                 parse: async (val: unknown) => val as { value: number },
 58:                 eventShape: { type: "json", messageTerminator: "\n" },
 59:             });
 60: 
 61:             const messages: unknown[] = [];
 62:             for await (const message of stream) {
 63:                 messages.push(message);
 64:             }
 65: 
 66:             expect(messages).toEqual([{ value: 1 }, { value: 2 }]);
 67:         });
 68: 
 69:         it("should handle custom message terminator", async () => {
 70:             const mockStream = createReadableStream(['{"value": 1}|||{"value": 2}|||']);
 71:             const stream = new Stream({
 72:                 stream: mockStream,
 73:                 parse: async (val: unknown) => val as { value: number },
 74:                 eventShape: { type: "json", messageTerminator: "|||" },
 75:             });
 76: 
 77:             const messages: unknown[] = [];
 78:             for await (const message of stream) {
 79:                 messages.push(message);
 80:             }
 81: 
 82:             expect(messages).toEqual([{ value: 1 }, { value: 2 }]);
 83:         });
 84:     });
 85: 
 86:     describe("SSE streaming", () => {
 87:         it("should parse SSE data with prefix", async () => {
 88:             const mockStream = createReadableStream(['data: {"value": 1}\n']);
 89:             const stream = new Stream({
 90:                 stream: mockStream,
 91:                 parse: async (val: unknown) => val as { value: number },
 92:                 eventShape: { type: "sse" },
 93:             });
 94: 
 95:             const messages: unknown[] = [];
 96:             for await (const message of stream) {
 97:                 messages.push(message);
 98:             }
 99: 
100:             expect(messages).toEqual([{ value: 1 }]);
101:         });
102: 
103:         it("should parse multiple SSE events", async () => {
104:             const mockStream = createReadableStream(['data: {"value": 1}\ndata: {"value": 2}\ndata: {"value": 3}\n']);
105:             const stream = new Stream({
106:                 stream: mockStream,
107:                 parse: async (val: unknown) => val as { value: number },
108:                 eventShape: { type: "sse" },
109:             });
110: 
111:             const messages: unknown[] = [];
112:             for await (const message of stream) {
113:                 messages.push(message);
114:             }
115: 
116:             expect(messages).toEqual([{ value: 1 }, { value: 2 }, { value: 3 }]);
117:         });
118: 
119:         it("should stop at stream terminator", async () => {
120:             const mockStream = createReadableStream(['data: {"value": 1}\ndata: [DONE]\ndata: {"value": 2}\n']);
121:             const stream = new Stream({
122:                 stream: mockStream,
123:                 parse: async (val: unknown) => val as { value: number },
124:                 eventShape: { type: "sse", streamTerminator: "[DONE]" },
125:             });
126: 
127:             const messages: unknown[] = [];
128:             for await (const message of stream) {
129:                 messages.push(message);
130:             }
131: 
132:             expect(messages).toEqual([{ value: 1 }]);
133:         });
134: 
135:         it("should skip lines without data prefix", async () => {
136:             const mockStream = createReadableStream([
137:                 'event: message\ndata: {"value": 1}\nid: 123\ndata: {"value": 2}\n',
138:             ]);
139:             const stream = new Stream({
140:                 stream: mockStream,
141:                 parse: async (val: unknown) => val as { value: number },
142:                 eventShape: { type: "sse" },
143:             });
144: 
145:             const messages: unknown[] = [];
146:             for await (const message of stream) {
147:                 messages.push(message);
148:             }
149: 
150:             expect(messages).toEqual([{ value: 1 }, { value: 2 }]);
151:         });
152:     });
153: 
154:     describe("encoding and decoding", () => {
155:         it("should decode UTF-8 text using TextDecoder", async () => {
156:             const encoder = new TextEncoder();
157:             const mockStream = createReadableStream([encoder.encode('{"text": "café"}\n')]);
158:             const stream = new Stream({
159:                 stream: mockStream,
160:                 parse: async (val: unknown) => val as { text: string },
161:                 eventShape: { type: "json", messageTerminator: "\n" },
162:             });
163: 
164:             const messages: unknown[] = [];
165:             for await (const message of stream) {
166:                 messages.push(message);
167:             }
168: 
169:             expect(messages).toEqual([{ text: "café" }]);
170:         });
171: 
172:         it("should decode emoji correctly", async () => {
173:             const encoder = new TextEncoder();
174:             const mockStream = createReadableStream([encoder.encode('{"emoji": "🎉"}\n')]);
175:             const stream = new Stream({
176:                 stream: mockStream,
177:                 parse: async (val: unknown) => val as { emoji: string },
178:                 eventShape: { type: "json", messageTerminator: "\n" },
179:             });
180: 
181:             const messages: unknown[] = [];
182:             for await (const message of stream) {
183:                 messages.push(message);
184:             }
185: 
186:             expect(messages).toEqual([{ emoji: "🎉" }]);
187:         });
188: 
189:         it("should handle binary data chunks", async () => {
190:             const encoder = new TextEncoder();
191:             const mockStream = createReadableStream([encoder.encode('{"val'), encoder.encode('ue": 1}\n')]);
192:             const stream = new Stream({
193:                 stream: mockStream,
194:                 parse: async (val: unknown) => val as { value: number },
195:                 eventShape: { type: "json", messageTerminator: "\n" },
196:             });
197: 
198:             const messages: unknown[] = [];
199:             for await (const message of stream) {
200:                 messages.push(message);
201:             }
202: 
203:             expect(messages).toEqual([{ value: 1 }]);
204:         });
205: 
206:         it("should handle multi-byte UTF-8 characters split across chunk boundaries", async () => {
207:             // Test string with Japanese (3 bytes), Russian (2 bytes), German (2 bytes), and Chinese (3 bytes)
208:             const testString = '{"text": "こんにちは Привет Größe 你好"}\n';
209:             const fullBytes = new TextEncoder().encode(testString);
210: 
211:             // Split the bytes in the middle of multi-byte characters
212:             // Japanese "こ" starts at byte 11, is 3 bytes (E3 81 93)
213:             // Split after first byte of "こ" to test mid-character splitting
214:             const splitPoint = 12; // This splits "こ" in the middle
215:             const chunk1 = fullBytes.slice(0, splitPoint);
216:             const chunk2 = fullBytes.slice(splitPoint);
217: 
218:             const mockStream = createReadableStream([chunk1, chunk2]);
219:             const stream = new Stream({
220:                 stream: mockStream,
221:                 parse: async (val: unknown) => val as { text: string },
222:                 eventShape: { type: "json", messageTerminator: "\n" },
223:             });
224: 
225:             const messages: unknown[] = [];
226:             for await (const message of stream) {
227:                 messages.push(message);
228:             }
229: 
230:             expect(messages).toEqual([{ text: "こんにちは Привет Größe 你好" }]);
231:         });
232:     });
233: 
234:     describe("abort signal", () => {
235:         it("should handle abort signal", async () => {
236:             const controller = new AbortController();
237:             const mockStream = createReadableStream(['{"value": 1}\n{"value": 2}\n{"value": 3}\n']);
238:             const stream = new Stream({
239:                 stream: mockStream,
240:                 parse: async (val: unknown) => val as { value: number },
241:                 eventShape: { type: "json", messageTerminator: "\n" },
242:                 signal: controller.signal,
243:             });
244: 
245:             const messages: unknown[] = [];
246:             let count = 0;
247:             for await (const message of stream) {
248:                 messages.push(message);
249:                 count++;
250:                 if (count === 2) {
251:                     controller.abort();
252:                     break;
253:                 }
254:             }
255: 
256:             expect(messages.length).toBe(2);
257:         });
258:     });
259: 
260:     describe("async iteration", () => {
261:         it("should support async iterator protocol", async () => {
262:             const mockStream = createReadableStream(['{"value": 1}\n{"value": 2}\n']);
263:             const stream = new Stream({
264:                 stream: mockStream,
265:                 parse: async (val: unknown) => val as { value: number },
266:                 eventShape: { type: "json", messageTerminator: "\n" },
267:             });
268: 
269:             const iterator = stream[Symbol.asyncIterator]();
270:             const first = await iterator.next();
271:             expect(first.done).toBe(false);
272:             expect(first.value).toEqual({ value: 1 });
273: 
274:             const second = await iterator.next();
275:             expect(second.done).toBe(false);
276:             expect(second.value).toEqual({ value: 2 });
277: 
278:             const third = await iterator.next();
279:             expect(third.done).toBe(true);
280:         });
281:     });
282: 
283:     describe("edge cases", () => {
284:         it("should handle empty stream", async () => {
285:             const mockStream = createReadableStream([]);
286:             const stream = new Stream({
287:                 stream: mockStream,
288:                 parse: async (val: unknown) => val as { value: number },
289:                 eventShape: { type: "json", messageTerminator: "\n" },
290:             });
291: 
292:             const messages: unknown[] = [];
293:             for await (const message of stream) {
294:                 messages.push(message);
295:             }
296: 
297:             expect(messages).toEqual([]);
298:         });
299: 
300:         it("should handle stream with only whitespace", async () => {
301:             const mockStream = createReadableStream(["   \n\n\t\n   "]);
302:             const stream = new Stream({
303:                 stream: mockStream,
304:                 parse: async (val: unknown) => val as { value: number },
305:                 eventShape: { type: "json", messageTerminator: "\n" },
306:             });
307: 
308:             const messages: unknown[] = [];
309:             for await (const message of stream) {
310:                 messages.push(message);
311:             }
312: 
313:             expect(messages).toEqual([]);
314:         });
315: 
316:         it("should handle incomplete message at end of stream", async () => {
317:             const mockStream = createReadableStream(['{"value": 1}\n{"incomplete']);
318:             const stream = new Stream({
319:                 stream: mockStream,
320:                 parse: async (val: unknown) => val as { value: number },
321:                 eventShape: { type: "json", messageTerminator: "\n" },
322:             });
323: 
324:             const messages: unknown[] = [];
325:             for await (const message of stream) {
326:                 messages.push(message);
327:             }
328: 
329:             expect(messages).toEqual([{ value: 1 }]);
330:         });
331:     });
332: });
333: 
334: // Helper function to create a ReadableStream from string chunks
335: function createReadableStream(chunks: (string | Uint8Array)[]): ReadableStream {
336:     // For standard type, return ReadableStream
337:     let index = 0;
338:     return new ReadableStream({
339:         pull(controller) {
340:             if (index < chunks.length) {
341:                 const chunk = chunks[index++];
342:                 controller.enqueue(typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk);
343:             } else {
344:                 controller.close();
345:             }
346:         },
347:     });
348: }
````

## File: tests/unit/url/join.test.ts
````typescript
  1: import { join } from "../../../src/core/url/index";
  2: 
  3: describe("join", () => {
  4:     interface TestCase {
  5:         description: string;
  6:         base: string;
  7:         segments: string[];
  8:         expected: string;
  9:     }
 10: 
 11:     describe("basic functionality", () => {
 12:         const basicTests: TestCase[] = [
 13:             { description: "should return empty string for empty base", base: "", segments: [], expected: "" },
 14:             {
 15:                 description: "should return empty string for empty base with path",
 16:                 base: "",
 17:                 segments: ["path"],
 18:                 expected: "",
 19:             },
 20:             {
 21:                 description: "should handle single segment",
 22:                 base: "base",
 23:                 segments: ["segment"],
 24:                 expected: "base/segment",
 25:             },
 26:             {
 27:                 description: "should handle single segment with trailing slash on base",
 28:                 base: "base/",
 29:                 segments: ["segment"],
 30:                 expected: "base/segment",
 31:             },
 32:             {
 33:                 description: "should handle single segment with leading slash",
 34:                 base: "base",
 35:                 segments: ["/segment"],
 36:                 expected: "base/segment",
 37:             },
 38:             {
 39:                 description: "should handle single segment with both slashes",
 40:                 base: "base/",
 41:                 segments: ["/segment"],
 42:                 expected: "base/segment",
 43:             },
 44:             {
 45:                 description: "should handle multiple segments",
 46:                 base: "base",
 47:                 segments: ["path1", "path2", "path3"],
 48:                 expected: "base/path1/path2/path3",
 49:             },
 50:             {
 51:                 description: "should handle multiple segments with slashes",
 52:                 base: "base/",
 53:                 segments: ["/path1/", "/path2/", "/path3/"],
 54:                 expected: "base/path1/path2/path3/",
 55:             },
 56:         ];
 57: 
 58:         basicTests.forEach(({ description, base, segments, expected }) => {
 59:             it(description, () => {
 60:                 expect(join(base, ...segments)).toBe(expected);
 61:             });
 62:         });
 63:     });
 64: 
 65:     describe("URL handling", () => {
 66:         const urlTests: TestCase[] = [
 67:             {
 68:                 description: "should handle absolute URLs",
 69:                 base: "https://example.com",
 70:                 segments: ["api", "v1"],
 71:                 expected: "https://example.com/api/v1",
 72:             },
 73:             {
 74:                 description: "should handle absolute URLs with slashes",
 75:                 base: "https://example.com/",
 76:                 segments: ["/api/", "/v1/"],
 77:                 expected: "https://example.com/api/v1/",
 78:             },
 79:             {
 80:                 description: "should handle absolute URLs with base path",
 81:                 base: "https://example.com/base",
 82:                 segments: ["api", "v1"],
 83:                 expected: "https://example.com/base/api/v1",
 84:             },
 85:             {
 86:                 description: "should preserve URL query parameters",
 87:                 base: "https://example.com?query=1",
 88:                 segments: ["api"],
 89:                 expected: "https://example.com/api?query=1",
 90:             },
 91:             {
 92:                 description: "should preserve URL fragments",
 93:                 base: "https://example.com#fragment",
 94:                 segments: ["api"],
 95:                 expected: "https://example.com/api#fragment",
 96:             },
 97:             {
 98:                 description: "should preserve URL query and fragments",
 99:                 base: "https://example.com?query=1#fragment",
100:                 segments: ["api"],
101:                 expected: "https://example.com/api?query=1#fragment",
102:             },
103:             {
104:                 description: "should handle http protocol",
105:                 base: "http://example.com",
106:                 segments: ["api"],
107:                 expected: "http://example.com/api",
108:             },
109:             {
110:                 description: "should handle ftp protocol",
111:                 base: "ftp://example.com",
112:                 segments: ["files"],
113:                 expected: "ftp://example.com/files",
114:             },
115:             {
116:                 description: "should handle ws protocol",
117:                 base: "ws://example.com",
118:                 segments: ["socket"],
119:                 expected: "ws://example.com/socket",
120:             },
121:             {
122:                 description: "should fallback to path joining for malformed URLs",
123:                 base: "not-a-url://",
124:                 segments: ["path"],
125:                 expected: "not-a-url:///path",
126:             },
127:         ];
128: 
129:         urlTests.forEach(({ description, base, segments, expected }) => {
130:             it(description, () => {
131:                 expect(join(base, ...segments)).toBe(expected);
132:             });
133:         });
134:     });
135: 
136:     describe("edge cases", () => {
137:         const edgeCaseTests: TestCase[] = [
138:             {
139:                 description: "should handle empty segments",
140:                 base: "base",
141:                 segments: ["", "path"],
142:                 expected: "base/path",
143:             },
144:             {
145:                 description: "should handle null segments",
146:                 base: "base",
147:                 segments: [null as any, "path"],
148:                 expected: "base/path",
149:             },
150:             {
151:                 description: "should handle undefined segments",
152:                 base: "base",
153:                 segments: [undefined as any, "path"],
154:                 expected: "base/path",
155:             },
156:             {
157:                 description: "should handle segments with only single slash",
158:                 base: "base",
159:                 segments: ["/", "path"],
160:                 expected: "base/path",
161:             },
162:             {
163:                 description: "should handle segments with only double slash",
164:                 base: "base",
165:                 segments: ["//", "path"],
166:                 expected: "base/path",
167:             },
168:             {
169:                 description: "should handle base paths with trailing slashes",
170:                 base: "base/",
171:                 segments: ["path"],
172:                 expected: "base/path",
173:             },
174:             {
175:                 description: "should handle complex nested paths",
176:                 base: "api/v1/",
177:                 segments: ["/users/", "/123/", "/profile"],
178:                 expected: "api/v1/users/123/profile",
179:             },
180:         ];
181: 
182:         edgeCaseTests.forEach(({ description, base, segments, expected }) => {
183:             it(description, () => {
184:                 expect(join(base, ...segments)).toBe(expected);
185:             });
186:         });
187:     });
188: 
189:     describe("real-world scenarios", () => {
190:         const realWorldTests: TestCase[] = [
191:             {
192:                 description: "should handle API endpoint construction",
193:                 base: "https://api.example.com/v1",
194:                 segments: ["users", "123", "posts"],
195:                 expected: "https://api.example.com/v1/users/123/posts",
196:             },
197:             {
198:                 description: "should handle file path construction",
199:                 base: "/var/www",
200:                 segments: ["html", "assets", "images"],
201:                 expected: "/var/www/html/assets/images",
202:             },
203:             {
204:                 description: "should handle relative path construction",
205:                 base: "../parent",
206:                 segments: ["child", "grandchild"],
207:                 expected: "../parent/child/grandchild",
208:             },
209:             {
210:                 description: "should handle Windows-style paths",
211:                 base: "C:\\Users",
212:                 segments: ["Documents", "file.txt"],
213:                 expected: "C:\\Users/Documents/file.txt",
214:             },
215:         ];
216: 
217:         realWorldTests.forEach(({ description, base, segments, expected }) => {
218:             it(description, () => {
219:                 expect(join(base, ...segments)).toBe(expected);
220:             });
221:         });
222:     });
223: 
224:     describe("performance scenarios", () => {
225:         it("should handle many segments efficiently", () => {
226:             const segments = Array(100).fill("segment");
227:             const result = join("base", ...segments);
228:             expect(result).toBe(`base/${segments.join("/")}`);
229:         });
230: 
231:         it("should handle long URLs", () => {
232:             const longPath = "a".repeat(1000);
233:             expect(join("https://example.com", longPath)).toBe(`https://example.com/${longPath}`);
234:         });
235:     });
236: 
237:     describe("trailing slash preservation", () => {
238:         const trailingSlashTests: TestCase[] = [
239:             {
240:                 description:
241:                     "should preserve trailing slash on final result when base has trailing slash and no segments",
242:                 base: "https://api.example.com/",
243:                 segments: [],
244:                 expected: "https://api.example.com/",
245:             },
246:             {
247:                 description: "should preserve trailing slash on v1 path",
248:                 base: "https://api.example.com/v1/",
249:                 segments: [],
250:                 expected: "https://api.example.com/v1/",
251:             },
252:             {
253:                 description: "should preserve trailing slash when last segment has trailing slash",
254:                 base: "https://api.example.com",
255:                 segments: ["users/"],
256:                 expected: "https://api.example.com/users/",
257:             },
258:             {
259:                 description: "should preserve trailing slash with relative path",
260:                 base: "api/v1",
261:                 segments: ["users/"],
262:                 expected: "api/v1/users/",
263:             },
264:             {
265:                 description: "should preserve trailing slash with multiple segments",
266:                 base: "https://api.example.com",
267:                 segments: ["v1", "collections/"],
268:                 expected: "https://api.example.com/v1/collections/",
269:             },
270:             {
271:                 description: "should preserve trailing slash with base path",
272:                 base: "base",
273:                 segments: ["path1", "path2/"],
274:                 expected: "base/path1/path2/",
275:             },
276:         ];
277: 
278:         trailingSlashTests.forEach(({ description, base, segments, expected }) => {
279:             it(description, () => {
280:                 expect(join(base, ...segments)).toBe(expected);
281:             });
282:         });
283:     });
284: });
````

## File: tests/unit/url/qs.test.ts
````typescript
  1: import { toQueryString } from "../../../src/core/url/index";
  2: 
  3: describe("Test qs toQueryString", () => {
  4:     interface BasicTestCase {
  5:         description: string;
  6:         input: any;
  7:         expected: string;
  8:     }
  9: 
 10:     describe("Basic functionality", () => {
 11:         const basicTests: BasicTestCase[] = [
 12:             { description: "should return empty string for null", input: null, expected: "" },
 13:             { description: "should return empty string for undefined", input: undefined, expected: "" },
 14:             { description: "should return empty string for string primitive", input: "hello", expected: "" },
 15:             { description: "should return empty string for number primitive", input: 42, expected: "" },
 16:             { description: "should return empty string for true boolean", input: true, expected: "" },
 17:             { description: "should return empty string for false boolean", input: false, expected: "" },
 18:             { description: "should handle empty objects", input: {}, expected: "" },
 19:             {
 20:                 description: "should handle simple key-value pairs",
 21:                 input: { name: "John", age: 30 },
 22:                 expected: "name=John&age=30",
 23:             },
 24:         ];
 25: 
 26:         basicTests.forEach(({ description, input, expected }) => {
 27:             it(description, () => {
 28:                 expect(toQueryString(input)).toBe(expected);
 29:             });
 30:         });
 31:     });
 32: 
 33:     describe("Array handling", () => {
 34:         interface ArrayTestCase {
 35:             description: string;
 36:             input: any;
 37:             options?: { arrayFormat?: "repeat" | "indices" };
 38:             expected: string;
 39:         }
 40: 
 41:         const arrayTests: ArrayTestCase[] = [
 42:             {
 43:                 description: "should handle arrays with indices format (default)",
 44:                 input: { items: ["a", "b", "c"] },
 45:                 expected: "items%5B0%5D=a&items%5B1%5D=b&items%5B2%5D=c",
 46:             },
 47:             {
 48:                 description: "should handle arrays with repeat format",
 49:                 input: { items: ["a", "b", "c"] },
 50:                 options: { arrayFormat: "repeat" },
 51:                 expected: "items=a&items=b&items=c",
 52:             },
 53:             {
 54:                 description: "should handle empty arrays",
 55:                 input: { items: [] },
 56:                 expected: "",
 57:             },
 58:             {
 59:                 description: "should handle arrays with mixed types",
 60:                 input: { mixed: ["string", 42, true, false] },
 61:                 expected: "mixed%5B0%5D=string&mixed%5B1%5D=42&mixed%5B2%5D=true&mixed%5B3%5D=false",
 62:             },
 63:             {
 64:                 description: "should handle arrays with objects",
 65:                 input: { users: [{ name: "John" }, { name: "Jane" }] },
 66:                 expected: "users%5B0%5D%5Bname%5D=John&users%5B1%5D%5Bname%5D=Jane",
 67:             },
 68:             {
 69:                 description: "should handle arrays with objects in repeat format",
 70:                 input: { users: [{ name: "John" }, { name: "Jane" }] },
 71:                 options: { arrayFormat: "repeat" },
 72:                 expected: "users%5Bname%5D=John&users%5Bname%5D=Jane",
 73:             },
 74:         ];
 75: 
 76:         arrayTests.forEach(({ description, input, options, expected }) => {
 77:             it(description, () => {
 78:                 expect(toQueryString(input, options)).toBe(expected);
 79:             });
 80:         });
 81:     });
 82: 
 83:     describe("Nested objects", () => {
 84:         const nestedTests: BasicTestCase[] = [
 85:             {
 86:                 description: "should handle nested objects",
 87:                 input: { user: { name: "John", age: 30 } },
 88:                 expected: "user%5Bname%5D=John&user%5Bage%5D=30",
 89:             },
 90:             {
 91:                 description: "should handle deeply nested objects",
 92:                 input: { user: { profile: { name: "John", settings: { theme: "dark" } } } },
 93:                 expected: "user%5Bprofile%5D%5Bname%5D=John&user%5Bprofile%5D%5Bsettings%5D%5Btheme%5D=dark",
 94:             },
 95:             {
 96:                 description: "should handle empty nested objects",
 97:                 input: { user: {} },
 98:                 expected: "",
 99:             },
100:         ];
101: 
102:         nestedTests.forEach(({ description, input, expected }) => {
103:             it(description, () => {
104:                 expect(toQueryString(input)).toBe(expected);
105:             });
106:         });
107:     });
108: 
109:     describe("Encoding", () => {
110:         interface EncodingTestCase {
111:             description: string;
112:             input: any;
113:             options?: { encode?: boolean };
114:             expected: string;
115:         }
116: 
117:         const encodingTests: EncodingTestCase[] = [
118:             {
119:                 description: "should encode by default",
120:                 input: { name: "John Doe", email: "john@example.com" },
121:                 expected: "name=John%20Doe&email=john%40example.com",
122:             },
123:             {
124:                 description: "should not encode when encode is false",
125:                 input: { name: "John Doe", email: "john@example.com" },
126:                 options: { encode: false },
127:                 expected: "name=John Doe&email=john@example.com",
128:             },
129:             {
130:                 description: "should encode special characters in keys",
131:                 input: { "user name": "John", "email[primary]": "john@example.com" },
132:                 expected: "user%20name=John&email%5Bprimary%5D=john%40example.com",
133:             },
134:             {
135:                 description: "should not encode special characters in keys when encode is false",
136:                 input: { "user name": "John", "email[primary]": "john@example.com" },
137:                 options: { encode: false },
138:                 expected: "user name=John&email[primary]=john@example.com",
139:             },
140:         ];
141: 
142:         encodingTests.forEach(({ description, input, options, expected }) => {
143:             it(description, () => {
144:                 expect(toQueryString(input, options)).toBe(expected);
145:             });
146:         });
147:     });
148: 
149:     describe("Mixed scenarios", () => {
150:         interface MixedTestCase {
151:             description: string;
152:             input: any;
153:             options?: { arrayFormat?: "repeat" | "indices" };
154:             expected: string;
155:         }
156: 
157:         const mixedTests: MixedTestCase[] = [
158:             {
159:                 description: "should handle complex nested structures",
160:                 input: {
161:                     filters: {
162:                         status: ["active", "pending"],
163:                         category: {
164:                             type: "electronics",
165:                             subcategories: ["phones", "laptops"],
166:                         },
167:                     },
168:                     sort: { field: "name", direction: "asc" },
169:                 },
170:                 expected:
171:                     "filters%5Bstatus%5D%5B0%5D=active&filters%5Bstatus%5D%5B1%5D=pending&filters%5Bcategory%5D%5Btype%5D=electronics&filters%5Bcategory%5D%5Bsubcategories%5D%5B0%5D=phones&filters%5Bcategory%5D%5Bsubcategories%5D%5B1%5D=laptops&sort%5Bfield%5D=name&sort%5Bdirection%5D=asc",
172:             },
173:             {
174:                 description: "should handle complex nested structures with repeat format",
175:                 input: {
176:                     filters: {
177:                         status: ["active", "pending"],
178:                         category: {
179:                             type: "electronics",
180:                             subcategories: ["phones", "laptops"],
181:                         },
182:                     },
183:                     sort: { field: "name", direction: "asc" },
184:                 },
185:                 options: { arrayFormat: "repeat" },
186:                 expected:
187:                     "filters%5Bstatus%5D=active&filters%5Bstatus%5D=pending&filters%5Bcategory%5D%5Btype%5D=electronics&filters%5Bcategory%5D%5Bsubcategories%5D=phones&filters%5Bcategory%5D%5Bsubcategories%5D=laptops&sort%5Bfield%5D=name&sort%5Bdirection%5D=asc",
188:             },
189:             {
190:                 description: "should handle arrays with null/undefined values",
191:                 input: { items: ["a", null, "c", undefined, "e"] },
192:                 expected: "items%5B0%5D=a&items%5B1%5D=&items%5B2%5D=c&items%5B4%5D=e",
193:             },
194:             {
195:                 description: "should handle objects with null/undefined values",
196:                 input: { name: "John", age: null, email: undefined, active: true },
197:                 expected: "name=John&age=&active=true",
198:             },
199:         ];
200: 
201:         mixedTests.forEach(({ description, input, options, expected }) => {
202:             it(description, () => {
203:                 expect(toQueryString(input, options)).toBe(expected);
204:             });
205:         });
206:     });
207: 
208:     describe("Edge cases", () => {
209:         const edgeCaseTests: BasicTestCase[] = [
210:             {
211:                 description: "should handle numeric keys",
212:                 input: { "0": "zero", "1": "one" },
213:                 expected: "0=zero&1=one",
214:             },
215:             {
216:                 description: "should handle boolean values in objects",
217:                 input: { enabled: true, disabled: false },
218:                 expected: "enabled=true&disabled=false",
219:             },
220:             {
221:                 description: "should handle empty strings",
222:                 input: { name: "", description: "test" },
223:                 expected: "name=&description=test",
224:             },
225:             {
226:                 description: "should handle zero values",
227:                 input: { count: 0, price: 0.0 },
228:                 expected: "count=0&price=0",
229:             },
230:             {
231:                 description: "should handle arrays with empty strings",
232:                 input: { items: ["a", "", "c"] },
233:                 expected: "items%5B0%5D=a&items%5B1%5D=&items%5B2%5D=c",
234:             },
235:         ];
236: 
237:         edgeCaseTests.forEach(({ description, input, expected }) => {
238:             it(description, () => {
239:                 expect(toQueryString(input)).toBe(expected);
240:             });
241:         });
242:     });
243: 
244:     describe("Options combinations", () => {
245:         interface OptionsTestCase {
246:             description: string;
247:             input: any;
248:             options?: { arrayFormat?: "repeat" | "indices"; encode?: boolean };
249:             expected: string;
250:         }
251: 
252:         const optionsTests: OptionsTestCase[] = [
253:             {
254:                 description: "should respect both arrayFormat and encode options",
255:                 input: { items: ["a & b", "c & d"] },
256:                 options: { arrayFormat: "repeat", encode: false },
257:                 expected: "items=a & b&items=c & d",
258:             },
259:             {
260:                 description: "should use default options when none provided",
261:                 input: { items: ["a", "b"] },
262:                 expected: "items%5B0%5D=a&items%5B1%5D=b",
263:             },
264:             {
265:                 description: "should merge provided options with defaults",
266:                 input: { items: ["a", "b"], name: "John Doe" },
267:                 options: { encode: false },
268:                 expected: "items[0]=a&items[1]=b&name=John Doe",
269:             },
270:         ];
271: 
272:         optionsTests.forEach(({ description, input, options, expected }) => {
273:             it(description, () => {
274:                 expect(toQueryString(input, options)).toBe(expected);
275:             });
276:         });
277:     });
278: });
````

## File: tests/unit/utils/setObjectProperty.test.ts
````typescript
 1: import { setObjectProperty } from "../../../src/core/utils/setObjectProperty";
 2: 
 3: interface TestCase {
 4:     description: string;
 5:     giveObject: object;
 6:     givePath: string;
 7:     giveValue: any;
 8:     wantObject: object;
 9: }
10: 
11: describe("Test setObjectProperty", () => {
12:     const testCases: TestCase[] = [
13:         {
14:             description: "empty",
15:             giveObject: {},
16:             givePath: "",
17:             giveValue: 0,
18:             wantObject: { "": 0 },
19:         },
20:         {
21:             description: "top-level primitive",
22:             giveObject: {},
23:             givePath: "age",
24:             giveValue: 42,
25:             wantObject: { age: 42 },
26:         },
27:         {
28:             description: "top-level object",
29:             giveObject: {},
30:             givePath: "name",
31:             giveValue: { first: "John", last: "Doe" },
32:             wantObject: { name: { first: "John", last: "Doe" } },
33:         },
34:         {
35:             description: "top-level array",
36:             giveObject: {},
37:             givePath: "values",
38:             giveValue: [1, 2, 3],
39:             wantObject: { values: [1, 2, 3] },
40:         },
41:         {
42:             description: "nested object property",
43:             giveObject: {
44:                 name: {
45:                     first: "John",
46:                 },
47:             },
48:             givePath: "name.last",
49:             giveValue: "Doe",
50:             wantObject: { name: { first: "John", last: "Doe" } },
51:         },
52:         {
53:             description: "deeply nested object property",
54:             giveObject: {
55:                 info: {
56:                     address: {
57:                         street: "123 Main St.",
58:                     },
59:                     age: 42,
60:                     name: {
61:                         last: "Doe",
62:                     },
63:                 },
64:             },
65:             givePath: "info.name.first",
66:             giveValue: "John",
67:             wantObject: {
68:                 info: { age: 42, address: { street: "123 Main St." }, name: { first: "John", last: "Doe" } },
69:             },
70:         },
71:     ];
72:     test.each(testCases)("$description", ({ giveObject, givePath, giveValue, wantObject }) => {
73:         const result = setObjectProperty(giveObject, givePath, giveValue);
74:         expect(result).toEqual(wantObject);
75:     });
76: });
````

## File: tests/unit/base64.test.ts
````typescript
 1: import { base64Decode, base64Encode } from "../../src/core/base64";
 2: 
 3: describe("base64", () => {
 4:     describe("base64Encode", () => {
 5:         it("should encode ASCII strings", () => {
 6:             expect(base64Encode("hello")).toBe("aGVsbG8=");
 7:             expect(base64Encode("")).toBe("");
 8:         });
 9: 
10:         it("should encode UTF-8 strings", () => {
11:             expect(base64Encode("café")).toBe("Y2Fmw6k=");
12:             expect(base64Encode("🎉")).toBe("8J+OiQ==");
13:         });
14: 
15:         it("should handle basic auth credentials", () => {
16:             expect(base64Encode("username:password")).toBe("dXNlcm5hbWU6cGFzc3dvcmQ=");
17:         });
18:     });
19: 
20:     describe("base64Decode", () => {
21:         it("should decode ASCII strings", () => {
22:             expect(base64Decode("aGVsbG8=")).toBe("hello");
23:             expect(base64Decode("")).toBe("");
24:         });
25: 
26:         it("should decode UTF-8 strings", () => {
27:             expect(base64Decode("Y2Fmw6k=")).toBe("café");
28:             expect(base64Decode("8J+OiQ==")).toBe("🎉");
29:         });
30: 
31:         it("should handle basic auth credentials", () => {
32:             expect(base64Decode("dXNlcm5hbWU6cGFzc3dvcmQ=")).toBe("username:password");
33:         });
34:     });
35: 
36:     describe("round-trip encoding", () => {
37:         const testStrings = [
38:             "hello world",
39:             "test@example.com",
40:             "café",
41:             "username:password",
42:             "user@domain.com:super$ecret123!",
43:         ];
44: 
45:         testStrings.forEach((testString) => {
46:             it(`should round-trip encode/decode: "${testString}"`, () => {
47:                 const encoded = base64Encode(testString);
48:                 const decoded = base64Decode(encoded);
49:                 expect(decoded).toBe(testString);
50:             });
51:         });
52:     });
53: });
````

## File: tests/unit/test-file.txt
````
1: This is a test file!
````

## File: tests/wire/empathic-voice/chatGroups.test.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import * as Hume from "../../../src/api/index";
  4: import { HumeClient } from "../../../src/Client";
  5: import { mockServerPool } from "../../mock-server/MockServerPool";
  6: 
  7: describe("ChatGroupsClient", () => {
  8:     test("list-chat-groups (1)", async () => {
  9:         const server = mockServerPool.createServer();
 10:         const client = new HumeClient({
 11:             maxRetries: 0,
 12:             apiKey: "test",
 13:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 14:         });
 15: 
 16:         const rawResponseBody = {
 17:             page_number: 0,
 18:             page_size: 1,
 19:             total_pages: 1,
 20:             pagination_direction: "ASC",
 21:             chat_groups_page: [
 22:                 {
 23:                     id: "697056f0-6c7e-487d-9bd8-9c19df79f05f",
 24:                     first_start_timestamp: 1721844196397,
 25:                     most_recent_start_timestamp: 1721861821717,
 26:                     active: false,
 27:                     most_recent_chat_id: "dfdbdd4d-0ddf-418b-8fc4-80a266579d36",
 28:                     num_chats: 5,
 29:                 },
 30:             ],
 31:         };
 32:         server
 33:             .mockEndpoint({ once: false })
 34:             .get("/v0/evi/chat_groups")
 35:             .respondWith()
 36:             .statusCode(200)
 37:             .jsonBody(rawResponseBody)
 38:             .build();
 39: 
 40:         const expected = {
 41:             pageNumber: 0,
 42:             pageSize: 1,
 43:             totalPages: 1,
 44:             paginationDirection: "ASC",
 45:             chatGroupsPage: [
 46:                 {
 47:                     id: "697056f0-6c7e-487d-9bd8-9c19df79f05f",
 48:                     firstStartTimestamp: 1721844196397,
 49:                     mostRecentStartTimestamp: 1721861821717,
 50:                     active: false,
 51:                     mostRecentChatId: "dfdbdd4d-0ddf-418b-8fc4-80a266579d36",
 52:                     numChats: 5,
 53:                 },
 54:             ],
 55:         };
 56:         const page = await client.empathicVoice.chatGroups.listChatGroups({
 57:             pageNumber: 0,
 58:             pageSize: 1,
 59:             ascendingOrder: true,
 60:             configId: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 61:         });
 62: 
 63:         expect(expected.chatGroupsPage).toEqual(page.data);
 64:         expect(page.hasNextPage()).toBe(true);
 65:         const nextPage = await page.getNextPage();
 66:         expect(expected.chatGroupsPage).toEqual(nextPage.data);
 67:     });
 68: 
 69:     test("list-chat-groups (2)", async () => {
 70:         const server = mockServerPool.createServer();
 71:         const client = new HumeClient({
 72:             maxRetries: 0,
 73:             apiKey: "test",
 74:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 75:         });
 76: 
 77:         const rawResponseBody = {};
 78:         server
 79:             .mockEndpoint({ once: false })
 80:             .get("/v0/evi/chat_groups")
 81:             .respondWith()
 82:             .statusCode(400)
 83:             .jsonBody(rawResponseBody)
 84:             .build();
 85: 
 86:         await expect(async () => {
 87:             return await client.empathicVoice.chatGroups.listChatGroups();
 88:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
 89:     });
 90: 
 91:     test("get-chat-group (1)", async () => {
 92:         const server = mockServerPool.createServer();
 93:         const client = new HumeClient({
 94:             maxRetries: 0,
 95:             apiKey: "test",
 96:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 97:         });
 98: 
 99:         const rawResponseBody = {
100:             id: "369846cf-6ad5-404d-905e-a8acb5cdfc78",
101:             first_start_timestamp: 1712334213647,
102:             most_recent_start_timestamp: 1712334213647,
103:             num_chats: 1,
104:             page_number: 0,
105:             page_size: 1,
106:             total_pages: 1,
107:             pagination_direction: "ASC",
108:             chats_page: [
109:                 {
110:                     id: "6375d4f8-cd3e-4d6b-b13b-ace66b7c8aaa",
111:                     chat_group_id: "369846cf-6ad5-404d-905e-a8acb5cdfc78",
112:                     status: "USER_ENDED",
113:                     start_timestamp: 1712334213647,
114:                     end_timestamp: 1712334332571,
115:                     event_count: 0,
116:                 },
117:             ],
118:             active: false,
119:         };
120:         server
121:             .mockEndpoint()
122:             .get("/v0/evi/chat_groups/697056f0-6c7e-487d-9bd8-9c19df79f05f")
123:             .respondWith()
124:             .statusCode(200)
125:             .jsonBody(rawResponseBody)
126:             .build();
127: 
128:         const response = await client.empathicVoice.chatGroups.getChatGroup("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
129:             pageNumber: 0,
130:             pageSize: 1,
131:             ascendingOrder: true,
132:         });
133:         expect(response).toEqual({
134:             id: "369846cf-6ad5-404d-905e-a8acb5cdfc78",
135:             firstStartTimestamp: 1712334213647,
136:             mostRecentStartTimestamp: 1712334213647,
137:             numChats: 1,
138:             pageNumber: 0,
139:             pageSize: 1,
140:             totalPages: 1,
141:             paginationDirection: "ASC",
142:             chatsPage: [
143:                 {
144:                     id: "6375d4f8-cd3e-4d6b-b13b-ace66b7c8aaa",
145:                     chatGroupId: "369846cf-6ad5-404d-905e-a8acb5cdfc78",
146:                     status: "USER_ENDED",
147:                     startTimestamp: 1712334213647,
148:                     endTimestamp: 1712334332571,
149:                     eventCount: 0,
150:                 },
151:             ],
152:             active: false,
153:         });
154:     });
155: 
156:     test("get-chat-group (2)", async () => {
157:         const server = mockServerPool.createServer();
158:         const client = new HumeClient({
159:             maxRetries: 0,
160:             apiKey: "test",
161:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
162:         });
163: 
164:         const rawResponseBody = {};
165:         server
166:             .mockEndpoint()
167:             .get("/v0/evi/chat_groups/id")
168:             .respondWith()
169:             .statusCode(400)
170:             .jsonBody(rawResponseBody)
171:             .build();
172: 
173:         await expect(async () => {
174:             return await client.empathicVoice.chatGroups.getChatGroup("id");
175:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
176:     });
177: 
178:     test("get-audio (1)", async () => {
179:         const server = mockServerPool.createServer();
180:         const client = new HumeClient({
181:             maxRetries: 0,
182:             apiKey: "test",
183:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
184:         });
185: 
186:         const rawResponseBody = {
187:             id: "369846cf-6ad5-404d-905e-a8acb5cdfc78",
188:             user_id: "e6235940-cfda-3988-9147-ff531627cf42",
189:             num_chats: 1,
190:             page_number: 0,
191:             page_size: 10,
192:             total_pages: 1,
193:             pagination_direction: "ASC",
194:             audio_reconstructions_page: [
195:                 {
196:                     id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
197:                     user_id: "e6235940-cfda-3988-9147-ff531627cf42",
198:                     status: "COMPLETE",
199:                     filename:
200:                         "e6235940-cfda-3988-9147-ff531627cf42/470a49f6-1dec-4afe-8b61-035d3b2d63b0/reconstructed_audio.mp4",
201:                     modified_at: 1729875432555,
202:                     signed_audio_url: "https://storage.googleapis.com/...etc.",
203:                     signed_url_expiration_timestamp_millis: 1730232816964,
204:                 },
205:             ],
206:         };
207:         server
208:             .mockEndpoint()
209:             .get("/v0/evi/chat_groups/369846cf-6ad5-404d-905e-a8acb5cdfc78/audio")
210:             .respondWith()
211:             .statusCode(200)
212:             .jsonBody(rawResponseBody)
213:             .build();
214: 
215:         const response = await client.empathicVoice.chatGroups.getAudio("369846cf-6ad5-404d-905e-a8acb5cdfc78", {
216:             pageNumber: 0,
217:             pageSize: 10,
218:             ascendingOrder: true,
219:         });
220:         expect(response).toEqual({
221:             id: "369846cf-6ad5-404d-905e-a8acb5cdfc78",
222:             userId: "e6235940-cfda-3988-9147-ff531627cf42",
223:             numChats: 1,
224:             pageNumber: 0,
225:             pageSize: 10,
226:             totalPages: 1,
227:             paginationDirection: "ASC",
228:             audioReconstructionsPage: [
229:                 {
230:                     id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
231:                     userId: "e6235940-cfda-3988-9147-ff531627cf42",
232:                     status: "COMPLETE",
233:                     filename:
234:                         "e6235940-cfda-3988-9147-ff531627cf42/470a49f6-1dec-4afe-8b61-035d3b2d63b0/reconstructed_audio.mp4",
235:                     modifiedAt: 1729875432555,
236:                     signedAudioUrl: "https://storage.googleapis.com/...etc.",
237:                     signedUrlExpirationTimestampMillis: 1730232816964,
238:                 },
239:             ],
240:         });
241:     });
242: 
243:     test("get-audio (2)", async () => {
244:         const server = mockServerPool.createServer();
245:         const client = new HumeClient({
246:             maxRetries: 0,
247:             apiKey: "test",
248:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
249:         });
250: 
251:         const rawResponseBody = {};
252:         server
253:             .mockEndpoint()
254:             .get("/v0/evi/chat_groups/id/audio")
255:             .respondWith()
256:             .statusCode(400)
257:             .jsonBody(rawResponseBody)
258:             .build();
259: 
260:         await expect(async () => {
261:             return await client.empathicVoice.chatGroups.getAudio("id");
262:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
263:     });
264: 
265:     test("list-chat-group-events (1)", async () => {
266:         const server = mockServerPool.createServer();
267:         const client = new HumeClient({
268:             maxRetries: 0,
269:             apiKey: "test",
270:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
271:         });
272: 
273:         const rawResponseBody = {
274:             id: "697056f0-6c7e-487d-9bd8-9c19df79f05f",
275:             page_number: 0,
276:             page_size: 3,
277:             total_pages: 1,
278:             pagination_direction: "ASC",
279:             events_page: [
280:                 {
281:                     id: "5d44bdbb-49a3-40fb-871d-32bf7e76efe7",
282:                     chat_id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
283:                     timestamp: 1716244940762,
284:                     role: "SYSTEM",
285:                     type: "SYSTEM_PROMPT",
286:                     message_text:
287:                         "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
288:                     emotion_features: "",
289:                     metadata: "",
290:                 },
291:                 {
292:                     id: "5976ddf6-d093-4bb9-ba60-8f6c25832dde",
293:                     chat_id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
294:                     timestamp: 1716244956278,
295:                     role: "USER",
296:                     type: "USER_MESSAGE",
297:                     message_text: "Hello.",
298:                     emotion_features:
299:                         '{"Admiration": 0.09906005859375, "Adoration": 0.12213134765625, "Aesthetic Appreciation": 0.05035400390625, "Amusement": 0.16552734375, "Anger": 0.0037384033203125, "Anxiety": 0.010101318359375, "Awe": 0.058197021484375, "Awkwardness": 0.10552978515625, "Boredom": 0.1141357421875, "Calmness": 0.115234375, "Concentration": 0.00444793701171875, "Confusion": 0.0343017578125, "Contemplation": 0.00812530517578125, "Contempt": 0.009002685546875, "Contentment": 0.087158203125, "Craving": 0.00818634033203125, "Desire": 0.018310546875, "Determination": 0.003238677978515625, "Disappointment": 0.024169921875, "Disgust": 0.00702667236328125, "Distress": 0.00936126708984375, "Doubt": 0.00632476806640625, "Ecstasy": 0.0293731689453125, "Embarrassment": 0.01800537109375, "Empathic Pain": 0.0088348388671875, "Entrancement": 0.013397216796875, "Envy": 0.02557373046875, "Excitement": 0.12109375, "Fear": 0.004413604736328125, "Guilt": 0.016571044921875, "Horror": 0.00274658203125, "Interest": 0.2142333984375, "Joy": 0.29638671875, "Love": 0.16015625, "Nostalgia": 0.007843017578125, "Pain": 0.007160186767578125, "Pride": 0.00508880615234375, "Realization": 0.054229736328125, "Relief": 0.048736572265625, "Romance": 0.026397705078125, "Sadness": 0.0265350341796875, "Satisfaction": 0.051361083984375, "Shame": 0.00974273681640625, "Surprise (negative)": 0.0218963623046875, "Surprise (positive)": 0.216064453125, "Sympathy": 0.021728515625, "Tiredness": 0.0173797607421875, "Triumph": 0.004520416259765625}',
300:                     metadata:
301:                         '{"segments": [{"content": "Hello.", "embedding": [0.6181640625, 0.1763916015625, -30.921875, 1.2705078125, 0.927734375, 0.63720703125, 2.865234375, 0.1080322265625, 0.2978515625, 1.0107421875, 1.34375, 0.74560546875, 0.416259765625, 0.99462890625, -0.333740234375, 0.361083984375, -1.388671875, 1.0107421875, 1.3173828125, 0.55615234375, 0.541015625, -0.1837158203125, 1.697265625, 0.228515625, 2.087890625, -0.311767578125, 0.053680419921875, 1.3349609375, 0.95068359375, 0.00441741943359375, 0.705078125, 1.8916015625, -0.939453125, 0.93701171875, -0.28955078125, 1.513671875, 0.5595703125, 1.0126953125, -0.1624755859375, 1.4072265625, -0.28857421875, -0.4560546875, -0.1500244140625, -0.1102294921875, -0.222412109375, 0.8779296875, 1.275390625, 1.6689453125, 0.80712890625, -0.34814453125, -0.325439453125, 0.412841796875, 0.81689453125, 0.55126953125, 1.671875, 0.6611328125, 0.7451171875, 1.50390625, 1.0224609375, -1.671875, 0.7373046875, 2.1328125, 2.166015625, 0.41015625, -0.127685546875, 1.9345703125, -4.2734375, 0.332275390625, 0.26171875, 0.76708984375, 0.2685546875, 0.468017578125, 1.208984375, -1.517578125, 1.083984375, 0.84814453125, 1.0244140625, -0.0072174072265625, 1.34375, 1.0712890625, 1.517578125, -0.52001953125, 0.59228515625, 0.8154296875, -0.951171875, -0.07757568359375, 1.3330078125, 1.125, 0.61181640625, 1.494140625, 0.357421875, 1.1796875, 1.482421875, 0.8046875, 0.1536865234375, 1.8076171875, 0.68115234375, -15.171875, 1.2294921875, 0.319091796875, 0.499755859375, 1.5771484375, 0.94677734375, -0.2490234375, 0.88525390625, 3.47265625, 0.75927734375, 0.71044921875, 1.2333984375, 1.4169921875, -0.56640625, -1.8095703125, 1.37109375, 0.428955078125, 1.89453125, -0.39013671875, 0.1734619140625, 1.5595703125, -1.2294921875, 2.552734375, 0.58349609375, 0.2156982421875, -0.00984954833984375, -0.6865234375, -0.0272979736328125, -0.2264404296875, 2.853515625, 1.3896484375, 0.52978515625, 0.783203125, 3.0390625, 0.75537109375, 0.219970703125, 0.384521484375, 0.385986328125, 2.0546875, -0.10443115234375, 1.5146484375, 1.4296875, 1.9716796875, 1.1318359375, 0.31591796875, 0.338623046875, 1.654296875, -0.88037109375, -0.21484375, 1.45703125, 1.0380859375, -0.52294921875, -0.47802734375, 0.1650390625, 1.2392578125, -1.138671875, 0.56787109375, 1.318359375, 0.4287109375, 0.1981201171875, 2.4375, 0.281005859375, 0.89404296875, -0.1552734375, 0.6474609375, -0.08331298828125, 0.00740814208984375, -0.045501708984375, -0.578125, 2.02734375, 0.59228515625, 0.35693359375, 1.2919921875, 1.22265625, 1.0537109375, 0.145263671875, 1.05859375, -0.369140625, 0.207275390625, 0.78857421875, 0.599609375, 0.99072265625, 0.24462890625, 1.26953125, 0.08404541015625, 1.349609375, 0.73291015625, 1.3212890625, 0.388916015625, 1.0869140625, 0.9931640625, -1.5673828125, 0.0462646484375, 0.650390625, 0.253662109375, 0.58251953125, 1.8134765625, 0.8642578125, 2.591796875, 0.7314453125, 0.85986328125, 0.5615234375, 0.9296875, 0.04144287109375, 1.66015625, 1.99609375, 1.171875, 1.181640625, 1.5126953125, 0.0224456787109375, 0.58349609375, -1.4931640625, 0.81884765625, 0.732421875, -0.6455078125, -0.62451171875, 1.7802734375, 0.01526641845703125, -0.423095703125, 0.461669921875, 4.87890625, 1.2392578125, -0.6953125, 0.6689453125, 0.62451171875, -1.521484375, 1.7685546875, 0.810546875, 0.65478515625, 0.26123046875, 1.6396484375, 0.87548828125, 1.7353515625, 2.046875, 1.5634765625, 0.69384765625, 1.375, 0.8916015625, 1.0107421875, 0.1304931640625, 2.009765625, 0.06402587890625, -0.08428955078125, 0.04351806640625, -1.7529296875, 2.02734375, 3.521484375, 0.404541015625, 1.6337890625, -0.276611328125, 0.8837890625, -0.1287841796875, 0.91064453125, 0.8193359375, 0.701171875, 0.036529541015625, 1.26171875, 1.0478515625, -0.1422119140625, 1.0634765625, 0.61083984375, 1.3505859375, 1.208984375, 0.57275390625, 1.3623046875, 2.267578125, 0.484375, 0.9150390625, 0.56787109375, -0.70068359375, 0.27587890625, -0.70654296875, 0.8466796875, 0.57568359375, 1.6162109375, 0.87939453125, 2.248046875, -0.5458984375, 1.7744140625, 1.328125, 1.232421875, 0.6806640625, 0.9365234375, 1.052734375, -1.08984375, 1.8330078125, -0.4033203125, 1.0673828125, 0.297607421875, 1.5703125, 1.67578125, 1.34765625, 2.8203125, 2.025390625, -0.48583984375, 0.7626953125, 0.01007843017578125, 1.435546875, 0.007205963134765625, 0.05157470703125, -0.9853515625, 0.26708984375, 1.16796875, 1.2041015625, 1.99609375, -0.07916259765625, 1.244140625, -0.32080078125, 0.6748046875, 0.419921875, 1.3212890625, 1.291015625, 0.599609375, 0.0550537109375, 0.9599609375, 0.93505859375, 0.111083984375, 1.302734375, 0.0833740234375, 2.244140625, 1.25390625, 1.6015625, 0.58349609375, 1.7568359375, -0.263427734375, -0.019866943359375, -0.24658203125, -0.1871337890625, 0.927734375, 0.62255859375, 0.275146484375, 0.79541015625, 1.1796875, 1.1767578125, -0.26123046875, -0.268310546875, 1.8994140625, 1.318359375, 2.1875, 0.2469482421875, 1.41015625, 0.03973388671875, 1.2685546875, 1.1025390625, 0.9560546875, 0.865234375, -1.92578125, 1.154296875, 0.389892578125, 1.130859375, 0.95947265625, 0.72314453125, 2.244140625, 0.048553466796875, 0.626953125, 0.42919921875, 0.82275390625, 0.311767578125, -0.320556640625, 0.01041412353515625, 0.1483154296875, 0.10809326171875, -0.3173828125, 1.1337890625, -0.8642578125, 1.4033203125, 0.048828125, 1.1787109375, 0.98779296875, 1.818359375, 1.1552734375, 0.6015625, 1.2392578125, -1.2685546875, 0.39208984375, 0.83251953125, 0.224365234375, 0.0019989013671875, 0.87548828125, 1.6572265625, 1.107421875, 0.434814453125, 1.8251953125, 0.442626953125, 1.2587890625, 0.09320068359375, -0.896484375, 1.8017578125, 1.451171875, -0.0755615234375, 0.6083984375, 2.06640625, 0.673828125, -0.33740234375, 0.192138671875, 0.21435546875, 0.80224609375, -1.490234375, 0.9501953125, 0.86083984375, -0.40283203125, 4.109375, 2.533203125, 1.2529296875, 0.8271484375, 0.225830078125, 1.0478515625, -1.9755859375, 0.841796875, 0.392822265625, 0.525390625, 0.33935546875, -0.79443359375, 0.71630859375, 0.97998046875, -0.175537109375, 0.97705078125, 1.705078125, 0.29638671875, 0.68359375, 0.54150390625, 0.435791015625, 0.99755859375, -0.369140625, 1.009765625, -0.140380859375, 0.426513671875, 0.189697265625, 1.8193359375, 1.1201171875, -0.5009765625, -0.331298828125, 0.759765625, -0.09442138671875, 0.74609375, -1.947265625, 1.3544921875, -3.935546875, 2.544921875, 1.359375, 0.1363525390625, 0.79296875, 0.79931640625, -0.3466796875, 1.1396484375, -0.33447265625, 2.0078125, -0.241455078125, 0.6318359375, 0.365234375, 0.296142578125, 0.830078125, 1.0458984375, 0.5830078125, 0.61572265625, 14.0703125, -2.0078125, -0.381591796875, 1.228515625, 0.08282470703125, -0.67822265625, -0.04339599609375, 0.397216796875, 0.1656494140625, 0.137451171875, 0.244873046875, 1.1611328125, -1.3818359375, 0.8447265625, 1.171875, 0.36328125, 0.252685546875, 0.1197509765625, 0.232177734375, -0.020172119140625, 0.64404296875, -0.01100921630859375, -1.9267578125, 0.222412109375, 0.56005859375, 1.3046875, 1.1630859375, 1.197265625, 1.02734375, 1.6806640625, -0.043731689453125, 1.4697265625, 0.81201171875, 1.5390625, 1.240234375, -0.7353515625, 1.828125, 1.115234375, 1.931640625, -0.517578125, 0.77880859375, 1.0546875, 0.95361328125, 3.42578125, 0.0160369873046875, 0.875, 0.56005859375, 1.2421875, 1.986328125, 1.4814453125, 0.0948486328125, 1.115234375, 0.00665283203125, 2.09375, 0.3544921875, -0.52783203125, 1.2099609375, 0.45068359375, 0.65625, 0.1112060546875, 1.0751953125, -0.9521484375, -0.30029296875, 1.4462890625, 2.046875, 3.212890625, 1.68359375, 1.07421875, -0.5263671875, 0.74560546875, 1.37890625, 0.15283203125, 0.2440185546875, 0.62646484375, -0.1280517578125, 0.7646484375, -0.515625, -0.35693359375, 1.2958984375, 0.96923828125, 0.58935546875, 1.3701171875, 1.0673828125, 0.2337646484375, 0.93115234375, 0.66357421875, 6.0, 1.1025390625, -0.51708984375, -0.38330078125, 0.7197265625, 0.246826171875, -0.45166015625, 1.9521484375, 0.5546875, 0.08807373046875, 0.18505859375, 0.8857421875, -0.57177734375, 0.251708984375, 0.234375, 2.57421875, 0.9599609375, 0.5029296875, 0.10382080078125, 0.08331298828125, 0.66748046875, -0.349609375, 1.287109375, 0.259765625, 2.015625, 2.828125, -0.3095703125, -0.164306640625, -0.3408203125, 0.486572265625, 0.8466796875, 1.9130859375, 0.09088134765625, 0.66552734375, 0.00972747802734375, -0.83154296875, 1.755859375, 0.654296875, 0.173828125, 0.27587890625, -0.47607421875, -0.264404296875, 0.7529296875, 0.6533203125, 0.7275390625, 0.499755859375, 0.833984375, -0.44775390625, -0.05078125, -0.454833984375, 0.75439453125, 0.68505859375, 0.210693359375, -0.283935546875, -0.53564453125, 0.96826171875, 0.861328125, -3.33984375, -0.26171875, 0.77734375, 0.26513671875, -0.14111328125, -0.042236328125, -0.84814453125, 0.2137451171875, 0.94921875, 0.65185546875, -0.5380859375, 0.1529541015625, -0.360595703125, -0.0333251953125, -0.69189453125, 0.8974609375, 0.7109375, 0.81494140625, -0.259521484375, 1.1904296875, 0.62158203125, 1.345703125, 0.89404296875, 0.70556640625, 1.0673828125, 1.392578125, 0.5068359375, 0.962890625, 0.736328125, 1.55078125, 0.50390625, -0.398681640625, 2.361328125, 0.345947265625, -0.61962890625, 0.330078125, 0.75439453125, -0.673828125, -0.2379150390625, 1.5673828125, 1.369140625, 0.1119384765625, -0.1834716796875, 1.4599609375, -0.77587890625, 0.5556640625, 0.09954833984375, 0.0285186767578125, 0.58935546875, -0.501953125, 0.212890625, 0.02679443359375, 0.1715087890625, 0.03466796875, -0.564453125, 2.029296875, 2.45703125, -0.72216796875, 2.138671875, 0.50830078125, -0.09356689453125, 0.230224609375, 1.6943359375, 1.5126953125, 0.39453125, 0.411376953125, 1.07421875, -0.8046875, 0.51416015625, 0.2271728515625, -0.283447265625, 0.38427734375, 0.73388671875, 0.6962890625, 1.4990234375, 0.02813720703125, 0.40478515625, 1.2451171875, 1.1162109375, -5.5703125, 0.76171875, 0.322021484375, 1.0361328125, 1.197265625, 0.1163330078125, 0.2425537109375, 1.5595703125, 1.5791015625, -0.0921630859375, 0.484619140625, 1.9052734375, 5.31640625, 1.6337890625, 0.95947265625, -0.1751708984375, 0.466552734375, 0.8330078125, 1.03125, 0.2044677734375, 0.31298828125, -1.1220703125, 0.5517578125, 0.93505859375, 0.45166015625, 1.951171875, 0.65478515625, 1.30859375, 1.0859375, 0.56494140625, 2.322265625, 0.242919921875, 1.81640625, -0.469970703125, -0.841796875, 0.90869140625, 1.5361328125, 0.923828125, 1.0595703125, 0.356689453125, -0.46142578125, 2.134765625, 1.3037109375, -0.32373046875, -9.2265625, 0.4521484375, 0.88037109375, -0.53955078125, 0.96484375, 0.7705078125, 0.84521484375, 1.580078125, -0.1448974609375, 0.7607421875, 1.0166015625, -0.086669921875, 1.611328125, 0.05938720703125, 0.5078125, 0.8427734375, 2.431640625, 0.66357421875, 3.203125, 0.132080078125, 0.461181640625, 0.779296875, 1.9482421875, 1.8720703125, 0.845703125, -1.3837890625, -0.138916015625, 0.35546875, 0.2457275390625, 0.75341796875, 1.828125, 1.4169921875, 0.60791015625, 1.0068359375, 1.109375, 0.484130859375, -0.302001953125, 0.4951171875, 0.802734375, 1.9482421875, 0.916015625, 0.1646728515625, 2.599609375, 1.7177734375, -0.2374267578125, 0.98046875, 0.39306640625, -1.1396484375, 1.6533203125, 0.375244140625], "scores": [0.09906005859375, 0.12213134765625, 0.05035400390625, 0.16552734375, 0.0037384033203125, 0.010101318359375, 0.058197021484375, 0.10552978515625, 0.1141357421875, 0.115234375, 0.00444793701171875, 0.00812530517578125, 0.0343017578125, 0.009002685546875, 0.087158203125, 0.00818634033203125, 0.003238677978515625, 0.024169921875, 0.00702667236328125, 0.00936126708984375, 0.00632476806640625, 0.0293731689453125, 0.01800537109375, 0.0088348388671875, 0.013397216796875, 0.02557373046875, 0.12109375, 0.004413604736328125, 0.016571044921875, 0.00274658203125, 0.2142333984375, 0.29638671875, 0.16015625, 0.007843017578125, 0.007160186767578125, 0.00508880615234375, 0.054229736328125, 0.048736572265625, 0.026397705078125, 0.0265350341796875, 0.051361083984375, 0.018310546875, 0.00974273681640625, 0.0218963623046875, 0.216064453125, 0.021728515625, 0.0173797607421875, 0.004520416259765625], "stoks": [52, 52, 52, 52, 52, 41, 41, 374, 303, 303, 303, 427], "time": {"begin_ms": 640, "end_ms": 1140}}]}',
302:                 },
303:                 {
304:                     id: "7645a0d1-2e64-410d-83a8-b96040432e9a",
305:                     chat_id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
306:                     timestamp: 1716244957031,
307:                     role: "AGENT",
308:                     type: "AGENT_MESSAGE",
309:                     message_text: "Hello!",
310:                     emotion_features:
311:                         '{"Admiration": 0.044921875, "Adoration": 0.0253753662109375, "Aesthetic Appreciation": 0.03265380859375, "Amusement": 0.118408203125, "Anger": 0.06719970703125, "Anxiety": 0.0411376953125, "Awe": 0.03802490234375, "Awkwardness": 0.056549072265625, "Boredom": 0.04217529296875, "Calmness": 0.08709716796875, "Concentration": 0.070556640625, "Confusion": 0.06964111328125, "Contemplation": 0.0343017578125, "Contempt": 0.037689208984375, "Contentment": 0.059417724609375, "Craving": 0.01132965087890625, "Desire": 0.01406097412109375, "Determination": 0.1143798828125, "Disappointment": 0.051177978515625, "Disgust": 0.028594970703125, "Distress": 0.054901123046875, "Doubt": 0.04638671875, "Ecstasy": 0.0258026123046875, "Embarrassment": 0.0222015380859375, "Empathic Pain": 0.015777587890625, "Entrancement": 0.0160980224609375, "Envy": 0.0163421630859375, "Excitement": 0.129638671875, "Fear": 0.03125, "Guilt": 0.01483917236328125, "Horror": 0.0194549560546875, "Interest": 0.1341552734375, "Joy": 0.0738525390625, "Love": 0.0216522216796875, "Nostalgia": 0.0210418701171875, "Pain": 0.020721435546875, "Pride": 0.05499267578125, "Realization": 0.0728759765625, "Relief": 0.04052734375, "Romance": 0.0129241943359375, "Sadness": 0.0254669189453125, "Satisfaction": 0.07159423828125, "Shame": 0.01495361328125, "Surprise (negative)": 0.05560302734375, "Surprise (positive)": 0.07965087890625, "Sympathy": 0.022247314453125, "Tiredness": 0.0194549560546875, "Triumph": 0.04107666015625}',
312:                     metadata: "",
313:                 },
314:             ],
315:         };
316:         server
317:             .mockEndpoint({ once: false })
318:             .get("/v0/evi/chat_groups/697056f0-6c7e-487d-9bd8-9c19df79f05f/events")
319:             .respondWith()
320:             .statusCode(200)
321:             .jsonBody(rawResponseBody)
322:             .build();
323: 
324:         const expected = {
325:             id: "697056f0-6c7e-487d-9bd8-9c19df79f05f",
326:             pageNumber: 0,
327:             pageSize: 3,
328:             totalPages: 1,
329:             paginationDirection: "ASC",
330:             eventsPage: [
331:                 {
332:                     id: "5d44bdbb-49a3-40fb-871d-32bf7e76efe7",
333:                     chatId: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
334:                     timestamp: 1716244940762,
335:                     role: "SYSTEM",
336:                     type: "SYSTEM_PROMPT",
337:                     messageText:
338:                         "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
339:                     emotionFeatures: "",
340:                     metadata: "",
341:                 },
342:                 {
343:                     id: "5976ddf6-d093-4bb9-ba60-8f6c25832dde",
344:                     chatId: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
345:                     timestamp: 1716244956278,
346:                     role: "USER",
347:                     type: "USER_MESSAGE",
348:                     messageText: "Hello.",
349:                     emotionFeatures:
350:                         '{"Admiration": 0.09906005859375, "Adoration": 0.12213134765625, "Aesthetic Appreciation": 0.05035400390625, "Amusement": 0.16552734375, "Anger": 0.0037384033203125, "Anxiety": 0.010101318359375, "Awe": 0.058197021484375, "Awkwardness": 0.10552978515625, "Boredom": 0.1141357421875, "Calmness": 0.115234375, "Concentration": 0.00444793701171875, "Confusion": 0.0343017578125, "Contemplation": 0.00812530517578125, "Contempt": 0.009002685546875, "Contentment": 0.087158203125, "Craving": 0.00818634033203125, "Desire": 0.018310546875, "Determination": 0.003238677978515625, "Disappointment": 0.024169921875, "Disgust": 0.00702667236328125, "Distress": 0.00936126708984375, "Doubt": 0.00632476806640625, "Ecstasy": 0.0293731689453125, "Embarrassment": 0.01800537109375, "Empathic Pain": 0.0088348388671875, "Entrancement": 0.013397216796875, "Envy": 0.02557373046875, "Excitement": 0.12109375, "Fear": 0.004413604736328125, "Guilt": 0.016571044921875, "Horror": 0.00274658203125, "Interest": 0.2142333984375, "Joy": 0.29638671875, "Love": 0.16015625, "Nostalgia": 0.007843017578125, "Pain": 0.007160186767578125, "Pride": 0.00508880615234375, "Realization": 0.054229736328125, "Relief": 0.048736572265625, "Romance": 0.026397705078125, "Sadness": 0.0265350341796875, "Satisfaction": 0.051361083984375, "Shame": 0.00974273681640625, "Surprise (negative)": 0.0218963623046875, "Surprise (positive)": 0.216064453125, "Sympathy": 0.021728515625, "Tiredness": 0.0173797607421875, "Triumph": 0.004520416259765625}',
351:                     metadata:
352:                         '{"segments": [{"content": "Hello.", "embedding": [0.6181640625, 0.1763916015625, -30.921875, 1.2705078125, 0.927734375, 0.63720703125, 2.865234375, 0.1080322265625, 0.2978515625, 1.0107421875, 1.34375, 0.74560546875, 0.416259765625, 0.99462890625, -0.333740234375, 0.361083984375, -1.388671875, 1.0107421875, 1.3173828125, 0.55615234375, 0.541015625, -0.1837158203125, 1.697265625, 0.228515625, 2.087890625, -0.311767578125, 0.053680419921875, 1.3349609375, 0.95068359375, 0.00441741943359375, 0.705078125, 1.8916015625, -0.939453125, 0.93701171875, -0.28955078125, 1.513671875, 0.5595703125, 1.0126953125, -0.1624755859375, 1.4072265625, -0.28857421875, -0.4560546875, -0.1500244140625, -0.1102294921875, -0.222412109375, 0.8779296875, 1.275390625, 1.6689453125, 0.80712890625, -0.34814453125, -0.325439453125, 0.412841796875, 0.81689453125, 0.55126953125, 1.671875, 0.6611328125, 0.7451171875, 1.50390625, 1.0224609375, -1.671875, 0.7373046875, 2.1328125, 2.166015625, 0.41015625, -0.127685546875, 1.9345703125, -4.2734375, 0.332275390625, 0.26171875, 0.76708984375, 0.2685546875, 0.468017578125, 1.208984375, -1.517578125, 1.083984375, 0.84814453125, 1.0244140625, -0.0072174072265625, 1.34375, 1.0712890625, 1.517578125, -0.52001953125, 0.59228515625, 0.8154296875, -0.951171875, -0.07757568359375, 1.3330078125, 1.125, 0.61181640625, 1.494140625, 0.357421875, 1.1796875, 1.482421875, 0.8046875, 0.1536865234375, 1.8076171875, 0.68115234375, -15.171875, 1.2294921875, 0.319091796875, 0.499755859375, 1.5771484375, 0.94677734375, -0.2490234375, 0.88525390625, 3.47265625, 0.75927734375, 0.71044921875, 1.2333984375, 1.4169921875, -0.56640625, -1.8095703125, 1.37109375, 0.428955078125, 1.89453125, -0.39013671875, 0.1734619140625, 1.5595703125, -1.2294921875, 2.552734375, 0.58349609375, 0.2156982421875, -0.00984954833984375, -0.6865234375, -0.0272979736328125, -0.2264404296875, 2.853515625, 1.3896484375, 0.52978515625, 0.783203125, 3.0390625, 0.75537109375, 0.219970703125, 0.384521484375, 0.385986328125, 2.0546875, -0.10443115234375, 1.5146484375, 1.4296875, 1.9716796875, 1.1318359375, 0.31591796875, 0.338623046875, 1.654296875, -0.88037109375, -0.21484375, 1.45703125, 1.0380859375, -0.52294921875, -0.47802734375, 0.1650390625, 1.2392578125, -1.138671875, 0.56787109375, 1.318359375, 0.4287109375, 0.1981201171875, 2.4375, 0.281005859375, 0.89404296875, -0.1552734375, 0.6474609375, -0.08331298828125, 0.00740814208984375, -0.045501708984375, -0.578125, 2.02734375, 0.59228515625, 0.35693359375, 1.2919921875, 1.22265625, 1.0537109375, 0.145263671875, 1.05859375, -0.369140625, 0.207275390625, 0.78857421875, 0.599609375, 0.99072265625, 0.24462890625, 1.26953125, 0.08404541015625, 1.349609375, 0.73291015625, 1.3212890625, 0.388916015625, 1.0869140625, 0.9931640625, -1.5673828125, 0.0462646484375, 0.650390625, 0.253662109375, 0.58251953125, 1.8134765625, 0.8642578125, 2.591796875, 0.7314453125, 0.85986328125, 0.5615234375, 0.9296875, 0.04144287109375, 1.66015625, 1.99609375, 1.171875, 1.181640625, 1.5126953125, 0.0224456787109375, 0.58349609375, -1.4931640625, 0.81884765625, 0.732421875, -0.6455078125, -0.62451171875, 1.7802734375, 0.01526641845703125, -0.423095703125, 0.461669921875, 4.87890625, 1.2392578125, -0.6953125, 0.6689453125, 0.62451171875, -1.521484375, 1.7685546875, 0.810546875, 0.65478515625, 0.26123046875, 1.6396484375, 0.87548828125, 1.7353515625, 2.046875, 1.5634765625, 0.69384765625, 1.375, 0.8916015625, 1.0107421875, 0.1304931640625, 2.009765625, 0.06402587890625, -0.08428955078125, 0.04351806640625, -1.7529296875, 2.02734375, 3.521484375, 0.404541015625, 1.6337890625, -0.276611328125, 0.8837890625, -0.1287841796875, 0.91064453125, 0.8193359375, 0.701171875, 0.036529541015625, 1.26171875, 1.0478515625, -0.1422119140625, 1.0634765625, 0.61083984375, 1.3505859375, 1.208984375, 0.57275390625, 1.3623046875, 2.267578125, 0.484375, 0.9150390625, 0.56787109375, -0.70068359375, 0.27587890625, -0.70654296875, 0.8466796875, 0.57568359375, 1.6162109375, 0.87939453125, 2.248046875, -0.5458984375, 1.7744140625, 1.328125, 1.232421875, 0.6806640625, 0.9365234375, 1.052734375, -1.08984375, 1.8330078125, -0.4033203125, 1.0673828125, 0.297607421875, 1.5703125, 1.67578125, 1.34765625, 2.8203125, 2.025390625, -0.48583984375, 0.7626953125, 0.01007843017578125, 1.435546875, 0.007205963134765625, 0.05157470703125, -0.9853515625, 0.26708984375, 1.16796875, 1.2041015625, 1.99609375, -0.07916259765625, 1.244140625, -0.32080078125, 0.6748046875, 0.419921875, 1.3212890625, 1.291015625, 0.599609375, 0.0550537109375, 0.9599609375, 0.93505859375, 0.111083984375, 1.302734375, 0.0833740234375, 2.244140625, 1.25390625, 1.6015625, 0.58349609375, 1.7568359375, -0.263427734375, -0.019866943359375, -0.24658203125, -0.1871337890625, 0.927734375, 0.62255859375, 0.275146484375, 0.79541015625, 1.1796875, 1.1767578125, -0.26123046875, -0.268310546875, 1.8994140625, 1.318359375, 2.1875, 0.2469482421875, 1.41015625, 0.03973388671875, 1.2685546875, 1.1025390625, 0.9560546875, 0.865234375, -1.92578125, 1.154296875, 0.389892578125, 1.130859375, 0.95947265625, 0.72314453125, 2.244140625, 0.048553466796875, 0.626953125, 0.42919921875, 0.82275390625, 0.311767578125, -0.320556640625, 0.01041412353515625, 0.1483154296875, 0.10809326171875, -0.3173828125, 1.1337890625, -0.8642578125, 1.4033203125, 0.048828125, 1.1787109375, 0.98779296875, 1.818359375, 1.1552734375, 0.6015625, 1.2392578125, -1.2685546875, 0.39208984375, 0.83251953125, 0.224365234375, 0.0019989013671875, 0.87548828125, 1.6572265625, 1.107421875, 0.434814453125, 1.8251953125, 0.442626953125, 1.2587890625, 0.09320068359375, -0.896484375, 1.8017578125, 1.451171875, -0.0755615234375, 0.6083984375, 2.06640625, 0.673828125, -0.33740234375, 0.192138671875, 0.21435546875, 0.80224609375, -1.490234375, 0.9501953125, 0.86083984375, -0.40283203125, 4.109375, 2.533203125, 1.2529296875, 0.8271484375, 0.225830078125, 1.0478515625, -1.9755859375, 0.841796875, 0.392822265625, 0.525390625, 0.33935546875, -0.79443359375, 0.71630859375, 0.97998046875, -0.175537109375, 0.97705078125, 1.705078125, 0.29638671875, 0.68359375, 0.54150390625, 0.435791015625, 0.99755859375, -0.369140625, 1.009765625, -0.140380859375, 0.426513671875, 0.189697265625, 1.8193359375, 1.1201171875, -0.5009765625, -0.331298828125, 0.759765625, -0.09442138671875, 0.74609375, -1.947265625, 1.3544921875, -3.935546875, 2.544921875, 1.359375, 0.1363525390625, 0.79296875, 0.79931640625, -0.3466796875, 1.1396484375, -0.33447265625, 2.0078125, -0.241455078125, 0.6318359375, 0.365234375, 0.296142578125, 0.830078125, 1.0458984375, 0.5830078125, 0.61572265625, 14.0703125, -2.0078125, -0.381591796875, 1.228515625, 0.08282470703125, -0.67822265625, -0.04339599609375, 0.397216796875, 0.1656494140625, 0.137451171875, 0.244873046875, 1.1611328125, -1.3818359375, 0.8447265625, 1.171875, 0.36328125, 0.252685546875, 0.1197509765625, 0.232177734375, -0.020172119140625, 0.64404296875, -0.01100921630859375, -1.9267578125, 0.222412109375, 0.56005859375, 1.3046875, 1.1630859375, 1.197265625, 1.02734375, 1.6806640625, -0.043731689453125, 1.4697265625, 0.81201171875, 1.5390625, 1.240234375, -0.7353515625, 1.828125, 1.115234375, 1.931640625, -0.517578125, 0.77880859375, 1.0546875, 0.95361328125, 3.42578125, 0.0160369873046875, 0.875, 0.56005859375, 1.2421875, 1.986328125, 1.4814453125, 0.0948486328125, 1.115234375, 0.00665283203125, 2.09375, 0.3544921875, -0.52783203125, 1.2099609375, 0.45068359375, 0.65625, 0.1112060546875, 1.0751953125, -0.9521484375, -0.30029296875, 1.4462890625, 2.046875, 3.212890625, 1.68359375, 1.07421875, -0.5263671875, 0.74560546875, 1.37890625, 0.15283203125, 0.2440185546875, 0.62646484375, -0.1280517578125, 0.7646484375, -0.515625, -0.35693359375, 1.2958984375, 0.96923828125, 0.58935546875, 1.3701171875, 1.0673828125, 0.2337646484375, 0.93115234375, 0.66357421875, 6.0, 1.1025390625, -0.51708984375, -0.38330078125, 0.7197265625, 0.246826171875, -0.45166015625, 1.9521484375, 0.5546875, 0.08807373046875, 0.18505859375, 0.8857421875, -0.57177734375, 0.251708984375, 0.234375, 2.57421875, 0.9599609375, 0.5029296875, 0.10382080078125, 0.08331298828125, 0.66748046875, -0.349609375, 1.287109375, 0.259765625, 2.015625, 2.828125, -0.3095703125, -0.164306640625, -0.3408203125, 0.486572265625, 0.8466796875, 1.9130859375, 0.09088134765625, 0.66552734375, 0.00972747802734375, -0.83154296875, 1.755859375, 0.654296875, 0.173828125, 0.27587890625, -0.47607421875, -0.264404296875, 0.7529296875, 0.6533203125, 0.7275390625, 0.499755859375, 0.833984375, -0.44775390625, -0.05078125, -0.454833984375, 0.75439453125, 0.68505859375, 0.210693359375, -0.283935546875, -0.53564453125, 0.96826171875, 0.861328125, -3.33984375, -0.26171875, 0.77734375, 0.26513671875, -0.14111328125, -0.042236328125, -0.84814453125, 0.2137451171875, 0.94921875, 0.65185546875, -0.5380859375, 0.1529541015625, -0.360595703125, -0.0333251953125, -0.69189453125, 0.8974609375, 0.7109375, 0.81494140625, -0.259521484375, 1.1904296875, 0.62158203125, 1.345703125, 0.89404296875, 0.70556640625, 1.0673828125, 1.392578125, 0.5068359375, 0.962890625, 0.736328125, 1.55078125, 0.50390625, -0.398681640625, 2.361328125, 0.345947265625, -0.61962890625, 0.330078125, 0.75439453125, -0.673828125, -0.2379150390625, 1.5673828125, 1.369140625, 0.1119384765625, -0.1834716796875, 1.4599609375, -0.77587890625, 0.5556640625, 0.09954833984375, 0.0285186767578125, 0.58935546875, -0.501953125, 0.212890625, 0.02679443359375, 0.1715087890625, 0.03466796875, -0.564453125, 2.029296875, 2.45703125, -0.72216796875, 2.138671875, 0.50830078125, -0.09356689453125, 0.230224609375, 1.6943359375, 1.5126953125, 0.39453125, 0.411376953125, 1.07421875, -0.8046875, 0.51416015625, 0.2271728515625, -0.283447265625, 0.38427734375, 0.73388671875, 0.6962890625, 1.4990234375, 0.02813720703125, 0.40478515625, 1.2451171875, 1.1162109375, -5.5703125, 0.76171875, 0.322021484375, 1.0361328125, 1.197265625, 0.1163330078125, 0.2425537109375, 1.5595703125, 1.5791015625, -0.0921630859375, 0.484619140625, 1.9052734375, 5.31640625, 1.6337890625, 0.95947265625, -0.1751708984375, 0.466552734375, 0.8330078125, 1.03125, 0.2044677734375, 0.31298828125, -1.1220703125, 0.5517578125, 0.93505859375, 0.45166015625, 1.951171875, 0.65478515625, 1.30859375, 1.0859375, 0.56494140625, 2.322265625, 0.242919921875, 1.81640625, -0.469970703125, -0.841796875, 0.90869140625, 1.5361328125, 0.923828125, 1.0595703125, 0.356689453125, -0.46142578125, 2.134765625, 1.3037109375, -0.32373046875, -9.2265625, 0.4521484375, 0.88037109375, -0.53955078125, 0.96484375, 0.7705078125, 0.84521484375, 1.580078125, -0.1448974609375, 0.7607421875, 1.0166015625, -0.086669921875, 1.611328125, 0.05938720703125, 0.5078125, 0.8427734375, 2.431640625, 0.66357421875, 3.203125, 0.132080078125, 0.461181640625, 0.779296875, 1.9482421875, 1.8720703125, 0.845703125, -1.3837890625, -0.138916015625, 0.35546875, 0.2457275390625, 0.75341796875, 1.828125, 1.4169921875, 0.60791015625, 1.0068359375, 1.109375, 0.484130859375, -0.302001953125, 0.4951171875, 0.802734375, 1.9482421875, 0.916015625, 0.1646728515625, 2.599609375, 1.7177734375, -0.2374267578125, 0.98046875, 0.39306640625, -1.1396484375, 1.6533203125, 0.375244140625], "scores": [0.09906005859375, 0.12213134765625, 0.05035400390625, 0.16552734375, 0.0037384033203125, 0.010101318359375, 0.058197021484375, 0.10552978515625, 0.1141357421875, 0.115234375, 0.00444793701171875, 0.00812530517578125, 0.0343017578125, 0.009002685546875, 0.087158203125, 0.00818634033203125, 0.003238677978515625, 0.024169921875, 0.00702667236328125, 0.00936126708984375, 0.00632476806640625, 0.0293731689453125, 0.01800537109375, 0.0088348388671875, 0.013397216796875, 0.02557373046875, 0.12109375, 0.004413604736328125, 0.016571044921875, 0.00274658203125, 0.2142333984375, 0.29638671875, 0.16015625, 0.007843017578125, 0.007160186767578125, 0.00508880615234375, 0.054229736328125, 0.048736572265625, 0.026397705078125, 0.0265350341796875, 0.051361083984375, 0.018310546875, 0.00974273681640625, 0.0218963623046875, 0.216064453125, 0.021728515625, 0.0173797607421875, 0.004520416259765625], "stoks": [52, 52, 52, 52, 52, 41, 41, 374, 303, 303, 303, 427], "time": {"begin_ms": 640, "end_ms": 1140}}]}',
353:                 },
354:                 {
355:                     id: "7645a0d1-2e64-410d-83a8-b96040432e9a",
356:                     chatId: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
357:                     timestamp: 1716244957031,
358:                     role: "AGENT",
359:                     type: "AGENT_MESSAGE",
360:                     messageText: "Hello!",
361:                     emotionFeatures:
362:                         '{"Admiration": 0.044921875, "Adoration": 0.0253753662109375, "Aesthetic Appreciation": 0.03265380859375, "Amusement": 0.118408203125, "Anger": 0.06719970703125, "Anxiety": 0.0411376953125, "Awe": 0.03802490234375, "Awkwardness": 0.056549072265625, "Boredom": 0.04217529296875, "Calmness": 0.08709716796875, "Concentration": 0.070556640625, "Confusion": 0.06964111328125, "Contemplation": 0.0343017578125, "Contempt": 0.037689208984375, "Contentment": 0.059417724609375, "Craving": 0.01132965087890625, "Desire": 0.01406097412109375, "Determination": 0.1143798828125, "Disappointment": 0.051177978515625, "Disgust": 0.028594970703125, "Distress": 0.054901123046875, "Doubt": 0.04638671875, "Ecstasy": 0.0258026123046875, "Embarrassment": 0.0222015380859375, "Empathic Pain": 0.015777587890625, "Entrancement": 0.0160980224609375, "Envy": 0.0163421630859375, "Excitement": 0.129638671875, "Fear": 0.03125, "Guilt": 0.01483917236328125, "Horror": 0.0194549560546875, "Interest": 0.1341552734375, "Joy": 0.0738525390625, "Love": 0.0216522216796875, "Nostalgia": 0.0210418701171875, "Pain": 0.020721435546875, "Pride": 0.05499267578125, "Realization": 0.0728759765625, "Relief": 0.04052734375, "Romance": 0.0129241943359375, "Sadness": 0.0254669189453125, "Satisfaction": 0.07159423828125, "Shame": 0.01495361328125, "Surprise (negative)": 0.05560302734375, "Surprise (positive)": 0.07965087890625, "Sympathy": 0.022247314453125, "Tiredness": 0.0194549560546875, "Triumph": 0.04107666015625}',
363:                     metadata: "",
364:                 },
365:             ],
366:         };
367:         const page = await client.empathicVoice.chatGroups.listChatGroupEvents("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
368:             pageNumber: 0,
369:             pageSize: 3,
370:             ascendingOrder: true,
371:         });
372: 
373:         expect(expected.eventsPage).toEqual(page.data);
374:         expect(page.hasNextPage()).toBe(true);
375:         const nextPage = await page.getNextPage();
376:         expect(expected.eventsPage).toEqual(nextPage.data);
377:     });
378: 
379:     test("list-chat-group-events (2)", async () => {
380:         const server = mockServerPool.createServer();
381:         const client = new HumeClient({
382:             maxRetries: 0,
383:             apiKey: "test",
384:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
385:         });
386: 
387:         const rawResponseBody = {};
388:         server
389:             .mockEndpoint({ once: false })
390:             .get("/v0/evi/chat_groups/id/events")
391:             .respondWith()
392:             .statusCode(400)
393:             .jsonBody(rawResponseBody)
394:             .build();
395: 
396:         await expect(async () => {
397:             return await client.empathicVoice.chatGroups.listChatGroupEvents("id");
398:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
399:     });
400: });
````

## File: tests/wire/empathic-voice/chats.test.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import * as Hume from "../../../src/api/index";
  4: import { HumeClient } from "../../../src/Client";
  5: import { mockServerPool } from "../../mock-server/MockServerPool";
  6: 
  7: describe("ChatsClient", () => {
  8:     test("list-chats (1)", async () => {
  9:         const server = mockServerPool.createServer();
 10:         const client = new HumeClient({
 11:             maxRetries: 0,
 12:             apiKey: "test",
 13:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 14:         });
 15: 
 16:         const rawResponseBody = {
 17:             page_number: 0,
 18:             page_size: 1,
 19:             total_pages: 1,
 20:             pagination_direction: "ASC",
 21:             chats_page: [
 22:                 {
 23:                     id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
 24:                     chat_group_id: "9fc18597-3567-42d5-94d6-935bde84bf2f",
 25:                     status: "USER_ENDED",
 26:                     start_timestamp: 1716244940648,
 27:                     end_timestamp: 1716244958546,
 28:                     event_count: 3,
 29:                     metadata: "",
 30:                     config: { id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3", version: 0 },
 31:                 },
 32:             ],
 33:         };
 34:         server
 35:             .mockEndpoint({ once: false })
 36:             .get("/v0/evi/chats")
 37:             .respondWith()
 38:             .statusCode(200)
 39:             .jsonBody(rawResponseBody)
 40:             .build();
 41: 
 42:         const expected = {
 43:             pageNumber: 0,
 44:             pageSize: 1,
 45:             totalPages: 1,
 46:             paginationDirection: "ASC",
 47:             chatsPage: [
 48:                 {
 49:                     id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
 50:                     chatGroupId: "9fc18597-3567-42d5-94d6-935bde84bf2f",
 51:                     status: "USER_ENDED",
 52:                     startTimestamp: 1716244940648,
 53:                     endTimestamp: 1716244958546,
 54:                     eventCount: 3,
 55:                     metadata: "",
 56:                     config: {
 57:                         id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 58:                         version: 0,
 59:                     },
 60:                 },
 61:             ],
 62:         };
 63:         const page = await client.empathicVoice.chats.listChats({
 64:             pageNumber: 0,
 65:             pageSize: 1,
 66:             ascendingOrder: true,
 67:         });
 68: 
 69:         expect(expected.chatsPage).toEqual(page.data);
 70:         expect(page.hasNextPage()).toBe(true);
 71:         const nextPage = await page.getNextPage();
 72:         expect(expected.chatsPage).toEqual(nextPage.data);
 73:     });
 74: 
 75:     test("list-chats (2)", async () => {
 76:         const server = mockServerPool.createServer();
 77:         const client = new HumeClient({
 78:             maxRetries: 0,
 79:             apiKey: "test",
 80:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 81:         });
 82: 
 83:         const rawResponseBody = {};
 84:         server
 85:             .mockEndpoint({ once: false })
 86:             .get("/v0/evi/chats")
 87:             .respondWith()
 88:             .statusCode(400)
 89:             .jsonBody(rawResponseBody)
 90:             .build();
 91: 
 92:         await expect(async () => {
 93:             return await client.empathicVoice.chats.listChats();
 94:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
 95:     });
 96: 
 97:     test("list-chat-events (1)", async () => {
 98:         const server = mockServerPool.createServer();
 99:         const client = new HumeClient({
100:             maxRetries: 0,
101:             apiKey: "test",
102:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
103:         });
104: 
105:         const rawResponseBody = {
106:             id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
107:             chat_group_id: "9fc18597-3567-42d5-94d6-935bde84bf2f",
108:             status: "USER_ENDED",
109:             start_timestamp: 1716244940648,
110:             pagination_direction: "ASC",
111:             events_page: [
112:                 {
113:                     id: "5d44bdbb-49a3-40fb-871d-32bf7e76efe7",
114:                     chat_id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
115:                     timestamp: 1716244940762,
116:                     role: "SYSTEM",
117:                     type: "SYSTEM_PROMPT",
118:                     message_text:
119:                         "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
120:                     emotion_features: "",
121:                     metadata: "",
122:                 },
123:                 {
124:                     id: "5976ddf6-d093-4bb9-ba60-8f6c25832dde",
125:                     chat_id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
126:                     timestamp: 1716244956278,
127:                     role: "USER",
128:                     type: "USER_MESSAGE",
129:                     message_text: "Hello.",
130:                     emotion_features:
131:                         '{"Admiration": 0.09906005859375, "Adoration": 0.12213134765625, "Aesthetic Appreciation": 0.05035400390625, "Amusement": 0.16552734375, "Anger": 0.0037384033203125, "Anxiety": 0.010101318359375, "Awe": 0.058197021484375, "Awkwardness": 0.10552978515625, "Boredom": 0.1141357421875, "Calmness": 0.115234375, "Concentration": 0.00444793701171875, "Confusion": 0.0343017578125, "Contemplation": 0.00812530517578125, "Contempt": 0.009002685546875, "Contentment": 0.087158203125, "Craving": 0.00818634033203125, "Desire": 0.018310546875, "Determination": 0.003238677978515625, "Disappointment": 0.024169921875, "Disgust": 0.00702667236328125, "Distress": 0.00936126708984375, "Doubt": 0.00632476806640625, "Ecstasy": 0.0293731689453125, "Embarrassment": 0.01800537109375, "Empathic Pain": 0.0088348388671875, "Entrancement": 0.013397216796875, "Envy": 0.02557373046875, "Excitement": 0.12109375, "Fear": 0.004413604736328125, "Guilt": 0.016571044921875, "Horror": 0.00274658203125, "Interest": 0.2142333984375, "Joy": 0.29638671875, "Love": 0.16015625, "Nostalgia": 0.007843017578125, "Pain": 0.007160186767578125, "Pride": 0.00508880615234375, "Realization": 0.054229736328125, "Relief": 0.048736572265625, "Romance": 0.026397705078125, "Sadness": 0.0265350341796875, "Satisfaction": 0.051361083984375, "Shame": 0.00974273681640625, "Surprise (negative)": 0.0218963623046875, "Surprise (positive)": 0.216064453125, "Sympathy": 0.021728515625, "Tiredness": 0.0173797607421875, "Triumph": 0.004520416259765625}',
132:                     metadata:
133:                         '{"segments": [{"content": "Hello.", "embedding": [0.6181640625, 0.1763916015625, -30.921875, 1.2705078125, 0.927734375, 0.63720703125, 2.865234375, 0.1080322265625, 0.2978515625, 1.0107421875, 1.34375, 0.74560546875, 0.416259765625, 0.99462890625, -0.333740234375, 0.361083984375, -1.388671875, 1.0107421875, 1.3173828125, 0.55615234375, 0.541015625, -0.1837158203125, 1.697265625, 0.228515625, 2.087890625, -0.311767578125, 0.053680419921875, 1.3349609375, 0.95068359375, 0.00441741943359375, 0.705078125, 1.8916015625, -0.939453125, 0.93701171875, -0.28955078125, 1.513671875, 0.5595703125, 1.0126953125, -0.1624755859375, 1.4072265625, -0.28857421875, -0.4560546875, -0.1500244140625, -0.1102294921875, -0.222412109375, 0.8779296875, 1.275390625, 1.6689453125, 0.80712890625, -0.34814453125, -0.325439453125, 0.412841796875, 0.81689453125, 0.55126953125, 1.671875, 0.6611328125, 0.7451171875, 1.50390625, 1.0224609375, -1.671875, 0.7373046875, 2.1328125, 2.166015625, 0.41015625, -0.127685546875, 1.9345703125, -4.2734375, 0.332275390625, 0.26171875, 0.76708984375, 0.2685546875, 0.468017578125, 1.208984375, -1.517578125, 1.083984375, 0.84814453125, 1.0244140625, -0.0072174072265625, 1.34375, 1.0712890625, 1.517578125, -0.52001953125, 0.59228515625, 0.8154296875, -0.951171875, -0.07757568359375, 1.3330078125, 1.125, 0.61181640625, 1.494140625, 0.357421875, 1.1796875, 1.482421875, 0.8046875, 0.1536865234375, 1.8076171875, 0.68115234375, -15.171875, 1.2294921875, 0.319091796875, 0.499755859375, 1.5771484375, 0.94677734375, -0.2490234375, 0.88525390625, 3.47265625, 0.75927734375, 0.71044921875, 1.2333984375, 1.4169921875, -0.56640625, -1.8095703125, 1.37109375, 0.428955078125, 1.89453125, -0.39013671875, 0.1734619140625, 1.5595703125, -1.2294921875, 2.552734375, 0.58349609375, 0.2156982421875, -0.00984954833984375, -0.6865234375, -0.0272979736328125, -0.2264404296875, 2.853515625, 1.3896484375, 0.52978515625, 0.783203125, 3.0390625, 0.75537109375, 0.219970703125, 0.384521484375, 0.385986328125, 2.0546875, -0.10443115234375, 1.5146484375, 1.4296875, 1.9716796875, 1.1318359375, 0.31591796875, 0.338623046875, 1.654296875, -0.88037109375, -0.21484375, 1.45703125, 1.0380859375, -0.52294921875, -0.47802734375, 0.1650390625, 1.2392578125, -1.138671875, 0.56787109375, 1.318359375, 0.4287109375, 0.1981201171875, 2.4375, 0.281005859375, 0.89404296875, -0.1552734375, 0.6474609375, -0.08331298828125, 0.00740814208984375, -0.045501708984375, -0.578125, 2.02734375, 0.59228515625, 0.35693359375, 1.2919921875, 1.22265625, 1.0537109375, 0.145263671875, 1.05859375, -0.369140625, 0.207275390625, 0.78857421875, 0.599609375, 0.99072265625, 0.24462890625, 1.26953125, 0.08404541015625, 1.349609375, 0.73291015625, 1.3212890625, 0.388916015625, 1.0869140625, 0.9931640625, -1.5673828125, 0.0462646484375, 0.650390625, 0.253662109375, 0.58251953125, 1.8134765625, 0.8642578125, 2.591796875, 0.7314453125, 0.85986328125, 0.5615234375, 0.9296875, 0.04144287109375, 1.66015625, 1.99609375, 1.171875, 1.181640625, 1.5126953125, 0.0224456787109375, 0.58349609375, -1.4931640625, 0.81884765625, 0.732421875, -0.6455078125, -0.62451171875, 1.7802734375, 0.01526641845703125, -0.423095703125, 0.461669921875, 4.87890625, 1.2392578125, -0.6953125, 0.6689453125, 0.62451171875, -1.521484375, 1.7685546875, 0.810546875, 0.65478515625, 0.26123046875, 1.6396484375, 0.87548828125, 1.7353515625, 2.046875, 1.5634765625, 0.69384765625, 1.375, 0.8916015625, 1.0107421875, 0.1304931640625, 2.009765625, 0.06402587890625, -0.08428955078125, 0.04351806640625, -1.7529296875, 2.02734375, 3.521484375, 0.404541015625, 1.6337890625, -0.276611328125, 0.8837890625, -0.1287841796875, 0.91064453125, 0.8193359375, 0.701171875, 0.036529541015625, 1.26171875, 1.0478515625, -0.1422119140625, 1.0634765625, 0.61083984375, 1.3505859375, 1.208984375, 0.57275390625, 1.3623046875, 2.267578125, 0.484375, 0.9150390625, 0.56787109375, -0.70068359375, 0.27587890625, -0.70654296875, 0.8466796875, 0.57568359375, 1.6162109375, 0.87939453125, 2.248046875, -0.5458984375, 1.7744140625, 1.328125, 1.232421875, 0.6806640625, 0.9365234375, 1.052734375, -1.08984375, 1.8330078125, -0.4033203125, 1.0673828125, 0.297607421875, 1.5703125, 1.67578125, 1.34765625, 2.8203125, 2.025390625, -0.48583984375, 0.7626953125, 0.01007843017578125, 1.435546875, 0.007205963134765625, 0.05157470703125, -0.9853515625, 0.26708984375, 1.16796875, 1.2041015625, 1.99609375, -0.07916259765625, 1.244140625, -0.32080078125, 0.6748046875, 0.419921875, 1.3212890625, 1.291015625, 0.599609375, 0.0550537109375, 0.9599609375, 0.93505859375, 0.111083984375, 1.302734375, 0.0833740234375, 2.244140625, 1.25390625, 1.6015625, 0.58349609375, 1.7568359375, -0.263427734375, -0.019866943359375, -0.24658203125, -0.1871337890625, 0.927734375, 0.62255859375, 0.275146484375, 0.79541015625, 1.1796875, 1.1767578125, -0.26123046875, -0.268310546875, 1.8994140625, 1.318359375, 2.1875, 0.2469482421875, 1.41015625, 0.03973388671875, 1.2685546875, 1.1025390625, 0.9560546875, 0.865234375, -1.92578125, 1.154296875, 0.389892578125, 1.130859375, 0.95947265625, 0.72314453125, 2.244140625, 0.048553466796875, 0.626953125, 0.42919921875, 0.82275390625, 0.311767578125, -0.320556640625, 0.01041412353515625, 0.1483154296875, 0.10809326171875, -0.3173828125, 1.1337890625, -0.8642578125, 1.4033203125, 0.048828125, 1.1787109375, 0.98779296875, 1.818359375, 1.1552734375, 0.6015625, 1.2392578125, -1.2685546875, 0.39208984375, 0.83251953125, 0.224365234375, 0.0019989013671875, 0.87548828125, 1.6572265625, 1.107421875, 0.434814453125, 1.8251953125, 0.442626953125, 1.2587890625, 0.09320068359375, -0.896484375, 1.8017578125, 1.451171875, -0.0755615234375, 0.6083984375, 2.06640625, 0.673828125, -0.33740234375, 0.192138671875, 0.21435546875, 0.80224609375, -1.490234375, 0.9501953125, 0.86083984375, -0.40283203125, 4.109375, 2.533203125, 1.2529296875, 0.8271484375, 0.225830078125, 1.0478515625, -1.9755859375, 0.841796875, 0.392822265625, 0.525390625, 0.33935546875, -0.79443359375, 0.71630859375, 0.97998046875, -0.175537109375, 0.97705078125, 1.705078125, 0.29638671875, 0.68359375, 0.54150390625, 0.435791015625, 0.99755859375, -0.369140625, 1.009765625, -0.140380859375, 0.426513671875, 0.189697265625, 1.8193359375, 1.1201171875, -0.5009765625, -0.331298828125, 0.759765625, -0.09442138671875, 0.74609375, -1.947265625, 1.3544921875, -3.935546875, 2.544921875, 1.359375, 0.1363525390625, 0.79296875, 0.79931640625, -0.3466796875, 1.1396484375, -0.33447265625, 2.0078125, -0.241455078125, 0.6318359375, 0.365234375, 0.296142578125, 0.830078125, 1.0458984375, 0.5830078125, 0.61572265625, 14.0703125, -2.0078125, -0.381591796875, 1.228515625, 0.08282470703125, -0.67822265625, -0.04339599609375, 0.397216796875, 0.1656494140625, 0.137451171875, 0.244873046875, 1.1611328125, -1.3818359375, 0.8447265625, 1.171875, 0.36328125, 0.252685546875, 0.1197509765625, 0.232177734375, -0.020172119140625, 0.64404296875, -0.01100921630859375, -1.9267578125, 0.222412109375, 0.56005859375, 1.3046875, 1.1630859375, 1.197265625, 1.02734375, 1.6806640625, -0.043731689453125, 1.4697265625, 0.81201171875, 1.5390625, 1.240234375, -0.7353515625, 1.828125, 1.115234375, 1.931640625, -0.517578125, 0.77880859375, 1.0546875, 0.95361328125, 3.42578125, 0.0160369873046875, 0.875, 0.56005859375, 1.2421875, 1.986328125, 1.4814453125, 0.0948486328125, 1.115234375, 0.00665283203125, 2.09375, 0.3544921875, -0.52783203125, 1.2099609375, 0.45068359375, 0.65625, 0.1112060546875, 1.0751953125, -0.9521484375, -0.30029296875, 1.4462890625, 2.046875, 3.212890625, 1.68359375, 1.07421875, -0.5263671875, 0.74560546875, 1.37890625, 0.15283203125, 0.2440185546875, 0.62646484375, -0.1280517578125, 0.7646484375, -0.515625, -0.35693359375, 1.2958984375, 0.96923828125, 0.58935546875, 1.3701171875, 1.0673828125, 0.2337646484375, 0.93115234375, 0.66357421875, 6.0, 1.1025390625, -0.51708984375, -0.38330078125, 0.7197265625, 0.246826171875, -0.45166015625, 1.9521484375, 0.5546875, 0.08807373046875, 0.18505859375, 0.8857421875, -0.57177734375, 0.251708984375, 0.234375, 2.57421875, 0.9599609375, 0.5029296875, 0.10382080078125, 0.08331298828125, 0.66748046875, -0.349609375, 1.287109375, 0.259765625, 2.015625, 2.828125, -0.3095703125, -0.164306640625, -0.3408203125, 0.486572265625, 0.8466796875, 1.9130859375, 0.09088134765625, 0.66552734375, 0.00972747802734375, -0.83154296875, 1.755859375, 0.654296875, 0.173828125, 0.27587890625, -0.47607421875, -0.264404296875, 0.7529296875, 0.6533203125, 0.7275390625, 0.499755859375, 0.833984375, -0.44775390625, -0.05078125, -0.454833984375, 0.75439453125, 0.68505859375, 0.210693359375, -0.283935546875, -0.53564453125, 0.96826171875, 0.861328125, -3.33984375, -0.26171875, 0.77734375, 0.26513671875, -0.14111328125, -0.042236328125, -0.84814453125, 0.2137451171875, 0.94921875, 0.65185546875, -0.5380859375, 0.1529541015625, -0.360595703125, -0.0333251953125, -0.69189453125, 0.8974609375, 0.7109375, 0.81494140625, -0.259521484375, 1.1904296875, 0.62158203125, 1.345703125, 0.89404296875, 0.70556640625, 1.0673828125, 1.392578125, 0.5068359375, 0.962890625, 0.736328125, 1.55078125, 0.50390625, -0.398681640625, 2.361328125, 0.345947265625, -0.61962890625, 0.330078125, 0.75439453125, -0.673828125, -0.2379150390625, 1.5673828125, 1.369140625, 0.1119384765625, -0.1834716796875, 1.4599609375, -0.77587890625, 0.5556640625, 0.09954833984375, 0.0285186767578125, 0.58935546875, -0.501953125, 0.212890625, 0.02679443359375, 0.1715087890625, 0.03466796875, -0.564453125, 2.029296875, 2.45703125, -0.72216796875, 2.138671875, 0.50830078125, -0.09356689453125, 0.230224609375, 1.6943359375, 1.5126953125, 0.39453125, 0.411376953125, 1.07421875, -0.8046875, 0.51416015625, 0.2271728515625, -0.283447265625, 0.38427734375, 0.73388671875, 0.6962890625, 1.4990234375, 0.02813720703125, 0.40478515625, 1.2451171875, 1.1162109375, -5.5703125, 0.76171875, 0.322021484375, 1.0361328125, 1.197265625, 0.1163330078125, 0.2425537109375, 1.5595703125, 1.5791015625, -0.0921630859375, 0.484619140625, 1.9052734375, 5.31640625, 1.6337890625, 0.95947265625, -0.1751708984375, 0.466552734375, 0.8330078125, 1.03125, 0.2044677734375, 0.31298828125, -1.1220703125, 0.5517578125, 0.93505859375, 0.45166015625, 1.951171875, 0.65478515625, 1.30859375, 1.0859375, 0.56494140625, 2.322265625, 0.242919921875, 1.81640625, -0.469970703125, -0.841796875, 0.90869140625, 1.5361328125, 0.923828125, 1.0595703125, 0.356689453125, -0.46142578125, 2.134765625, 1.3037109375, -0.32373046875, -9.2265625, 0.4521484375, 0.88037109375, -0.53955078125, 0.96484375, 0.7705078125, 0.84521484375, 1.580078125, -0.1448974609375, 0.7607421875, 1.0166015625, -0.086669921875, 1.611328125, 0.05938720703125, 0.5078125, 0.8427734375, 2.431640625, 0.66357421875, 3.203125, 0.132080078125, 0.461181640625, 0.779296875, 1.9482421875, 1.8720703125, 0.845703125, -1.3837890625, -0.138916015625, 0.35546875, 0.2457275390625, 0.75341796875, 1.828125, 1.4169921875, 0.60791015625, 1.0068359375, 1.109375, 0.484130859375, -0.302001953125, 0.4951171875, 0.802734375, 1.9482421875, 0.916015625, 0.1646728515625, 2.599609375, 1.7177734375, -0.2374267578125, 0.98046875, 0.39306640625, -1.1396484375, 1.6533203125, 0.375244140625], "scores": [0.09906005859375, 0.12213134765625, 0.05035400390625, 0.16552734375, 0.0037384033203125, 0.010101318359375, 0.058197021484375, 0.10552978515625, 0.1141357421875, 0.115234375, 0.00444793701171875, 0.00812530517578125, 0.0343017578125, 0.009002685546875, 0.087158203125, 0.00818634033203125, 0.003238677978515625, 0.024169921875, 0.00702667236328125, 0.00936126708984375, 0.00632476806640625, 0.0293731689453125, 0.01800537109375, 0.0088348388671875, 0.013397216796875, 0.02557373046875, 0.12109375, 0.004413604736328125, 0.016571044921875, 0.00274658203125, 0.2142333984375, 0.29638671875, 0.16015625, 0.007843017578125, 0.007160186767578125, 0.00508880615234375, 0.054229736328125, 0.048736572265625, 0.026397705078125, 0.0265350341796875, 0.051361083984375, 0.018310546875, 0.00974273681640625, 0.0218963623046875, 0.216064453125, 0.021728515625, 0.0173797607421875, 0.004520416259765625], "stoks": [52, 52, 52, 52, 52, 41, 41, 374, 303, 303, 303, 427], "time": {"begin_ms": 640, "end_ms": 1140}}]}',
134:                 },
135:                 {
136:                     id: "7645a0d1-2e64-410d-83a8-b96040432e9a",
137:                     chat_id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
138:                     timestamp: 1716244957031,
139:                     role: "AGENT",
140:                     type: "AGENT_MESSAGE",
141:                     message_text: "Hello!",
142:                     emotion_features:
143:                         '{"Admiration": 0.044921875, "Adoration": 0.0253753662109375, "Aesthetic Appreciation": 0.03265380859375, "Amusement": 0.118408203125, "Anger": 0.06719970703125, "Anxiety": 0.0411376953125, "Awe": 0.03802490234375, "Awkwardness": 0.056549072265625, "Boredom": 0.04217529296875, "Calmness": 0.08709716796875, "Concentration": 0.070556640625, "Confusion": 0.06964111328125, "Contemplation": 0.0343017578125, "Contempt": 0.037689208984375, "Contentment": 0.059417724609375, "Craving": 0.01132965087890625, "Desire": 0.01406097412109375, "Determination": 0.1143798828125, "Disappointment": 0.051177978515625, "Disgust": 0.028594970703125, "Distress": 0.054901123046875, "Doubt": 0.04638671875, "Ecstasy": 0.0258026123046875, "Embarrassment": 0.0222015380859375, "Empathic Pain": 0.015777587890625, "Entrancement": 0.0160980224609375, "Envy": 0.0163421630859375, "Excitement": 0.129638671875, "Fear": 0.03125, "Guilt": 0.01483917236328125, "Horror": 0.0194549560546875, "Interest": 0.1341552734375, "Joy": 0.0738525390625, "Love": 0.0216522216796875, "Nostalgia": 0.0210418701171875, "Pain": 0.020721435546875, "Pride": 0.05499267578125, "Realization": 0.0728759765625, "Relief": 0.04052734375, "Romance": 0.0129241943359375, "Sadness": 0.0254669189453125, "Satisfaction": 0.07159423828125, "Shame": 0.01495361328125, "Surprise (negative)": 0.05560302734375, "Surprise (positive)": 0.07965087890625, "Sympathy": 0.022247314453125, "Tiredness": 0.0194549560546875, "Triumph": 0.04107666015625}',
144:                     metadata: "",
145:                 },
146:             ],
147:             page_number: 0,
148:             page_size: 3,
149:             total_pages: 1,
150:             end_timestamp: 1716244958546,
151:             metadata: "",
152:             config: { id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3", version: 0 },
153:         };
154:         server
155:             .mockEndpoint({ once: false })
156:             .get("/v0/evi/chats/470a49f6-1dec-4afe-8b61-035d3b2d63b0")
157:             .respondWith()
158:             .statusCode(200)
159:             .jsonBody(rawResponseBody)
160:             .build();
161: 
162:         const expected = {
163:             id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
164:             chatGroupId: "9fc18597-3567-42d5-94d6-935bde84bf2f",
165:             status: "USER_ENDED",
166:             startTimestamp: 1716244940648,
167:             paginationDirection: "ASC",
168:             eventsPage: [
169:                 {
170:                     id: "5d44bdbb-49a3-40fb-871d-32bf7e76efe7",
171:                     chatId: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
172:                     timestamp: 1716244940762,
173:                     role: "SYSTEM",
174:                     type: "SYSTEM_PROMPT",
175:                     messageText:
176:                         "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
177:                     emotionFeatures: "",
178:                     metadata: "",
179:                 },
180:                 {
181:                     id: "5976ddf6-d093-4bb9-ba60-8f6c25832dde",
182:                     chatId: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
183:                     timestamp: 1716244956278,
184:                     role: "USER",
185:                     type: "USER_MESSAGE",
186:                     messageText: "Hello.",
187:                     emotionFeatures:
188:                         '{"Admiration": 0.09906005859375, "Adoration": 0.12213134765625, "Aesthetic Appreciation": 0.05035400390625, "Amusement": 0.16552734375, "Anger": 0.0037384033203125, "Anxiety": 0.010101318359375, "Awe": 0.058197021484375, "Awkwardness": 0.10552978515625, "Boredom": 0.1141357421875, "Calmness": 0.115234375, "Concentration": 0.00444793701171875, "Confusion": 0.0343017578125, "Contemplation": 0.00812530517578125, "Contempt": 0.009002685546875, "Contentment": 0.087158203125, "Craving": 0.00818634033203125, "Desire": 0.018310546875, "Determination": 0.003238677978515625, "Disappointment": 0.024169921875, "Disgust": 0.00702667236328125, "Distress": 0.00936126708984375, "Doubt": 0.00632476806640625, "Ecstasy": 0.0293731689453125, "Embarrassment": 0.01800537109375, "Empathic Pain": 0.0088348388671875, "Entrancement": 0.013397216796875, "Envy": 0.02557373046875, "Excitement": 0.12109375, "Fear": 0.004413604736328125, "Guilt": 0.016571044921875, "Horror": 0.00274658203125, "Interest": 0.2142333984375, "Joy": 0.29638671875, "Love": 0.16015625, "Nostalgia": 0.007843017578125, "Pain": 0.007160186767578125, "Pride": 0.00508880615234375, "Realization": 0.054229736328125, "Relief": 0.048736572265625, "Romance": 0.026397705078125, "Sadness": 0.0265350341796875, "Satisfaction": 0.051361083984375, "Shame": 0.00974273681640625, "Surprise (negative)": 0.0218963623046875, "Surprise (positive)": 0.216064453125, "Sympathy": 0.021728515625, "Tiredness": 0.0173797607421875, "Triumph": 0.004520416259765625}',
189:                     metadata:
190:                         '{"segments": [{"content": "Hello.", "embedding": [0.6181640625, 0.1763916015625, -30.921875, 1.2705078125, 0.927734375, 0.63720703125, 2.865234375, 0.1080322265625, 0.2978515625, 1.0107421875, 1.34375, 0.74560546875, 0.416259765625, 0.99462890625, -0.333740234375, 0.361083984375, -1.388671875, 1.0107421875, 1.3173828125, 0.55615234375, 0.541015625, -0.1837158203125, 1.697265625, 0.228515625, 2.087890625, -0.311767578125, 0.053680419921875, 1.3349609375, 0.95068359375, 0.00441741943359375, 0.705078125, 1.8916015625, -0.939453125, 0.93701171875, -0.28955078125, 1.513671875, 0.5595703125, 1.0126953125, -0.1624755859375, 1.4072265625, -0.28857421875, -0.4560546875, -0.1500244140625, -0.1102294921875, -0.222412109375, 0.8779296875, 1.275390625, 1.6689453125, 0.80712890625, -0.34814453125, -0.325439453125, 0.412841796875, 0.81689453125, 0.55126953125, 1.671875, 0.6611328125, 0.7451171875, 1.50390625, 1.0224609375, -1.671875, 0.7373046875, 2.1328125, 2.166015625, 0.41015625, -0.127685546875, 1.9345703125, -4.2734375, 0.332275390625, 0.26171875, 0.76708984375, 0.2685546875, 0.468017578125, 1.208984375, -1.517578125, 1.083984375, 0.84814453125, 1.0244140625, -0.0072174072265625, 1.34375, 1.0712890625, 1.517578125, -0.52001953125, 0.59228515625, 0.8154296875, -0.951171875, -0.07757568359375, 1.3330078125, 1.125, 0.61181640625, 1.494140625, 0.357421875, 1.1796875, 1.482421875, 0.8046875, 0.1536865234375, 1.8076171875, 0.68115234375, -15.171875, 1.2294921875, 0.319091796875, 0.499755859375, 1.5771484375, 0.94677734375, -0.2490234375, 0.88525390625, 3.47265625, 0.75927734375, 0.71044921875, 1.2333984375, 1.4169921875, -0.56640625, -1.8095703125, 1.37109375, 0.428955078125, 1.89453125, -0.39013671875, 0.1734619140625, 1.5595703125, -1.2294921875, 2.552734375, 0.58349609375, 0.2156982421875, -0.00984954833984375, -0.6865234375, -0.0272979736328125, -0.2264404296875, 2.853515625, 1.3896484375, 0.52978515625, 0.783203125, 3.0390625, 0.75537109375, 0.219970703125, 0.384521484375, 0.385986328125, 2.0546875, -0.10443115234375, 1.5146484375, 1.4296875, 1.9716796875, 1.1318359375, 0.31591796875, 0.338623046875, 1.654296875, -0.88037109375, -0.21484375, 1.45703125, 1.0380859375, -0.52294921875, -0.47802734375, 0.1650390625, 1.2392578125, -1.138671875, 0.56787109375, 1.318359375, 0.4287109375, 0.1981201171875, 2.4375, 0.281005859375, 0.89404296875, -0.1552734375, 0.6474609375, -0.08331298828125, 0.00740814208984375, -0.045501708984375, -0.578125, 2.02734375, 0.59228515625, 0.35693359375, 1.2919921875, 1.22265625, 1.0537109375, 0.145263671875, 1.05859375, -0.369140625, 0.207275390625, 0.78857421875, 0.599609375, 0.99072265625, 0.24462890625, 1.26953125, 0.08404541015625, 1.349609375, 0.73291015625, 1.3212890625, 0.388916015625, 1.0869140625, 0.9931640625, -1.5673828125, 0.0462646484375, 0.650390625, 0.253662109375, 0.58251953125, 1.8134765625, 0.8642578125, 2.591796875, 0.7314453125, 0.85986328125, 0.5615234375, 0.9296875, 0.04144287109375, 1.66015625, 1.99609375, 1.171875, 1.181640625, 1.5126953125, 0.0224456787109375, 0.58349609375, -1.4931640625, 0.81884765625, 0.732421875, -0.6455078125, -0.62451171875, 1.7802734375, 0.01526641845703125, -0.423095703125, 0.461669921875, 4.87890625, 1.2392578125, -0.6953125, 0.6689453125, 0.62451171875, -1.521484375, 1.7685546875, 0.810546875, 0.65478515625, 0.26123046875, 1.6396484375, 0.87548828125, 1.7353515625, 2.046875, 1.5634765625, 0.69384765625, 1.375, 0.8916015625, 1.0107421875, 0.1304931640625, 2.009765625, 0.06402587890625, -0.08428955078125, 0.04351806640625, -1.7529296875, 2.02734375, 3.521484375, 0.404541015625, 1.6337890625, -0.276611328125, 0.8837890625, -0.1287841796875, 0.91064453125, 0.8193359375, 0.701171875, 0.036529541015625, 1.26171875, 1.0478515625, -0.1422119140625, 1.0634765625, 0.61083984375, 1.3505859375, 1.208984375, 0.57275390625, 1.3623046875, 2.267578125, 0.484375, 0.9150390625, 0.56787109375, -0.70068359375, 0.27587890625, -0.70654296875, 0.8466796875, 0.57568359375, 1.6162109375, 0.87939453125, 2.248046875, -0.5458984375, 1.7744140625, 1.328125, 1.232421875, 0.6806640625, 0.9365234375, 1.052734375, -1.08984375, 1.8330078125, -0.4033203125, 1.0673828125, 0.297607421875, 1.5703125, 1.67578125, 1.34765625, 2.8203125, 2.025390625, -0.48583984375, 0.7626953125, 0.01007843017578125, 1.435546875, 0.007205963134765625, 0.05157470703125, -0.9853515625, 0.26708984375, 1.16796875, 1.2041015625, 1.99609375, -0.07916259765625, 1.244140625, -0.32080078125, 0.6748046875, 0.419921875, 1.3212890625, 1.291015625, 0.599609375, 0.0550537109375, 0.9599609375, 0.93505859375, 0.111083984375, 1.302734375, 0.0833740234375, 2.244140625, 1.25390625, 1.6015625, 0.58349609375, 1.7568359375, -0.263427734375, -0.019866943359375, -0.24658203125, -0.1871337890625, 0.927734375, 0.62255859375, 0.275146484375, 0.79541015625, 1.1796875, 1.1767578125, -0.26123046875, -0.268310546875, 1.8994140625, 1.318359375, 2.1875, 0.2469482421875, 1.41015625, 0.03973388671875, 1.2685546875, 1.1025390625, 0.9560546875, 0.865234375, -1.92578125, 1.154296875, 0.389892578125, 1.130859375, 0.95947265625, 0.72314453125, 2.244140625, 0.048553466796875, 0.626953125, 0.42919921875, 0.82275390625, 0.311767578125, -0.320556640625, 0.01041412353515625, 0.1483154296875, 0.10809326171875, -0.3173828125, 1.1337890625, -0.8642578125, 1.4033203125, 0.048828125, 1.1787109375, 0.98779296875, 1.818359375, 1.1552734375, 0.6015625, 1.2392578125, -1.2685546875, 0.39208984375, 0.83251953125, 0.224365234375, 0.0019989013671875, 0.87548828125, 1.6572265625, 1.107421875, 0.434814453125, 1.8251953125, 0.442626953125, 1.2587890625, 0.09320068359375, -0.896484375, 1.8017578125, 1.451171875, -0.0755615234375, 0.6083984375, 2.06640625, 0.673828125, -0.33740234375, 0.192138671875, 0.21435546875, 0.80224609375, -1.490234375, 0.9501953125, 0.86083984375, -0.40283203125, 4.109375, 2.533203125, 1.2529296875, 0.8271484375, 0.225830078125, 1.0478515625, -1.9755859375, 0.841796875, 0.392822265625, 0.525390625, 0.33935546875, -0.79443359375, 0.71630859375, 0.97998046875, -0.175537109375, 0.97705078125, 1.705078125, 0.29638671875, 0.68359375, 0.54150390625, 0.435791015625, 0.99755859375, -0.369140625, 1.009765625, -0.140380859375, 0.426513671875, 0.189697265625, 1.8193359375, 1.1201171875, -0.5009765625, -0.331298828125, 0.759765625, -0.09442138671875, 0.74609375, -1.947265625, 1.3544921875, -3.935546875, 2.544921875, 1.359375, 0.1363525390625, 0.79296875, 0.79931640625, -0.3466796875, 1.1396484375, -0.33447265625, 2.0078125, -0.241455078125, 0.6318359375, 0.365234375, 0.296142578125, 0.830078125, 1.0458984375, 0.5830078125, 0.61572265625, 14.0703125, -2.0078125, -0.381591796875, 1.228515625, 0.08282470703125, -0.67822265625, -0.04339599609375, 0.397216796875, 0.1656494140625, 0.137451171875, 0.244873046875, 1.1611328125, -1.3818359375, 0.8447265625, 1.171875, 0.36328125, 0.252685546875, 0.1197509765625, 0.232177734375, -0.020172119140625, 0.64404296875, -0.01100921630859375, -1.9267578125, 0.222412109375, 0.56005859375, 1.3046875, 1.1630859375, 1.197265625, 1.02734375, 1.6806640625, -0.043731689453125, 1.4697265625, 0.81201171875, 1.5390625, 1.240234375, -0.7353515625, 1.828125, 1.115234375, 1.931640625, -0.517578125, 0.77880859375, 1.0546875, 0.95361328125, 3.42578125, 0.0160369873046875, 0.875, 0.56005859375, 1.2421875, 1.986328125, 1.4814453125, 0.0948486328125, 1.115234375, 0.00665283203125, 2.09375, 0.3544921875, -0.52783203125, 1.2099609375, 0.45068359375, 0.65625, 0.1112060546875, 1.0751953125, -0.9521484375, -0.30029296875, 1.4462890625, 2.046875, 3.212890625, 1.68359375, 1.07421875, -0.5263671875, 0.74560546875, 1.37890625, 0.15283203125, 0.2440185546875, 0.62646484375, -0.1280517578125, 0.7646484375, -0.515625, -0.35693359375, 1.2958984375, 0.96923828125, 0.58935546875, 1.3701171875, 1.0673828125, 0.2337646484375, 0.93115234375, 0.66357421875, 6.0, 1.1025390625, -0.51708984375, -0.38330078125, 0.7197265625, 0.246826171875, -0.45166015625, 1.9521484375, 0.5546875, 0.08807373046875, 0.18505859375, 0.8857421875, -0.57177734375, 0.251708984375, 0.234375, 2.57421875, 0.9599609375, 0.5029296875, 0.10382080078125, 0.08331298828125, 0.66748046875, -0.349609375, 1.287109375, 0.259765625, 2.015625, 2.828125, -0.3095703125, -0.164306640625, -0.3408203125, 0.486572265625, 0.8466796875, 1.9130859375, 0.09088134765625, 0.66552734375, 0.00972747802734375, -0.83154296875, 1.755859375, 0.654296875, 0.173828125, 0.27587890625, -0.47607421875, -0.264404296875, 0.7529296875, 0.6533203125, 0.7275390625, 0.499755859375, 0.833984375, -0.44775390625, -0.05078125, -0.454833984375, 0.75439453125, 0.68505859375, 0.210693359375, -0.283935546875, -0.53564453125, 0.96826171875, 0.861328125, -3.33984375, -0.26171875, 0.77734375, 0.26513671875, -0.14111328125, -0.042236328125, -0.84814453125, 0.2137451171875, 0.94921875, 0.65185546875, -0.5380859375, 0.1529541015625, -0.360595703125, -0.0333251953125, -0.69189453125, 0.8974609375, 0.7109375, 0.81494140625, -0.259521484375, 1.1904296875, 0.62158203125, 1.345703125, 0.89404296875, 0.70556640625, 1.0673828125, 1.392578125, 0.5068359375, 0.962890625, 0.736328125, 1.55078125, 0.50390625, -0.398681640625, 2.361328125, 0.345947265625, -0.61962890625, 0.330078125, 0.75439453125, -0.673828125, -0.2379150390625, 1.5673828125, 1.369140625, 0.1119384765625, -0.1834716796875, 1.4599609375, -0.77587890625, 0.5556640625, 0.09954833984375, 0.0285186767578125, 0.58935546875, -0.501953125, 0.212890625, 0.02679443359375, 0.1715087890625, 0.03466796875, -0.564453125, 2.029296875, 2.45703125, -0.72216796875, 2.138671875, 0.50830078125, -0.09356689453125, 0.230224609375, 1.6943359375, 1.5126953125, 0.39453125, 0.411376953125, 1.07421875, -0.8046875, 0.51416015625, 0.2271728515625, -0.283447265625, 0.38427734375, 0.73388671875, 0.6962890625, 1.4990234375, 0.02813720703125, 0.40478515625, 1.2451171875, 1.1162109375, -5.5703125, 0.76171875, 0.322021484375, 1.0361328125, 1.197265625, 0.1163330078125, 0.2425537109375, 1.5595703125, 1.5791015625, -0.0921630859375, 0.484619140625, 1.9052734375, 5.31640625, 1.6337890625, 0.95947265625, -0.1751708984375, 0.466552734375, 0.8330078125, 1.03125, 0.2044677734375, 0.31298828125, -1.1220703125, 0.5517578125, 0.93505859375, 0.45166015625, 1.951171875, 0.65478515625, 1.30859375, 1.0859375, 0.56494140625, 2.322265625, 0.242919921875, 1.81640625, -0.469970703125, -0.841796875, 0.90869140625, 1.5361328125, 0.923828125, 1.0595703125, 0.356689453125, -0.46142578125, 2.134765625, 1.3037109375, -0.32373046875, -9.2265625, 0.4521484375, 0.88037109375, -0.53955078125, 0.96484375, 0.7705078125, 0.84521484375, 1.580078125, -0.1448974609375, 0.7607421875, 1.0166015625, -0.086669921875, 1.611328125, 0.05938720703125, 0.5078125, 0.8427734375, 2.431640625, 0.66357421875, 3.203125, 0.132080078125, 0.461181640625, 0.779296875, 1.9482421875, 1.8720703125, 0.845703125, -1.3837890625, -0.138916015625, 0.35546875, 0.2457275390625, 0.75341796875, 1.828125, 1.4169921875, 0.60791015625, 1.0068359375, 1.109375, 0.484130859375, -0.302001953125, 0.4951171875, 0.802734375, 1.9482421875, 0.916015625, 0.1646728515625, 2.599609375, 1.7177734375, -0.2374267578125, 0.98046875, 0.39306640625, -1.1396484375, 1.6533203125, 0.375244140625], "scores": [0.09906005859375, 0.12213134765625, 0.05035400390625, 0.16552734375, 0.0037384033203125, 0.010101318359375, 0.058197021484375, 0.10552978515625, 0.1141357421875, 0.115234375, 0.00444793701171875, 0.00812530517578125, 0.0343017578125, 0.009002685546875, 0.087158203125, 0.00818634033203125, 0.003238677978515625, 0.024169921875, 0.00702667236328125, 0.00936126708984375, 0.00632476806640625, 0.0293731689453125, 0.01800537109375, 0.0088348388671875, 0.013397216796875, 0.02557373046875, 0.12109375, 0.004413604736328125, 0.016571044921875, 0.00274658203125, 0.2142333984375, 0.29638671875, 0.16015625, 0.007843017578125, 0.007160186767578125, 0.00508880615234375, 0.054229736328125, 0.048736572265625, 0.026397705078125, 0.0265350341796875, 0.051361083984375, 0.018310546875, 0.00974273681640625, 0.0218963623046875, 0.216064453125, 0.021728515625, 0.0173797607421875, 0.004520416259765625], "stoks": [52, 52, 52, 52, 52, 41, 41, 374, 303, 303, 303, 427], "time": {"begin_ms": 640, "end_ms": 1140}}]}',
191:                 },
192:                 {
193:                     id: "7645a0d1-2e64-410d-83a8-b96040432e9a",
194:                     chatId: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
195:                     timestamp: 1716244957031,
196:                     role: "AGENT",
197:                     type: "AGENT_MESSAGE",
198:                     messageText: "Hello!",
199:                     emotionFeatures:
200:                         '{"Admiration": 0.044921875, "Adoration": 0.0253753662109375, "Aesthetic Appreciation": 0.03265380859375, "Amusement": 0.118408203125, "Anger": 0.06719970703125, "Anxiety": 0.0411376953125, "Awe": 0.03802490234375, "Awkwardness": 0.056549072265625, "Boredom": 0.04217529296875, "Calmness": 0.08709716796875, "Concentration": 0.070556640625, "Confusion": 0.06964111328125, "Contemplation": 0.0343017578125, "Contempt": 0.037689208984375, "Contentment": 0.059417724609375, "Craving": 0.01132965087890625, "Desire": 0.01406097412109375, "Determination": 0.1143798828125, "Disappointment": 0.051177978515625, "Disgust": 0.028594970703125, "Distress": 0.054901123046875, "Doubt": 0.04638671875, "Ecstasy": 0.0258026123046875, "Embarrassment": 0.0222015380859375, "Empathic Pain": 0.015777587890625, "Entrancement": 0.0160980224609375, "Envy": 0.0163421630859375, "Excitement": 0.129638671875, "Fear": 0.03125, "Guilt": 0.01483917236328125, "Horror": 0.0194549560546875, "Interest": 0.1341552734375, "Joy": 0.0738525390625, "Love": 0.0216522216796875, "Nostalgia": 0.0210418701171875, "Pain": 0.020721435546875, "Pride": 0.05499267578125, "Realization": 0.0728759765625, "Relief": 0.04052734375, "Romance": 0.0129241943359375, "Sadness": 0.0254669189453125, "Satisfaction": 0.07159423828125, "Shame": 0.01495361328125, "Surprise (negative)": 0.05560302734375, "Surprise (positive)": 0.07965087890625, "Sympathy": 0.022247314453125, "Tiredness": 0.0194549560546875, "Triumph": 0.04107666015625}',
201:                     metadata: "",
202:                 },
203:             ],
204:             pageNumber: 0,
205:             pageSize: 3,
206:             totalPages: 1,
207:             endTimestamp: 1716244958546,
208:             metadata: "",
209:             config: {
210:                 id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
211:                 version: 0,
212:             },
213:         };
214:         const page = await client.empathicVoice.chats.listChatEvents("470a49f6-1dec-4afe-8b61-035d3b2d63b0", {
215:             pageNumber: 0,
216:             pageSize: 3,
217:             ascendingOrder: true,
218:         });
219: 
220:         expect(expected.eventsPage).toEqual(page.data);
221:         expect(page.hasNextPage()).toBe(true);
222:         const nextPage = await page.getNextPage();
223:         expect(expected.eventsPage).toEqual(nextPage.data);
224:     });
225: 
226:     test("list-chat-events (2)", async () => {
227:         const server = mockServerPool.createServer();
228:         const client = new HumeClient({
229:             maxRetries: 0,
230:             apiKey: "test",
231:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
232:         });
233: 
234:         const rawResponseBody = {};
235:         server
236:             .mockEndpoint({ once: false })
237:             .get("/v0/evi/chats/id")
238:             .respondWith()
239:             .statusCode(400)
240:             .jsonBody(rawResponseBody)
241:             .build();
242: 
243:         await expect(async () => {
244:             return await client.empathicVoice.chats.listChatEvents("id");
245:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
246:     });
247: 
248:     test("get-audio (1)", async () => {
249:         const server = mockServerPool.createServer();
250:         const client = new HumeClient({
251:             maxRetries: 0,
252:             apiKey: "test",
253:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
254:         });
255: 
256:         const rawResponseBody = {
257:             id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
258:             user_id: "e6235940-cfda-3988-9147-ff531627cf42",
259:             status: "COMPLETE",
260:             filename:
261:                 "e6235940-cfda-3988-9147-ff531627cf42/470a49f6-1dec-4afe-8b61-035d3b2d63b0/reconstructed_audio.mp4",
262:             modified_at: 1729875432555,
263:             signed_audio_url: "https://storage.googleapis.com/...etc.",
264:             signed_url_expiration_timestamp_millis: 1730232816964,
265:         };
266:         server
267:             .mockEndpoint()
268:             .get("/v0/evi/chats/470a49f6-1dec-4afe-8b61-035d3b2d63b0/audio")
269:             .respondWith()
270:             .statusCode(200)
271:             .jsonBody(rawResponseBody)
272:             .build();
273: 
274:         const response = await client.empathicVoice.chats.getAudio("470a49f6-1dec-4afe-8b61-035d3b2d63b0");
275:         expect(response).toEqual({
276:             id: "470a49f6-1dec-4afe-8b61-035d3b2d63b0",
277:             userId: "e6235940-cfda-3988-9147-ff531627cf42",
278:             status: "COMPLETE",
279:             filename:
280:                 "e6235940-cfda-3988-9147-ff531627cf42/470a49f6-1dec-4afe-8b61-035d3b2d63b0/reconstructed_audio.mp4",
281:             modifiedAt: 1729875432555,
282:             signedAudioUrl: "https://storage.googleapis.com/...etc.",
283:             signedUrlExpirationTimestampMillis: 1730232816964,
284:         });
285:     });
286: 
287:     test("get-audio (2)", async () => {
288:         const server = mockServerPool.createServer();
289:         const client = new HumeClient({
290:             maxRetries: 0,
291:             apiKey: "test",
292:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
293:         });
294: 
295:         const rawResponseBody = {};
296:         server
297:             .mockEndpoint()
298:             .get("/v0/evi/chats/id/audio")
299:             .respondWith()
300:             .statusCode(400)
301:             .jsonBody(rawResponseBody)
302:             .build();
303: 
304:         await expect(async () => {
305:             return await client.empathicVoice.chats.getAudio("id");
306:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
307:     });
308: });
````

## File: tests/wire/empathic-voice/configs.test.ts
````typescript
   1: // This file was auto-generated by Fern from our API Definition.
   2: 
   3: import * as Hume from "../../../src/api/index";
   4: import { HumeClient } from "../../../src/Client";
   5: import { mockServerPool } from "../../mock-server/MockServerPool";
   6: 
   7: describe("ConfigsClient", () => {
   8:     test("list-configs (1)", async () => {
   9:         const server = mockServerPool.createServer();
  10:         const client = new HumeClient({
  11:             maxRetries: 0,
  12:             apiKey: "test",
  13:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
  14:         });
  15: 
  16:         const rawResponseBody = {
  17:             page_number: 0,
  18:             page_size: 1,
  19:             total_pages: 1,
  20:             configs_page: [
  21:                 {
  22:                     id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
  23:                     version: 0,
  24:                     version_description: "",
  25:                     name: "Weather Assistant Config",
  26:                     created_on: 1715267200693,
  27:                     modified_on: 1715267200693,
  28:                     evi_version: "3",
  29:                     prompt: {
  30:                         id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
  31:                         version: 0,
  32:                         version_type: "FIXED",
  33:                         version_description: "",
  34:                         name: "Weather Assistant Prompt",
  35:                         created_on: 1715267200693,
  36:                         modified_on: 1715267200693,
  37:                         text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
  38:                     },
  39:                     voice: { provider: "HUME_AI", name: "Ava Song", id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c" },
  40:                     language_model: {
  41:                         model_provider: "ANTHROPIC",
  42:                         model_resource: "claude-3-7-sonnet-latest",
  43:                         temperature: 1,
  44:                     },
  45:                     ellm_model: { allow_short_responses: false },
  46:                     tools: [],
  47:                     builtin_tools: [],
  48:                     event_messages: {
  49:                         on_new_chat: { enabled: false, text: "" },
  50:                         on_inactivity_timeout: { enabled: false, text: "" },
  51:                         on_max_duration_timeout: { enabled: false, text: "" },
  52:                     },
  53:                     timeouts: {
  54:                         inactivity: { enabled: true, duration_secs: 600 },
  55:                         max_duration: { enabled: true, duration_secs: 1800 },
  56:                     },
  57:                 },
  58:             ],
  59:         };
  60:         server
  61:             .mockEndpoint({ once: false })
  62:             .get("/v0/evi/configs")
  63:             .respondWith()
  64:             .statusCode(200)
  65:             .jsonBody(rawResponseBody)
  66:             .build();
  67: 
  68:         const expected = {
  69:             pageNumber: 0,
  70:             pageSize: 1,
  71:             totalPages: 1,
  72:             configsPage: [
  73:                 {
  74:                     id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
  75:                     version: 0,
  76:                     versionDescription: "",
  77:                     name: "Weather Assistant Config",
  78:                     createdOn: 1715267200693,
  79:                     modifiedOn: 1715267200693,
  80:                     eviVersion: "3",
  81:                     prompt: {
  82:                         id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
  83:                         version: 0,
  84:                         versionType: "FIXED",
  85:                         versionDescription: "",
  86:                         name: "Weather Assistant Prompt",
  87:                         createdOn: 1715267200693,
  88:                         modifiedOn: 1715267200693,
  89:                         text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
  90:                     },
  91:                     voice: {
  92:                         provider: "HUME_AI",
  93:                         name: "Ava Song",
  94:                         id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c",
  95:                     },
  96:                     languageModel: {
  97:                         modelProvider: "ANTHROPIC",
  98:                         modelResource: "claude-3-7-sonnet-latest",
  99:                         temperature: 1,
 100:                     },
 101:                     ellmModel: {
 102:                         allowShortResponses: false,
 103:                     },
 104:                     tools: [],
 105:                     builtinTools: [],
 106:                     eventMessages: {
 107:                         onNewChat: {
 108:                             enabled: false,
 109:                             text: "",
 110:                         },
 111:                         onInactivityTimeout: {
 112:                             enabled: false,
 113:                             text: "",
 114:                         },
 115:                         onMaxDurationTimeout: {
 116:                             enabled: false,
 117:                             text: "",
 118:                         },
 119:                     },
 120:                     timeouts: {
 121:                         inactivity: {
 122:                             enabled: true,
 123:                             durationSecs: 600,
 124:                         },
 125:                         maxDuration: {
 126:                             enabled: true,
 127:                             durationSecs: 1800,
 128:                         },
 129:                     },
 130:                 },
 131:             ],
 132:         };
 133:         const page = await client.empathicVoice.configs.listConfigs({
 134:             pageNumber: 0,
 135:             pageSize: 1,
 136:         });
 137: 
 138:         expect(expected.configsPage).toEqual(page.data);
 139:         expect(page.hasNextPage()).toBe(true);
 140:         const nextPage = await page.getNextPage();
 141:         expect(expected.configsPage).toEqual(nextPage.data);
 142:     });
 143: 
 144:     test("list-configs (2)", async () => {
 145:         const server = mockServerPool.createServer();
 146:         const client = new HumeClient({
 147:             maxRetries: 0,
 148:             apiKey: "test",
 149:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 150:         });
 151: 
 152:         const rawResponseBody = {};
 153:         server
 154:             .mockEndpoint({ once: false })
 155:             .get("/v0/evi/configs")
 156:             .respondWith()
 157:             .statusCode(400)
 158:             .jsonBody(rawResponseBody)
 159:             .build();
 160: 
 161:         await expect(async () => {
 162:             return await client.empathicVoice.configs.listConfigs();
 163:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
 164:     });
 165: 
 166:     test("create-config (1)", async () => {
 167:         const server = mockServerPool.createServer();
 168:         const client = new HumeClient({
 169:             maxRetries: 0,
 170:             apiKey: "test",
 171:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 172:         });
 173:         const rawRequestBody = {
 174:             name: "Weather Assistant Config",
 175:             prompt: { id: "af699d45-2985-42cc-91b9-af9e5da3bac5", version: 0 },
 176:             evi_version: "3",
 177:             voice: { provider: "HUME_AI", name: "Ava Song" },
 178:             language_model: { model_provider: "ANTHROPIC", model_resource: "claude-3-7-sonnet-latest", temperature: 1 },
 179:             event_messages: {
 180:                 on_new_chat: { enabled: false, text: "" },
 181:                 on_inactivity_timeout: { enabled: false, text: "" },
 182:                 on_max_duration_timeout: { enabled: false, text: "" },
 183:             },
 184:         };
 185:         const rawResponseBody = {
 186:             id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 187:             version: 0,
 188:             version_description: "",
 189:             name: "Weather Assistant Config",
 190:             created_on: 1715275452390,
 191:             modified_on: 1715275452390,
 192:             evi_version: "3",
 193:             prompt: {
 194:                 id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 195:                 version: 0,
 196:                 version_type: "FIXED",
 197:                 version_description: "",
 198:                 name: "Weather Assistant Prompt",
 199:                 created_on: 1715267200693,
 200:                 modified_on: 1715267200693,
 201:                 text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 202:             },
 203:             voice: { provider: "HUME_AI", name: "Ava Song", id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c" },
 204:             language_model: { model_provider: "ANTHROPIC", model_resource: "claude-3-7-sonnet-latest", temperature: 1 },
 205:             ellm_model: { allow_short_responses: false },
 206:             tools: [],
 207:             builtin_tools: [],
 208:             event_messages: {
 209:                 on_new_chat: { enabled: false, text: "" },
 210:                 on_inactivity_timeout: { enabled: false, text: "" },
 211:                 on_max_duration_timeout: { enabled: false, text: "" },
 212:             },
 213:             timeouts: {
 214:                 inactivity: { enabled: true, duration_secs: 600 },
 215:                 max_duration: { enabled: true, duration_secs: 1800 },
 216:             },
 217:         };
 218:         server
 219:             .mockEndpoint()
 220:             .post("/v0/evi/configs")
 221:             .jsonBody(rawRequestBody)
 222:             .respondWith()
 223:             .statusCode(200)
 224:             .jsonBody(rawResponseBody)
 225:             .build();
 226: 
 227:         const response = await client.empathicVoice.configs.createConfig({
 228:             name: "Weather Assistant Config",
 229:             prompt: {
 230:                 id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 231:                 version: 0,
 232:             },
 233:             eviVersion: "3",
 234:             voice: {
 235:                 provider: "HUME_AI",
 236:                 name: "Ava Song",
 237:             },
 238:             languageModel: {
 239:                 modelProvider: "ANTHROPIC",
 240:                 modelResource: "claude-3-7-sonnet-latest",
 241:                 temperature: 1,
 242:             },
 243:             eventMessages: {
 244:                 onNewChat: {
 245:                     enabled: false,
 246:                     text: "",
 247:                 },
 248:                 onInactivityTimeout: {
 249:                     enabled: false,
 250:                     text: "",
 251:                 },
 252:                 onMaxDurationTimeout: {
 253:                     enabled: false,
 254:                     text: "",
 255:                 },
 256:             },
 257:         });
 258:         expect(response).toEqual({
 259:             id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 260:             version: 0,
 261:             versionDescription: "",
 262:             name: "Weather Assistant Config",
 263:             createdOn: 1715275452390,
 264:             modifiedOn: 1715275452390,
 265:             eviVersion: "3",
 266:             prompt: {
 267:                 id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 268:                 version: 0,
 269:                 versionType: "FIXED",
 270:                 versionDescription: "",
 271:                 name: "Weather Assistant Prompt",
 272:                 createdOn: 1715267200693,
 273:                 modifiedOn: 1715267200693,
 274:                 text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 275:             },
 276:             voice: {
 277:                 provider: "HUME_AI",
 278:                 name: "Ava Song",
 279:                 id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c",
 280:             },
 281:             languageModel: {
 282:                 modelProvider: "ANTHROPIC",
 283:                 modelResource: "claude-3-7-sonnet-latest",
 284:                 temperature: 1,
 285:             },
 286:             ellmModel: {
 287:                 allowShortResponses: false,
 288:             },
 289:             tools: [],
 290:             builtinTools: [],
 291:             eventMessages: {
 292:                 onNewChat: {
 293:                     enabled: false,
 294:                     text: "",
 295:                 },
 296:                 onInactivityTimeout: {
 297:                     enabled: false,
 298:                     text: "",
 299:                 },
 300:                 onMaxDurationTimeout: {
 301:                     enabled: false,
 302:                     text: "",
 303:                 },
 304:             },
 305:             timeouts: {
 306:                 inactivity: {
 307:                     enabled: true,
 308:                     durationSecs: 600,
 309:                 },
 310:                 maxDuration: {
 311:                     enabled: true,
 312:                     durationSecs: 1800,
 313:                 },
 314:             },
 315:         });
 316:     });
 317: 
 318:     test("create-config (2)", async () => {
 319:         const server = mockServerPool.createServer();
 320:         const client = new HumeClient({
 321:             maxRetries: 0,
 322:             apiKey: "test",
 323:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 324:         });
 325:         const rawRequestBody = { evi_version: "evi_version", name: "name" };
 326:         const rawResponseBody = {};
 327:         server
 328:             .mockEndpoint()
 329:             .post("/v0/evi/configs")
 330:             .jsonBody(rawRequestBody)
 331:             .respondWith()
 332:             .statusCode(400)
 333:             .jsonBody(rawResponseBody)
 334:             .build();
 335: 
 336:         await expect(async () => {
 337:             return await client.empathicVoice.configs.createConfig({
 338:                 eviVersion: "evi_version",
 339:                 name: "name",
 340:             });
 341:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
 342:     });
 343: 
 344:     test("list-config-versions (1)", async () => {
 345:         const server = mockServerPool.createServer();
 346:         const client = new HumeClient({
 347:             maxRetries: 0,
 348:             apiKey: "test",
 349:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 350:         });
 351: 
 352:         const rawResponseBody = {
 353:             page_number: 0,
 354:             page_size: 10,
 355:             total_pages: 1,
 356:             configs_page: [
 357:                 {
 358:                     id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 359:                     version: 0,
 360:                     version_description: "",
 361:                     name: "Weather Assistant Config",
 362:                     created_on: 1715275452390,
 363:                     modified_on: 1715275452390,
 364:                     evi_version: "3",
 365:                     prompt: {
 366:                         id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 367:                         version: 0,
 368:                         version_type: "FIXED",
 369:                         version_description: "",
 370:                         name: "Weather Assistant Prompt",
 371:                         created_on: 1715267200693,
 372:                         modified_on: 1715267200693,
 373:                         text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 374:                     },
 375:                     voice: { provider: "HUME_AI", name: "Ava Song", id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c" },
 376:                     language_model: {
 377:                         model_provider: "ANTHROPIC",
 378:                         model_resource: "claude-3-7-sonnet-latest",
 379:                         temperature: 1,
 380:                     },
 381:                     ellm_model: { allow_short_responses: false },
 382:                     tools: [],
 383:                     builtin_tools: [],
 384:                     event_messages: {
 385:                         on_new_chat: { enabled: false, text: "" },
 386:                         on_inactivity_timeout: { enabled: false, text: "" },
 387:                         on_max_duration_timeout: { enabled: false, text: "" },
 388:                     },
 389:                     timeouts: {
 390:                         inactivity: { enabled: true, duration_secs: 600 },
 391:                         max_duration: { enabled: true, duration_secs: 1800 },
 392:                     },
 393:                 },
 394:             ],
 395:         };
 396:         server
 397:             .mockEndpoint({ once: false })
 398:             .get("/v0/evi/configs/1b60e1a0-cc59-424a-8d2c-189d354db3f3")
 399:             .respondWith()
 400:             .statusCode(200)
 401:             .jsonBody(rawResponseBody)
 402:             .build();
 403: 
 404:         const expected = {
 405:             pageNumber: 0,
 406:             pageSize: 10,
 407:             totalPages: 1,
 408:             configsPage: [
 409:                 {
 410:                     id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 411:                     version: 0,
 412:                     versionDescription: "",
 413:                     name: "Weather Assistant Config",
 414:                     createdOn: 1715275452390,
 415:                     modifiedOn: 1715275452390,
 416:                     eviVersion: "3",
 417:                     prompt: {
 418:                         id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 419:                         version: 0,
 420:                         versionType: "FIXED",
 421:                         versionDescription: "",
 422:                         name: "Weather Assistant Prompt",
 423:                         createdOn: 1715267200693,
 424:                         modifiedOn: 1715267200693,
 425:                         text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 426:                     },
 427:                     voice: {
 428:                         provider: "HUME_AI",
 429:                         name: "Ava Song",
 430:                         id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c",
 431:                     },
 432:                     languageModel: {
 433:                         modelProvider: "ANTHROPIC",
 434:                         modelResource: "claude-3-7-sonnet-latest",
 435:                         temperature: 1,
 436:                     },
 437:                     ellmModel: {
 438:                         allowShortResponses: false,
 439:                     },
 440:                     tools: [],
 441:                     builtinTools: [],
 442:                     eventMessages: {
 443:                         onNewChat: {
 444:                             enabled: false,
 445:                             text: "",
 446:                         },
 447:                         onInactivityTimeout: {
 448:                             enabled: false,
 449:                             text: "",
 450:                         },
 451:                         onMaxDurationTimeout: {
 452:                             enabled: false,
 453:                             text: "",
 454:                         },
 455:                     },
 456:                     timeouts: {
 457:                         inactivity: {
 458:                             enabled: true,
 459:                             durationSecs: 600,
 460:                         },
 461:                         maxDuration: {
 462:                             enabled: true,
 463:                             durationSecs: 1800,
 464:                         },
 465:                     },
 466:                 },
 467:             ],
 468:         };
 469:         const page = await client.empathicVoice.configs.listConfigVersions("1b60e1a0-cc59-424a-8d2c-189d354db3f3");
 470: 
 471:         expect(expected.configsPage).toEqual(page.data);
 472:         expect(page.hasNextPage()).toBe(true);
 473:         const nextPage = await page.getNextPage();
 474:         expect(expected.configsPage).toEqual(nextPage.data);
 475:     });
 476: 
 477:     test("list-config-versions (2)", async () => {
 478:         const server = mockServerPool.createServer();
 479:         const client = new HumeClient({
 480:             maxRetries: 0,
 481:             apiKey: "test",
 482:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 483:         });
 484: 
 485:         const rawResponseBody = {};
 486:         server
 487:             .mockEndpoint({ once: false })
 488:             .get("/v0/evi/configs/id")
 489:             .respondWith()
 490:             .statusCode(400)
 491:             .jsonBody(rawResponseBody)
 492:             .build();
 493: 
 494:         await expect(async () => {
 495:             return await client.empathicVoice.configs.listConfigVersions("id");
 496:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
 497:     });
 498: 
 499:     test("create-config-version (1)", async () => {
 500:         const server = mockServerPool.createServer();
 501:         const client = new HumeClient({
 502:             maxRetries: 0,
 503:             apiKey: "test",
 504:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 505:         });
 506:         const rawRequestBody = {
 507:             version_description: "This is an updated version of the Weather Assistant Config.",
 508:             evi_version: "3",
 509:             prompt: { id: "af699d45-2985-42cc-91b9-af9e5da3bac5", version: 0 },
 510:             voice: { provider: "HUME_AI", name: "Ava Song" },
 511:             language_model: { model_provider: "ANTHROPIC", model_resource: "claude-3-7-sonnet-latest", temperature: 1 },
 512:             ellm_model: { allow_short_responses: true },
 513:             event_messages: {
 514:                 on_new_chat: { enabled: false, text: "" },
 515:                 on_inactivity_timeout: { enabled: false, text: "" },
 516:                 on_max_duration_timeout: { enabled: false, text: "" },
 517:             },
 518:         };
 519:         const rawResponseBody = {
 520:             id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 521:             version: 1,
 522:             version_description: "This is an updated version of the Weather Assistant Config.",
 523:             name: "Weather Assistant Config",
 524:             created_on: 1715275452390,
 525:             modified_on: 1722642242998,
 526:             evi_version: "3",
 527:             prompt: {
 528:                 id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 529:                 version: 0,
 530:                 version_type: "FIXED",
 531:                 version_description: "",
 532:                 name: "Weather Assistant Prompt",
 533:                 created_on: 1715267200693,
 534:                 modified_on: 1715267200693,
 535:                 text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 536:             },
 537:             voice: { provider: "HUME_AI", name: "Ava Song", id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c" },
 538:             language_model: { model_provider: "ANTHROPIC", model_resource: "claude-3-7-sonnet-latest", temperature: 1 },
 539:             ellm_model: { allow_short_responses: true },
 540:             tools: [],
 541:             builtin_tools: [],
 542:             event_messages: {
 543:                 on_new_chat: { enabled: false, text: "" },
 544:                 on_inactivity_timeout: { enabled: false, text: "" },
 545:                 on_max_duration_timeout: { enabled: false, text: "" },
 546:             },
 547:             timeouts: {
 548:                 inactivity: { enabled: true, duration_secs: 600 },
 549:                 max_duration: { enabled: true, duration_secs: 1800 },
 550:             },
 551:         };
 552:         server
 553:             .mockEndpoint()
 554:             .post("/v0/evi/configs/1b60e1a0-cc59-424a-8d2c-189d354db3f3")
 555:             .jsonBody(rawRequestBody)
 556:             .respondWith()
 557:             .statusCode(200)
 558:             .jsonBody(rawResponseBody)
 559:             .build();
 560: 
 561:         const response = await client.empathicVoice.configs.createConfigVersion(
 562:             "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 563:             {
 564:                 versionDescription: "This is an updated version of the Weather Assistant Config.",
 565:                 eviVersion: "3",
 566:                 prompt: {
 567:                     id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 568:                     version: 0,
 569:                 },
 570:                 voice: {
 571:                     provider: "HUME_AI",
 572:                     name: "Ava Song",
 573:                 },
 574:                 languageModel: {
 575:                     modelProvider: "ANTHROPIC",
 576:                     modelResource: "claude-3-7-sonnet-latest",
 577:                     temperature: 1,
 578:                 },
 579:                 ellmModel: {
 580:                     allowShortResponses: true,
 581:                 },
 582:                 eventMessages: {
 583:                     onNewChat: {
 584:                         enabled: false,
 585:                         text: "",
 586:                     },
 587:                     onInactivityTimeout: {
 588:                         enabled: false,
 589:                         text: "",
 590:                     },
 591:                     onMaxDurationTimeout: {
 592:                         enabled: false,
 593:                         text: "",
 594:                     },
 595:                 },
 596:             },
 597:         );
 598:         expect(response).toEqual({
 599:             id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 600:             version: 1,
 601:             versionDescription: "This is an updated version of the Weather Assistant Config.",
 602:             name: "Weather Assistant Config",
 603:             createdOn: 1715275452390,
 604:             modifiedOn: 1722642242998,
 605:             eviVersion: "3",
 606:             prompt: {
 607:                 id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 608:                 version: 0,
 609:                 versionType: "FIXED",
 610:                 versionDescription: "",
 611:                 name: "Weather Assistant Prompt",
 612:                 createdOn: 1715267200693,
 613:                 modifiedOn: 1715267200693,
 614:                 text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 615:             },
 616:             voice: {
 617:                 provider: "HUME_AI",
 618:                 name: "Ava Song",
 619:                 id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c",
 620:             },
 621:             languageModel: {
 622:                 modelProvider: "ANTHROPIC",
 623:                 modelResource: "claude-3-7-sonnet-latest",
 624:                 temperature: 1,
 625:             },
 626:             ellmModel: {
 627:                 allowShortResponses: true,
 628:             },
 629:             tools: [],
 630:             builtinTools: [],
 631:             eventMessages: {
 632:                 onNewChat: {
 633:                     enabled: false,
 634:                     text: "",
 635:                 },
 636:                 onInactivityTimeout: {
 637:                     enabled: false,
 638:                     text: "",
 639:                 },
 640:                 onMaxDurationTimeout: {
 641:                     enabled: false,
 642:                     text: "",
 643:                 },
 644:             },
 645:             timeouts: {
 646:                 inactivity: {
 647:                     enabled: true,
 648:                     durationSecs: 600,
 649:                 },
 650:                 maxDuration: {
 651:                     enabled: true,
 652:                     durationSecs: 1800,
 653:                 },
 654:             },
 655:         });
 656:     });
 657: 
 658:     test("create-config-version (2)", async () => {
 659:         const server = mockServerPool.createServer();
 660:         const client = new HumeClient({
 661:             maxRetries: 0,
 662:             apiKey: "test",
 663:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 664:         });
 665:         const rawRequestBody = { evi_version: "evi_version" };
 666:         const rawResponseBody = {};
 667:         server
 668:             .mockEndpoint()
 669:             .post("/v0/evi/configs/id")
 670:             .jsonBody(rawRequestBody)
 671:             .respondWith()
 672:             .statusCode(400)
 673:             .jsonBody(rawResponseBody)
 674:             .build();
 675: 
 676:         await expect(async () => {
 677:             return await client.empathicVoice.configs.createConfigVersion("id", {
 678:                 eviVersion: "evi_version",
 679:             });
 680:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
 681:     });
 682: 
 683:     test("delete-config (1)", async () => {
 684:         const server = mockServerPool.createServer();
 685:         const client = new HumeClient({
 686:             maxRetries: 0,
 687:             apiKey: "test",
 688:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 689:         });
 690: 
 691:         server
 692:             .mockEndpoint()
 693:             .delete("/v0/evi/configs/1b60e1a0-cc59-424a-8d2c-189d354db3f3")
 694:             .respondWith()
 695:             .statusCode(200)
 696:             .build();
 697: 
 698:         const response = await client.empathicVoice.configs.deleteConfig("1b60e1a0-cc59-424a-8d2c-189d354db3f3");
 699:         expect(response).toEqual(undefined);
 700:     });
 701: 
 702:     test("delete-config (2)", async () => {
 703:         const server = mockServerPool.createServer();
 704:         const client = new HumeClient({
 705:             maxRetries: 0,
 706:             apiKey: "test",
 707:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 708:         });
 709: 
 710:         const rawResponseBody = {};
 711:         server
 712:             .mockEndpoint()
 713:             .delete("/v0/evi/configs/id")
 714:             .respondWith()
 715:             .statusCode(400)
 716:             .jsonBody(rawResponseBody)
 717:             .build();
 718: 
 719:         await expect(async () => {
 720:             return await client.empathicVoice.configs.deleteConfig("id");
 721:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
 722:     });
 723: 
 724:     test("get-config-version (1)", async () => {
 725:         const server = mockServerPool.createServer();
 726:         const client = new HumeClient({
 727:             maxRetries: 0,
 728:             apiKey: "test",
 729:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 730:         });
 731: 
 732:         const rawResponseBody = {
 733:             id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 734:             version: 1,
 735:             version_description: "",
 736:             name: "Weather Assistant Config",
 737:             created_on: 1715275452390,
 738:             modified_on: 1715275452390,
 739:             evi_version: "3",
 740:             prompt: {
 741:                 id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 742:                 version: 0,
 743:                 version_type: "FIXED",
 744:                 version_description: "",
 745:                 name: "Weather Assistant Prompt",
 746:                 created_on: 1715267200693,
 747:                 modified_on: 1715267200693,
 748:                 text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 749:             },
 750:             voice: { provider: "HUME_AI", name: "Ava Song", id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c" },
 751:             language_model: { model_provider: "ANTHROPIC", model_resource: "claude-3-7-sonnet-latest", temperature: 1 },
 752:             ellm_model: { allow_short_responses: false },
 753:             tools: [],
 754:             builtin_tools: [],
 755:             event_messages: {
 756:                 on_new_chat: { enabled: false, text: "" },
 757:                 on_inactivity_timeout: { enabled: false, text: "" },
 758:                 on_max_duration_timeout: { enabled: false, text: "" },
 759:             },
 760:             timeouts: {
 761:                 inactivity: { enabled: true, duration_secs: 600 },
 762:                 max_duration: { enabled: true, duration_secs: 1800 },
 763:             },
 764:         };
 765:         server
 766:             .mockEndpoint()
 767:             .get("/v0/evi/configs/1b60e1a0-cc59-424a-8d2c-189d354db3f3/version/1")
 768:             .respondWith()
 769:             .statusCode(200)
 770:             .jsonBody(rawResponseBody)
 771:             .build();
 772: 
 773:         const response = await client.empathicVoice.configs.getConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1);
 774:         expect(response).toEqual({
 775:             id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 776:             version: 1,
 777:             versionDescription: "",
 778:             name: "Weather Assistant Config",
 779:             createdOn: 1715275452390,
 780:             modifiedOn: 1715275452390,
 781:             eviVersion: "3",
 782:             prompt: {
 783:                 id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 784:                 version: 0,
 785:                 versionType: "FIXED",
 786:                 versionDescription: "",
 787:                 name: "Weather Assistant Prompt",
 788:                 createdOn: 1715267200693,
 789:                 modifiedOn: 1715267200693,
 790:                 text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 791:             },
 792:             voice: {
 793:                 provider: "HUME_AI",
 794:                 name: "Ava Song",
 795:                 id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c",
 796:             },
 797:             languageModel: {
 798:                 modelProvider: "ANTHROPIC",
 799:                 modelResource: "claude-3-7-sonnet-latest",
 800:                 temperature: 1,
 801:             },
 802:             ellmModel: {
 803:                 allowShortResponses: false,
 804:             },
 805:             tools: [],
 806:             builtinTools: [],
 807:             eventMessages: {
 808:                 onNewChat: {
 809:                     enabled: false,
 810:                     text: "",
 811:                 },
 812:                 onInactivityTimeout: {
 813:                     enabled: false,
 814:                     text: "",
 815:                 },
 816:                 onMaxDurationTimeout: {
 817:                     enabled: false,
 818:                     text: "",
 819:                 },
 820:             },
 821:             timeouts: {
 822:                 inactivity: {
 823:                     enabled: true,
 824:                     durationSecs: 600,
 825:                 },
 826:                 maxDuration: {
 827:                     enabled: true,
 828:                     durationSecs: 1800,
 829:                 },
 830:             },
 831:         });
 832:     });
 833: 
 834:     test("get-config-version (2)", async () => {
 835:         const server = mockServerPool.createServer();
 836:         const client = new HumeClient({
 837:             maxRetries: 0,
 838:             apiKey: "test",
 839:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 840:         });
 841: 
 842:         const rawResponseBody = {};
 843:         server
 844:             .mockEndpoint()
 845:             .get("/v0/evi/configs/id/version/1")
 846:             .respondWith()
 847:             .statusCode(400)
 848:             .jsonBody(rawResponseBody)
 849:             .build();
 850: 
 851:         await expect(async () => {
 852:             return await client.empathicVoice.configs.getConfigVersion("id", 1);
 853:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
 854:     });
 855: 
 856:     test("delete-config-version (1)", async () => {
 857:         const server = mockServerPool.createServer();
 858:         const client = new HumeClient({
 859:             maxRetries: 0,
 860:             apiKey: "test",
 861:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 862:         });
 863: 
 864:         server
 865:             .mockEndpoint()
 866:             .delete("/v0/evi/configs/1b60e1a0-cc59-424a-8d2c-189d354db3f3/version/1")
 867:             .respondWith()
 868:             .statusCode(200)
 869:             .build();
 870: 
 871:         const response = await client.empathicVoice.configs.deleteConfigVersion(
 872:             "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 873:             1,
 874:         );
 875:         expect(response).toEqual(undefined);
 876:     });
 877: 
 878:     test("delete-config-version (2)", async () => {
 879:         const server = mockServerPool.createServer();
 880:         const client = new HumeClient({
 881:             maxRetries: 0,
 882:             apiKey: "test",
 883:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 884:         });
 885: 
 886:         const rawResponseBody = {};
 887:         server
 888:             .mockEndpoint()
 889:             .delete("/v0/evi/configs/id/version/1")
 890:             .respondWith()
 891:             .statusCode(400)
 892:             .jsonBody(rawResponseBody)
 893:             .build();
 894: 
 895:         await expect(async () => {
 896:             return await client.empathicVoice.configs.deleteConfigVersion("id", 1);
 897:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
 898:     });
 899: 
 900:     test("update-config-description (1)", async () => {
 901:         const server = mockServerPool.createServer();
 902:         const client = new HumeClient({
 903:             maxRetries: 0,
 904:             apiKey: "test",
 905:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 906:         });
 907:         const rawRequestBody = { version_description: "This is an updated version_description." };
 908:         const rawResponseBody = {
 909:             id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 910:             version: 1,
 911:             version_description: "This is an updated version_description.",
 912:             name: "Weather Assistant Config",
 913:             created_on: 1715275452390,
 914:             modified_on: 1715275452390,
 915:             evi_version: "3",
 916:             prompt: {
 917:                 id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 918:                 version: 0,
 919:                 version_type: "FIXED",
 920:                 version_description: "",
 921:                 name: "Weather Assistant Prompt",
 922:                 created_on: 1715267200693,
 923:                 modified_on: 1715267200693,
 924:                 text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 925:             },
 926:             voice: { provider: "HUME_AI", name: "Ava Song", id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c" },
 927:             language_model: { model_provider: "ANTHROPIC", model_resource: "claude-3-7-sonnet-latest", temperature: 1 },
 928:             ellm_model: { allow_short_responses: false },
 929:             tools: [],
 930:             builtin_tools: [],
 931:             event_messages: {
 932:                 on_new_chat: { enabled: false, text: "" },
 933:                 on_inactivity_timeout: { enabled: false, text: "" },
 934:                 on_max_duration_timeout: { enabled: false, text: "" },
 935:             },
 936:             timeouts: {
 937:                 inactivity: { enabled: true, duration_secs: 600 },
 938:                 max_duration: { enabled: true, duration_secs: 1800 },
 939:             },
 940:         };
 941:         server
 942:             .mockEndpoint()
 943:             .patch("/v0/evi/configs/1b60e1a0-cc59-424a-8d2c-189d354db3f3/version/1")
 944:             .jsonBody(rawRequestBody)
 945:             .respondWith()
 946:             .statusCode(200)
 947:             .jsonBody(rawResponseBody)
 948:             .build();
 949: 
 950:         const response = await client.empathicVoice.configs.updateConfigDescription(
 951:             "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 952:             1,
 953:             {
 954:                 versionDescription: "This is an updated version_description.",
 955:             },
 956:         );
 957:         expect(response).toEqual({
 958:             id: "1b60e1a0-cc59-424a-8d2c-189d354db3f3",
 959:             version: 1,
 960:             versionDescription: "This is an updated version_description.",
 961:             name: "Weather Assistant Config",
 962:             createdOn: 1715275452390,
 963:             modifiedOn: 1715275452390,
 964:             eviVersion: "3",
 965:             prompt: {
 966:                 id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 967:                 version: 0,
 968:                 versionType: "FIXED",
 969:                 versionDescription: "",
 970:                 name: "Weather Assistant Prompt",
 971:                 createdOn: 1715267200693,
 972:                 modifiedOn: 1715267200693,
 973:                 text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 974:             },
 975:             voice: {
 976:                 provider: "HUME_AI",
 977:                 name: "Ava Song",
 978:                 id: "5bb7de05-c8fe-426a-8fcc-ba4fc4ce9f9c",
 979:             },
 980:             languageModel: {
 981:                 modelProvider: "ANTHROPIC",
 982:                 modelResource: "claude-3-7-sonnet-latest",
 983:                 temperature: 1,
 984:             },
 985:             ellmModel: {
 986:                 allowShortResponses: false,
 987:             },
 988:             tools: [],
 989:             builtinTools: [],
 990:             eventMessages: {
 991:                 onNewChat: {
 992:                     enabled: false,
 993:                     text: "",
 994:                 },
 995:                 onInactivityTimeout: {
 996:                     enabled: false,
 997:                     text: "",
 998:                 },
 999:                 onMaxDurationTimeout: {
1000:                     enabled: false,
1001:                     text: "",
1002:                 },
1003:             },
1004:             timeouts: {
1005:                 inactivity: {
1006:                     enabled: true,
1007:                     durationSecs: 600,
1008:                 },
1009:                 maxDuration: {
1010:                     enabled: true,
1011:                     durationSecs: 1800,
1012:                 },
1013:             },
1014:         });
1015:     });
1016: 
1017:     test("update-config-description (2)", async () => {
1018:         const server = mockServerPool.createServer();
1019:         const client = new HumeClient({
1020:             maxRetries: 0,
1021:             apiKey: "test",
1022:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
1023:         });
1024:         const rawRequestBody = {};
1025:         const rawResponseBody = {};
1026:         server
1027:             .mockEndpoint()
1028:             .patch("/v0/evi/configs/id/version/1")
1029:             .jsonBody(rawRequestBody)
1030:             .respondWith()
1031:             .statusCode(400)
1032:             .jsonBody(rawResponseBody)
1033:             .build();
1034: 
1035:         await expect(async () => {
1036:             return await client.empathicVoice.configs.updateConfigDescription("id", 1);
1037:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
1038:     });
1039: });
````

## File: tests/wire/empathic-voice/controlPlane.test.ts
````typescript
 1: // This file was auto-generated by Fern from our API Definition.
 2: 
 3: import * as Hume from "../../../src/api/index";
 4: import { HumeClient } from "../../../src/Client";
 5: import { mockServerPool } from "../../mock-server/MockServerPool";
 6: 
 7: describe("ControlPlaneClient", () => {
 8:     test("send (1)", async () => {
 9:         const server = mockServerPool.createServer();
10:         const client = new HumeClient({
11:             maxRetries: 0,
12:             apiKey: "test",
13:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
14:         });
15:         const rawRequestBody = { type: "session_settings" };
16: 
17:         server
18:             .mockEndpoint()
19:             .post("/v0/evi/chat/chat_id/send")
20:             .jsonBody(rawRequestBody)
21:             .respondWith()
22:             .statusCode(200)
23:             .build();
24: 
25:         const response = await client.empathicVoice.controlPlane.send("chat_id", {
26:             type: "session_settings",
27:         });
28:         expect(response).toEqual(undefined);
29:     });
30: 
31:     test("send (2)", async () => {
32:         const server = mockServerPool.createServer();
33:         const client = new HumeClient({
34:             maxRetries: 0,
35:             apiKey: "test",
36:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
37:         });
38:         const rawRequestBody = { type: "session_settings" };
39:         const rawResponseBody = {};
40:         server
41:             .mockEndpoint()
42:             .post("/v0/evi/chat/chat_id/send")
43:             .jsonBody(rawRequestBody)
44:             .respondWith()
45:             .statusCode(422)
46:             .jsonBody(rawResponseBody)
47:             .build();
48: 
49:         await expect(async () => {
50:             return await client.empathicVoice.controlPlane.send("chat_id", {
51:                 type: "session_settings",
52:             });
53:         }).rejects.toThrow(Hume.empathicVoice.UnprocessableEntityError);
54:     });
55: });
````

## File: tests/wire/empathic-voice/prompts.test.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import * as Hume from "../../../src/api/index";
  4: import { HumeClient } from "../../../src/Client";
  5: import { mockServerPool } from "../../mock-server/MockServerPool";
  6: 
  7: describe("PromptsClient", () => {
  8:     test("list-prompts (1)", async () => {
  9:         const server = mockServerPool.createServer();
 10:         const client = new HumeClient({
 11:             maxRetries: 0,
 12:             apiKey: "test",
 13:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 14:         });
 15: 
 16:         const rawResponseBody = {
 17:             page_number: 0,
 18:             page_size: 2,
 19:             total_pages: 1,
 20:             prompts_page: [
 21:                 {
 22:                     id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 23:                     version: 0,
 24:                     version_type: "FIXED",
 25:                     version_description: "",
 26:                     name: "Weather Assistant Prompt",
 27:                     created_on: 1715267200693,
 28:                     modified_on: 1715267200693,
 29:                     text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 30:                 },
 31:                 {
 32:                     id: "616b2b4c-a096-4445-9c23-64058b564fc2",
 33:                     version: 0,
 34:                     version_type: "FIXED",
 35:                     version_description: "",
 36:                     name: "Web Search Assistant Prompt",
 37:                     created_on: 1715267200693,
 38:                     modified_on: 1715267200693,
 39:                     text: "<role>You are an AI web search assistant designed to help users find accurate and relevant information on the web. Respond to user queries promptly, using the built-in web search tool to retrieve up-to-date results. Present information clearly and concisely, summarizing key points where necessary. Use simple language and avoid technical jargon. If needed, provide helpful tips for refining search queries to obtain better results.</role>",
 40:                 },
 41:             ],
 42:         };
 43:         server
 44:             .mockEndpoint({ once: false })
 45:             .get("/v0/evi/prompts")
 46:             .respondWith()
 47:             .statusCode(200)
 48:             .jsonBody(rawResponseBody)
 49:             .build();
 50: 
 51:         const expected = {
 52:             pageNumber: 0,
 53:             pageSize: 2,
 54:             totalPages: 1,
 55:             promptsPage: [
 56:                 {
 57:                     id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
 58:                     version: 0,
 59:                     versionType: "FIXED",
 60:                     versionDescription: "",
 61:                     name: "Weather Assistant Prompt",
 62:                     createdOn: 1715267200693,
 63:                     modifiedOn: 1715267200693,
 64:                     text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
 65:                 },
 66:                 {
 67:                     id: "616b2b4c-a096-4445-9c23-64058b564fc2",
 68:                     version: 0,
 69:                     versionType: "FIXED",
 70:                     versionDescription: "",
 71:                     name: "Web Search Assistant Prompt",
 72:                     createdOn: 1715267200693,
 73:                     modifiedOn: 1715267200693,
 74:                     text: "<role>You are an AI web search assistant designed to help users find accurate and relevant information on the web. Respond to user queries promptly, using the built-in web search tool to retrieve up-to-date results. Present information clearly and concisely, summarizing key points where necessary. Use simple language and avoid technical jargon. If needed, provide helpful tips for refining search queries to obtain better results.</role>",
 75:                 },
 76:             ],
 77:         };
 78:         const page = await client.empathicVoice.prompts.listPrompts({
 79:             pageNumber: 0,
 80:             pageSize: 2,
 81:         });
 82: 
 83:         expect(expected.promptsPage).toEqual(page.data);
 84:         expect(page.hasNextPage()).toBe(true);
 85:         const nextPage = await page.getNextPage();
 86:         expect(expected.promptsPage).toEqual(nextPage.data);
 87:     });
 88: 
 89:     test("list-prompts (2)", async () => {
 90:         const server = mockServerPool.createServer();
 91:         const client = new HumeClient({
 92:             maxRetries: 0,
 93:             apiKey: "test",
 94:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 95:         });
 96: 
 97:         const rawResponseBody = {};
 98:         server
 99:             .mockEndpoint({ once: false })
100:             .get("/v0/evi/prompts")
101:             .respondWith()
102:             .statusCode(400)
103:             .jsonBody(rawResponseBody)
104:             .build();
105: 
106:         await expect(async () => {
107:             return await client.empathicVoice.prompts.listPrompts();
108:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
109:     });
110: 
111:     test("create-prompt (1)", async () => {
112:         const server = mockServerPool.createServer();
113:         const client = new HumeClient({
114:             maxRetries: 0,
115:             apiKey: "test",
116:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
117:         });
118:         const rawRequestBody = {
119:             name: "Weather Assistant Prompt",
120:             text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
121:         };
122:         const rawResponseBody = {
123:             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
124:             version: 0,
125:             version_type: "FIXED",
126:             name: "Weather Assistant Prompt",
127:             created_on: 1722633247488,
128:             modified_on: 1722633247488,
129:             text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
130:         };
131:         server
132:             .mockEndpoint()
133:             .post("/v0/evi/prompts")
134:             .jsonBody(rawRequestBody)
135:             .respondWith()
136:             .statusCode(200)
137:             .jsonBody(rawResponseBody)
138:             .build();
139: 
140:         const response = await client.empathicVoice.prompts.createPrompt({
141:             name: "Weather Assistant Prompt",
142:             text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
143:         });
144:         expect(response).toEqual({
145:             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
146:             version: 0,
147:             versionType: "FIXED",
148:             name: "Weather Assistant Prompt",
149:             createdOn: 1722633247488,
150:             modifiedOn: 1722633247488,
151:             text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
152:         });
153:     });
154: 
155:     test("create-prompt (2)", async () => {
156:         const server = mockServerPool.createServer();
157:         const client = new HumeClient({
158:             maxRetries: 0,
159:             apiKey: "test",
160:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
161:         });
162:         const rawRequestBody = { name: "name", text: "text" };
163:         const rawResponseBody = {};
164:         server
165:             .mockEndpoint()
166:             .post("/v0/evi/prompts")
167:             .jsonBody(rawRequestBody)
168:             .respondWith()
169:             .statusCode(400)
170:             .jsonBody(rawResponseBody)
171:             .build();
172: 
173:         await expect(async () => {
174:             return await client.empathicVoice.prompts.createPrompt({
175:                 name: "name",
176:                 text: "text",
177:             });
178:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
179:     });
180: 
181:     test("list-prompt-versions (1)", async () => {
182:         const server = mockServerPool.createServer();
183:         const client = new HumeClient({
184:             maxRetries: 0,
185:             apiKey: "test",
186:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
187:         });
188: 
189:         const rawResponseBody = {
190:             page_number: 0,
191:             page_size: 10,
192:             total_pages: 1,
193:             prompts_page: [
194:                 {
195:                     id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
196:                     version: 0,
197:                     version_type: "FIXED",
198:                     version_description: "",
199:                     name: "Weather Assistant Prompt",
200:                     created_on: 1722633247488,
201:                     modified_on: 1722633247488,
202:                     text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
203:                 },
204:             ],
205:         };
206:         server
207:             .mockEndpoint()
208:             .get("/v0/evi/prompts/af699d45-2985-42cc-91b9-af9e5da3bac5")
209:             .respondWith()
210:             .statusCode(200)
211:             .jsonBody(rawResponseBody)
212:             .build();
213: 
214:         const response = await client.empathicVoice.prompts.listPromptVersions("af699d45-2985-42cc-91b9-af9e5da3bac5");
215:         expect(response).toEqual({
216:             pageNumber: 0,
217:             pageSize: 10,
218:             totalPages: 1,
219:             promptsPage: [
220:                 {
221:                     id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
222:                     version: 0,
223:                     versionType: "FIXED",
224:                     versionDescription: "",
225:                     name: "Weather Assistant Prompt",
226:                     createdOn: 1722633247488,
227:                     modifiedOn: 1722633247488,
228:                     text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
229:                 },
230:             ],
231:         });
232:     });
233: 
234:     test("list-prompt-versions (2)", async () => {
235:         const server = mockServerPool.createServer();
236:         const client = new HumeClient({
237:             maxRetries: 0,
238:             apiKey: "test",
239:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
240:         });
241: 
242:         const rawResponseBody = {};
243:         server.mockEndpoint().get("/v0/evi/prompts/id").respondWith().statusCode(400).jsonBody(rawResponseBody).build();
244: 
245:         await expect(async () => {
246:             return await client.empathicVoice.prompts.listPromptVersions("id");
247:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
248:     });
249: 
250:     test("create-prompt-version (1)", async () => {
251:         const server = mockServerPool.createServer();
252:         const client = new HumeClient({
253:             maxRetries: 0,
254:             apiKey: "test",
255:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
256:         });
257:         const rawRequestBody = {
258:             text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
259:             version_description: "This is an updated version of the Weather Assistant Prompt.",
260:         };
261:         const rawResponseBody = {
262:             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
263:             version: 1,
264:             version_type: "FIXED",
265:             version_description: "This is an updated version of the Weather Assistant Prompt.",
266:             name: "Weather Assistant Prompt",
267:             created_on: 1722633247488,
268:             modified_on: 1722635140150,
269:             text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
270:         };
271:         server
272:             .mockEndpoint()
273:             .post("/v0/evi/prompts/af699d45-2985-42cc-91b9-af9e5da3bac5")
274:             .jsonBody(rawRequestBody)
275:             .respondWith()
276:             .statusCode(200)
277:             .jsonBody(rawResponseBody)
278:             .build();
279: 
280:         const response = await client.empathicVoice.prompts.createPromptVersion(
281:             "af699d45-2985-42cc-91b9-af9e5da3bac5",
282:             {
283:                 text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
284:                 versionDescription: "This is an updated version of the Weather Assistant Prompt.",
285:             },
286:         );
287:         expect(response).toEqual({
288:             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
289:             version: 1,
290:             versionType: "FIXED",
291:             versionDescription: "This is an updated version of the Weather Assistant Prompt.",
292:             name: "Weather Assistant Prompt",
293:             createdOn: 1722633247488,
294:             modifiedOn: 1722635140150,
295:             text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
296:         });
297:     });
298: 
299:     test("create-prompt-version (2)", async () => {
300:         const server = mockServerPool.createServer();
301:         const client = new HumeClient({
302:             maxRetries: 0,
303:             apiKey: "test",
304:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
305:         });
306:         const rawRequestBody = { text: "text" };
307:         const rawResponseBody = {};
308:         server
309:             .mockEndpoint()
310:             .post("/v0/evi/prompts/id")
311:             .jsonBody(rawRequestBody)
312:             .respondWith()
313:             .statusCode(400)
314:             .jsonBody(rawResponseBody)
315:             .build();
316: 
317:         await expect(async () => {
318:             return await client.empathicVoice.prompts.createPromptVersion("id", {
319:                 text: "text",
320:             });
321:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
322:     });
323: 
324:     test("delete-prompt (1)", async () => {
325:         const server = mockServerPool.createServer();
326:         const client = new HumeClient({
327:             maxRetries: 0,
328:             apiKey: "test",
329:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
330:         });
331: 
332:         server
333:             .mockEndpoint()
334:             .delete("/v0/evi/prompts/af699d45-2985-42cc-91b9-af9e5da3bac5")
335:             .respondWith()
336:             .statusCode(200)
337:             .build();
338: 
339:         const response = await client.empathicVoice.prompts.deletePrompt("af699d45-2985-42cc-91b9-af9e5da3bac5");
340:         expect(response).toEqual(undefined);
341:     });
342: 
343:     test("delete-prompt (2)", async () => {
344:         const server = mockServerPool.createServer();
345:         const client = new HumeClient({
346:             maxRetries: 0,
347:             apiKey: "test",
348:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
349:         });
350: 
351:         const rawResponseBody = {};
352:         server
353:             .mockEndpoint()
354:             .delete("/v0/evi/prompts/id")
355:             .respondWith()
356:             .statusCode(400)
357:             .jsonBody(rawResponseBody)
358:             .build();
359: 
360:         await expect(async () => {
361:             return await client.empathicVoice.prompts.deletePrompt("id");
362:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
363:     });
364: 
365:     test("get-prompt-version (1)", async () => {
366:         const server = mockServerPool.createServer();
367:         const client = new HumeClient({
368:             maxRetries: 0,
369:             apiKey: "test",
370:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
371:         });
372: 
373:         const rawResponseBody = {
374:             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
375:             version: 0,
376:             version_type: "FIXED",
377:             version_description: "",
378:             name: "Weather Assistant Prompt",
379:             created_on: 1722633247488,
380:             modified_on: 1722633247488,
381:             text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
382:         };
383:         server
384:             .mockEndpoint()
385:             .get("/v0/evi/prompts/af699d45-2985-42cc-91b9-af9e5da3bac5/version/0")
386:             .respondWith()
387:             .statusCode(200)
388:             .jsonBody(rawResponseBody)
389:             .build();
390: 
391:         const response = await client.empathicVoice.prompts.getPromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", 0);
392:         expect(response).toEqual({
393:             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
394:             version: 0,
395:             versionType: "FIXED",
396:             versionDescription: "",
397:             name: "Weather Assistant Prompt",
398:             createdOn: 1722633247488,
399:             modifiedOn: 1722633247488,
400:             text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
401:         });
402:     });
403: 
404:     test("get-prompt-version (2)", async () => {
405:         const server = mockServerPool.createServer();
406:         const client = new HumeClient({
407:             maxRetries: 0,
408:             apiKey: "test",
409:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
410:         });
411: 
412:         const rawResponseBody = {};
413:         server
414:             .mockEndpoint()
415:             .get("/v0/evi/prompts/id/version/1")
416:             .respondWith()
417:             .statusCode(400)
418:             .jsonBody(rawResponseBody)
419:             .build();
420: 
421:         await expect(async () => {
422:             return await client.empathicVoice.prompts.getPromptVersion("id", 1);
423:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
424:     });
425: 
426:     test("delete-prompt-version (1)", async () => {
427:         const server = mockServerPool.createServer();
428:         const client = new HumeClient({
429:             maxRetries: 0,
430:             apiKey: "test",
431:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
432:         });
433: 
434:         server
435:             .mockEndpoint()
436:             .delete("/v0/evi/prompts/af699d45-2985-42cc-91b9-af9e5da3bac5/version/1")
437:             .respondWith()
438:             .statusCode(200)
439:             .build();
440: 
441:         const response = await client.empathicVoice.prompts.deletePromptVersion(
442:             "af699d45-2985-42cc-91b9-af9e5da3bac5",
443:             1,
444:         );
445:         expect(response).toEqual(undefined);
446:     });
447: 
448:     test("delete-prompt-version (2)", async () => {
449:         const server = mockServerPool.createServer();
450:         const client = new HumeClient({
451:             maxRetries: 0,
452:             apiKey: "test",
453:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
454:         });
455: 
456:         const rawResponseBody = {};
457:         server
458:             .mockEndpoint()
459:             .delete("/v0/evi/prompts/id/version/1")
460:             .respondWith()
461:             .statusCode(400)
462:             .jsonBody(rawResponseBody)
463:             .build();
464: 
465:         await expect(async () => {
466:             return await client.empathicVoice.prompts.deletePromptVersion("id", 1);
467:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
468:     });
469: 
470:     test("update-prompt-description (1)", async () => {
471:         const server = mockServerPool.createServer();
472:         const client = new HumeClient({
473:             maxRetries: 0,
474:             apiKey: "test",
475:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
476:         });
477:         const rawRequestBody = { version_description: "This is an updated version_description." };
478:         const rawResponseBody = {
479:             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
480:             version: 1,
481:             version_type: "FIXED",
482:             version_description: "This is an updated version_description.",
483:             name: "string",
484:             created_on: 1722633247488,
485:             modified_on: 1722634770585,
486:             text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
487:         };
488:         server
489:             .mockEndpoint()
490:             .patch("/v0/evi/prompts/af699d45-2985-42cc-91b9-af9e5da3bac5/version/1")
491:             .jsonBody(rawRequestBody)
492:             .respondWith()
493:             .statusCode(200)
494:             .jsonBody(rawResponseBody)
495:             .build();
496: 
497:         const response = await client.empathicVoice.prompts.updatePromptDescription(
498:             "af699d45-2985-42cc-91b9-af9e5da3bac5",
499:             1,
500:             {
501:                 versionDescription: "This is an updated version_description.",
502:             },
503:         );
504:         expect(response).toEqual({
505:             id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
506:             version: 1,
507:             versionType: "FIXED",
508:             versionDescription: "This is an updated version_description.",
509:             name: "string",
510:             createdOn: 1722633247488,
511:             modifiedOn: 1722634770585,
512:             text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
513:         });
514:     });
515: 
516:     test("update-prompt-description (2)", async () => {
517:         const server = mockServerPool.createServer();
518:         const client = new HumeClient({
519:             maxRetries: 0,
520:             apiKey: "test",
521:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
522:         });
523:         const rawRequestBody = {};
524:         const rawResponseBody = {};
525:         server
526:             .mockEndpoint()
527:             .patch("/v0/evi/prompts/id/version/1")
528:             .jsonBody(rawRequestBody)
529:             .respondWith()
530:             .statusCode(400)
531:             .jsonBody(rawResponseBody)
532:             .build();
533: 
534:         await expect(async () => {
535:             return await client.empathicVoice.prompts.updatePromptDescription("id", 1);
536:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
537:     });
538: });
````

## File: tests/wire/empathic-voice/tools.test.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import * as Hume from "../../../src/api/index";
  4: import { HumeClient } from "../../../src/Client";
  5: import { mockServerPool } from "../../mock-server/MockServerPool";
  6: 
  7: describe("ToolsClient", () => {
  8:     test("list-tools (1)", async () => {
  9:         const server = mockServerPool.createServer();
 10:         const client = new HumeClient({
 11:             maxRetries: 0,
 12:             apiKey: "test",
 13:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 14:         });
 15: 
 16:         const rawResponseBody = {
 17:             page_number: 0,
 18:             page_size: 2,
 19:             total_pages: 1,
 20:             tools_page: [
 21:                 {
 22:                     tool_type: "FUNCTION",
 23:                     id: "d20827af-5d8d-4f66-b6b9-ce2e3e1ea2b2",
 24:                     version: 0,
 25:                     version_type: "FIXED",
 26:                     version_description: "Fetches user's current location.",
 27:                     name: "get_current_location",
 28:                     created_on: 1715267200693,
 29:                     modified_on: 1715267200693,
 30:                     fallback_content: "Unable to fetch location.",
 31:                     description: "Fetches user's current location.",
 32:                     parameters:
 33:                         '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }}, "required": ["location"] }',
 34:                 },
 35:                 {
 36:                     tool_type: "FUNCTION",
 37:                     id: "4442f3ea-9038-40e3-a2ce-1522b7de770f",
 38:                     version: 0,
 39:                     version_type: "FIXED",
 40:                     version_description:
 41:                         "Fetches current weather and uses celsius or fahrenheit based on location of user.",
 42:                     name: "get_current_weather",
 43:                     created_on: 1715266126705,
 44:                     modified_on: 1715266126705,
 45:                     fallback_content: "Unable to fetch location.",
 46:                     description: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
 47:                     parameters:
 48:                         '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
 49:                 },
 50:             ],
 51:         };
 52:         server
 53:             .mockEndpoint({ once: false })
 54:             .get("/v0/evi/tools")
 55:             .respondWith()
 56:             .statusCode(200)
 57:             .jsonBody(rawResponseBody)
 58:             .build();
 59: 
 60:         const expected = {
 61:             pageNumber: 0,
 62:             pageSize: 2,
 63:             totalPages: 1,
 64:             toolsPage: [
 65:                 {
 66:                     toolType: "FUNCTION",
 67:                     id: "d20827af-5d8d-4f66-b6b9-ce2e3e1ea2b2",
 68:                     version: 0,
 69:                     versionType: "FIXED",
 70:                     versionDescription: "Fetches user's current location.",
 71:                     name: "get_current_location",
 72:                     createdOn: 1715267200693,
 73:                     modifiedOn: 1715267200693,
 74:                     fallbackContent: "Unable to fetch location.",
 75:                     description: "Fetches user's current location.",
 76:                     parameters:
 77:                         '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }}, "required": ["location"] }',
 78:                 },
 79:                 {
 80:                     toolType: "FUNCTION",
 81:                     id: "4442f3ea-9038-40e3-a2ce-1522b7de770f",
 82:                     version: 0,
 83:                     versionType: "FIXED",
 84:                     versionDescription:
 85:                         "Fetches current weather and uses celsius or fahrenheit based on location of user.",
 86:                     name: "get_current_weather",
 87:                     createdOn: 1715266126705,
 88:                     modifiedOn: 1715266126705,
 89:                     fallbackContent: "Unable to fetch location.",
 90:                     description: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
 91:                     parameters:
 92:                         '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
 93:                 },
 94:             ],
 95:         };
 96:         const page = await client.empathicVoice.tools.listTools({
 97:             pageNumber: 0,
 98:             pageSize: 2,
 99:         });
100: 
101:         expect(expected.toolsPage).toEqual(page.data);
102:         expect(page.hasNextPage()).toBe(true);
103:         const nextPage = await page.getNextPage();
104:         expect(expected.toolsPage).toEqual(nextPage.data);
105:     });
106: 
107:     test("list-tools (2)", async () => {
108:         const server = mockServerPool.createServer();
109:         const client = new HumeClient({
110:             maxRetries: 0,
111:             apiKey: "test",
112:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
113:         });
114: 
115:         const rawResponseBody = {};
116:         server
117:             .mockEndpoint({ once: false })
118:             .get("/v0/evi/tools")
119:             .respondWith()
120:             .statusCode(400)
121:             .jsonBody(rawResponseBody)
122:             .build();
123: 
124:         await expect(async () => {
125:             return await client.empathicVoice.tools.listTools();
126:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
127:     });
128: 
129:     test("create-tool (1)", async () => {
130:         const server = mockServerPool.createServer();
131:         const client = new HumeClient({
132:             maxRetries: 0,
133:             apiKey: "test",
134:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
135:         });
136:         const rawRequestBody = {
137:             name: "get_current_weather",
138:             parameters:
139:                 '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
140:             version_description: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
141:             description: "This tool is for getting the current weather.",
142:             fallback_content: "Unable to fetch current weather.",
143:         };
144:         const rawResponseBody = {
145:             tool_type: "FUNCTION",
146:             id: "aa9b71c4-723c-47ff-9f83-1a1829e74376",
147:             version: 0,
148:             version_type: "FIXED",
149:             version_description: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
150:             name: "get_current_weather",
151:             created_on: 1715275452390,
152:             modified_on: 1715275452390,
153:             fallback_content: "Unable to fetch current weather.",
154:             description: "This tool is for getting the current weather.",
155:             parameters:
156:                 '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
157:         };
158:         server
159:             .mockEndpoint()
160:             .post("/v0/evi/tools")
161:             .jsonBody(rawRequestBody)
162:             .respondWith()
163:             .statusCode(200)
164:             .jsonBody(rawResponseBody)
165:             .build();
166: 
167:         const response = await client.empathicVoice.tools.createTool({
168:             name: "get_current_weather",
169:             parameters:
170:                 '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
171:             versionDescription: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
172:             description: "This tool is for getting the current weather.",
173:             fallbackContent: "Unable to fetch current weather.",
174:         });
175:         expect(response).toEqual({
176:             toolType: "FUNCTION",
177:             id: "aa9b71c4-723c-47ff-9f83-1a1829e74376",
178:             version: 0,
179:             versionType: "FIXED",
180:             versionDescription: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
181:             name: "get_current_weather",
182:             createdOn: 1715275452390,
183:             modifiedOn: 1715275452390,
184:             fallbackContent: "Unable to fetch current weather.",
185:             description: "This tool is for getting the current weather.",
186:             parameters:
187:                 '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
188:         });
189:     });
190: 
191:     test("create-tool (2)", async () => {
192:         const server = mockServerPool.createServer();
193:         const client = new HumeClient({
194:             maxRetries: 0,
195:             apiKey: "test",
196:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
197:         });
198:         const rawRequestBody = { name: "name", parameters: "parameters" };
199:         const rawResponseBody = {};
200:         server
201:             .mockEndpoint()
202:             .post("/v0/evi/tools")
203:             .jsonBody(rawRequestBody)
204:             .respondWith()
205:             .statusCode(400)
206:             .jsonBody(rawResponseBody)
207:             .build();
208: 
209:         await expect(async () => {
210:             return await client.empathicVoice.tools.createTool({
211:                 name: "name",
212:                 parameters: "parameters",
213:             });
214:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
215:     });
216: 
217:     test("list-tool-versions (1)", async () => {
218:         const server = mockServerPool.createServer();
219:         const client = new HumeClient({
220:             maxRetries: 0,
221:             apiKey: "test",
222:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
223:         });
224: 
225:         const rawResponseBody = {
226:             page_number: 0,
227:             page_size: 10,
228:             total_pages: 1,
229:             tools_page: [
230:                 {
231:                     tool_type: "FUNCTION",
232:                     id: "00183a3f-79ba-413d-9f3b-609864268bea",
233:                     version: 1,
234:                     version_type: "FIXED",
235:                     version_description:
236:                         "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
237:                     name: "get_current_weather",
238:                     created_on: 1715277014228,
239:                     modified_on: 1715277602313,
240:                     fallback_content: "Unable to fetch current weather.",
241:                     description: "This tool is for getting the current weather.",
242:                     parameters:
243:                         '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
244:                 },
245:             ],
246:         };
247:         server
248:             .mockEndpoint({ once: false })
249:             .get("/v0/evi/tools/00183a3f-79ba-413d-9f3b-609864268bea")
250:             .respondWith()
251:             .statusCode(200)
252:             .jsonBody(rawResponseBody)
253:             .build();
254: 
255:         const expected = {
256:             pageNumber: 0,
257:             pageSize: 10,
258:             totalPages: 1,
259:             toolsPage: [
260:                 {
261:                     toolType: "FUNCTION",
262:                     id: "00183a3f-79ba-413d-9f3b-609864268bea",
263:                     version: 1,
264:                     versionType: "FIXED",
265:                     versionDescription:
266:                         "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
267:                     name: "get_current_weather",
268:                     createdOn: 1715277014228,
269:                     modifiedOn: 1715277602313,
270:                     fallbackContent: "Unable to fetch current weather.",
271:                     description: "This tool is for getting the current weather.",
272:                     parameters:
273:                         '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
274:                 },
275:             ],
276:         };
277:         const page = await client.empathicVoice.tools.listToolVersions("00183a3f-79ba-413d-9f3b-609864268bea");
278: 
279:         expect(expected.toolsPage).toEqual(page.data);
280:         expect(page.hasNextPage()).toBe(true);
281:         const nextPage = await page.getNextPage();
282:         expect(expected.toolsPage).toEqual(nextPage.data);
283:     });
284: 
285:     test("list-tool-versions (2)", async () => {
286:         const server = mockServerPool.createServer();
287:         const client = new HumeClient({
288:             maxRetries: 0,
289:             apiKey: "test",
290:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
291:         });
292: 
293:         const rawResponseBody = {};
294:         server
295:             .mockEndpoint({ once: false })
296:             .get("/v0/evi/tools/id")
297:             .respondWith()
298:             .statusCode(400)
299:             .jsonBody(rawResponseBody)
300:             .build();
301: 
302:         await expect(async () => {
303:             return await client.empathicVoice.tools.listToolVersions("id");
304:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
305:     });
306: 
307:     test("create-tool-version (1)", async () => {
308:         const server = mockServerPool.createServer();
309:         const client = new HumeClient({
310:             maxRetries: 0,
311:             apiKey: "test",
312:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
313:         });
314:         const rawRequestBody = {
315:             parameters:
316:                 '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
317:             version_description:
318:                 "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
319:             fallback_content: "Unable to fetch current weather.",
320:             description: "This tool is for getting the current weather.",
321:         };
322:         const rawResponseBody = {
323:             tool_type: "FUNCTION",
324:             id: "00183a3f-79ba-413d-9f3b-609864268bea",
325:             version: 1,
326:             version_type: "FIXED",
327:             version_description:
328:                 "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
329:             name: "get_current_weather",
330:             created_on: 1715277014228,
331:             modified_on: 1715277602313,
332:             fallback_content: "Unable to fetch current weather.",
333:             description: "This tool is for getting the current weather.",
334:             parameters:
335:                 '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
336:         };
337:         server
338:             .mockEndpoint()
339:             .post("/v0/evi/tools/00183a3f-79ba-413d-9f3b-609864268bea")
340:             .jsonBody(rawRequestBody)
341:             .respondWith()
342:             .statusCode(200)
343:             .jsonBody(rawResponseBody)
344:             .build();
345: 
346:         const response = await client.empathicVoice.tools.createToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", {
347:             parameters:
348:                 '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
349:             versionDescription:
350:                 "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
351:             fallbackContent: "Unable to fetch current weather.",
352:             description: "This tool is for getting the current weather.",
353:         });
354:         expect(response).toEqual({
355:             toolType: "FUNCTION",
356:             id: "00183a3f-79ba-413d-9f3b-609864268bea",
357:             version: 1,
358:             versionType: "FIXED",
359:             versionDescription:
360:                 "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
361:             name: "get_current_weather",
362:             createdOn: 1715277014228,
363:             modifiedOn: 1715277602313,
364:             fallbackContent: "Unable to fetch current weather.",
365:             description: "This tool is for getting the current weather.",
366:             parameters:
367:                 '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
368:         });
369:     });
370: 
371:     test("create-tool-version (2)", async () => {
372:         const server = mockServerPool.createServer();
373:         const client = new HumeClient({
374:             maxRetries: 0,
375:             apiKey: "test",
376:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
377:         });
378:         const rawRequestBody = { parameters: "parameters" };
379:         const rawResponseBody = {};
380:         server
381:             .mockEndpoint()
382:             .post("/v0/evi/tools/id")
383:             .jsonBody(rawRequestBody)
384:             .respondWith()
385:             .statusCode(400)
386:             .jsonBody(rawResponseBody)
387:             .build();
388: 
389:         await expect(async () => {
390:             return await client.empathicVoice.tools.createToolVersion("id", {
391:                 parameters: "parameters",
392:             });
393:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
394:     });
395: 
396:     test("delete-tool (1)", async () => {
397:         const server = mockServerPool.createServer();
398:         const client = new HumeClient({
399:             maxRetries: 0,
400:             apiKey: "test",
401:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
402:         });
403: 
404:         server
405:             .mockEndpoint()
406:             .delete("/v0/evi/tools/00183a3f-79ba-413d-9f3b-609864268bea")
407:             .respondWith()
408:             .statusCode(200)
409:             .build();
410: 
411:         const response = await client.empathicVoice.tools.deleteTool("00183a3f-79ba-413d-9f3b-609864268bea");
412:         expect(response).toEqual(undefined);
413:     });
414: 
415:     test("delete-tool (2)", async () => {
416:         const server = mockServerPool.createServer();
417:         const client = new HumeClient({
418:             maxRetries: 0,
419:             apiKey: "test",
420:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
421:         });
422: 
423:         const rawResponseBody = {};
424:         server
425:             .mockEndpoint()
426:             .delete("/v0/evi/tools/id")
427:             .respondWith()
428:             .statusCode(400)
429:             .jsonBody(rawResponseBody)
430:             .build();
431: 
432:         await expect(async () => {
433:             return await client.empathicVoice.tools.deleteTool("id");
434:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
435:     });
436: 
437:     test("get-tool-version (1)", async () => {
438:         const server = mockServerPool.createServer();
439:         const client = new HumeClient({
440:             maxRetries: 0,
441:             apiKey: "test",
442:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
443:         });
444: 
445:         const rawResponseBody = {
446:             tool_type: "FUNCTION",
447:             id: "00183a3f-79ba-413d-9f3b-609864268bea",
448:             version: 1,
449:             version_type: "FIXED",
450:             version_description:
451:                 "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
452:             name: "string",
453:             created_on: 1715277014228,
454:             modified_on: 1715277602313,
455:             fallback_content: "Unable to fetch current weather.",
456:             description: "This tool is for getting the current weather.",
457:             parameters:
458:                 '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
459:         };
460:         server
461:             .mockEndpoint()
462:             .get("/v0/evi/tools/00183a3f-79ba-413d-9f3b-609864268bea/version/1")
463:             .respondWith()
464:             .statusCode(200)
465:             .jsonBody(rawResponseBody)
466:             .build();
467: 
468:         const response = await client.empathicVoice.tools.getToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1);
469:         expect(response).toEqual({
470:             toolType: "FUNCTION",
471:             id: "00183a3f-79ba-413d-9f3b-609864268bea",
472:             version: 1,
473:             versionType: "FIXED",
474:             versionDescription:
475:                 "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
476:             name: "string",
477:             createdOn: 1715277014228,
478:             modifiedOn: 1715277602313,
479:             fallbackContent: "Unable to fetch current weather.",
480:             description: "This tool is for getting the current weather.",
481:             parameters:
482:                 '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
483:         });
484:     });
485: 
486:     test("get-tool-version (2)", async () => {
487:         const server = mockServerPool.createServer();
488:         const client = new HumeClient({
489:             maxRetries: 0,
490:             apiKey: "test",
491:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
492:         });
493: 
494:         const rawResponseBody = {};
495:         server
496:             .mockEndpoint()
497:             .get("/v0/evi/tools/id/version/1")
498:             .respondWith()
499:             .statusCode(400)
500:             .jsonBody(rawResponseBody)
501:             .build();
502: 
503:         await expect(async () => {
504:             return await client.empathicVoice.tools.getToolVersion("id", 1);
505:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
506:     });
507: 
508:     test("delete-tool-version (1)", async () => {
509:         const server = mockServerPool.createServer();
510:         const client = new HumeClient({
511:             maxRetries: 0,
512:             apiKey: "test",
513:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
514:         });
515: 
516:         server
517:             .mockEndpoint()
518:             .delete("/v0/evi/tools/00183a3f-79ba-413d-9f3b-609864268bea/version/1")
519:             .respondWith()
520:             .statusCode(200)
521:             .build();
522: 
523:         const response = await client.empathicVoice.tools.deleteToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1);
524:         expect(response).toEqual(undefined);
525:     });
526: 
527:     test("delete-tool-version (2)", async () => {
528:         const server = mockServerPool.createServer();
529:         const client = new HumeClient({
530:             maxRetries: 0,
531:             apiKey: "test",
532:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
533:         });
534: 
535:         const rawResponseBody = {};
536:         server
537:             .mockEndpoint()
538:             .delete("/v0/evi/tools/id/version/1")
539:             .respondWith()
540:             .statusCode(400)
541:             .jsonBody(rawResponseBody)
542:             .build();
543: 
544:         await expect(async () => {
545:             return await client.empathicVoice.tools.deleteToolVersion("id", 1);
546:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
547:     });
548: 
549:     test("update-tool-description (1)", async () => {
550:         const server = mockServerPool.createServer();
551:         const client = new HumeClient({
552:             maxRetries: 0,
553:             apiKey: "test",
554:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
555:         });
556:         const rawRequestBody = {
557:             version_description:
558:                 "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region.",
559:         };
560:         const rawResponseBody = {
561:             tool_type: "FUNCTION",
562:             id: "00183a3f-79ba-413d-9f3b-609864268bea",
563:             version: 1,
564:             version_type: "FIXED",
565:             version_description:
566:                 "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region.",
567:             name: "string",
568:             created_on: 1715277014228,
569:             modified_on: 1715277602313,
570:             fallback_content: "Unable to fetch current weather.",
571:             description: "This tool is for getting the current weather.",
572:             parameters:
573:                 '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
574:         };
575:         server
576:             .mockEndpoint()
577:             .patch("/v0/evi/tools/00183a3f-79ba-413d-9f3b-609864268bea/version/1")
578:             .jsonBody(rawRequestBody)
579:             .respondWith()
580:             .statusCode(200)
581:             .jsonBody(rawResponseBody)
582:             .build();
583: 
584:         const response = await client.empathicVoice.tools.updateToolDescription(
585:             "00183a3f-79ba-413d-9f3b-609864268bea",
586:             1,
587:             {
588:                 versionDescription:
589:                     "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region.",
590:             },
591:         );
592:         expect(response).toEqual({
593:             toolType: "FUNCTION",
594:             id: "00183a3f-79ba-413d-9f3b-609864268bea",
595:             version: 1,
596:             versionType: "FIXED",
597:             versionDescription:
598:                 "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region.",
599:             name: "string",
600:             createdOn: 1715277014228,
601:             modifiedOn: 1715277602313,
602:             fallbackContent: "Unable to fetch current weather.",
603:             description: "This tool is for getting the current weather.",
604:             parameters:
605:                 '{ "type": "object", "properties": { "location": { "type": "string", "description": "The city and state, e.g. San Francisco, CA" }, "format": { "type": "string", "enum": ["celsius", "fahrenheit", "kelvin"], "description": "The temperature unit to use. Infer this from the users location." } }, "required": ["location", "format"] }',
606:         });
607:     });
608: 
609:     test("update-tool-description (2)", async () => {
610:         const server = mockServerPool.createServer();
611:         const client = new HumeClient({
612:             maxRetries: 0,
613:             apiKey: "test",
614:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
615:         });
616:         const rawRequestBody = {};
617:         const rawResponseBody = {};
618:         server
619:             .mockEndpoint()
620:             .patch("/v0/evi/tools/id/version/1")
621:             .jsonBody(rawRequestBody)
622:             .respondWith()
623:             .statusCode(400)
624:             .jsonBody(rawResponseBody)
625:             .build();
626: 
627:         await expect(async () => {
628:             return await client.empathicVoice.tools.updateToolDescription("id", 1);
629:         }).rejects.toThrow(Hume.empathicVoice.BadRequestError);
630:     });
631: });
````

## File: tests/wire/expression-measurement/batch/main.test.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import { HumeClient } from "../../../../src/Client";
  4: import { mockServerPool } from "../../../mock-server/MockServerPool";
  5: 
  6: describe("BatchClient", () => {
  7:     test("list-jobs", async () => {
  8:         const server = mockServerPool.createServer();
  9:         const client = new HumeClient({
 10:             maxRetries: 0,
 11:             apiKey: "test",
 12:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 13:         });
 14: 
 15:         const rawResponseBody = [
 16:             {
 17:                 job_id: "job_id",
 18:                 request: {
 19:                     files: [{ filename: "filename", md5sum: "md5sum", content_type: "content_type" }],
 20:                     models: {
 21:                         burst: {},
 22:                         face: {
 23:                             fps_pred: 3,
 24:                             identify_faces: false,
 25:                             min_face_size: 60,
 26:                             prob_threshold: 0.99,
 27:                             save_faces: false,
 28:                         },
 29:                         facemesh: {},
 30:                         language: { granularity: "word", identify_speakers: false },
 31:                         ner: { identify_speakers: false },
 32:                         prosody: { granularity: "utterance", identify_speakers: false },
 33:                     },
 34:                     notify: true,
 35:                     text: [],
 36:                     urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
 37:                 },
 38:                 state: {
 39:                     status: "COMPLETED",
 40:                     created_timestamp_ms: 1712587158717,
 41:                     ended_timestamp_ms: 1712587159274,
 42:                     num_errors: 0,
 43:                     num_predictions: 10,
 44:                     started_timestamp_ms: 1712587158800,
 45:                 },
 46:                 type: "INFERENCE",
 47:             },
 48:         ];
 49:         server.mockEndpoint().get("/v0/batch/jobs").respondWith().statusCode(200).jsonBody(rawResponseBody).build();
 50: 
 51:         const response = await client.expressionMeasurement.batch.listJobs();
 52:         expect(response).toEqual([
 53:             {
 54:                 jobId: "job_id",
 55:                 request: {
 56:                     files: [
 57:                         {
 58:                             filename: "filename",
 59:                             md5Sum: "md5sum",
 60:                             contentType: "content_type",
 61:                         },
 62:                     ],
 63:                     models: {
 64:                         burst: {},
 65:                         face: {
 66:                             fpsPred: 3,
 67:                             identifyFaces: false,
 68:                             minFaceSize: 60,
 69:                             probThreshold: 0.99,
 70:                             saveFaces: false,
 71:                         },
 72:                         facemesh: {},
 73:                         language: {
 74:                             granularity: "word",
 75:                             identifySpeakers: false,
 76:                         },
 77:                         ner: {
 78:                             identifySpeakers: false,
 79:                         },
 80:                         prosody: {
 81:                             granularity: "utterance",
 82:                             identifySpeakers: false,
 83:                         },
 84:                     },
 85:                     notify: true,
 86:                     text: [],
 87:                     urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
 88:                 },
 89:                 state: {
 90:                     status: "COMPLETED",
 91:                     createdTimestampMs: 1712587158717,
 92:                     endedTimestampMs: 1712587159274,
 93:                     numErrors: 0,
 94:                     numPredictions: 10,
 95:                     startedTimestampMs: 1712587158800,
 96:                 },
 97:                 type: "INFERENCE",
 98:             },
 99:         ]);
100:     });
101: 
102:     test("start-inference-job", async () => {
103:         const server = mockServerPool.createServer();
104:         const client = new HumeClient({
105:             maxRetries: 0,
106:             apiKey: "test",
107:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
108:         });
109:         const rawRequestBody = { urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"], notify: true };
110:         const rawResponseBody = { job_id: "job_id" };
111:         server
112:             .mockEndpoint()
113:             .post("/v0/batch/jobs")
114:             .jsonBody(rawRequestBody)
115:             .respondWith()
116:             .statusCode(200)
117:             .jsonBody(rawResponseBody)
118:             .build();
119: 
120:         const response = await client.expressionMeasurement.batch.startInferenceJob({
121:             urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
122:             notify: true,
123:         });
124:         expect(response).toEqual({
125:             jobId: "job_id",
126:         });
127:     });
128: 
129:     test("get-job-details", async () => {
130:         const server = mockServerPool.createServer();
131:         const client = new HumeClient({
132:             maxRetries: 0,
133:             apiKey: "test",
134:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
135:         });
136: 
137:         const rawResponseBody = {
138:             type: "INFERENCE",
139:             job_id: "job_id",
140:             request: {
141:                 files: [],
142:                 models: {
143:                     burst: {},
144:                     face: {
145:                         fps_pred: 3,
146:                         identify_faces: false,
147:                         min_face_size: 60,
148:                         prob_threshold: 0.99,
149:                         save_faces: false,
150:                     },
151:                     facemesh: {},
152:                     language: { granularity: "word", identify_speakers: false },
153:                     ner: { identify_speakers: false },
154:                     prosody: { granularity: "utterance", identify_speakers: false },
155:                 },
156:                 notify: true,
157:                 text: [],
158:                 urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
159:             },
160:             state: {
161:                 status: "COMPLETED",
162:                 created_timestamp_ms: 1712590457884,
163:                 ended_timestamp_ms: 1712590462252,
164:                 num_errors: 0,
165:                 num_predictions: 10,
166:                 started_timestamp_ms: 1712590457995,
167:             },
168:         };
169:         server
170:             .mockEndpoint()
171:             .get("/v0/batch/jobs/job_id")
172:             .respondWith()
173:             .statusCode(200)
174:             .jsonBody(rawResponseBody)
175:             .build();
176: 
177:         const response = await client.expressionMeasurement.batch.getJobDetails("job_id");
178:         expect(response).toEqual({
179:             type: "INFERENCE",
180:             jobId: "job_id",
181:             request: {
182:                 files: [],
183:                 models: {
184:                     burst: {},
185:                     face: {
186:                         fpsPred: 3,
187:                         identifyFaces: false,
188:                         minFaceSize: 60,
189:                         probThreshold: 0.99,
190:                         saveFaces: false,
191:                     },
192:                     facemesh: {},
193:                     language: {
194:                         granularity: "word",
195:                         identifySpeakers: false,
196:                     },
197:                     ner: {
198:                         identifySpeakers: false,
199:                     },
200:                     prosody: {
201:                         granularity: "utterance",
202:                         identifySpeakers: false,
203:                     },
204:                 },
205:                 notify: true,
206:                 text: [],
207:                 urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
208:             },
209:             state: {
210:                 status: "COMPLETED",
211:                 createdTimestampMs: 1712590457884,
212:                 endedTimestampMs: 1712590462252,
213:                 numErrors: 0,
214:                 numPredictions: 10,
215:                 startedTimestampMs: 1712590457995,
216:             },
217:         });
218:     });
219: 
220:     test("get-job-predictions", async () => {
221:         const server = mockServerPool.createServer();
222:         const client = new HumeClient({
223:             maxRetries: 0,
224:             apiKey: "test",
225:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
226:         });
227: 
228:         const rawResponseBody = [
229:             {
230:                 source: { type: "url", url: "https://hume-tutorials.s3.amazonaws.com/faces.zip" },
231:                 results: {
232:                     predictions: [
233:                         {
234:                             file: "faces/100.jpg",
235:                             models: {
236:                                 face: {
237:                                     grouped_predictions: [
238:                                         {
239:                                             id: "unknown",
240:                                             predictions: [
241:                                                 {
242:                                                     frame: 0,
243:                                                     time: 0,
244:                                                     prob: 0.9994111061096191,
245:                                                     box: {
246:                                                         x: 1187.885986328125,
247:                                                         y: 1397.697509765625,
248:                                                         w: 1401.668701171875,
249:                                                         h: 1961.424560546875,
250:                                                     },
251:                                                     emotions: [
252:                                                         { name: "Admiration", score: 0.10722749680280685 },
253:                                                         { name: "Adoration", score: 0.06395940482616425 },
254:                                                         { name: "Aesthetic Appreciation", score: 0.05811462551355362 },
255:                                                         { name: "Amusement", score: 0.14187128841876984 },
256:                                                         { name: "Anger", score: 0.02804684266448021 },
257:                                                         { name: "Anxiety", score: 0.2713485360145569 },
258:                                                         { name: "Awe", score: 0.33812594413757324 },
259:                                                         { name: "Awkwardness", score: 0.1745193600654602 },
260:                                                         { name: "Boredom", score: 0.23600080609321594 },
261:                                                         { name: "Calmness", score: 0.18988418579101562 },
262:                                                         { name: "Concentration", score: 0.44288986921310425 },
263:                                                         { name: "Confusion", score: 0.39346569776535034 },
264:                                                         { name: "Contemplation", score: 0.31002455949783325 },
265:                                                         { name: "Contempt", score: 0.048870109021663666 },
266:                                                         { name: "Contentment", score: 0.0579497292637825 },
267:                                                         { name: "Craving", score: 0.06544201076030731 },
268:                                                         { name: "Desire", score: 0.05526508390903473 },
269:                                                         { name: "Determination", score: 0.08590991795063019 },
270:                                                         { name: "Disappointment", score: 0.19508258998394012 },
271:                                                         { name: "Disgust", score: 0.031529419124126434 },
272:                                                         { name: "Distress", score: 0.23210826516151428 },
273:                                                         { name: "Doubt", score: 0.3284550905227661 },
274:                                                         { name: "Ecstasy", score: 0.040716782212257385 },
275:                                                         { name: "Embarrassment", score: 0.1467227339744568 },
276:                                                         { name: "Empathic Pain", score: 0.07633581757545471 },
277:                                                         { name: "Entrancement", score: 0.16245244443416595 },
278:                                                         { name: "Envy", score: 0.03267110139131546 },
279:                                                         { name: "Excitement", score: 0.10656816512346268 },
280:                                                         { name: "Fear", score: 0.3115977346897125 },
281:                                                         { name: "Guilt", score: 0.11615975946187973 },
282:                                                         { name: "Horror", score: 0.19795553386211395 },
283:                                                         { name: "Interest", score: 0.3136432468891144 },
284:                                                         { name: "Joy", score: 0.06285581737756729 },
285:                                                         { name: "Love", score: 0.06339752674102783 },
286:                                                         { name: "Nostalgia", score: 0.05866732448339462 },
287:                                                         { name: "Pain", score: 0.07684041559696198 },
288:                                                         { name: "Pride", score: 0.026822954416275024 },
289:                                                         { name: "Realization", score: 0.30000734329223633 },
290:                                                         { name: "Relief", score: 0.04414166510105133 },
291:                                                         { name: "Romance", score: 0.042728863656520844 },
292:                                                         { name: "Sadness", score: 0.14773206412792206 },
293:                                                         { name: "Satisfaction", score: 0.05902980640530586 },
294:                                                         { name: "Shame", score: 0.08103451132774353 },
295:                                                         { name: "Surprise (negative)", score: 0.25518184900283813 },
296:                                                         { name: "Surprise (positive)", score: 0.28845661878585815 },
297:                                                         { name: "Sympathy", score: 0.062488824129104614 },
298:                                                         { name: "Tiredness", score: 0.1559651643037796 },
299:                                                         { name: "Triumph", score: 0.01955239288508892 },
300:                                                     ],
301:                                                 },
302:                                             ],
303:                                         },
304:                                     ],
305:                                 },
306:                             },
307:                         },
308:                     ],
309:                     errors: [],
310:                 },
311:             },
312:         ];
313:         server
314:             .mockEndpoint()
315:             .get("/v0/batch/jobs/job_id/predictions")
316:             .respondWith()
317:             .statusCode(200)
318:             .jsonBody(rawResponseBody)
319:             .build();
320: 
321:         const response = await client.expressionMeasurement.batch.getJobPredictions("job_id");
322:         expect(response).toEqual([
323:             {
324:                 source: {
325:                     type: "url",
326:                     url: "https://hume-tutorials.s3.amazonaws.com/faces.zip",
327:                 },
328:                 results: {
329:                     predictions: [
330:                         {
331:                             file: "faces/100.jpg",
332:                             models: {
333:                                 face: {
334:                                     groupedPredictions: [
335:                                         {
336:                                             id: "unknown",
337:                                             predictions: [
338:                                                 {
339:                                                     frame: 0,
340:                                                     time: 0,
341:                                                     prob: 0.9994111061096191,
342:                                                     box: {
343:                                                         x: 1187.885986328125,
344:                                                         y: 1397.697509765625,
345:                                                         w: 1401.668701171875,
346:                                                         h: 1961.424560546875,
347:                                                     },
348:                                                     emotions: [
349:                                                         {
350:                                                             name: "Admiration",
351:                                                             score: 0.10722749680280685,
352:                                                         },
353:                                                         {
354:                                                             name: "Adoration",
355:                                                             score: 0.06395940482616425,
356:                                                         },
357:                                                         {
358:                                                             name: "Aesthetic Appreciation",
359:                                                             score: 0.05811462551355362,
360:                                                         },
361:                                                         {
362:                                                             name: "Amusement",
363:                                                             score: 0.14187128841876984,
364:                                                         },
365:                                                         {
366:                                                             name: "Anger",
367:                                                             score: 0.02804684266448021,
368:                                                         },
369:                                                         {
370:                                                             name: "Anxiety",
371:                                                             score: 0.2713485360145569,
372:                                                         },
373:                                                         {
374:                                                             name: "Awe",
375:                                                             score: 0.33812594413757324,
376:                                                         },
377:                                                         {
378:                                                             name: "Awkwardness",
379:                                                             score: 0.1745193600654602,
380:                                                         },
381:                                                         {
382:                                                             name: "Boredom",
383:                                                             score: 0.23600080609321594,
384:                                                         },
385:                                                         {
386:                                                             name: "Calmness",
387:                                                             score: 0.18988418579101562,
388:                                                         },
389:                                                         {
390:                                                             name: "Concentration",
391:                                                             score: 0.44288986921310425,
392:                                                         },
393:                                                         {
394:                                                             name: "Confusion",
395:                                                             score: 0.39346569776535034,
396:                                                         },
397:                                                         {
398:                                                             name: "Contemplation",
399:                                                             score: 0.31002455949783325,
400:                                                         },
401:                                                         {
402:                                                             name: "Contempt",
403:                                                             score: 0.048870109021663666,
404:                                                         },
405:                                                         {
406:                                                             name: "Contentment",
407:                                                             score: 0.0579497292637825,
408:                                                         },
409:                                                         {
410:                                                             name: "Craving",
411:                                                             score: 0.06544201076030731,
412:                                                         },
413:                                                         {
414:                                                             name: "Desire",
415:                                                             score: 0.05526508390903473,
416:                                                         },
417:                                                         {
418:                                                             name: "Determination",
419:                                                             score: 0.08590991795063019,
420:                                                         },
421:                                                         {
422:                                                             name: "Disappointment",
423:                                                             score: 0.19508258998394012,
424:                                                         },
425:                                                         {
426:                                                             name: "Disgust",
427:                                                             score: 0.031529419124126434,
428:                                                         },
429:                                                         {
430:                                                             name: "Distress",
431:                                                             score: 0.23210826516151428,
432:                                                         },
433:                                                         {
434:                                                             name: "Doubt",
435:                                                             score: 0.3284550905227661,
436:                                                         },
437:                                                         {
438:                                                             name: "Ecstasy",
439:                                                             score: 0.040716782212257385,
440:                                                         },
441:                                                         {
442:                                                             name: "Embarrassment",
443:                                                             score: 0.1467227339744568,
444:                                                         },
445:                                                         {
446:                                                             name: "Empathic Pain",
447:                                                             score: 0.07633581757545471,
448:                                                         },
449:                                                         {
450:                                                             name: "Entrancement",
451:                                                             score: 0.16245244443416595,
452:                                                         },
453:                                                         {
454:                                                             name: "Envy",
455:                                                             score: 0.03267110139131546,
456:                                                         },
457:                                                         {
458:                                                             name: "Excitement",
459:                                                             score: 0.10656816512346268,
460:                                                         },
461:                                                         {
462:                                                             name: "Fear",
463:                                                             score: 0.3115977346897125,
464:                                                         },
465:                                                         {
466:                                                             name: "Guilt",
467:                                                             score: 0.11615975946187973,
468:                                                         },
469:                                                         {
470:                                                             name: "Horror",
471:                                                             score: 0.19795553386211395,
472:                                                         },
473:                                                         {
474:                                                             name: "Interest",
475:                                                             score: 0.3136432468891144,
476:                                                         },
477:                                                         {
478:                                                             name: "Joy",
479:                                                             score: 0.06285581737756729,
480:                                                         },
481:                                                         {
482:                                                             name: "Love",
483:                                                             score: 0.06339752674102783,
484:                                                         },
485:                                                         {
486:                                                             name: "Nostalgia",
487:                                                             score: 0.05866732448339462,
488:                                                         },
489:                                                         {
490:                                                             name: "Pain",
491:                                                             score: 0.07684041559696198,
492:                                                         },
493:                                                         {
494:                                                             name: "Pride",
495:                                                             score: 0.026822954416275024,
496:                                                         },
497:                                                         {
498:                                                             name: "Realization",
499:                                                             score: 0.30000734329223633,
500:                                                         },
501:                                                         {
502:                                                             name: "Relief",
503:                                                             score: 0.04414166510105133,
504:                                                         },
505:                                                         {
506:                                                             name: "Romance",
507:                                                             score: 0.042728863656520844,
508:                                                         },
509:                                                         {
510:                                                             name: "Sadness",
511:                                                             score: 0.14773206412792206,
512:                                                         },
513:                                                         {
514:                                                             name: "Satisfaction",
515:                                                             score: 0.05902980640530586,
516:                                                         },
517:                                                         {
518:                                                             name: "Shame",
519:                                                             score: 0.08103451132774353,
520:                                                         },
521:                                                         {
522:                                                             name: "Surprise (negative)",
523:                                                             score: 0.25518184900283813,
524:                                                         },
525:                                                         {
526:                                                             name: "Surprise (positive)",
527:                                                             score: 0.28845661878585815,
528:                                                         },
529:                                                         {
530:                                                             name: "Sympathy",
531:                                                             score: 0.062488824129104614,
532:                                                         },
533:                                                         {
534:                                                             name: "Tiredness",
535:                                                             score: 0.1559651643037796,
536:                                                         },
537:                                                         {
538:                                                             name: "Triumph",
539:                                                             score: 0.01955239288508892,
540:                                                         },
541:                                                     ],
542:                                                 },
543:                                             ],
544:                                         },
545:                                     ],
546:                                 },
547:                             },
548:                         },
549:                     ],
550:                     errors: [],
551:                 },
552:             },
553:         ]);
554:     });
555: });
````

## File: tests/wire/tts/main.test.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import * as Hume from "../../../src/api/index";
  4: import { HumeClient } from "../../../src/Client";
  5: import { mockServerPool } from "../../mock-server/MockServerPool";
  6: 
  7: describe("TtsClient", () => {
  8:     test("synthesize-json (1)", async () => {
  9:         const server = mockServerPool.createServer();
 10:         const client = new HumeClient({
 11:             maxRetries: 0,
 12:             apiKey: "test",
 13:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 14:         });
 15:         const rawRequestBody = {
 16:             context: {
 17:                 utterances: [
 18:                     {
 19:                         text: "How can people see beauty so differently?",
 20:                         description:
 21:                             "A curious student with a clear and respectful tone, seeking clarification on Hume's ideas with a straightforward question.",
 22:                     },
 23:                 ],
 24:             },
 25:             format: { type: "mp3" },
 26:             num_generations: 1,
 27:             utterances: [
 28:                 {
 29:                     text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
 30:                     description:
 31:                         "Middle-aged masculine voice with a clear, rhythmic Scots lilt, rounded vowels, and a warm, steady tone with an articulate, academic quality.",
 32:                 },
 33:             ],
 34:         };
 35:         const rawResponseBody = {
 36:             generations: [
 37:                 {
 38:                     audio: "//PExAA0DDYRvkpNfhv3JI5JZ...etc.",
 39:                     duration: 7.44225,
 40:                     encoding: { format: "mp3", sample_rate: 48000 },
 41:                     file_size: 120192,
 42:                     generation_id: "795c949a-1510-4a80-9646-7d0863b023ab",
 43:                     snippets: [
 44:                         [
 45:                             {
 46:                                 audio: "//PExAA0DDYRvkpNfhv3JI5JZ...etc.",
 47:                                 generation_id: "795c949a-1510-4a80-9646-7d0863b023ab",
 48:                                 id: "37b1b1b1-1b1b-1b1b-1b1b-1b1b1b1b1b1b",
 49:                                 text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
 50:                                 utterance_index: 0,
 51:                                 timestamps: [],
 52:                             },
 53:                         ],
 54:                     ],
 55:                 },
 56:             ],
 57:             request_id: "66e01f90-4501-4aa0-bbaf-74f45dc15aa725906",
 58:         };
 59:         server
 60:             .mockEndpoint()
 61:             .post("/v0/tts")
 62:             .jsonBody(rawRequestBody)
 63:             .respondWith()
 64:             .statusCode(200)
 65:             .jsonBody(rawResponseBody)
 66:             .build();
 67: 
 68:         const response = await client.tts.synthesizeJson({
 69:             context: {
 70:                 utterances: [
 71:                     {
 72:                         text: "How can people see beauty so differently?",
 73:                         description:
 74:                             "A curious student with a clear and respectful tone, seeking clarification on Hume's ideas with a straightforward question.",
 75:                     },
 76:                 ],
 77:             },
 78:             format: {
 79:                 type: "mp3",
 80:             },
 81:             numGenerations: 1,
 82:             utterances: [
 83:                 {
 84:                     text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
 85:                     description:
 86:                         "Middle-aged masculine voice with a clear, rhythmic Scots lilt, rounded vowels, and a warm, steady tone with an articulate, academic quality.",
 87:                 },
 88:             ],
 89:         });
 90:         expect(response).toEqual({
 91:             generations: [
 92:                 {
 93:                     audio: "//PExAA0DDYRvkpNfhv3JI5JZ...etc.",
 94:                     duration: 7.44225,
 95:                     encoding: {
 96:                         format: "mp3",
 97:                         sampleRate: 48000,
 98:                     },
 99:                     fileSize: 120192,
100:                     generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
101:                     snippets: [
102:                         [
103:                             {
104:                                 audio: "//PExAA0DDYRvkpNfhv3JI5JZ...etc.",
105:                                 generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
106:                                 id: "37b1b1b1-1b1b-1b1b-1b1b-1b1b1b1b1b1b",
107:                                 text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
108:                                 utteranceIndex: 0,
109:                                 timestamps: [],
110:                             },
111:                         ],
112:                     ],
113:                 },
114:             ],
115:             requestId: "66e01f90-4501-4aa0-bbaf-74f45dc15aa725906",
116:         });
117:     });
118: 
119:     test("synthesize-json (2)", async () => {
120:         const server = mockServerPool.createServer();
121:         const client = new HumeClient({
122:             maxRetries: 0,
123:             apiKey: "test",
124:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
125:         });
126:         const rawRequestBody = { utterances: [{ text: "text" }, { text: "text" }] };
127:         const rawResponseBody = {};
128:         server
129:             .mockEndpoint()
130:             .post("/v0/tts")
131:             .jsonBody(rawRequestBody)
132:             .respondWith()
133:             .statusCode(422)
134:             .jsonBody(rawResponseBody)
135:             .build();
136: 
137:         await expect(async () => {
138:             return await client.tts.synthesizeJson({
139:                 utterances: [
140:                     {
141:                         text: "text",
142:                     },
143:                     {
144:                         text: "text",
145:                     },
146:                 ],
147:             });
148:         }).rejects.toThrow(Hume.tts.UnprocessableEntityError);
149:     });
150: });
````

## File: tests/wire/tts/voices.test.ts
````typescript
  1: // This file was auto-generated by Fern from our API Definition.
  2: 
  3: import * as Hume from "../../../src/api/index";
  4: import { HumeClient } from "../../../src/Client";
  5: import { mockServerPool } from "../../mock-server/MockServerPool";
  6: 
  7: describe("VoicesClient", () => {
  8:     test("list (1)", async () => {
  9:         const server = mockServerPool.createServer();
 10:         const client = new HumeClient({
 11:             maxRetries: 0,
 12:             apiKey: "test",
 13:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 14:         });
 15: 
 16:         const rawResponseBody = {
 17:             page_number: 0,
 18:             page_size: 10,
 19:             total_pages: 1,
 20:             voices_page: [
 21:                 { id: "c42352c0-4566-455d-b180-0f654b65b525", name: "David Hume", provider: "CUSTOM_VOICE" },
 22:                 { id: "d87352b0-26a3-4b11-081b-d157a5674d19", name: "Goliath Hume", provider: "CUSTOM_VOICE" },
 23:             ],
 24:         };
 25:         server
 26:             .mockEndpoint({ once: false })
 27:             .get("/v0/tts/voices")
 28:             .respondWith()
 29:             .statusCode(200)
 30:             .jsonBody(rawResponseBody)
 31:             .build();
 32: 
 33:         const expected = {
 34:             pageNumber: 0,
 35:             pageSize: 10,
 36:             totalPages: 1,
 37:             voicesPage: [
 38:                 {
 39:                     id: "c42352c0-4566-455d-b180-0f654b65b525",
 40:                     name: "David Hume",
 41:                     provider: "CUSTOM_VOICE",
 42:                 },
 43:                 {
 44:                     id: "d87352b0-26a3-4b11-081b-d157a5674d19",
 45:                     name: "Goliath Hume",
 46:                     provider: "CUSTOM_VOICE",
 47:                 },
 48:             ],
 49:         };
 50:         const page = await client.tts.voices.list({
 51:             provider: "CUSTOM_VOICE",
 52:         });
 53: 
 54:         expect(expected.voicesPage).toEqual(page.data);
 55:         expect(page.hasNextPage()).toBe(true);
 56:         const nextPage = await page.getNextPage();
 57:         expect(expected.voicesPage).toEqual(nextPage.data);
 58:     });
 59: 
 60:     test("list (2)", async () => {
 61:         const server = mockServerPool.createServer();
 62:         const client = new HumeClient({
 63:             maxRetries: 0,
 64:             apiKey: "test",
 65:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 66:         });
 67: 
 68:         const rawResponseBody = {};
 69:         server
 70:             .mockEndpoint({ once: false })
 71:             .get("/v0/tts/voices")
 72:             .respondWith()
 73:             .statusCode(400)
 74:             .jsonBody(rawResponseBody)
 75:             .build();
 76: 
 77:         await expect(async () => {
 78:             return await client.tts.voices.list({
 79:                 provider: "HUME_AI",
 80:             });
 81:         }).rejects.toThrow(Hume.tts.BadRequestError);
 82:     });
 83: 
 84:     test("create (1)", async () => {
 85:         const server = mockServerPool.createServer();
 86:         const client = new HumeClient({
 87:             maxRetries: 0,
 88:             apiKey: "test",
 89:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
 90:         });
 91:         const rawRequestBody = { generation_id: "795c949a-1510-4a80-9646-7d0863b023ab", name: "David Hume" };
 92:         const rawResponseBody = {
 93:             id: "c42352c0-4566-455d-b180-0f654b65b525",
 94:             name: "David Hume",
 95:             provider: "CUSTOM_VOICE",
 96:         };
 97:         server
 98:             .mockEndpoint()
 99:             .post("/v0/tts/voices")
100:             .jsonBody(rawRequestBody)
101:             .respondWith()
102:             .statusCode(200)
103:             .jsonBody(rawResponseBody)
104:             .build();
105: 
106:         const response = await client.tts.voices.create({
107:             generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
108:             name: "David Hume",
109:         });
110:         expect(response).toEqual({
111:             id: "c42352c0-4566-455d-b180-0f654b65b525",
112:             name: "David Hume",
113:             provider: "CUSTOM_VOICE",
114:         });
115:     });
116: 
117:     test("create (2)", async () => {
118:         const server = mockServerPool.createServer();
119:         const client = new HumeClient({
120:             maxRetries: 0,
121:             apiKey: "test",
122:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
123:         });
124:         const rawRequestBody = { generation_id: "generation_id", name: "name" };
125:         const rawResponseBody = {};
126:         server
127:             .mockEndpoint()
128:             .post("/v0/tts/voices")
129:             .jsonBody(rawRequestBody)
130:             .respondWith()
131:             .statusCode(422)
132:             .jsonBody(rawResponseBody)
133:             .build();
134: 
135:         await expect(async () => {
136:             return await client.tts.voices.create({
137:                 generationId: "generation_id",
138:                 name: "name",
139:             });
140:         }).rejects.toThrow(Hume.tts.UnprocessableEntityError);
141:     });
142: 
143:     test("delete (1)", async () => {
144:         const server = mockServerPool.createServer();
145:         const client = new HumeClient({
146:             maxRetries: 0,
147:             apiKey: "test",
148:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
149:         });
150: 
151:         server.mockEndpoint().delete("/v0/tts/voices").respondWith().statusCode(200).build();
152: 
153:         const response = await client.tts.voices.delete({
154:             name: "David Hume",
155:         });
156:         expect(response).toEqual(undefined);
157:     });
158: 
159:     test("delete (2)", async () => {
160:         const server = mockServerPool.createServer();
161:         const client = new HumeClient({
162:             maxRetries: 0,
163:             apiKey: "test",
164:             environment: { base: server.baseUrl, evi: server.baseUrl, tts: server.baseUrl, stream: server.baseUrl },
165:         });
166: 
167:         const rawResponseBody = {};
168:         server.mockEndpoint().delete("/v0/tts/voices").respondWith().statusCode(400).jsonBody(rawResponseBody).build();
169: 
170:         await expect(async () => {
171:             return await client.tts.voices.delete({
172:                 name: "name",
173:             });
174:         }).rejects.toThrow(Hume.tts.BadRequestError);
175:     });
176: });
````

## File: tests/wire/.gitkeep
````
1: 
````

## File: tests/BrowserTestEnvironment.ts
````typescript
 1: /** THIS FILE IS MANUALLY MAINAINED: see .fernignore */
 2: import { TestEnvironment } from "jest-environment-jsdom";
 3: 
 4: class BrowserTestEnvironment extends TestEnvironment {
 5:     async setup() {
 6:         await super.setup();
 7:         this.global.Request = Request;
 8:         this.global.Response = Response;
 9:         this.global.ReadableStream = ReadableStream;
10:         this.global.TextEncoder = TextEncoder;
11:         this.global.TextDecoder = TextDecoder;
12:         this.global.FormData = FormData;
13:         if (typeof File === "undefined") {
14:             this.global.File = require("buffer").File;
15:         } else {
16:             this.global.File = File;
17:         }
18:         this.global.Blob = Blob;
19:     }
20: }
21: 
22: export default BrowserTestEnvironment;
````

## File: tests/custom.test.ts
````typescript
 1: /**
 2:  * This is a custom test file, if you wish to add more tests
 3:  * to your SDK.
 4:  * Be sure to mark this file in `.fernignore`.
 5:  *
 6:  * If you include example requests/responses in your fern definition,
 7:  * you will have tests automatically generated for you.
 8:  */
 9: describe("test", () => {
10:     it("default", () => {
11:         expect(true).toBe(true);
12:     });
13: });
````

## File: tests/setup.ts
````typescript
 1: import { expect } from "vitest";
 2: 
 3: interface CustomMatchers<R = unknown> {
 4:     toContainHeaders(expectedHeaders: Record<string, string>): R;
 5: }
 6: 
 7: declare module "vitest" {
 8:     interface Assertion<T = any> extends CustomMatchers<T> {}
 9:     interface AsymmetricMatchersContaining extends CustomMatchers {}
10: }
11: 
12: expect.extend({
13:     toContainHeaders(actual: unknown, expectedHeaders: Record<string, string>) {
14:         const isHeaders = actual instanceof Headers;
15:         const isPlainObject = typeof actual === "object" && actual !== null && !Array.isArray(actual);
16: 
17:         if (!isHeaders && !isPlainObject) {
18:             throw new TypeError("Received value must be an instance of Headers or a plain object!");
19:         }
20: 
21:         if (typeof expectedHeaders !== "object" || expectedHeaders === null || Array.isArray(expectedHeaders)) {
22:             throw new TypeError("Expected headers must be a plain object!");
23:         }
24: 
25:         const missingHeaders: string[] = [];
26:         const mismatchedHeaders: Array<{ key: string; expected: string; actual: string | null }> = [];
27: 
28:         for (const [key, value] of Object.entries(expectedHeaders)) {
29:             let actualValue: string | null = null;
30: 
31:             if (isHeaders) {
32:                 // Headers.get() is already case-insensitive
33:                 actualValue = (actual as Headers).get(key);
34:             } else {
35:                 // For plain objects, do case-insensitive lookup
36:                 const actualObj = actual as Record<string, string>;
37:                 const lowerKey = key.toLowerCase();
38:                 const foundKey = Object.keys(actualObj).find((k) => k.toLowerCase() === lowerKey);
39:                 actualValue = foundKey ? actualObj[foundKey] : null;
40:             }
41: 
42:             if (actualValue === null || actualValue === undefined) {
43:                 missingHeaders.push(key);
44:             } else if (actualValue !== value) {
45:                 mismatchedHeaders.push({ key, expected: value, actual: actualValue });
46:             }
47:         }
48: 
49:         const pass = missingHeaders.length === 0 && mismatchedHeaders.length === 0;
50: 
51:         const actualType = isHeaders ? "Headers" : "object";
52: 
53:         if (pass) {
54:             return {
55:                 message: () => `expected ${actualType} not to contain ${this.utils.printExpected(expectedHeaders)}`,
56:                 pass: true,
57:             };
58:         } else {
59:             const messages: string[] = [];
60: 
61:             if (missingHeaders.length > 0) {
62:                 messages.push(`Missing headers: ${this.utils.printExpected(missingHeaders.join(", "))}`);
63:             }
64: 
65:             if (mismatchedHeaders.length > 0) {
66:                 const mismatches = mismatchedHeaders.map(
67:                     ({ key, expected, actual }) =>
68:                         `${key}: expected ${this.utils.printExpected(expected)} but got ${this.utils.printReceived(actual)}`,
69:                 );
70:                 messages.push(mismatches.join("\n"));
71:             }
72: 
73:             return {
74:                 message: () =>
75:                     `expected ${actualType} to contain ${this.utils.printExpected(expectedHeaders)}\n\n${messages.join("\n")}`,
76:                 pass: false,
77:             };
78:         }
79:     },
80: });
````

## File: tests/tsconfig.json
````json
 1: {
 2:     "extends": "../tsconfig.base.json",
 3:     "compilerOptions": {
 4:         "outDir": null,
 5:         "rootDir": "..",
 6:         "baseUrl": "..",
 7:         "types": ["vitest/globals"]
 8:     },
 9:     "include": ["../src", "../tests"],
10:     "exclude": []
11: }
````

## File: .fernignore
````
 1: # Specify files that shouldn't be modified by Fern
 2: 
 3: README.md
 4: CITATIONS.md
 5: LICENSE
 6: CONTRIBUTING.md
 7: 
 8: # Tooling
 9: eslint.config.mjs
10: #jest.config.mjs
11: justfile
12: tsconfig.dev.json
13: .nvmrc
14: .github
15: .prettierignore
16: 
17: 
18: # EVI WebSocket
19: # Supplier.ts - sync version required to keep EVI chat client .connect() method synchronous
20: src/core/fetcher/Supplier.ts
21: # src/Client.ts
22: # src/api/resources/empathicVoice/client/Client.ts
23: # src/api/resources/empathicVoice/resources/chat/index.ts
24: # src/api/resources/empathicVoice/resources/chat/client
25: # src/core/websocket
26: # src/core/index.ts
27: # EVI Chat Client - manually maintained to preserve backward compatibility
28: # Client.ts changes from generated version:
29: # - ConnectArgs.sessionSettings is optional (was required)
30: # - ConnectArgs.configVersion accepts string | number (was only number)
31: # - ConnectArgs.voiceId added back as deprecated parameter
32: # - ConnectArgs.queryParams added for arbitrary query parameters
33: # - connect() args parameter is optional with default {}
34: # - Handles voiceId parameter (maps to voice_id query param)
35: # - Handles flexible configVersion types (both string and number)
36: # - Conditional sessionSettings serialization (only if provided)
37: # - Merges custom queryParams into query parameters
38: src/api/resources/empathicVoice/resources/chat/client/Client.ts
39: 
40: # The below websocket clients also need a custom _getCustomAuthorizationHeaders
41: src/api/resources/tts/resources/streamInput/client/Client.ts
42: src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts
43: 
44: # Socket.ts changes from generated version:
45: # - Response type includes receivedAt: Date timestamp
46: # - handleMessage adds receivedAt timestamp to messages
47: # - Restored 8 convenience methods that wrap sendPublish():
48: #   - sendAudioInput(), sendSessionSettings(), sendAssistantInput()
49: #   - pauseAssistant(), resumeAssistant()
50: #   - sendToolResponseMessage(), sendToolErrorMessage(), sendUserInput()
51: # - Added tillSocketOpen() as deprecated alias for waitForOpen()
52: src/api/resources/empathicVoice/resources/chat/client/Socket.ts
53: 
54: # index.ts - manually maintained to export Chat and ChatSocket
55: # Generated version exports nothing (export {}), but we need to export
56: # our manually maintained Client and Socket classes
57: src/api/resources/empathicVoice/resources/chat/client/index.ts
58: 
59: # Manually added tests
60: tests/unit/url-resolution.test.ts
61: tests/expressionMeasurement/batch.test.ts
62: tests/expressionMeasurement/streaming.test.ts
63: 
64: # Required manual edits for Node 18 compatibility
65: tests/unit/fetcher/Fetcher.test.ts
66: tests/unit/file/file.test.ts
67: tests/unit/file/test-file.txt
68: 
69: # Needed because node 18 doesn't actually have a global.File
70: tests/BrowserTestEnvironment.ts
71: 
72: # Needed to send apiKey on websocket queryParams
73: # See https://github.com/fern-demo/hume-typescript-sdk/pull/1
74: src/core/websocket/ws.ts
75: 
76: # Needed to export the utilities under src/wrapper
77: src/wrapper
78: src/index.ts
79: 
80: # Deprecated type aliases for backward compatibility
81: src/api/resources/empathicVoice/resources/chat/types/SubscribeEvent.ts
82: src/serialization/resources/empathicVoice/resources/chat/types/SubscribeEvent.ts
83: # Modified index files to support deprecated aliases
84: src/api/resources/empathicVoice/resources/chat/index.ts
85: src/serialization/resources/empathicVoice/resources/chat/index.ts
86: 
87: scripts/test-examples-local.sh
88: justfile
89: 
90: # Custom HeaderAuthProvider to support both apiKey and accessToken authentication
91: src/auth/HeaderAuthProvider.ts
92: 
93: # Auth tests
94: tests/unit/auth/auth.test.ts
````

## File: .gitignore
````
1: node_modules
2: .DS_Store
3: /dist
````

## File: .nvmrc
````
1: 18.18.0
````

## File: .prettierignore
````
1: .mock
````

## File: biome.json
````json
 1: {
 2:     "$schema": "https://biomejs.dev/schemas/2.3.1/schema.json",
 3:     "root": true,
 4:     "vcs": {
 5:         "enabled": false
 6:     },
 7:     "files": {
 8:         "ignoreUnknown": true,
 9:         "includes": [
10:             "**",
11:             "!!dist",
12:             "!!**/dist",
13:             "!!lib",
14:             "!!**/lib",
15:             "!!_tmp_*",
16:             "!!**/_tmp_*",
17:             "!!*.tmp",
18:             "!!**/*.tmp",
19:             "!!.tmp/",
20:             "!!**/.tmp/",
21:             "!!*.log",
22:             "!!**/*.log",
23:             "!!**/.DS_Store",
24:             "!!**/Thumbs.db"
25:         ]
26:     },
27:     "formatter": {
28:         "enabled": true,
29:         "indentStyle": "space",
30:         "indentWidth": 4,
31:         "lineWidth": 120
32:     },
33:     "javascript": {
34:         "formatter": {
35:             "quoteStyle": "double"
36:         }
37:     },
38:     "assist": {
39:         "enabled": true,
40:         "actions": {
41:             "source": {
42:                 "organizeImports": "on"
43:             }
44:         }
45:     },
46:     "linter": {
47:         "rules": {
48:             "style": {
49:                 "useNodejsImportProtocol": "off"
50:             },
51:             "suspicious": {
52:                 "noAssignInExpressions": "warn",
53:                 "noUselessEscapeInString": {
54:                     "level": "warn",
55:                     "fix": "none",
56:                     "options": {}
57:                 },
58:                 "noThenProperty": "warn",
59:                 "useIterableCallbackReturn": "warn",
60:                 "noShadowRestrictedNames": "warn",
61:                 "noTsIgnore": {
62:                     "level": "warn",
63:                     "fix": "none",
64:                     "options": {}
65:                 },
66:                 "noConfusingVoidType": {
67:                     "level": "warn",
68:                     "fix": "none",
69:                     "options": {}
70:                 }
71:             }
72:         }
73:     }
74: }
````

## File: CITATIONS.md
````markdown
  1: # Citations
  2: 
  3: To cite Hume's expressive communication platform, please reference one or more of the papers relevant to your application.
  4: 
  5: | Publication                                                                                                                                                                          | Year | Modality |   BibTeX    |
  6: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--: | :------: | :---------: |
  7: | [Self-report captures 27 distinct categories of emotion bridged by continuous gradients](https://doi.org/10.1073/pnas.1702247114)                                                    | 2017 |  multi   | [Cite](#1)  |
  8: | [Mapping the Passions: Toward a High-Dimensional Taxonomy of Emotional Experience and Expression](https://doi.org/10.1177/1529100619850176)                                          | 2019 |  multi   | [Cite](#2)  |
  9: | [The primacy of categories in the recognition of 12 emotions in speech prosody across two cultures](https://doi.org/10.1038/s41562-019-0533-6)                                       | 2019 |  voice   | [Cite](#3)  |
 10: | [Mapping 24 emotions conveyed by brief human vocalization](https://doi.org/10.1037/amp0000399)                                                                                       | 2019 |  voice   | [Cite](#4)  |
 11: | [Emotional expression: Advances in basic emotion theory](https://doi.org/10.1007%2Fs10919-019-00293-3)                                                                               | 2019 |  multi   | [Cite](#5)  |
 12: | [What the face displays: Mapping 28 emotions conveyed by naturalistic expression](https://doi.org/10.1037/amp0000488)                                                                | 2020 |   face   | [Cite](#6)  |
 13: | [The neural representation of visually evoked emotion is high-dimensional, categorical, and distributed across transmodal brain regions](https://doi.org/10.1016/j.isci.2020.101060) | 2020 |  multi   | [Cite](#7)  |
 14: | [What music makes us feel: At least 13 dimensions organize subjective experiences associated with music across different cultures](https://doi.org/10.1073/pnas.1910704117)          | 2020 |  music   | [Cite](#8)  |
 15: | [GoEmotions: A Dataset of Fine-Grained Emotions](https://doi.org/10.18653/v1/2020.acl-main.372)                                                                                      | 2020 |   text   | [Cite](#9)  |
 16: | [Universal facial expressions uncovered in art of the ancient Americas: A computational approach](https://doi.org/10.1126/sciadv.abb1005)                                            | 2020 |   face   | [Cite](#10) |
 17: | [Sixteen facial expressions occur in similar contexts worldwide](https://doi.org/10.1038/s41586-020-3037-7)                                                                          | 2021 |   face   | [Cite](#11) |
 18: | [The MuSe 2022 Multimodal Sentiment Analysis Challenge: Humor, Emotional Reactions, and Stress](https://doi.org/10.48550/arXiv.2207.05691)                                           | 2022 |  multi   | [Cite](#12) |
 19: | [The ACII 2022 Affective Vocal Bursts Workshop & Competition: Understanding a critically understudied modality of emotional expression](https://doi.org/10.48550/arXiv.2207.03572)   | 2022 |  voice   | [Cite](#13) |
 20: | [The ICML 2022 Expressive Vocalizations Workshop and Competition: Recognizing, Generating, and Personalizing Vocal Bursts](https://doi.org/10.48550/arXiv.2205.01780)                | 2022 |  voice   | [Cite](#14) |
 21: | [Intersectionality in emotion signaling and recognition: The influence of gender, ethnicity, and social class](https://doi.org/10.1037/emo0001082)                                   | 2022 |   body   | [Cite](#15) |
 22: | [How emotions, relationships, and culture constitute each other: advances in social functionalist theory](https://doi.org/10.1080/02699931.2022.2047009)                             | 2022 |  multi   | [Cite](#16) |
 23: | [State & Trait Measurement from Nonverbal Vocalizations: A Multi-Task Joint Learning Approach](https://doi.org/10.21437/Interspeech.2022-10927)                                      | 2022 |  voice   | [Cite](#17) |
 24: 
 25: ## BibTeX
 26: 
 27: ### <a id="1"></a>
 28: 
 29: ```bibtex
 30: @article{cowen2017self,
 31:   title={Self-report captures 27 distinct categories of emotion bridged by continuous gradients},
 32:   author={Cowen, Alan S and Keltner, Dacher},
 33:   journal={Proceedings of the national academy of sciences},
 34:   volume={114},
 35:   number={38},
 36:   pages={E7900--E7909},
 37:   year={2017},
 38:   publisher={National Acad Sciences}
 39: }
 40: ```
 41: 
 42: ### <a id="2"></a>
 43: 
 44: ```bibtex
 45: @article{cowen2019mapping,
 46:   title={Mapping the passions: Toward a high-dimensional taxonomy of emotional experience and expression},
 47:   author={Cowen, Alan and Sauter, Disa and Tracy, Jessica L and Keltner, Dacher},
 48:   journal={Psychological Science in the Public Interest},
 49:   volume={20},
 50:   number={1},
 51:   pages={69--90},
 52:   year={2019},
 53:   publisher={Sage Publications Sage CA: Los Angeles, CA}
 54: }
 55: ```
 56: 
 57: ### <a id="3"></a>
 58: 
 59: ```bibtex
 60: @article{cowen2019primacy,
 61:   title={The primacy of categories in the recognition of 12 emotions in speech prosody across two cultures},
 62:   author={Cowen, Alan S and Laukka, Petri and Elfenbein, Hillary Anger and Liu, Runjing and Keltner, Dacher},
 63:   journal={Nature human behaviour},
 64:   volume={3},
 65:   number={4},
 66:   pages={369--382},
 67:   year={2019},
 68:   publisher={Nature Publishing Group}
 69: }
 70: ```
 71: 
 72: ### <a id="4"></a>
 73: 
 74: ```bibtex
 75: @article{cowen2019mapping,
 76:   title={Mapping 24 emotions conveyed by brief human vocalization.},
 77:   author={Cowen, Alan S and Elfenbein, Hillary Anger and Laukka, Petri and Keltner, Dacher},
 78:   journal={American Psychologist},
 79:   volume={74},
 80:   number={6},
 81:   pages={698},
 82:   year={2019},
 83:   publisher={American Psychological Association}
 84: }
 85: ```
 86: 
 87: ### <a id="5"></a>
 88: 
 89: ```bibtex
 90: @article{keltner2019emotional,
 91:   title={Emotional expression: Advances in basic emotion theory},
 92:   author={Keltner, Dacher and Sauter, Disa and Tracy, Jessica and Cowen, Alan},
 93:   journal={Journal of nonverbal behavior},
 94:   volume={43},
 95:   number={2},
 96:   pages={133--160},
 97:   year={2019},
 98:   publisher={Springer}
 99: }
100: ```
101: 
102: ### <a id="6"></a>
103: 
104: ```bibtex
105: @article{cowen2020face,
106:   title={What the face displays: Mapping 28 emotions conveyed by naturalistic expression.},
107:   author={Cowen, Alan S and Keltner, Dacher},
108:   journal={American Psychologist},
109:   volume={75},
110:   number={3},
111:   pages={349},
112:   year={2020},
113:   publisher={American Psychological Association}
114: }
115: ```
116: 
117: ### <a id="7"></a>
118: 
119: ```bibtex
120: @article{horikawa2020neural,
121:   title={The neural representation of visually evoked emotion is high-dimensional, categorical, and distributed across transmodal brain regions},
122:   author={Horikawa, Tomoyasu and Cowen, Alan S and Keltner, Dacher and Kamitani, Yukiyasu},
123:   journal={Iscience},
124:   volume={23},
125:   number={5},
126:   pages={101060},
127:   year={2020},
128:   publisher={Elsevier}
129: }
130: ```
131: 
132: ### <a id="8"></a>
133: 
134: ```bibtex
135: @article{cowen2020music,
136:   title={What music makes us feel: At least 13 dimensions organize subjective experiences associated with music across different cultures},
137:   author={Cowen, Alan S and Fang, Xia and Sauter, Disa and Keltner, Dacher},
138:   journal={Proceedings of the National Academy of Sciences},
139:   volume={117},
140:   number={4},
141:   pages={1924--1934},
142:   year={2020},
143:   publisher={National Acad Sciences}
144: }
145: ```
146: 
147: ### <a id="9"></a>
148: 
149: ```bibtex
150: @article{demszky2020goemotions,
151:   title={GoEmotions: A dataset of fine-grained emotions},
152:   author={Demszky, Dorottya and Movshovitz-Attias, Dana and Ko, Jeongwoo and Cowen, Alan and Nemade, Gaurav and Ravi, Sujith},
153:   journal={arXiv preprint arXiv:2005.00547},
154:   year={2020}
155: }
156: ```
157: 
158: ### <a id="10"></a>
159: 
160: ```bibtex
161: @article{cowen2020universal,
162:   title={Universal facial expressions uncovered in art of the ancient Americas: A computational approach},
163:   author={Cowen, Alan S and Keltner, Dacher},
164:   journal={Science advances},
165:   volume={6},
166:   number={34},
167:   pages={eabb1005},
168:   year={2020},
169:   publisher={American Association for the Advancement of Science}
170: }
171: ```
172: 
173: ### <a id="11"></a>
174: 
175: ```bibtex
176: @article{cowen2021sixteen,
177:   title={Sixteen facial expressions occur in similar contexts worldwide},
178:   author={Cowen, Alan S and Keltner, Dacher and Schroff, Florian and Jou, Brendan and Adam, Hartwig and Prasad, Gautam},
179:   journal={Nature},
180:   volume={589},
181:   number={7841},
182:   pages={251--257},
183:   year={2021},
184:   publisher={Nature Publishing Group}
185: }
186: ```
187: 
188: ### <a id="12"></a>
189: 
190: ```bibtex
191: @article{christ2022muse,
192:   title={The MuSe 2022 Multimodal Sentiment Analysis Challenge: Humor, Emotional Reactions, and Stress},
193:   author={Christ, Lukas and Amiriparian, Shahin and Baird, Alice and Tzirakis, Panagiotis and Kathan, Alexander and M{\"u}ller, Niklas and Stappen, Lukas and Me{\ss}ner, Eva-Maria and K{\"o}nig, Andreas and Cowen, Alan and others},
194:   year={2022}
195: }
196: ```
197: 
198: ### <a id="13"></a>
199: 
200: ```bibtex
201: @article{baird2022acii,
202:   title={The ACII 2022 Affective Vocal Bursts Workshop \& Competition: Understanding a critically understudied modality of emotional expression},
203:   author={Baird, Alice and Tzirakis, Panagiotis and Brooks, Jeffrey A and Gregory, Christopher B and Schuller, Bj{\"o}rn and Batliner, Anton and Keltner, Dacher and Cowen, Alan},
204:   journal={arXiv preprint arXiv:2207.03572},
205:   year={2022}
206: }
207: ```
208: 
209: ### <a id="14"></a>
210: 
211: ```bibtex
212: @article{baird2022icml,
213:   title={The ICML 2022 Expressive Vocalizations Workshop and Competition: Recognizing, Generating, and Personalizing Vocal Bursts},
214:   author={Baird, Alice and Tzirakis, Panagiotis and Gidel, Gauthier and Jiralerspong, Marco and Muller, Eilif B and Mathewson, Kory and Schuller, Bj{\"o}rn and Cambria, Erik and Keltner, Dacher and Cowen, Alan},
215:   journal={arXiv preprint arXiv:2205.01780},
216:   year={2022}
217: }
218: ```
219: 
220: ### <a id="15"></a>
221: 
222: ```bibtex
223: @article{monroy2022intersectionality,
224:   title={Intersectionality in emotion signaling and recognition: The influence of gender, ethnicity, and social class.},
225:   author={Monroy, Maria and Cowen, Alan S and Keltner, Dacher},
226:   journal={Emotion},
227:   year={2022},
228:   publisher={American Psychological Association}
229: }
230: ```
231: 
232: ### <a id="16"></a>
233: 
234: ```bibtex
235: @article{keltner2022emotions,
236:   title={How emotions, relationships, and culture constitute each other: advances in social functionalist theory},
237:   author={Keltner, Dacher and Sauter, Disa and Tracy, Jessica L and Wetchler, Everett and Cowen, Alan S},
238:   journal={Cognition and Emotion},
239:   volume={36},
240:   number={3},
241:   pages={388--401},
242:   year={2022},
243:   publisher={Taylor \& Francis}
244: }
245: ```
246: 
247: ### <a id="17"></a>
248: 
249: ```bibtex
250: @inproceedings{baird22_interspeech,
251:   author={Alice Baird and Panagiotis Tzirakis and Jeff Brooks and Lauren Kim and Michael Opara and Chris Gregory and Jacob Metrick and Garrett Boseck and Dacher Keltner and Alan Cowen},
252:   title={{State & Trait Measurement from Nonverbal Vocalizations: A Multi-Task Joint Learning Approach}},
253:   year=2022,
254:   booktitle={Proc. Interspeech 2022},
255:   pages={2028--2032},
256:   doi={10.21437/Interspeech.2022-10927}
257: }
258: ```
````

## File: CONTRIBUTING.md
````markdown
1: # Contributing
2: 
3: While we value open-source contributions to this SDK, this library is generated programmatically. Additions made directly to this library would have to be moved over to our generation code, otherwise they would be overwritten upon the next generated release. Feel free to open a PR as a proof of concept, but know that we will not be able to merge it as-is. We suggest opening an issue first to discuss with us!
4: 
5: On the other hand, contributions to the README are always very welcome!
````

## File: eslint.config.mjs
````javascript
 1: import js from "@eslint/js";
 2: import tseslint from "typescript-eslint";
 3: 
 4: const fernRules = {
 5:     files: ["src/**/*.ts"],
 6:     rules: {
 7:         "@typescript-eslint/no-unused-vars": "off",
 8:         "@typescript-eslint/no-unnecessary-type-assertion": "warn",
 9:         "@typescript-eslint/no-explicit-any": "warn",
10:         "@typescript-eslint/ban-ts-comment": "warn",
11:         "prefer-const": "warn",
12:     },
13: };
14: 
15: const humeRules = {
16:     files: ["src/wrapper/**/*.ts"],
17:     rules: {
18:         "@typescript-eslint/no-unused-vars": "error",
19:         "@typescript-eslint/no-unnecessary-type-assertion": "error",
20:         "@typescript-eslint/no-explicit-any": "error",
21:         "@typescript-eslint/ban-ts-comment": "error",
22:         "prefer-const": "error",
23:     },
24: };
25: 
26: export default [
27:     js.configs.recommended,
28:     ...tseslint.configs.recommended,
29:     {
30:         ignores: ["dist", "src/core/**/*.ts", "jest.config.js"],
31:     },
32:     {
33:         languageOptions: {
34:             parserOptions: {
35:                 project: "./tsconfig.dev.json",
36:             },
37:         },
38:     },
39:     {
40:         rules: {
41:             "@typescript-eslint/no-namespace": "off",
42:         },
43:     },
44:     fernRules,
45:     humeRules,
46: ];
````

## File: justfile
````
1: # run the CI workflow locally
2: local-ci:
3:     act -W '.github/workflows/ci.yml' --container-architecture linux/amd64 -s GITHUB_TOKEN="$(gh auth token)"
````

## File: LICENSE
````
 1: MIT License
 2: 
 3: Copyright (c) 2022 Hume AI, Inc.
 4: 
 5: Permission is hereby granted, free of charge, to any person obtaining a copy
 6: of this software and associated documentation files (the "Software"), to deal
 7: in the Software without restriction, including without limitation the rights
 8: to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9: copies of the Software, and to permit persons to whom the Software is
10: furnished to do so, subject to the following conditions:
11: 
12: The above copyright notice and this permission notice shall be included in all
13: copies or substantial portions of the Software.
14: 
15: THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16: IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17: FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18: AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19: LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20: OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21: SOFTWARE.
````

## File: package.json
````json
 1: {
 2:     "name": "hume",
 3:     "version": "0.15.12",
 4:     "private": false,
 5:     "repository": {
 6:         "type": "git",
 7:         "url": "git+https://github.com/HumeAI/hume-typescript-sdk.git"
 8:     },
 9:     "type": "commonjs",
10:     "main": "./dist/cjs/index.js",
11:     "module": "./dist/esm/index.mjs",
12:     "types": "./dist/cjs/index.d.ts",
13:     "exports": {
14:         ".": {
15:             "types": "./dist/cjs/index.d.ts",
16:             "import": {
17:                 "types": "./dist/esm/index.d.mts",
18:                 "default": "./dist/esm/index.mjs"
19:             },
20:             "require": {
21:                 "types": "./dist/cjs/index.d.ts",
22:                 "default": "./dist/cjs/index.js"
23:             },
24:             "default": "./dist/cjs/index.js"
25:         },
26:         "./serialization": {
27:             "types": "./dist/cjs/serialization/index.d.ts",
28:             "import": {
29:                 "types": "./dist/esm/serialization/index.d.mts",
30:                 "default": "./dist/esm/serialization/index.mjs"
31:             },
32:             "require": {
33:                 "types": "./dist/cjs/serialization/index.d.ts",
34:                 "default": "./dist/cjs/serialization/index.js"
35:             },
36:             "default": "./dist/cjs/serialization/index.js"
37:         },
38:         "./package.json": "./package.json"
39:     },
40:     "files": [
41:         "dist",
42:         "reference.md",
43:         "README.md",
44:         "LICENSE"
45:     ],
46:     "scripts": {
47:         "format": "biome format --write --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
48:         "format:check": "biome format --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
49:         "lint": "biome lint --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
50:         "lint:fix": "biome lint --fix --unsafe --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
51:         "check": "biome check --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
52:         "check:fix": "biome check --fix --unsafe --skip-parse-errors --no-errors-on-unmatched --max-diagnostics=none",
53:         "build": "pnpm build:cjs && pnpm build:esm",
54:         "build:cjs": "tsc --project ./tsconfig.cjs.json",
55:         "build:esm": "tsc --project ./tsconfig.esm.json && node scripts/rename-to-esm-files.js dist/esm",
56:         "test": "vitest",
57:         "test:unit": "vitest --project unit",
58:         "test:wire": "vitest --project wire"
59:     },
60:     "dependencies": {
61:         "ws": "^8.16.0",
62:         "uuid": "9.0.1",
63:         "zod": "^3.23.8"
64:     },
65:     "devDependencies": {
66:         "webpack": "^5.97.1",
67:         "ts-loader": "^9.5.1",
68:         "@types/ws": "^8.5.9",
69:         "vitest": "^3.2.4",
70:         "msw": "2.11.2",
71:         "@types/node": "^18.19.70",
72:         "typescript": "~5.7.2",
73:         "@biomejs/biome": "2.3.1",
74:         "@types/uuid": "9.0.7"
75:     },
76:     "browser": {
77:         "fs": false,
78:         "os": false,
79:         "path": false,
80:         "stream": false
81:     },
82:     "packageManager": "pnpm@10.20.0",
83:     "engines": {
84:         "node": ">=18.0.0"
85:     },
86:     "sideEffects": false
87: }
````

## File: pnpm-workspace.yaml
````yaml
1: packages: ['.']
````

## File: README.md
````markdown
  1: <div align="center">
  2:   <img src="https://storage.googleapis.com/hume-public-logos/hume/hume-banner.png">
  3:   <h1>Hume AI TypeScript SDK</h1>
  4: 
  5:   <p>
  6:     <strong>Integrate Hume APIs directly into your Node application or frontend</strong>
  7:   </p>
  8: 
  9:   <br>
 10:   <div>
 11:     <a href="https://www.npmjs.com/package/hume"><img src="https://img.shields.io/npm/v/hume">
 12:     <a href="https://buildwithfern.com/"><img src="https://img.shields.io/badge/%F0%9F%8C%BF-SDK%20generated%20by%20Fern-brightgreen">
 13:   </div>
 14:   <br>
 15: </div>
 16: 
 17: ## Documentation
 18: 
 19: API reference documentation is available [here](https://dev.hume.ai/reference/).
 20: 
 21: ## Installation
 22: 
 23: ```
 24: npm i hume
 25: ```
 26: 
 27: ## Usage
 28: 
 29: ```typescript
 30: import { HumeClient } from "hume";
 31: 
 32: const hume = new HumeClient({
 33:     apiKey: "YOUR_API_KEY",
 34: });
 35: 
 36: const job = await hume.expressionMeasurement.batch.startInferenceJob({
 37:     models: {
 38:         face: {},
 39:     },
 40:     urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
 41: });
 42: 
 43: console.log("Running...");
 44: 
 45: await job.awaitCompletion();
 46: 
 47: const predictions = await hume.expressionMeasurement.batch.getJobPredictions(job.jobId);
 48: 
 49: console.log(predictions);
 50: ```
 51: 
 52: ## Namespaces
 53: 
 54: This SDK contains the APIs for expression measurement, empathic voice and custom models. Even
 55: if you do not plan on using more than one API to start, the SDK provides easy access in
 56: case you find additional APIs in the future.
 57: 
 58: Each API is namespaced accordingly:
 59: 
 60: ```typescript
 61: import { HumeClient } from "hume";
 62: 
 63: const hume = new HumeClient({
 64:     apiKey: "YOUR_API_KEY"
 65: });
 66: 
 67: hume.expressionMeasurement. // APIs specific to Expression Measurement
 68: 
 69: hume.emapthicVoice. // APIs specific to Empathic Voice
 70: ```
 71: 
 72: ## Websockets
 73: 
 74: The SDK supports interacting with both WebSocket and REST APIs.
 75: 
 76: ### Request-Reply
 77: 
 78: The SDK supports a request-reply pattern for the streaming expression measurement API.
 79: You'll be able to pass an inference request and `await` till the response is received.
 80: 
 81: ```typescript
 82: import { HumeClient } from "hume";
 83: 
 84: const hume = new HumeClient({
 85:     apiKey: "YOUR_API_KEY",
 86: });
 87: 
 88: const socket = hume.expressionMeasurement.stream.connect({
 89:     config: {
 90:         language: {},
 91:     },
 92: });
 93: 
 94: for (const sample of samples) {
 95:     const result = await socket.sendText({ text: sample });
 96:     console.log(result);
 97: }
 98: ```
 99: 
100: ### Empathic Voice
101: 
102: The SDK supports sending and receiving audio from Empathic Voice.
103: 
104: ```typescript
105: import { HumeClient } from "hume";
106: 
107: const hume = new HumeClient({
108:     apiKey: "<>",
109:     secretKey: "<>",
110: });
111: 
112: const socket = hume.empathicVoice.chat.connect();
113: 
114: socket.on("message", (message) => {
115:     if (message.type === "audio_output") {
116:         const decoded = Buffer.from(message.data, "base64");
117:         // play decoded message
118:     }
119: });
120: 
121: // optional utility to wait for socket to be open
122: await socket.tillSocketOpen();
123: 
124: socket.sendUserInput("Hello, how are you?");
125: ```
126: 
127: ## Errors
128: 
129: When the API returns a non-success status code (4xx or 5xx response),
130: a subclass of [HumeError](./src/errors/HumeError.ts) will be thrown:
131: 
132: ```typescript
133: import { HumeError, HumeTimeoutError } from "hume";
134: 
135: try {
136:     await hume.expressionMeasurement.batch.startInferenceJob(/* ... */);
137: } catch (err) {
138:     if (err instanceof HumeTimeoutError) {
139:         console.log("Request timed out", err);
140:     } else if (err instanceof HumeError) {
141:         // catch all errros
142:         console.log(err.statusCode);
143:         console.log(err.message);
144:         console.log(err.body);
145:     }
146: }
147: ```
148: 
149: ## Retries
150: 
151: 409 Conflict, 429 Rate Limit, and >=500 Internal errors will all be retried twice with exponential bakcoff.
152: You can use the maxRetries option to configure this behavior:
153: 
154: ```typescript
155: await hume.expressionMeasurement.batch.startInferenceJob(..., {
156:     maxRetries: 0, // disable retries
157: });
158: ```
159: 
160: ## Timeouts
161: 
162: By default, the SDK has a timeout of 60s. You can use the `timeoutInSeconds` option to configure
163: this behavior
164: 
165: ```typescript
166: await hume.expressionMeasurement.batch.startInferenceJob(..., {
167:     timeoutInSeconds: 10, // timeout after 10 seconds
168: });
169: ```
170: 
171: ## Beta Status
172: 
173: This SDK is in beta, and there may be breaking changes between versions without a major
174: version update. Therefore, we recommend pinning the package version to a specific version.
175: This way, you can install the same version each time without breaking changes.
176: 
177: ## Contributing
178: 
179: While we value open-source contributions to this SDK, this library is generated programmatically.
180: Additions made directly to this library would have to be moved over to our generation code,
181: otherwise they would be overwritten upon the next generated release. Feel free to open a PR as a
182: proof of concept, but know that we will not be able to merge it as-is. We suggest opening an
183: issue first to discuss with us!
184: 
185: On the other hand, contributions to the README are always very welcome!
````

## File: reference.md
````markdown
   1: # Reference
   2: ## Tts
   3: <details><summary><code>client.tts.<a href="/src/api/resources/tts/client/Client.ts">synthesizeJson</a>({ ...params }) -> Hume.ReturnTts</code></summary>
   4: <dl>
   5: <dd>
   6: 
   7: #### 📝 Description
   8: 
   9: <dl>
  10: <dd>
  11: 
  12: <dl>
  13: <dd>
  14: 
  15: Synthesizes one or more input texts into speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
  16: 
  17: The response includes the base64-encoded audio and metadata in JSON format.
  18: </dd>
  19: </dl>
  20: </dd>
  21: </dl>
  22: 
  23: #### 🔌 Usage
  24: 
  25: <dl>
  26: <dd>
  27: 
  28: <dl>
  29: <dd>
  30: 
  31: ```typescript
  32: await client.tts.synthesizeJson({
  33:     context: {
  34:         utterances: [{
  35:                 text: "How can people see beauty so differently?",
  36:                 description: "A curious student with a clear and respectful tone, seeking clarification on Hume's ideas with a straightforward question."
  37:             }]
  38:     },
  39:     format: {
  40:         type: "mp3"
  41:     },
  42:     numGenerations: 1,
  43:     utterances: [{
  44:             text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
  45:             description: "Middle-aged masculine voice with a clear, rhythmic Scots lilt, rounded vowels, and a warm, steady tone with an articulate, academic quality."
  46:         }]
  47: });
  48: 
  49: ```
  50: </dd>
  51: </dl>
  52: </dd>
  53: </dl>
  54: 
  55: #### ⚙️ Parameters
  56: 
  57: <dl>
  58: <dd>
  59: 
  60: <dl>
  61: <dd>
  62: 
  63: **request:** `Hume.PostedTts` 
  64:     
  65: </dd>
  66: </dl>
  67: 
  68: <dl>
  69: <dd>
  70: 
  71: **requestOptions:** `TtsClient.RequestOptions` 
  72:     
  73: </dd>
  74: </dl>
  75: </dd>
  76: </dl>
  77: 
  78: 
  79: </dd>
  80: </dl>
  81: </details>
  82: 
  83: <details><summary><code>client.tts.<a href="/src/api/resources/tts/client/Client.ts">synthesizeFile</a>({ ...params }) -> core.BinaryResponse</code></summary>
  84: <dl>
  85: <dd>
  86: 
  87: #### 📝 Description
  88: 
  89: <dl>
  90: <dd>
  91: 
  92: <dl>
  93: <dd>
  94: 
  95: Synthesizes one or more input texts into speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody. 
  96: 
  97: The response contains the generated audio file in the requested format.
  98: </dd>
  99: </dl>
 100: </dd>
 101: </dl>
 102: 
 103: #### 🔌 Usage
 104: 
 105: <dl>
 106: <dd>
 107: 
 108: <dl>
 109: <dd>
 110: 
 111: ```typescript
 112: await client.tts.synthesizeFile({
 113:     context: {
 114:         generationId: "09ad914d-8e7f-40f8-a279-e34f07f7dab2"
 115:     },
 116:     format: {
 117:         type: "mp3"
 118:     },
 119:     numGenerations: 1,
 120:     utterances: [{
 121:             text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
 122:             description: "Middle-aged masculine voice with a clear, rhythmic Scots lilt, rounded vowels, and a warm, steady tone with an articulate, academic quality."
 123:         }]
 124: });
 125: 
 126: ```
 127: </dd>
 128: </dl>
 129: </dd>
 130: </dl>
 131: 
 132: #### ⚙️ Parameters
 133: 
 134: <dl>
 135: <dd>
 136: 
 137: <dl>
 138: <dd>
 139: 
 140: **request:** `Hume.PostedTts` 
 141:     
 142: </dd>
 143: </dl>
 144: 
 145: <dl>
 146: <dd>
 147: 
 148: **requestOptions:** `TtsClient.RequestOptions` 
 149:     
 150: </dd>
 151: </dl>
 152: </dd>
 153: </dl>
 154: 
 155: 
 156: </dd>
 157: </dl>
 158: </details>
 159: 
 160: <details><summary><code>client.tts.<a href="/src/api/resources/tts/client/Client.ts">synthesizeFileStreaming</a>({ ...params }) -> core.BinaryResponse</code></summary>
 161: <dl>
 162: <dd>
 163: 
 164: #### 📝 Description
 165: 
 166: <dl>
 167: <dd>
 168: 
 169: <dl>
 170: <dd>
 171: 
 172: Streams synthesized speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody.
 173: </dd>
 174: </dl>
 175: </dd>
 176: </dl>
 177: 
 178: #### 🔌 Usage
 179: 
 180: <dl>
 181: <dd>
 182: 
 183: <dl>
 184: <dd>
 185: 
 186: ```typescript
 187: await client.tts.synthesizeFileStreaming({
 188:     utterances: [{
 189:             text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
 190:             voice: {
 191:                 name: "Male English Actor",
 192:                 provider: "HUME_AI"
 193:             }
 194:         }]
 195: });
 196: 
 197: ```
 198: </dd>
 199: </dl>
 200: </dd>
 201: </dl>
 202: 
 203: #### ⚙️ Parameters
 204: 
 205: <dl>
 206: <dd>
 207: 
 208: <dl>
 209: <dd>
 210: 
 211: **request:** `Hume.PostedTts` 
 212:     
 213: </dd>
 214: </dl>
 215: 
 216: <dl>
 217: <dd>
 218: 
 219: **requestOptions:** `TtsClient.RequestOptions` 
 220:     
 221: </dd>
 222: </dl>
 223: </dd>
 224: </dl>
 225: 
 226: 
 227: </dd>
 228: </dl>
 229: </details>
 230: 
 231: <details><summary><code>client.tts.<a href="/src/api/resources/tts/client/Client.ts">synthesizeJsonStreaming</a>({ ...params }) -> core.Stream<Hume.TtsOutput></code></summary>
 232: <dl>
 233: <dd>
 234: 
 235: #### 📝 Description
 236: 
 237: <dl>
 238: <dd>
 239: 
 240: <dl>
 241: <dd>
 242: 
 243: Streams synthesized speech using the specified voice. If no voice is provided, a novel voice will be generated dynamically. Optionally, additional context can be included to influence the speech's style and prosody. 
 244: 
 245: The response is a stream of JSON objects including audio encoded in base64.
 246: </dd>
 247: </dl>
 248: </dd>
 249: </dl>
 250: 
 251: #### 🔌 Usage
 252: 
 253: <dl>
 254: <dd>
 255: 
 256: <dl>
 257: <dd>
 258: 
 259: ```typescript
 260: const response = await client.tts.synthesizeJsonStreaming({
 261:     utterances: [{
 262:             text: "Beauty is no quality in things themselves: It exists merely in the mind which contemplates them.",
 263:             voice: {
 264:                 name: "Male English Actor",
 265:                 provider: "HUME_AI"
 266:             }
 267:         }]
 268: });
 269: for await (const item of response) {
 270:     console.log(item);
 271: }
 272: 
 273: ```
 274: </dd>
 275: </dl>
 276: </dd>
 277: </dl>
 278: 
 279: #### ⚙️ Parameters
 280: 
 281: <dl>
 282: <dd>
 283: 
 284: <dl>
 285: <dd>
 286: 
 287: **request:** `Hume.PostedTts` 
 288:     
 289: </dd>
 290: </dl>
 291: 
 292: <dl>
 293: <dd>
 294: 
 295: **requestOptions:** `TtsClient.RequestOptions` 
 296:     
 297: </dd>
 298: </dl>
 299: </dd>
 300: </dl>
 301: 
 302: 
 303: </dd>
 304: </dl>
 305: </details>
 306: 
 307: <details><summary><code>client.tts.<a href="/src/api/resources/tts/client/Client.ts">convertVoiceJson</a>({ ...params }) -> core.Stream<Hume.TtsOutput></code></summary>
 308: <dl>
 309: <dd>
 310: 
 311: #### 🔌 Usage
 312: 
 313: <dl>
 314: <dd>
 315: 
 316: <dl>
 317: <dd>
 318: 
 319: ```typescript
 320: const response = await client.tts.convertVoiceJson({});
 321: for await (const item of response) {
 322:     console.log(item);
 323: }
 324: 
 325: ```
 326: </dd>
 327: </dl>
 328: </dd>
 329: </dl>
 330: 
 331: #### ⚙️ Parameters
 332: 
 333: <dl>
 334: <dd>
 335: 
 336: <dl>
 337: <dd>
 338: 
 339: **request:** `Hume.tts.ConvertVoiceJsonRequest` 
 340:     
 341: </dd>
 342: </dl>
 343: 
 344: <dl>
 345: <dd>
 346: 
 347: **requestOptions:** `TtsClient.RequestOptions` 
 348:     
 349: </dd>
 350: </dl>
 351: </dd>
 352: </dl>
 353: 
 354: 
 355: </dd>
 356: </dl>
 357: </details>
 358: 
 359: ## Tts Voices
 360: <details><summary><code>client.tts.voices.<a href="/src/api/resources/tts/resources/voices/client/Client.ts">list</a>({ ...params }) -> core.Page<Hume.ReturnVoice, Hume.ReturnPagedVoices></code></summary>
 361: <dl>
 362: <dd>
 363: 
 364: #### 📝 Description
 365: 
 366: <dl>
 367: <dd>
 368: 
 369: <dl>
 370: <dd>
 371: 
 372: Lists voices you have saved in your account, or voices from the [Voice Library](https://app.hume.ai/voices).
 373: </dd>
 374: </dl>
 375: </dd>
 376: </dl>
 377: 
 378: #### 🔌 Usage
 379: 
 380: <dl>
 381: <dd>
 382: 
 383: <dl>
 384: <dd>
 385: 
 386: ```typescript
 387: const pageableResponse = await client.tts.voices.list({
 388:     provider: "CUSTOM_VOICE"
 389: });
 390: for await (const item of pageableResponse) {
 391:     console.log(item);
 392: }
 393: 
 394: // Or you can manually iterate page-by-page
 395: let page = await client.tts.voices.list({
 396:     provider: "CUSTOM_VOICE"
 397: });
 398: while (page.hasNextPage()) {
 399:     page = page.getNextPage();
 400: }
 401: 
 402: // You can also access the underlying response
 403: const response = page.response;
 404: 
 405: ```
 406: </dd>
 407: </dl>
 408: </dd>
 409: </dl>
 410: 
 411: #### ⚙️ Parameters
 412: 
 413: <dl>
 414: <dd>
 415: 
 416: <dl>
 417: <dd>
 418: 
 419: **request:** `Hume.tts.VoicesListRequest` 
 420:     
 421: </dd>
 422: </dl>
 423: 
 424: <dl>
 425: <dd>
 426: 
 427: **requestOptions:** `VoicesClient.RequestOptions` 
 428:     
 429: </dd>
 430: </dl>
 431: </dd>
 432: </dl>
 433: 
 434: 
 435: </dd>
 436: </dl>
 437: </details>
 438: 
 439: <details><summary><code>client.tts.voices.<a href="/src/api/resources/tts/resources/voices/client/Client.ts">create</a>({ ...params }) -> Hume.ReturnVoice</code></summary>
 440: <dl>
 441: <dd>
 442: 
 443: #### 📝 Description
 444: 
 445: <dl>
 446: <dd>
 447: 
 448: <dl>
 449: <dd>
 450: 
 451: Saves a new custom voice to your account using the specified TTS generation ID.
 452: 
 453: Once saved, this voice can be reused in subsequent TTS requests, ensuring consistent speech style and prosody. For more details on voice creation, see the [Voices Guide](/docs/text-to-speech-tts/voices).
 454: </dd>
 455: </dl>
 456: </dd>
 457: </dl>
 458: 
 459: #### 🔌 Usage
 460: 
 461: <dl>
 462: <dd>
 463: 
 464: <dl>
 465: <dd>
 466: 
 467: ```typescript
 468: await client.tts.voices.create({
 469:     generationId: "795c949a-1510-4a80-9646-7d0863b023ab",
 470:     name: "David Hume"
 471: });
 472: 
 473: ```
 474: </dd>
 475: </dl>
 476: </dd>
 477: </dl>
 478: 
 479: #### ⚙️ Parameters
 480: 
 481: <dl>
 482: <dd>
 483: 
 484: <dl>
 485: <dd>
 486: 
 487: **request:** `Hume.tts.PostedVoice` 
 488:     
 489: </dd>
 490: </dl>
 491: 
 492: <dl>
 493: <dd>
 494: 
 495: **requestOptions:** `VoicesClient.RequestOptions` 
 496:     
 497: </dd>
 498: </dl>
 499: </dd>
 500: </dl>
 501: 
 502: 
 503: </dd>
 504: </dl>
 505: </details>
 506: 
 507: <details><summary><code>client.tts.voices.<a href="/src/api/resources/tts/resources/voices/client/Client.ts">delete</a>({ ...params }) -> void</code></summary>
 508: <dl>
 509: <dd>
 510: 
 511: #### 📝 Description
 512: 
 513: <dl>
 514: <dd>
 515: 
 516: <dl>
 517: <dd>
 518: 
 519: Deletes a previously generated custom voice.
 520: </dd>
 521: </dl>
 522: </dd>
 523: </dl>
 524: 
 525: #### 🔌 Usage
 526: 
 527: <dl>
 528: <dd>
 529: 
 530: <dl>
 531: <dd>
 532: 
 533: ```typescript
 534: await client.tts.voices.delete({
 535:     name: "David Hume"
 536: });
 537: 
 538: ```
 539: </dd>
 540: </dl>
 541: </dd>
 542: </dl>
 543: 
 544: #### ⚙️ Parameters
 545: 
 546: <dl>
 547: <dd>
 548: 
 549: <dl>
 550: <dd>
 551: 
 552: **request:** `Hume.tts.VoicesDeleteRequest` 
 553:     
 554: </dd>
 555: </dl>
 556: 
 557: <dl>
 558: <dd>
 559: 
 560: **requestOptions:** `VoicesClient.RequestOptions` 
 561:     
 562: </dd>
 563: </dl>
 564: </dd>
 565: </dl>
 566: 
 567: 
 568: </dd>
 569: </dl>
 570: </details>
 571: 
 572: ## EmpathicVoice ControlPlane
 573: <details><summary><code>client.empathicVoice.controlPlane.<a href="/src/api/resources/empathicVoice/resources/controlPlane/client/Client.ts">send</a>(chat_id, { ...params }) -> void</code></summary>
 574: <dl>
 575: <dd>
 576: 
 577: #### 📝 Description
 578: 
 579: <dl>
 580: <dd>
 581: 
 582: <dl>
 583: <dd>
 584: 
 585: Send a message to a specific chat.
 586: </dd>
 587: </dl>
 588: </dd>
 589: </dl>
 590: 
 591: #### 🔌 Usage
 592: 
 593: <dl>
 594: <dd>
 595: 
 596: <dl>
 597: <dd>
 598: 
 599: ```typescript
 600: await client.empathicVoice.controlPlane.send("chat_id", {
 601:     type: "session_settings"
 602: });
 603: 
 604: ```
 605: </dd>
 606: </dl>
 607: </dd>
 608: </dl>
 609: 
 610: #### ⚙️ Parameters
 611: 
 612: <dl>
 613: <dd>
 614: 
 615: <dl>
 616: <dd>
 617: 
 618: **chat_id:** `string` 
 619:     
 620: </dd>
 621: </dl>
 622: 
 623: <dl>
 624: <dd>
 625: 
 626: **request:** `Hume.ControlPlanePublishEvent` 
 627:     
 628: </dd>
 629: </dl>
 630: 
 631: <dl>
 632: <dd>
 633: 
 634: **requestOptions:** `ControlPlaneClient.RequestOptions` 
 635:     
 636: </dd>
 637: </dl>
 638: </dd>
 639: </dl>
 640: 
 641: 
 642: </dd>
 643: </dl>
 644: </details>
 645: 
 646: ## EmpathicVoice ChatGroups
 647: <details><summary><code>client.empathicVoice.chatGroups.<a href="/src/api/resources/empathicVoice/resources/chatGroups/client/Client.ts">listChatGroups</a>({ ...params }) -> core.Page<Hume.ReturnChatGroup, Hume.ReturnPagedChatGroups></code></summary>
 648: <dl>
 649: <dd>
 650: 
 651: #### 🔌 Usage
 652: 
 653: <dl>
 654: <dd>
 655: 
 656: <dl>
 657: <dd>
 658: 
 659: ```typescript
 660: const pageableResponse = await client.empathicVoice.chatGroups.listChatGroups({
 661:     pageNumber: 0,
 662:     pageSize: 1,
 663:     ascendingOrder: true,
 664:     configId: "1b60e1a0-cc59-424a-8d2c-189d354db3f3"
 665: });
 666: for await (const item of pageableResponse) {
 667:     console.log(item);
 668: }
 669: 
 670: // Or you can manually iterate page-by-page
 671: let page = await client.empathicVoice.chatGroups.listChatGroups({
 672:     pageNumber: 0,
 673:     pageSize: 1,
 674:     ascendingOrder: true,
 675:     configId: "1b60e1a0-cc59-424a-8d2c-189d354db3f3"
 676: });
 677: while (page.hasNextPage()) {
 678:     page = page.getNextPage();
 679: }
 680: 
 681: // You can also access the underlying response
 682: const response = page.response;
 683: 
 684: ```
 685: </dd>
 686: </dl>
 687: </dd>
 688: </dl>
 689: 
 690: #### ⚙️ Parameters
 691: 
 692: <dl>
 693: <dd>
 694: 
 695: <dl>
 696: <dd>
 697: 
 698: **request:** `Hume.empathicVoice.ChatGroupsListChatGroupsRequest` 
 699:     
 700: </dd>
 701: </dl>
 702: 
 703: <dl>
 704: <dd>
 705: 
 706: **requestOptions:** `ChatGroupsClient.RequestOptions` 
 707:     
 708: </dd>
 709: </dl>
 710: </dd>
 711: </dl>
 712: 
 713: 
 714: </dd>
 715: </dl>
 716: </details>
 717: 
 718: <details><summary><code>client.empathicVoice.chatGroups.<a href="/src/api/resources/empathicVoice/resources/chatGroups/client/Client.ts">getChatGroup</a>(id, { ...params }) -> Hume.ReturnChatGroupPagedChats</code></summary>
 719: <dl>
 720: <dd>
 721: 
 722: #### 🔌 Usage
 723: 
 724: <dl>
 725: <dd>
 726: 
 727: <dl>
 728: <dd>
 729: 
 730: ```typescript
 731: await client.empathicVoice.chatGroups.getChatGroup("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
 732:     pageNumber: 0,
 733:     pageSize: 1,
 734:     ascendingOrder: true
 735: });
 736: 
 737: ```
 738: </dd>
 739: </dl>
 740: </dd>
 741: </dl>
 742: 
 743: #### ⚙️ Parameters
 744: 
 745: <dl>
 746: <dd>
 747: 
 748: <dl>
 749: <dd>
 750: 
 751: **id:** `string` — Identifier for a chat. Formatted as a UUID.
 752:     
 753: </dd>
 754: </dl>
 755: 
 756: <dl>
 757: <dd>
 758: 
 759: **request:** `Hume.empathicVoice.ChatGroupsGetChatGroupRequest` 
 760:     
 761: </dd>
 762: </dl>
 763: 
 764: <dl>
 765: <dd>
 766: 
 767: **requestOptions:** `ChatGroupsClient.RequestOptions` 
 768:     
 769: </dd>
 770: </dl>
 771: </dd>
 772: </dl>
 773: 
 774: 
 775: </dd>
 776: </dl>
 777: </details>
 778: 
 779: <details><summary><code>client.empathicVoice.chatGroups.<a href="/src/api/resources/empathicVoice/resources/chatGroups/client/Client.ts">getAudio</a>(id, { ...params }) -> Hume.ReturnChatGroupPagedAudioReconstructions</code></summary>
 780: <dl>
 781: <dd>
 782: 
 783: #### 🔌 Usage
 784: 
 785: <dl>
 786: <dd>
 787: 
 788: <dl>
 789: <dd>
 790: 
 791: ```typescript
 792: await client.empathicVoice.chatGroups.getAudio("369846cf-6ad5-404d-905e-a8acb5cdfc78", {
 793:     pageNumber: 0,
 794:     pageSize: 10,
 795:     ascendingOrder: true
 796: });
 797: 
 798: ```
 799: </dd>
 800: </dl>
 801: </dd>
 802: </dl>
 803: 
 804: #### ⚙️ Parameters
 805: 
 806: <dl>
 807: <dd>
 808: 
 809: <dl>
 810: <dd>
 811: 
 812: **id:** `string` — Identifier for a chat. Formatted as a UUID.
 813:     
 814: </dd>
 815: </dl>
 816: 
 817: <dl>
 818: <dd>
 819: 
 820: **request:** `Hume.empathicVoice.ChatGroupsGetAudioRequest` 
 821:     
 822: </dd>
 823: </dl>
 824: 
 825: <dl>
 826: <dd>
 827: 
 828: **requestOptions:** `ChatGroupsClient.RequestOptions` 
 829:     
 830: </dd>
 831: </dl>
 832: </dd>
 833: </dl>
 834: 
 835: 
 836: </dd>
 837: </dl>
 838: </details>
 839: 
 840: <details><summary><code>client.empathicVoice.chatGroups.<a href="/src/api/resources/empathicVoice/resources/chatGroups/client/Client.ts">listChatGroupEvents</a>(id, { ...params }) -> core.Page<Hume.ReturnChatEvent, Hume.ReturnChatGroupPagedEvents></code></summary>
 841: <dl>
 842: <dd>
 843: 
 844: #### 🔌 Usage
 845: 
 846: <dl>
 847: <dd>
 848: 
 849: <dl>
 850: <dd>
 851: 
 852: ```typescript
 853: const pageableResponse = await client.empathicVoice.chatGroups.listChatGroupEvents("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
 854:     pageNumber: 0,
 855:     pageSize: 3,
 856:     ascendingOrder: true
 857: });
 858: for await (const item of pageableResponse) {
 859:     console.log(item);
 860: }
 861: 
 862: // Or you can manually iterate page-by-page
 863: let page = await client.empathicVoice.chatGroups.listChatGroupEvents("697056f0-6c7e-487d-9bd8-9c19df79f05f", {
 864:     pageNumber: 0,
 865:     pageSize: 3,
 866:     ascendingOrder: true
 867: });
 868: while (page.hasNextPage()) {
 869:     page = page.getNextPage();
 870: }
 871: 
 872: // You can also access the underlying response
 873: const response = page.response;
 874: 
 875: ```
 876: </dd>
 877: </dl>
 878: </dd>
 879: </dl>
 880: 
 881: #### ⚙️ Parameters
 882: 
 883: <dl>
 884: <dd>
 885: 
 886: <dl>
 887: <dd>
 888: 
 889: **id:** `string` — Identifier for a chat. Formatted as a UUID.
 890:     
 891: </dd>
 892: </dl>
 893: 
 894: <dl>
 895: <dd>
 896: 
 897: **request:** `Hume.empathicVoice.ChatGroupsListChatGroupEventsRequest` 
 898:     
 899: </dd>
 900: </dl>
 901: 
 902: <dl>
 903: <dd>
 904: 
 905: **requestOptions:** `ChatGroupsClient.RequestOptions` 
 906:     
 907: </dd>
 908: </dl>
 909: </dd>
 910: </dl>
 911: 
 912: 
 913: </dd>
 914: </dl>
 915: </details>
 916: 
 917: ## EmpathicVoice Chats
 918: <details><summary><code>client.empathicVoice.chats.<a href="/src/api/resources/empathicVoice/resources/chats/client/Client.ts">listChats</a>({ ...params }) -> core.Page<Hume.ReturnChat, Hume.ReturnPagedChats></code></summary>
 919: <dl>
 920: <dd>
 921: 
 922: #### 🔌 Usage
 923: 
 924: <dl>
 925: <dd>
 926: 
 927: <dl>
 928: <dd>
 929: 
 930: ```typescript
 931: const pageableResponse = await client.empathicVoice.chats.listChats({
 932:     pageNumber: 0,
 933:     pageSize: 1,
 934:     ascendingOrder: true
 935: });
 936: for await (const item of pageableResponse) {
 937:     console.log(item);
 938: }
 939: 
 940: // Or you can manually iterate page-by-page
 941: let page = await client.empathicVoice.chats.listChats({
 942:     pageNumber: 0,
 943:     pageSize: 1,
 944:     ascendingOrder: true
 945: });
 946: while (page.hasNextPage()) {
 947:     page = page.getNextPage();
 948: }
 949: 
 950: // You can also access the underlying response
 951: const response = page.response;
 952: 
 953: ```
 954: </dd>
 955: </dl>
 956: </dd>
 957: </dl>
 958: 
 959: #### ⚙️ Parameters
 960: 
 961: <dl>
 962: <dd>
 963: 
 964: <dl>
 965: <dd>
 966: 
 967: **request:** `Hume.empathicVoice.ChatsListChatsRequest` 
 968:     
 969: </dd>
 970: </dl>
 971: 
 972: <dl>
 973: <dd>
 974: 
 975: **requestOptions:** `ChatsClient.RequestOptions` 
 976:     
 977: </dd>
 978: </dl>
 979: </dd>
 980: </dl>
 981: 
 982: 
 983: </dd>
 984: </dl>
 985: </details>
 986: 
 987: <details><summary><code>client.empathicVoice.chats.<a href="/src/api/resources/empathicVoice/resources/chats/client/Client.ts">listChatEvents</a>(id, { ...params }) -> core.Page<Hume.ReturnChatEvent, Hume.ReturnChatPagedEvents></code></summary>
 988: <dl>
 989: <dd>
 990: 
 991: #### 🔌 Usage
 992: 
 993: <dl>
 994: <dd>
 995: 
 996: <dl>
 997: <dd>
 998: 
 999: ```typescript
1000: const pageableResponse = await client.empathicVoice.chats.listChatEvents("470a49f6-1dec-4afe-8b61-035d3b2d63b0", {
1001:     pageNumber: 0,
1002:     pageSize: 3,
1003:     ascendingOrder: true
1004: });
1005: for await (const item of pageableResponse) {
1006:     console.log(item);
1007: }
1008: 
1009: // Or you can manually iterate page-by-page
1010: let page = await client.empathicVoice.chats.listChatEvents("470a49f6-1dec-4afe-8b61-035d3b2d63b0", {
1011:     pageNumber: 0,
1012:     pageSize: 3,
1013:     ascendingOrder: true
1014: });
1015: while (page.hasNextPage()) {
1016:     page = page.getNextPage();
1017: }
1018: 
1019: // You can also access the underlying response
1020: const response = page.response;
1021: 
1022: ```
1023: </dd>
1024: </dl>
1025: </dd>
1026: </dl>
1027: 
1028: #### ⚙️ Parameters
1029: 
1030: <dl>
1031: <dd>
1032: 
1033: <dl>
1034: <dd>
1035: 
1036: **id:** `string` — Identifier for a chat. Formatted as a UUID.
1037:     
1038: </dd>
1039: </dl>
1040: 
1041: <dl>
1042: <dd>
1043: 
1044: **request:** `Hume.empathicVoice.ChatsListChatEventsRequest` 
1045:     
1046: </dd>
1047: </dl>
1048: 
1049: <dl>
1050: <dd>
1051: 
1052: **requestOptions:** `ChatsClient.RequestOptions` 
1053:     
1054: </dd>
1055: </dl>
1056: </dd>
1057: </dl>
1058: 
1059: 
1060: </dd>
1061: </dl>
1062: </details>
1063: 
1064: <details><summary><code>client.empathicVoice.chats.<a href="/src/api/resources/empathicVoice/resources/chats/client/Client.ts">getAudio</a>(id) -> Hume.ReturnChatAudioReconstruction</code></summary>
1065: <dl>
1066: <dd>
1067: 
1068: #### 🔌 Usage
1069: 
1070: <dl>
1071: <dd>
1072: 
1073: <dl>
1074: <dd>
1075: 
1076: ```typescript
1077: await client.empathicVoice.chats.getAudio("470a49f6-1dec-4afe-8b61-035d3b2d63b0");
1078: 
1079: ```
1080: </dd>
1081: </dl>
1082: </dd>
1083: </dl>
1084: 
1085: #### ⚙️ Parameters
1086: 
1087: <dl>
1088: <dd>
1089: 
1090: <dl>
1091: <dd>
1092: 
1093: **id:** `string` — Identifier for a chat. Formatted as a UUID.
1094:     
1095: </dd>
1096: </dl>
1097: 
1098: <dl>
1099: <dd>
1100: 
1101: **requestOptions:** `ChatsClient.RequestOptions` 
1102:     
1103: </dd>
1104: </dl>
1105: </dd>
1106: </dl>
1107: 
1108: 
1109: </dd>
1110: </dl>
1111: </details>
1112: 
1113: ## EmpathicVoice Configs
1114: <details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">listConfigs</a>({ ...params }) -> core.Page<Hume.ReturnConfig, Hume.ReturnPagedConfigs></code></summary>
1115: <dl>
1116: <dd>
1117: 
1118: #### 🔌 Usage
1119: 
1120: <dl>
1121: <dd>
1122: 
1123: <dl>
1124: <dd>
1125: 
1126: ```typescript
1127: const pageableResponse = await client.empathicVoice.configs.listConfigs({
1128:     pageNumber: 0,
1129:     pageSize: 1
1130: });
1131: for await (const item of pageableResponse) {
1132:     console.log(item);
1133: }
1134: 
1135: // Or you can manually iterate page-by-page
1136: let page = await client.empathicVoice.configs.listConfigs({
1137:     pageNumber: 0,
1138:     pageSize: 1
1139: });
1140: while (page.hasNextPage()) {
1141:     page = page.getNextPage();
1142: }
1143: 
1144: // You can also access the underlying response
1145: const response = page.response;
1146: 
1147: ```
1148: </dd>
1149: </dl>
1150: </dd>
1151: </dl>
1152: 
1153: #### ⚙️ Parameters
1154: 
1155: <dl>
1156: <dd>
1157: 
1158: <dl>
1159: <dd>
1160: 
1161: **request:** `Hume.empathicVoice.ConfigsListConfigsRequest` 
1162:     
1163: </dd>
1164: </dl>
1165: 
1166: <dl>
1167: <dd>
1168: 
1169: **requestOptions:** `ConfigsClient.RequestOptions` 
1170:     
1171: </dd>
1172: </dl>
1173: </dd>
1174: </dl>
1175: 
1176: 
1177: </dd>
1178: </dl>
1179: </details>
1180: 
1181: <details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">createConfig</a>({ ...params }) -> Hume.ReturnConfig</code></summary>
1182: <dl>
1183: <dd>
1184: 
1185: #### 🔌 Usage
1186: 
1187: <dl>
1188: <dd>
1189: 
1190: <dl>
1191: <dd>
1192: 
1193: ```typescript
1194: await client.empathicVoice.configs.createConfig({
1195:     name: "Weather Assistant Config",
1196:     prompt: {
1197:         id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
1198:         version: 0
1199:     },
1200:     eviVersion: "3",
1201:     voice: {
1202:         provider: "HUME_AI",
1203:         name: "Ava Song"
1204:     },
1205:     languageModel: {
1206:         modelProvider: "ANTHROPIC",
1207:         modelResource: "claude-3-7-sonnet-latest",
1208:         temperature: 1
1209:     },
1210:     eventMessages: {
1211:         onNewChat: {
1212:             enabled: false,
1213:             text: ""
1214:         },
1215:         onInactivityTimeout: {
1216:             enabled: false,
1217:             text: ""
1218:         },
1219:         onMaxDurationTimeout: {
1220:             enabled: false,
1221:             text: ""
1222:         }
1223:     }
1224: });
1225: 
1226: ```
1227: </dd>
1228: </dl>
1229: </dd>
1230: </dl>
1231: 
1232: #### ⚙️ Parameters
1233: 
1234: <dl>
1235: <dd>
1236: 
1237: <dl>
1238: <dd>
1239: 
1240: **request:** `Hume.empathicVoice.PostedConfig` 
1241:     
1242: </dd>
1243: </dl>
1244: 
1245: <dl>
1246: <dd>
1247: 
1248: **requestOptions:** `ConfigsClient.RequestOptions` 
1249:     
1250: </dd>
1251: </dl>
1252: </dd>
1253: </dl>
1254: 
1255: 
1256: </dd>
1257: </dl>
1258: </details>
1259: 
1260: <details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">listConfigVersions</a>(id, { ...params }) -> core.Page<Hume.ReturnConfig, Hume.ReturnPagedConfigs></code></summary>
1261: <dl>
1262: <dd>
1263: 
1264: #### 🔌 Usage
1265: 
1266: <dl>
1267: <dd>
1268: 
1269: <dl>
1270: <dd>
1271: 
1272: ```typescript
1273: const pageableResponse = await client.empathicVoice.configs.listConfigVersions("1b60e1a0-cc59-424a-8d2c-189d354db3f3");
1274: for await (const item of pageableResponse) {
1275:     console.log(item);
1276: }
1277: 
1278: // Or you can manually iterate page-by-page
1279: let page = await client.empathicVoice.configs.listConfigVersions("1b60e1a0-cc59-424a-8d2c-189d354db3f3");
1280: while (page.hasNextPage()) {
1281:     page = page.getNextPage();
1282: }
1283: 
1284: // You can also access the underlying response
1285: const response = page.response;
1286: 
1287: ```
1288: </dd>
1289: </dl>
1290: </dd>
1291: </dl>
1292: 
1293: #### ⚙️ Parameters
1294: 
1295: <dl>
1296: <dd>
1297: 
1298: <dl>
1299: <dd>
1300: 
1301: **id:** `string` — Identifier for a config. Formatted as a UUID.
1302:     
1303: </dd>
1304: </dl>
1305: 
1306: <dl>
1307: <dd>
1308: 
1309: **request:** `Hume.empathicVoice.ConfigsListConfigVersionsRequest` 
1310:     
1311: </dd>
1312: </dl>
1313: 
1314: <dl>
1315: <dd>
1316: 
1317: **requestOptions:** `ConfigsClient.RequestOptions` 
1318:     
1319: </dd>
1320: </dl>
1321: </dd>
1322: </dl>
1323: 
1324: 
1325: </dd>
1326: </dl>
1327: </details>
1328: 
1329: <details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">createConfigVersion</a>(id, { ...params }) -> Hume.ReturnConfig</code></summary>
1330: <dl>
1331: <dd>
1332: 
1333: #### 🔌 Usage
1334: 
1335: <dl>
1336: <dd>
1337: 
1338: <dl>
1339: <dd>
1340: 
1341: ```typescript
1342: await client.empathicVoice.configs.createConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", {
1343:     versionDescription: "This is an updated version of the Weather Assistant Config.",
1344:     eviVersion: "3",
1345:     prompt: {
1346:         id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
1347:         version: 0
1348:     },
1349:     voice: {
1350:         provider: "HUME_AI",
1351:         name: "Ava Song"
1352:     },
1353:     languageModel: {
1354:         modelProvider: "ANTHROPIC",
1355:         modelResource: "claude-3-7-sonnet-latest",
1356:         temperature: 1
1357:     },
1358:     ellmModel: {
1359:         allowShortResponses: true
1360:     },
1361:     eventMessages: {
1362:         onNewChat: {
1363:             enabled: false,
1364:             text: ""
1365:         },
1366:         onInactivityTimeout: {
1367:             enabled: false,
1368:             text: ""
1369:         },
1370:         onMaxDurationTimeout: {
1371:             enabled: false,
1372:             text: ""
1373:         }
1374:     }
1375: });
1376: 
1377: ```
1378: </dd>
1379: </dl>
1380: </dd>
1381: </dl>
1382: 
1383: #### ⚙️ Parameters
1384: 
1385: <dl>
1386: <dd>
1387: 
1388: <dl>
1389: <dd>
1390: 
1391: **id:** `string` — Identifier for a config. Formatted as a UUID.
1392:     
1393: </dd>
1394: </dl>
1395: 
1396: <dl>
1397: <dd>
1398: 
1399: **request:** `Hume.empathicVoice.PostedConfigVersion` 
1400:     
1401: </dd>
1402: </dl>
1403: 
1404: <dl>
1405: <dd>
1406: 
1407: **requestOptions:** `ConfigsClient.RequestOptions` 
1408:     
1409: </dd>
1410: </dl>
1411: </dd>
1412: </dl>
1413: 
1414: 
1415: </dd>
1416: </dl>
1417: </details>
1418: 
1419: <details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">deleteConfig</a>(id) -> void</code></summary>
1420: <dl>
1421: <dd>
1422: 
1423: #### 🔌 Usage
1424: 
1425: <dl>
1426: <dd>
1427: 
1428: <dl>
1429: <dd>
1430: 
1431: ```typescript
1432: await client.empathicVoice.configs.deleteConfig("1b60e1a0-cc59-424a-8d2c-189d354db3f3");
1433: 
1434: ```
1435: </dd>
1436: </dl>
1437: </dd>
1438: </dl>
1439: 
1440: #### ⚙️ Parameters
1441: 
1442: <dl>
1443: <dd>
1444: 
1445: <dl>
1446: <dd>
1447: 
1448: **id:** `string` — Identifier for a config. Formatted as a UUID.
1449:     
1450: </dd>
1451: </dl>
1452: 
1453: <dl>
1454: <dd>
1455: 
1456: **requestOptions:** `ConfigsClient.RequestOptions` 
1457:     
1458: </dd>
1459: </dl>
1460: </dd>
1461: </dl>
1462: 
1463: 
1464: </dd>
1465: </dl>
1466: </details>
1467: 
1468: <details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">updateConfigName</a>(id, { ...params }) -> string</code></summary>
1469: <dl>
1470: <dd>
1471: 
1472: #### 🔌 Usage
1473: 
1474: <dl>
1475: <dd>
1476: 
1477: <dl>
1478: <dd>
1479: 
1480: ```typescript
1481: await client.empathicVoice.configs.updateConfigName("1b60e1a0-cc59-424a-8d2c-189d354db3f3", {
1482:     name: "Updated Weather Assistant Config Name"
1483: });
1484: 
1485: ```
1486: </dd>
1487: </dl>
1488: </dd>
1489: </dl>
1490: 
1491: #### ⚙️ Parameters
1492: 
1493: <dl>
1494: <dd>
1495: 
1496: <dl>
1497: <dd>
1498: 
1499: **id:** `string` — Identifier for a config. Formatted as a UUID.
1500:     
1501: </dd>
1502: </dl>
1503: 
1504: <dl>
1505: <dd>
1506: 
1507: **request:** `Hume.empathicVoice.PostedConfigName` 
1508:     
1509: </dd>
1510: </dl>
1511: 
1512: <dl>
1513: <dd>
1514: 
1515: **requestOptions:** `ConfigsClient.RequestOptions` 
1516:     
1517: </dd>
1518: </dl>
1519: </dd>
1520: </dl>
1521: 
1522: 
1523: </dd>
1524: </dl>
1525: </details>
1526: 
1527: <details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">getConfigVersion</a>(id, version) -> Hume.ReturnConfig</code></summary>
1528: <dl>
1529: <dd>
1530: 
1531: #### 🔌 Usage
1532: 
1533: <dl>
1534: <dd>
1535: 
1536: <dl>
1537: <dd>
1538: 
1539: ```typescript
1540: await client.empathicVoice.configs.getConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1);
1541: 
1542: ```
1543: </dd>
1544: </dl>
1545: </dd>
1546: </dl>
1547: 
1548: #### ⚙️ Parameters
1549: 
1550: <dl>
1551: <dd>
1552: 
1553: <dl>
1554: <dd>
1555: 
1556: **id:** `string` — Identifier for a config. Formatted as a UUID.
1557:     
1558: </dd>
1559: </dl>
1560: 
1561: <dl>
1562: <dd>
1563: 
1564: **version:** `number` — Version number for a config. Version numbers should be integers.
1565:     
1566: </dd>
1567: </dl>
1568: 
1569: <dl>
1570: <dd>
1571: 
1572: **requestOptions:** `ConfigsClient.RequestOptions` 
1573:     
1574: </dd>
1575: </dl>
1576: </dd>
1577: </dl>
1578: 
1579: 
1580: </dd>
1581: </dl>
1582: </details>
1583: 
1584: <details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">deleteConfigVersion</a>(id, version) -> void</code></summary>
1585: <dl>
1586: <dd>
1587: 
1588: #### 🔌 Usage
1589: 
1590: <dl>
1591: <dd>
1592: 
1593: <dl>
1594: <dd>
1595: 
1596: ```typescript
1597: await client.empathicVoice.configs.deleteConfigVersion("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1);
1598: 
1599: ```
1600: </dd>
1601: </dl>
1602: </dd>
1603: </dl>
1604: 
1605: #### ⚙️ Parameters
1606: 
1607: <dl>
1608: <dd>
1609: 
1610: <dl>
1611: <dd>
1612: 
1613: **id:** `string` — Identifier for a config. Formatted as a UUID.
1614:     
1615: </dd>
1616: </dl>
1617: 
1618: <dl>
1619: <dd>
1620: 
1621: **version:** `number` — Version number for a config. Version numbers should be integers.
1622:     
1623: </dd>
1624: </dl>
1625: 
1626: <dl>
1627: <dd>
1628: 
1629: **requestOptions:** `ConfigsClient.RequestOptions` 
1630:     
1631: </dd>
1632: </dl>
1633: </dd>
1634: </dl>
1635: 
1636: 
1637: </dd>
1638: </dl>
1639: </details>
1640: 
1641: <details><summary><code>client.empathicVoice.configs.<a href="/src/api/resources/empathicVoice/resources/configs/client/Client.ts">updateConfigDescription</a>(id, version, { ...params }) -> Hume.ReturnConfig</code></summary>
1642: <dl>
1643: <dd>
1644: 
1645: #### 🔌 Usage
1646: 
1647: <dl>
1648: <dd>
1649: 
1650: <dl>
1651: <dd>
1652: 
1653: ```typescript
1654: await client.empathicVoice.configs.updateConfigDescription("1b60e1a0-cc59-424a-8d2c-189d354db3f3", 1, {
1655:     versionDescription: "This is an updated version_description."
1656: });
1657: 
1658: ```
1659: </dd>
1660: </dl>
1661: </dd>
1662: </dl>
1663: 
1664: #### ⚙️ Parameters
1665: 
1666: <dl>
1667: <dd>
1668: 
1669: <dl>
1670: <dd>
1671: 
1672: **id:** `string` — Identifier for a config. Formatted as a UUID.
1673:     
1674: </dd>
1675: </dl>
1676: 
1677: <dl>
1678: <dd>
1679: 
1680: **version:** `number` — Version number for a config. Version numbers should be integers.
1681:     
1682: </dd>
1683: </dl>
1684: 
1685: <dl>
1686: <dd>
1687: 
1688: **request:** `Hume.empathicVoice.PostedConfigVersionDescription` 
1689:     
1690: </dd>
1691: </dl>
1692: 
1693: <dl>
1694: <dd>
1695: 
1696: **requestOptions:** `ConfigsClient.RequestOptions` 
1697:     
1698: </dd>
1699: </dl>
1700: </dd>
1701: </dl>
1702: 
1703: 
1704: </dd>
1705: </dl>
1706: </details>
1707: 
1708: ## EmpathicVoice Prompts
1709: <details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">listPrompts</a>({ ...params }) -> core.Page<(Hume.ReturnPrompt | undefined), Hume.ReturnPagedPrompts></code></summary>
1710: <dl>
1711: <dd>
1712: 
1713: #### 🔌 Usage
1714: 
1715: <dl>
1716: <dd>
1717: 
1718: <dl>
1719: <dd>
1720: 
1721: ```typescript
1722: const pageableResponse = await client.empathicVoice.prompts.listPrompts({
1723:     pageNumber: 0,
1724:     pageSize: 2
1725: });
1726: for await (const item of pageableResponse) {
1727:     console.log(item);
1728: }
1729: 
1730: // Or you can manually iterate page-by-page
1731: let page = await client.empathicVoice.prompts.listPrompts({
1732:     pageNumber: 0,
1733:     pageSize: 2
1734: });
1735: while (page.hasNextPage()) {
1736:     page = page.getNextPage();
1737: }
1738: 
1739: // You can also access the underlying response
1740: const response = page.response;
1741: 
1742: ```
1743: </dd>
1744: </dl>
1745: </dd>
1746: </dl>
1747: 
1748: #### ⚙️ Parameters
1749: 
1750: <dl>
1751: <dd>
1752: 
1753: <dl>
1754: <dd>
1755: 
1756: **request:** `Hume.empathicVoice.PromptsListPromptsRequest` 
1757:     
1758: </dd>
1759: </dl>
1760: 
1761: <dl>
1762: <dd>
1763: 
1764: **requestOptions:** `PromptsClient.RequestOptions` 
1765:     
1766: </dd>
1767: </dl>
1768: </dd>
1769: </dl>
1770: 
1771: 
1772: </dd>
1773: </dl>
1774: </details>
1775: 
1776: <details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">createPrompt</a>({ ...params }) -> Hume.ReturnPrompt | undefined</code></summary>
1777: <dl>
1778: <dd>
1779: 
1780: #### 🔌 Usage
1781: 
1782: <dl>
1783: <dd>
1784: 
1785: <dl>
1786: <dd>
1787: 
1788: ```typescript
1789: await client.empathicVoice.prompts.createPrompt({
1790:     name: "Weather Assistant Prompt",
1791:     text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>"
1792: });
1793: 
1794: ```
1795: </dd>
1796: </dl>
1797: </dd>
1798: </dl>
1799: 
1800: #### ⚙️ Parameters
1801: 
1802: <dl>
1803: <dd>
1804: 
1805: <dl>
1806: <dd>
1807: 
1808: **request:** `Hume.empathicVoice.PostedPrompt` 
1809:     
1810: </dd>
1811: </dl>
1812: 
1813: <dl>
1814: <dd>
1815: 
1816: **requestOptions:** `PromptsClient.RequestOptions` 
1817:     
1818: </dd>
1819: </dl>
1820: </dd>
1821: </dl>
1822: 
1823: 
1824: </dd>
1825: </dl>
1826: </details>
1827: 
1828: <details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">listPromptVersions</a>(id, { ...params }) -> Hume.ReturnPagedPrompts</code></summary>
1829: <dl>
1830: <dd>
1831: 
1832: #### 🔌 Usage
1833: 
1834: <dl>
1835: <dd>
1836: 
1837: <dl>
1838: <dd>
1839: 
1840: ```typescript
1841: await client.empathicVoice.prompts.listPromptVersions("af699d45-2985-42cc-91b9-af9e5da3bac5");
1842: 
1843: ```
1844: </dd>
1845: </dl>
1846: </dd>
1847: </dl>
1848: 
1849: #### ⚙️ Parameters
1850: 
1851: <dl>
1852: <dd>
1853: 
1854: <dl>
1855: <dd>
1856: 
1857: **id:** `string` 
1858:     
1859: </dd>
1860: </dl>
1861: 
1862: <dl>
1863: <dd>
1864: 
1865: **request:** `Hume.empathicVoice.PromptsListPromptVersionsRequest` 
1866:     
1867: </dd>
1868: </dl>
1869: 
1870: <dl>
1871: <dd>
1872: 
1873: **requestOptions:** `PromptsClient.RequestOptions` 
1874:     
1875: </dd>
1876: </dl>
1877: </dd>
1878: </dl>
1879: 
1880: 
1881: </dd>
1882: </dl>
1883: </details>
1884: 
1885: <details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">createPromptVersion</a>(id, { ...params }) -> Hume.ReturnPrompt | undefined</code></summary>
1886: <dl>
1887: <dd>
1888: 
1889: #### 🔌 Usage
1890: 
1891: <dl>
1892: <dd>
1893: 
1894: <dl>
1895: <dd>
1896: 
1897: ```typescript
1898: await client.empathicVoice.prompts.createPromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", {
1899:     text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
1900:     versionDescription: "This is an updated version of the Weather Assistant Prompt."
1901: });
1902: 
1903: ```
1904: </dd>
1905: </dl>
1906: </dd>
1907: </dl>
1908: 
1909: #### ⚙️ Parameters
1910: 
1911: <dl>
1912: <dd>
1913: 
1914: <dl>
1915: <dd>
1916: 
1917: **id:** `string` — Identifier for a prompt. Formatted as a UUID.
1918:     
1919: </dd>
1920: </dl>
1921: 
1922: <dl>
1923: <dd>
1924: 
1925: **request:** `Hume.empathicVoice.PostedPromptVersion` 
1926:     
1927: </dd>
1928: </dl>
1929: 
1930: <dl>
1931: <dd>
1932: 
1933: **requestOptions:** `PromptsClient.RequestOptions` 
1934:     
1935: </dd>
1936: </dl>
1937: </dd>
1938: </dl>
1939: 
1940: 
1941: </dd>
1942: </dl>
1943: </details>
1944: 
1945: <details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">deletePrompt</a>(id) -> void</code></summary>
1946: <dl>
1947: <dd>
1948: 
1949: #### 🔌 Usage
1950: 
1951: <dl>
1952: <dd>
1953: 
1954: <dl>
1955: <dd>
1956: 
1957: ```typescript
1958: await client.empathicVoice.prompts.deletePrompt("af699d45-2985-42cc-91b9-af9e5da3bac5");
1959: 
1960: ```
1961: </dd>
1962: </dl>
1963: </dd>
1964: </dl>
1965: 
1966: #### ⚙️ Parameters
1967: 
1968: <dl>
1969: <dd>
1970: 
1971: <dl>
1972: <dd>
1973: 
1974: **id:** `string` — Identifier for a prompt. Formatted as a UUID.
1975:     
1976: </dd>
1977: </dl>
1978: 
1979: <dl>
1980: <dd>
1981: 
1982: **requestOptions:** `PromptsClient.RequestOptions` 
1983:     
1984: </dd>
1985: </dl>
1986: </dd>
1987: </dl>
1988: 
1989: 
1990: </dd>
1991: </dl>
1992: </details>
1993: 
1994: <details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">updatePromptName</a>(id, { ...params }) -> string</code></summary>
1995: <dl>
1996: <dd>
1997: 
1998: #### 🔌 Usage
1999: 
2000: <dl>
2001: <dd>
2002: 
2003: <dl>
2004: <dd>
2005: 
2006: ```typescript
2007: await client.empathicVoice.prompts.updatePromptName("af699d45-2985-42cc-91b9-af9e5da3bac5", {
2008:     name: "Updated Weather Assistant Prompt Name"
2009: });
2010: 
2011: ```
2012: </dd>
2013: </dl>
2014: </dd>
2015: </dl>
2016: 
2017: #### ⚙️ Parameters
2018: 
2019: <dl>
2020: <dd>
2021: 
2022: <dl>
2023: <dd>
2024: 
2025: **id:** `string` — Identifier for a prompt. Formatted as a UUID.
2026:     
2027: </dd>
2028: </dl>
2029: 
2030: <dl>
2031: <dd>
2032: 
2033: **request:** `Hume.empathicVoice.PostedPromptName` 
2034:     
2035: </dd>
2036: </dl>
2037: 
2038: <dl>
2039: <dd>
2040: 
2041: **requestOptions:** `PromptsClient.RequestOptions` 
2042:     
2043: </dd>
2044: </dl>
2045: </dd>
2046: </dl>
2047: 
2048: 
2049: </dd>
2050: </dl>
2051: </details>
2052: 
2053: <details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">getPromptVersion</a>(id, version) -> Hume.ReturnPrompt | undefined</code></summary>
2054: <dl>
2055: <dd>
2056: 
2057: #### 🔌 Usage
2058: 
2059: <dl>
2060: <dd>
2061: 
2062: <dl>
2063: <dd>
2064: 
2065: ```typescript
2066: await client.empathicVoice.prompts.getPromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", 0);
2067: 
2068: ```
2069: </dd>
2070: </dl>
2071: </dd>
2072: </dl>
2073: 
2074: #### ⚙️ Parameters
2075: 
2076: <dl>
2077: <dd>
2078: 
2079: <dl>
2080: <dd>
2081: 
2082: **id:** `string` — Identifier for a prompt. Formatted as a UUID.
2083:     
2084: </dd>
2085: </dl>
2086: 
2087: <dl>
2088: <dd>
2089: 
2090: **version:** `number` — Version number for a prompt. Version numbers should be integers.
2091:     
2092: </dd>
2093: </dl>
2094: 
2095: <dl>
2096: <dd>
2097: 
2098: **requestOptions:** `PromptsClient.RequestOptions` 
2099:     
2100: </dd>
2101: </dl>
2102: </dd>
2103: </dl>
2104: 
2105: 
2106: </dd>
2107: </dl>
2108: </details>
2109: 
2110: <details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">deletePromptVersion</a>(id, version) -> void</code></summary>
2111: <dl>
2112: <dd>
2113: 
2114: #### 🔌 Usage
2115: 
2116: <dl>
2117: <dd>
2118: 
2119: <dl>
2120: <dd>
2121: 
2122: ```typescript
2123: await client.empathicVoice.prompts.deletePromptVersion("af699d45-2985-42cc-91b9-af9e5da3bac5", 1);
2124: 
2125: ```
2126: </dd>
2127: </dl>
2128: </dd>
2129: </dl>
2130: 
2131: #### ⚙️ Parameters
2132: 
2133: <dl>
2134: <dd>
2135: 
2136: <dl>
2137: <dd>
2138: 
2139: **id:** `string` — Identifier for a prompt. Formatted as a UUID.
2140:     
2141: </dd>
2142: </dl>
2143: 
2144: <dl>
2145: <dd>
2146: 
2147: **version:** `number` — Version number for a prompt. Version numbers should be integers.
2148:     
2149: </dd>
2150: </dl>
2151: 
2152: <dl>
2153: <dd>
2154: 
2155: **requestOptions:** `PromptsClient.RequestOptions` 
2156:     
2157: </dd>
2158: </dl>
2159: </dd>
2160: </dl>
2161: 
2162: 
2163: </dd>
2164: </dl>
2165: </details>
2166: 
2167: <details><summary><code>client.empathicVoice.prompts.<a href="/src/api/resources/empathicVoice/resources/prompts/client/Client.ts">updatePromptDescription</a>(id, version, { ...params }) -> Hume.ReturnPrompt | undefined</code></summary>
2168: <dl>
2169: <dd>
2170: 
2171: #### 🔌 Usage
2172: 
2173: <dl>
2174: <dd>
2175: 
2176: <dl>
2177: <dd>
2178: 
2179: ```typescript
2180: await client.empathicVoice.prompts.updatePromptDescription("af699d45-2985-42cc-91b9-af9e5da3bac5", 1, {
2181:     versionDescription: "This is an updated version_description."
2182: });
2183: 
2184: ```
2185: </dd>
2186: </dl>
2187: </dd>
2188: </dl>
2189: 
2190: #### ⚙️ Parameters
2191: 
2192: <dl>
2193: <dd>
2194: 
2195: <dl>
2196: <dd>
2197: 
2198: **id:** `string` — Identifier for a prompt. Formatted as a UUID.
2199:     
2200: </dd>
2201: </dl>
2202: 
2203: <dl>
2204: <dd>
2205: 
2206: **version:** `number` — Version number for a prompt. Version numbers should be integers.
2207:     
2208: </dd>
2209: </dl>
2210: 
2211: <dl>
2212: <dd>
2213: 
2214: **request:** `Hume.empathicVoice.PostedPromptVersionDescription` 
2215:     
2216: </dd>
2217: </dl>
2218: 
2219: <dl>
2220: <dd>
2221: 
2222: **requestOptions:** `PromptsClient.RequestOptions` 
2223:     
2224: </dd>
2225: </dl>
2226: </dd>
2227: </dl>
2228: 
2229: 
2230: </dd>
2231: </dl>
2232: </details>
2233: 
2234: ## EmpathicVoice Tools
2235: <details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">listTools</a>({ ...params }) -> core.Page<(Hume.ReturnUserDefinedTool | undefined), Hume.ReturnPagedUserDefinedTools></code></summary>
2236: <dl>
2237: <dd>
2238: 
2239: #### 🔌 Usage
2240: 
2241: <dl>
2242: <dd>
2243: 
2244: <dl>
2245: <dd>
2246: 
2247: ```typescript
2248: const pageableResponse = await client.empathicVoice.tools.listTools({
2249:     pageNumber: 0,
2250:     pageSize: 2
2251: });
2252: for await (const item of pageableResponse) {
2253:     console.log(item);
2254: }
2255: 
2256: // Or you can manually iterate page-by-page
2257: let page = await client.empathicVoice.tools.listTools({
2258:     pageNumber: 0,
2259:     pageSize: 2
2260: });
2261: while (page.hasNextPage()) {
2262:     page = page.getNextPage();
2263: }
2264: 
2265: // You can also access the underlying response
2266: const response = page.response;
2267: 
2268: ```
2269: </dd>
2270: </dl>
2271: </dd>
2272: </dl>
2273: 
2274: #### ⚙️ Parameters
2275: 
2276: <dl>
2277: <dd>
2278: 
2279: <dl>
2280: <dd>
2281: 
2282: **request:** `Hume.empathicVoice.ToolsListToolsRequest` 
2283:     
2284: </dd>
2285: </dl>
2286: 
2287: <dl>
2288: <dd>
2289: 
2290: **requestOptions:** `ToolsClient.RequestOptions` 
2291:     
2292: </dd>
2293: </dl>
2294: </dd>
2295: </dl>
2296: 
2297: 
2298: </dd>
2299: </dl>
2300: </details>
2301: 
2302: <details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">createTool</a>({ ...params }) -> Hume.ReturnUserDefinedTool | undefined</code></summary>
2303: <dl>
2304: <dd>
2305: 
2306: #### 🔌 Usage
2307: 
2308: <dl>
2309: <dd>
2310: 
2311: <dl>
2312: <dd>
2313: 
2314: ```typescript
2315: await client.empathicVoice.tools.createTool({
2316:     name: "get_current_weather",
2317:     parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
2318:     versionDescription: "Fetches current weather and uses celsius or fahrenheit based on location of user.",
2319:     description: "This tool is for getting the current weather.",
2320:     fallbackContent: "Unable to fetch current weather."
2321: });
2322: 
2323: ```
2324: </dd>
2325: </dl>
2326: </dd>
2327: </dl>
2328: 
2329: #### ⚙️ Parameters
2330: 
2331: <dl>
2332: <dd>
2333: 
2334: <dl>
2335: <dd>
2336: 
2337: **request:** `Hume.empathicVoice.PostedUserDefinedTool` 
2338:     
2339: </dd>
2340: </dl>
2341: 
2342: <dl>
2343: <dd>
2344: 
2345: **requestOptions:** `ToolsClient.RequestOptions` 
2346:     
2347: </dd>
2348: </dl>
2349: </dd>
2350: </dl>
2351: 
2352: 
2353: </dd>
2354: </dl>
2355: </details>
2356: 
2357: <details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">listToolVersions</a>(id, { ...params }) -> core.Page<(Hume.ReturnUserDefinedTool | undefined), Hume.ReturnPagedUserDefinedTools></code></summary>
2358: <dl>
2359: <dd>
2360: 
2361: #### 🔌 Usage
2362: 
2363: <dl>
2364: <dd>
2365: 
2366: <dl>
2367: <dd>
2368: 
2369: ```typescript
2370: const pageableResponse = await client.empathicVoice.tools.listToolVersions("00183a3f-79ba-413d-9f3b-609864268bea");
2371: for await (const item of pageableResponse) {
2372:     console.log(item);
2373: }
2374: 
2375: // Or you can manually iterate page-by-page
2376: let page = await client.empathicVoice.tools.listToolVersions("00183a3f-79ba-413d-9f3b-609864268bea");
2377: while (page.hasNextPage()) {
2378:     page = page.getNextPage();
2379: }
2380: 
2381: // You can also access the underlying response
2382: const response = page.response;
2383: 
2384: ```
2385: </dd>
2386: </dl>
2387: </dd>
2388: </dl>
2389: 
2390: #### ⚙️ Parameters
2391: 
2392: <dl>
2393: <dd>
2394: 
2395: <dl>
2396: <dd>
2397: 
2398: **id:** `string` 
2399:     
2400: </dd>
2401: </dl>
2402: 
2403: <dl>
2404: <dd>
2405: 
2406: **request:** `Hume.empathicVoice.ToolsListToolVersionsRequest` 
2407:     
2408: </dd>
2409: </dl>
2410: 
2411: <dl>
2412: <dd>
2413: 
2414: **requestOptions:** `ToolsClient.RequestOptions` 
2415:     
2416: </dd>
2417: </dl>
2418: </dd>
2419: </dl>
2420: 
2421: 
2422: </dd>
2423: </dl>
2424: </details>
2425: 
2426: <details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">createToolVersion</a>(id, { ...params }) -> Hume.ReturnUserDefinedTool | undefined</code></summary>
2427: <dl>
2428: <dd>
2429: 
2430: #### 🔌 Usage
2431: 
2432: <dl>
2433: <dd>
2434: 
2435: <dl>
2436: <dd>
2437: 
2438: ```typescript
2439: await client.empathicVoice.tools.createToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", {
2440:     parameters: "{ \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"The city and state, e.g. San Francisco, CA\" }, \"format\": { \"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\", \"kelvin\"], \"description\": \"The temperature unit to use. Infer this from the users location.\" } }, \"required\": [\"location\", \"format\"] }",
2441:     versionDescription: "Fetches current weather and uses celsius, fahrenheit, or kelvin based on location of user.",
2442:     fallbackContent: "Unable to fetch current weather.",
2443:     description: "This tool is for getting the current weather."
2444: });
2445: 
2446: ```
2447: </dd>
2448: </dl>
2449: </dd>
2450: </dl>
2451: 
2452: #### ⚙️ Parameters
2453: 
2454: <dl>
2455: <dd>
2456: 
2457: <dl>
2458: <dd>
2459: 
2460: **id:** `string` — Identifier for a tool. Formatted as a UUID.
2461:     
2462: </dd>
2463: </dl>
2464: 
2465: <dl>
2466: <dd>
2467: 
2468: **request:** `Hume.empathicVoice.PostedUserDefinedToolVersion` 
2469:     
2470: </dd>
2471: </dl>
2472: 
2473: <dl>
2474: <dd>
2475: 
2476: **requestOptions:** `ToolsClient.RequestOptions` 
2477:     
2478: </dd>
2479: </dl>
2480: </dd>
2481: </dl>
2482: 
2483: 
2484: </dd>
2485: </dl>
2486: </details>
2487: 
2488: <details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">deleteTool</a>(id) -> void</code></summary>
2489: <dl>
2490: <dd>
2491: 
2492: #### 🔌 Usage
2493: 
2494: <dl>
2495: <dd>
2496: 
2497: <dl>
2498: <dd>
2499: 
2500: ```typescript
2501: await client.empathicVoice.tools.deleteTool("00183a3f-79ba-413d-9f3b-609864268bea");
2502: 
2503: ```
2504: </dd>
2505: </dl>
2506: </dd>
2507: </dl>
2508: 
2509: #### ⚙️ Parameters
2510: 
2511: <dl>
2512: <dd>
2513: 
2514: <dl>
2515: <dd>
2516: 
2517: **id:** `string` — Identifier for a tool. Formatted as a UUID.
2518:     
2519: </dd>
2520: </dl>
2521: 
2522: <dl>
2523: <dd>
2524: 
2525: **requestOptions:** `ToolsClient.RequestOptions` 
2526:     
2527: </dd>
2528: </dl>
2529: </dd>
2530: </dl>
2531: 
2532: 
2533: </dd>
2534: </dl>
2535: </details>
2536: 
2537: <details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">updateToolName</a>(id, { ...params }) -> string</code></summary>
2538: <dl>
2539: <dd>
2540: 
2541: #### 🔌 Usage
2542: 
2543: <dl>
2544: <dd>
2545: 
2546: <dl>
2547: <dd>
2548: 
2549: ```typescript
2550: await client.empathicVoice.tools.updateToolName("00183a3f-79ba-413d-9f3b-609864268bea", {
2551:     name: "get_current_temperature"
2552: });
2553: 
2554: ```
2555: </dd>
2556: </dl>
2557: </dd>
2558: </dl>
2559: 
2560: #### ⚙️ Parameters
2561: 
2562: <dl>
2563: <dd>
2564: 
2565: <dl>
2566: <dd>
2567: 
2568: **id:** `string` — Identifier for a tool. Formatted as a UUID.
2569:     
2570: </dd>
2571: </dl>
2572: 
2573: <dl>
2574: <dd>
2575: 
2576: **request:** `Hume.empathicVoice.PostedUserDefinedToolName` 
2577:     
2578: </dd>
2579: </dl>
2580: 
2581: <dl>
2582: <dd>
2583: 
2584: **requestOptions:** `ToolsClient.RequestOptions` 
2585:     
2586: </dd>
2587: </dl>
2588: </dd>
2589: </dl>
2590: 
2591: 
2592: </dd>
2593: </dl>
2594: </details>
2595: 
2596: <details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">getToolVersion</a>(id, version) -> Hume.ReturnUserDefinedTool | undefined</code></summary>
2597: <dl>
2598: <dd>
2599: 
2600: #### 🔌 Usage
2601: 
2602: <dl>
2603: <dd>
2604: 
2605: <dl>
2606: <dd>
2607: 
2608: ```typescript
2609: await client.empathicVoice.tools.getToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1);
2610: 
2611: ```
2612: </dd>
2613: </dl>
2614: </dd>
2615: </dl>
2616: 
2617: #### ⚙️ Parameters
2618: 
2619: <dl>
2620: <dd>
2621: 
2622: <dl>
2623: <dd>
2624: 
2625: **id:** `string` — Identifier for a tool. Formatted as a UUID.
2626:     
2627: </dd>
2628: </dl>
2629: 
2630: <dl>
2631: <dd>
2632: 
2633: **version:** `number` — Version number for a tool. Version numbers should be integers.
2634:     
2635: </dd>
2636: </dl>
2637: 
2638: <dl>
2639: <dd>
2640: 
2641: **requestOptions:** `ToolsClient.RequestOptions` 
2642:     
2643: </dd>
2644: </dl>
2645: </dd>
2646: </dl>
2647: 
2648: 
2649: </dd>
2650: </dl>
2651: </details>
2652: 
2653: <details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">deleteToolVersion</a>(id, version) -> void</code></summary>
2654: <dl>
2655: <dd>
2656: 
2657: #### 🔌 Usage
2658: 
2659: <dl>
2660: <dd>
2661: 
2662: <dl>
2663: <dd>
2664: 
2665: ```typescript
2666: await client.empathicVoice.tools.deleteToolVersion("00183a3f-79ba-413d-9f3b-609864268bea", 1);
2667: 
2668: ```
2669: </dd>
2670: </dl>
2671: </dd>
2672: </dl>
2673: 
2674: #### ⚙️ Parameters
2675: 
2676: <dl>
2677: <dd>
2678: 
2679: <dl>
2680: <dd>
2681: 
2682: **id:** `string` — Identifier for a tool. Formatted as a UUID.
2683:     
2684: </dd>
2685: </dl>
2686: 
2687: <dl>
2688: <dd>
2689: 
2690: **version:** `number` — Version number for a tool. Version numbers should be integers.
2691:     
2692: </dd>
2693: </dl>
2694: 
2695: <dl>
2696: <dd>
2697: 
2698: **requestOptions:** `ToolsClient.RequestOptions` 
2699:     
2700: </dd>
2701: </dl>
2702: </dd>
2703: </dl>
2704: 
2705: 
2706: </dd>
2707: </dl>
2708: </details>
2709: 
2710: <details><summary><code>client.empathicVoice.tools.<a href="/src/api/resources/empathicVoice/resources/tools/client/Client.ts">updateToolDescription</a>(id, version, { ...params }) -> Hume.ReturnUserDefinedTool | undefined</code></summary>
2711: <dl>
2712: <dd>
2713: 
2714: #### 🔌 Usage
2715: 
2716: <dl>
2717: <dd>
2718: 
2719: <dl>
2720: <dd>
2721: 
2722: ```typescript
2723: await client.empathicVoice.tools.updateToolDescription("00183a3f-79ba-413d-9f3b-609864268bea", 1, {
2724:     versionDescription: "Fetches current temperature, precipitation, wind speed, AQI, and other weather conditions. Uses Celsius, Fahrenheit, or kelvin depending on user's region."
2725: });
2726: 
2727: ```
2728: </dd>
2729: </dl>
2730: </dd>
2731: </dl>
2732: 
2733: #### ⚙️ Parameters
2734: 
2735: <dl>
2736: <dd>
2737: 
2738: <dl>
2739: <dd>
2740: 
2741: **id:** `string` — Identifier for a tool. Formatted as a UUID.
2742:     
2743: </dd>
2744: </dl>
2745: 
2746: <dl>
2747: <dd>
2748: 
2749: **version:** `number` — Version number for a tool. Version numbers should be integers.
2750:     
2751: </dd>
2752: </dl>
2753: 
2754: <dl>
2755: <dd>
2756: 
2757: **request:** `Hume.empathicVoice.PostedUserDefinedToolVersionDescription` 
2758:     
2759: </dd>
2760: </dl>
2761: 
2762: <dl>
2763: <dd>
2764: 
2765: **requestOptions:** `ToolsClient.RequestOptions` 
2766:     
2767: </dd>
2768: </dl>
2769: </dd>
2770: </dl>
2771: 
2772: 
2773: </dd>
2774: </dl>
2775: </details>
2776: 
2777: ## ExpressionMeasurement Batch
2778: <details><summary><code>client.expressionMeasurement.batch.<a href="/src/api/resources/expressionMeasurement/resources/batch/client/Client.ts">listJobs</a>({ ...params }) -> Hume.UnionJob[]</code></summary>
2779: <dl>
2780: <dd>
2781: 
2782: #### 📝 Description
2783: 
2784: <dl>
2785: <dd>
2786: 
2787: <dl>
2788: <dd>
2789: 
2790: Sort and filter jobs.
2791: </dd>
2792: </dl>
2793: </dd>
2794: </dl>
2795: 
2796: #### 🔌 Usage
2797: 
2798: <dl>
2799: <dd>
2800: 
2801: <dl>
2802: <dd>
2803: 
2804: ```typescript
2805: await client.expressionMeasurement.batch.listJobs();
2806: 
2807: ```
2808: </dd>
2809: </dl>
2810: </dd>
2811: </dl>
2812: 
2813: #### ⚙️ Parameters
2814: 
2815: <dl>
2816: <dd>
2817: 
2818: <dl>
2819: <dd>
2820: 
2821: **request:** `Hume.expressionMeasurement.batch.BatchListJobsRequest` 
2822:     
2823: </dd>
2824: </dl>
2825: 
2826: <dl>
2827: <dd>
2828: 
2829: **requestOptions:** `BatchClient.RequestOptions` 
2830:     
2831: </dd>
2832: </dl>
2833: </dd>
2834: </dl>
2835: 
2836: 
2837: </dd>
2838: </dl>
2839: </details>
2840: 
2841: <details><summary><code>client.expressionMeasurement.batch.<a href="/src/api/resources/expressionMeasurement/resources/batch/client/Client.ts">startInferenceJob</a>({ ...params }) -> Hume.JobId</code></summary>
2842: <dl>
2843: <dd>
2844: 
2845: #### 📝 Description
2846: 
2847: <dl>
2848: <dd>
2849: 
2850: <dl>
2851: <dd>
2852: 
2853: Start a new measurement inference job.
2854: </dd>
2855: </dl>
2856: </dd>
2857: </dl>
2858: 
2859: #### 🔌 Usage
2860: 
2861: <dl>
2862: <dd>
2863: 
2864: <dl>
2865: <dd>
2866: 
2867: ```typescript
2868: await client.expressionMeasurement.batch.startInferenceJob({
2869:     urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
2870:     notify: true
2871: });
2872: 
2873: ```
2874: </dd>
2875: </dl>
2876: </dd>
2877: </dl>
2878: 
2879: #### ⚙️ Parameters
2880: 
2881: <dl>
2882: <dd>
2883: 
2884: <dl>
2885: <dd>
2886: 
2887: **request:** `Hume.InferenceBaseRequest` 
2888:     
2889: </dd>
2890: </dl>
2891: 
2892: <dl>
2893: <dd>
2894: 
2895: **requestOptions:** `BatchClient.RequestOptions` 
2896:     
2897: </dd>
2898: </dl>
2899: </dd>
2900: </dl>
2901: 
2902: 
2903: </dd>
2904: </dl>
2905: </details>
2906: 
2907: <details><summary><code>client.expressionMeasurement.batch.<a href="/src/api/resources/expressionMeasurement/resources/batch/client/Client.ts">getJobDetails</a>(id) -> Hume.UnionJob</code></summary>
2908: <dl>
2909: <dd>
2910: 
2911: #### 📝 Description
2912: 
2913: <dl>
2914: <dd>
2915: 
2916: <dl>
2917: <dd>
2918: 
2919: Get the request details and state of a given job.
2920: </dd>
2921: </dl>
2922: </dd>
2923: </dl>
2924: 
2925: #### 🔌 Usage
2926: 
2927: <dl>
2928: <dd>
2929: 
2930: <dl>
2931: <dd>
2932: 
2933: ```typescript
2934: await client.expressionMeasurement.batch.getJobDetails("job_id");
2935: 
2936: ```
2937: </dd>
2938: </dl>
2939: </dd>
2940: </dl>
2941: 
2942: #### ⚙️ Parameters
2943: 
2944: <dl>
2945: <dd>
2946: 
2947: <dl>
2948: <dd>
2949: 
2950: **id:** `string` — The unique identifier for the job.
2951:     
2952: </dd>
2953: </dl>
2954: 
2955: <dl>
2956: <dd>
2957: 
2958: **requestOptions:** `BatchClient.RequestOptions` 
2959:     
2960: </dd>
2961: </dl>
2962: </dd>
2963: </dl>
2964: 
2965: 
2966: </dd>
2967: </dl>
2968: </details>
2969: 
2970: <details><summary><code>client.expressionMeasurement.batch.<a href="/src/api/resources/expressionMeasurement/resources/batch/client/Client.ts">getJobPredictions</a>(id) -> Hume.UnionPredictResult[]</code></summary>
2971: <dl>
2972: <dd>
2973: 
2974: #### 📝 Description
2975: 
2976: <dl>
2977: <dd>
2978: 
2979: <dl>
2980: <dd>
2981: 
2982: Get the JSON predictions of a completed inference job.
2983: </dd>
2984: </dl>
2985: </dd>
2986: </dl>
2987: 
2988: #### 🔌 Usage
2989: 
2990: <dl>
2991: <dd>
2992: 
2993: <dl>
2994: <dd>
2995: 
2996: ```typescript
2997: await client.expressionMeasurement.batch.getJobPredictions("job_id");
2998: 
2999: ```
3000: </dd>
3001: </dl>
3002: </dd>
3003: </dl>
3004: 
3005: #### ⚙️ Parameters
3006: 
3007: <dl>
3008: <dd>
3009: 
3010: <dl>
3011: <dd>
3012: 
3013: **id:** `string` — The unique identifier for the job.
3014:     
3015: </dd>
3016: </dl>
3017: 
3018: <dl>
3019: <dd>
3020: 
3021: **requestOptions:** `BatchClient.RequestOptions` 
3022:     
3023: </dd>
3024: </dl>
3025: </dd>
3026: </dl>
3027: 
3028: 
3029: </dd>
3030: </dl>
3031: </details>
3032: 
3033: <details><summary><code>client.expressionMeasurement.batch.<a href="/src/api/resources/expressionMeasurement/resources/batch/client/Client.ts">startInferenceJobFromLocalFile</a>({ ...params }) -> Hume.JobId</code></summary>
3034: <dl>
3035: <dd>
3036: 
3037: #### 📝 Description
3038: 
3039: <dl>
3040: <dd>
3041: 
3042: <dl>
3043: <dd>
3044: 
3045: Start a new batch inference job.
3046: </dd>
3047: </dl>
3048: </dd>
3049: </dl>
3050: 
3051: #### 🔌 Usage
3052: 
3053: <dl>
3054: <dd>
3055: 
3056: <dl>
3057: <dd>
3058: 
3059: ```typescript
3060: await client.expressionMeasurement.batch.startInferenceJobFromLocalFile({
3061:     file: [fs.createReadStream("/path/to/your/file")]
3062: });
3063: 
3064: ```
3065: </dd>
3066: </dl>
3067: </dd>
3068: </dl>
3069: 
3070: #### ⚙️ Parameters
3071: 
3072: <dl>
3073: <dd>
3074: 
3075: <dl>
3076: <dd>
3077: 
3078: **request:** `Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest` 
3079:     
3080: </dd>
3081: </dl>
3082: 
3083: <dl>
3084: <dd>
3085: 
3086: **requestOptions:** `BatchClient.RequestOptions` 
3087:     
3088: </dd>
3089: </dl>
3090: </dd>
3091: </dl>
3092: 
3093: 
3094: </dd>
3095: </dl>
3096: </details>
````

## File: tsconfig.base.json
````json
 1: {
 2:     "compilerOptions": {
 3:         "extendedDiagnostics": true,
 4:         "strict": true,
 5:         "target": "ES6",
 6:         "moduleResolution": "node",
 7:         "esModuleInterop": true,
 8:         "skipLibCheck": true,
 9:         "declaration": true,
10:         "outDir": "dist",
11:         "rootDir": "src",
12:         "baseUrl": "src",
13:         "isolatedModules": true,
14:         "isolatedDeclarations": true
15:     },
16:     "include": ["src"],
17:     "exclude": []
18: }
````

## File: tsconfig.cjs.json
````json
1: {
2:     "extends": "./tsconfig.base.json",
3:     "compilerOptions": {
4:         "module": "CommonJS",
5:         "outDir": "dist/cjs"
6:     },
7:     "include": ["src"],
8:     "exclude": []
9: }
````

## File: tsconfig.dev.json
````json
1: {
2:     "extends": "./tsconfig.json",
3:     "include": ["src/**/*.ts", "src/**/*.js", "tests", "eslint.config.mjs", "jest.config.mjs"],
4:     "exclude": ["dist"]
5: }
````

## File: tsconfig.esm.json
````json
 1: {
 2:     "extends": "./tsconfig.base.json",
 3:     "compilerOptions": {
 4:         "module": "esnext",
 5:         "outDir": "dist/esm",
 6:         "verbatimModuleSyntax": true
 7:     },
 8:     "include": ["src"],
 9:     "exclude": []
10: }
````

## File: tsconfig.json
````json
1: {
2:     "extends": "./tsconfig.cjs.json"
3: }
````

## File: vitest.config.mts
````typescript
 1: import { defineConfig } from "vitest/config";
 2: export default defineConfig({
 3:     test: {
 4:         projects: [
 5:             {
 6:                 test: {
 7:                     globals: true,
 8:                     name: "unit",
 9:                     environment: "node",
10:                     root: "./tests",
11:                     include: ["**/*.test.{js,ts,jsx,tsx}"],
12:                     exclude: ["wire/**"],
13:                     setupFiles: ["./setup.ts"],
14:                 },
15:             },
16:             {
17:                 test: {
18:                     globals: true,
19:                     name: "wire",
20:                     environment: "node",
21:                     root: "./tests/wire",
22:                     setupFiles: ["../setup.ts", "../mock-server/setup.ts"],
23:                 },
24:             },
25:         ],
26:         passWithNoTests: true,
27:     },
28: });
````
